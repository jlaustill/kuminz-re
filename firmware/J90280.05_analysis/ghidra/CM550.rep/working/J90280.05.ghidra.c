/*
 * Ghidra Decompilation Export - J90280.05 Firmware
 * Cummins CM550 ECU - MC68000 Architecture (Big-Endian)
 *
 * Generated: Tue Dec 16 10:04:43 MST 2025
 *
 * Data Sources:
 *   - enums.csv (623 entries)
 *   - structure_definitions.csv (73 types)
 *   - global_variables.csv (6108 variables)
 *   - Ghidra decompiler (789 functions)
 *
 * Target: m68k-elf-gcc
 * Compile: m68k-elf-gcc -c -Wall -Wextra J90280.05.ghidra.c
 */

/* ============================================================ */
/* Standard Includes                                            */
/* ============================================================ */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

/* ============================================================ */
/* Ghidra Decompiler Type Aliases                              */
/* ============================================================ */

typedef uint8_t byte;
typedef int8_t sbyte;
typedef uint16_t word;
typedef int16_t sword;
typedef uint32_t dword;
typedef int32_t sdword;
typedef uint16_t ushort;
typedef uint32_t uint;
typedef uint32_t ulong;
typedef int32_t slong;
typedef void* pointer;
typedef uint8_t undefined;
typedef uint8_t undefined1;
typedef uint16_t undefined2;
typedef uint8_t undefined3[3];
typedef uint32_t undefined4;
typedef uint8_t undefined5[5];
typedef uint8_t undefined6[6];
typedef uint8_t undefined7[7];
typedef uint64_t undefined8;

/* Ghidra decompiler type aliases */
typedef uint64_t ulonglong;
typedef uint8_t int3[3];  /* 3-byte integer (Ghidra artifact) */

/* ============================================================ */
/* Enum Definitions (from enums.csv)                           */
/* ============================================================ */

typedef enum {
    BASIC_DELAY = 0, /* Basic timer + delay with watchdog (can1TimerBuf... */
    ALT_TRANSMIT = 1, /* Alt timer + message transmit init (can1TimerBuf... */
    DIVIDED_TRANSMIT = 2, /* Divided timer + message transmit init 2 (can1Ti... */
    CONDITIONAL_DELAY = 3 /* Conditional timer + watchdog delay 2 (can1Timer... */
} __attribute__((packed)) CAN_TIMER_INIT_MODE;

typedef enum {
    CAN_STATUS_BYTE = 0x36, /* CAN message status byte offset */
    PARAM_BYTE_1 = 0x37, /* First parameter byte offset */
    PARAM_BYTE_2 = 0x38, /* Second parameter byte offset */
    PARAM_BYTE_3 = 0x39 /* Third parameter byte offset */
} CAN_BUFFER_OFFSETS;

typedef enum {
    VP44_FUEL_TEMP = 0x10, /* VP44 fuel temperature message */
    ALTERNATIVE_MSG = 0x11, /* Alternative message handler */
    THIRD_MSG = 0x13, /* Third message handler */
    ERROR_DEFAULT = 0xFF /* Error/default case message */
} CAN_MSG_TYPE;

typedef enum {
    VP44_CMD_BUILDER = 1, /* vp44Command0x100Builder function (0x2a418) */
    CONFIG_BUILDER = 2 /* configParamCanBuilder function (0x2a57e) */
} CAN_PARAM_BUILDERS;

typedef enum {
    FSO_CIRCUIT_STATUS_BIT0 = 1, /* VP44 FSO circuit status bit 0 - when set indica... */
    FSO_CIRCUIT_STATUS_BIT1 = 2, /* VP44 FSO circuit status bit 1 - redundant FSO m... */
    STATUS_BIT2 = 4, /* VP44 status bit 2 */
    STATUS_BIT3 = 8, /* VP44 status bit 3 */
    STATUS_BIT4 = 0x10, /* VP44 status bit 4 - affects fuel timing control */
    STATUS_BIT5 = 0x20, /* VP44 status bit 5 */
    STATUS_BIT6 = 0x40, /* VP44 status bit 6 */
    STATUS_BIT7 = 0x80 /* VP44 status bit 7 */
} VP44_STATUS_BITS;

typedef enum {
    ENGINE_IDLE = 1, /* Engine idle/startup mode */
    LOW_RPM_RUNNING = 2, /* Low RPM running mode */
    HIGH_RPM_RUNNING = 3, /* High RPM running mode */
    VP44_INJECTION_ACTIVE = 4, /* VP44 injection system active mode */
    HIGH_PERFORMANCE = 5, /* High performance/load mode */
    TRANSITIONAL_MODE_6 = 6, /* Transitional operating mode 6 */
    TRANSITIONAL_MODE_7 = 7, /* Transitional operating mode 7 */
    FAULT_EMERGENCY = 8 /* Fault/emergency mode */
} ENGINE_OPERATING_MODE;

typedef enum {
    VP44Handler = 0x10, /* VP44 pump communication handler */
    DiagParamRequestHandler = 0x11, /* Alternative handler for parameter requests */
    StatusRequestHandler = 0x13, /* Third handler for status/diagnostic requests */
    ErrorDefaultHandler = 0xFF /* Error/default case handler */
} DIAGNOSTIC_MESSAGE_TYPES;

typedef enum {
    FUEL_HIGH_BYTE = 1, /* Fuel amount high byte (param_table_aux>>8 + 125) */
    FUEL_LOW_BYTE = 2, /* Fuel amount low byte (param_table_main>>8 + 125) */
    RESERVED_ZERO_1 = 3, /* Reserved/zero byte 3 */
    RESERVED_ZERO_2 = 4, /* Reserved/zero byte 4 */
    TIMING_BYTE1 = 5, /* Injection timing advance (byte 5) */
    TIMING_BYTE2 = 6, /* Injection timing advance (byte 6) */
    RPM_LOW_BYTE = 7, /* Engine RPM×4 low byte (current_engine_rpm & 0xFF) */
    RPM_HIGH_BYTE = 8 /* Engine RPM×4 high byte (current_engine_rpm >> 8) */
} VP44_DATA_FIELDS;

typedef enum {
    CAN_CONTROLLER_MAIN = 0, /* Primary CAN controller (SSCNLTOB) */
    CAN_CONTROLLER_1 = 1 /* Secondary CAN controller 1 (SSC1LTOB) */
} DUAL_CAN_CONTROLLERS;

typedef enum {
    J1939_SOURCE_ADDR_1 = 1, /* J1939 source address 1 (JCSA1) */
    J1939_SOURCE_ADDR_2 = 2, /* J1939 source address 2 (JCSA2) */
    J1939_SOURCE_ADDR_3 = 3, /* J1939 source address 3 (JCSA3) */
    J1939_SOURCE_ADDR_4 = 4, /* J1939 source address 4 (JCSA4) */
    J1939_SOURCE_ADDR_5 = 5 /* J1939 source address 5 (JCSA5) */
} DUAL_CAN_J1939_SOURCE_ADDR;

typedef enum {
    DATA_PLATE_BLOCK = 0, /* Data plate identifier block */
    PRIMARY_BLOCK = 9 /* Main parameter memory block (PTESLOLM etc.) */
} EEPROM_MEMORY_BLOCKS;

typedef enum {
    MultiDimensionalTableSupport = 1, /* 5-stage table interpolation system confirmed */
    StructuredParameterSystem = 2, /* EEPROM → Tables → CAN flow */
    TimingTableSupport_4DTBTA = 3, /* 4D timing base table advance parameter */
    FuelMappingIntegration = 4 /* Integration with throttle/parameter systems */
} EFILIVE_COMPATIBILITY;

typedef enum {
    SCALE_FACTOR = 3, /* Base interpolation scaling */
    SHIFT_BITS = 8, /* Bit shift amount for scaling */
    WORD_MULTIPLIER = 0x0100 /* Word-size multiplication factor */
} INTERPOLATION_FACTORS;

typedef enum {
    CruiseControlReceiveEnable_JCCNRXFT = 1, /* CCVS message reception filter (0x07F0FEF1) */
    CruiseControlMessageEnable_JCCCBCEA = 2, /* Enable cruise control/vehicle speed message pro... */
    SpeedControlStatus_JCRPGVSS = 3, /* Speed control status (1=SPEED_CONTROL_MODE 0=NO... */
    SpeedControlBrakingInteraction_JCRDTXEA = 4 /* Enable speed control/engine braking interaction */
} J1939_CRUISE_CONTROL_ENABLE;

typedef enum {
    CalTermCommunication = 1, /* CalTerm parameter read/write via J1939 */
    InsiteCommunication = 2, /* Insite live data monitoring via J1939 */
    DiagnosticMessageDispatcher = 3, /* Routes diagnostic requests by message type */
    J1939ParamRequestHandler = 4, /* Processes EEPROM parameter read requests */
    ParameterResponseBuilder = 5 /* Formats parameter values for J1939 response */
} J1939_DIAGNOSTIC_PROTOCOL;

typedef enum {
    TorqueSpeedControlReceiveEnable_JCCNRXFT = 1, /* TSC1 message reception enable (0x07F00400) */
    JC39ENFG = 2, /* J1939 message enable flags table */
    AS01CF = 3, /* ASG throttle mode compensation filter coef. 1 */
    AS02CF = 4, /* ASG throttle mode compensation filter coef. 2 */
    AS03CF = 5 /* ASG throttle mode compensation filter coef. 3 */
} J1939_THROTTLE_ENABLE;

typedef enum {
    PHASE_0_VP44_RPM = 0, /* Even: VP44 engine management + RPM control */
    PHASE_1_ENGINE_FUEL = 1, /* Odd: Engine control + RPM fuel limiter */
    PHASE_2_DIAG_AUX = 2, /* Even: Diagnostic + Auxiliary + Advanced protection */
    PHASE_3_SLOW_CYCLES = 3, /* Odd: SlowCycle 4/8/10/20 coordinators */
    PHASE_4_BOOST_DIAG = 4, /* Even: VP44 + Boost + Diagnostic monitoring */
    PHASE_5_EPS_SLOW20 = 5, /* Odd: Engine + EPS monitoring + SlowCycle20 ext */
    PHASE_6_FUEL_CALC = 6, /* Even: Diagnostic + IO + Fuel calc + Kickdown */
    PHASE_7_SHUTDOWN = 7, /* Odd: SlowCycle4 + Shutdown protection + Trending */
    PHASE_8_DIAG_COMM = 8, /* Even: VP44 + Diagnostic comm + Fuel smoke */
    PHASE_9_CAM_TIMING = 9, /* Odd: Engine + Diagnostic data + Cam sync + Timi... */
    PHASE_10_DERATE = 10, /* Even: Diagnostic + RPM + Derate protection */
    PHASE_11_VP44_PROT = 11, /* Odd: SlowCycle4/8 + RPM limiter + VP44 protection */
    PHASE_12_FSO_FRIC = 12, /* Even: VP44 + Boost + FSO detection + Frictional... */
    PHASE_13_DIAG_FAULT = 13, /* Odd: Engine + SlowCycle10 + VP44 diagnostic fault */
    PHASE_14_FSO_MON = 14, /* Even: Diagnostic + Diagnostic monitoring + FSO ... */
    PHASE_15_EPS_TIMING = 15, /* Odd: SlowCycle4 + EPS + Timing calc + VP44 timi... */
    PHASE_16_DZG_TIMING = 0x10, /* Even: VP44 + IO control + DZG timing */
    PHASE_17_OUTPUT_CTRL = 0x11, /* Odd: Engine + Shutdown + Mode-based output */
    PHASE_18_DIAG_TEMP = 0x12, /* Even: Diagnostic + Auxiliary + VP44 diag + Fuel... */
    PHASE_19_DIAG_STATS = 0x13, /* Odd: SlowCycle4/8 + Diagnostic data + Stats */
    PHASE_20_RPM_VP44 = 0x14, /* Even: VP44 + Boost + RPM + VP44 control */
    PHASE_21_EXT_FAULT = 0x15, /* Odd: Engine + Boost + RPM limiter + VP44 ext fault */
    PHASE_22_ADV_PROT = 0x16, /* Even: Diagnostic + Secondary + Advanced protection */
    PHASE_23_SLOW_ALL = 0x17, /* Odd: SlowCycle 4/8/10/20 all */
    PHASE_24_FUEL_TIME = 0x18, /* Even: VP44 + Diagnostic monitoring + Fuel timing */
    PHASE_25_EPS_EXT = 0x19, /* Odd: Engine + EPS monitoring + SlowCycle20 ext */
    PHASE_26_IO_FUEL = 0x1A, /* Even: Diagnostic + IO control + Fuel calc */
    PHASE_27_SENSOR_HIST = 0x1B, /* Odd: SlowCycle4/8 + Shutdown + Sensor history */
    PHASE_28_SMOKE_LIM = 0x1C, /* Even: VP44 + Boost + Diagnostic comm + Smoke li... */
    PHASE_29_CAM_SYNC = 0x1D, /* Odd: Engine + Diagnostic data + Cam sync */
    PHASE_30_DERATE2 = 0x1E, /* Even: Diagnostic + RPM + Derate protection */
    PHASE_31_VP44_PROT2 = 0x1F, /* Odd: SlowCycle4 + RPM limiter + VP44 protection */
    PHASE_32_FSO_DET = 0x20, /* Even: VP44 + Secondary + FSO detection */
    PHASE_33_DIAG_MON = 0x21, /* Odd: Engine + SlowCycle10 + VP44 diag fault */
    PHASE_34_FSO_MON2 = 0x22, /* Even: Diagnostic + Auxiliary + FSO fault monito... */
    PHASE_35_EPS_EMPTY = 0x23, /* Odd: SlowCycle4/8 + EPS + Empty placeholder */
    PHASE_36_DZG_IO = 0x24, /* Even: VP44 + Boost + IO control + DZG timing */
    PHASE_37_OUTPUT2 = 0x25, /* Odd: Engine + Shutdown + Mode-based output */
    PHASE_38_VP44_DIAG = 0x26, /* Even: Diagnostic + Diagnostic comm + VP44 control */
    PHASE_39_FINAL = 0x27 /* Odd: SlowCycle4 + Diagnostic data + Stats (retu... */
} MAIN_LOOP_PHASE;

typedef enum {
    CAN_BUFFER_1 = 1, /* CAN parameter message buffer 1 (0x803066) */
    CAN_BUFFER_2 = 2, /* CAN parameter message buffer 2 (0x803056) */
    CAN_BUFFER_3 = 3, /* CAN parameter message buffer 3 (0x80306e) */
    CAN_BUFFER_4 = 4 /* CAN parameter message buffer 4 (0x80303e) */
} MC68336_CAN_BUFFERS;

typedef enum {
    J1922_PROTOCOL = 0, /* J1922 network protocol selection */
    J1939_PROTOCOL = 1 /* J1939 network protocol selection */
} NETWORK_TYPE_SELECTION;

typedef enum {
    LOOKUP_1 = 1, /* param_lookup_1 function (0xd632) */
    LOOKUP_2 = 2, /* param_lookup_2 function (0xd69c) */
    LOOKUP_3 = 3 /* param_lookup_3 function (0xd756) */
} PARAM_ACCESS_FUNCTIONS;

typedef enum {
    DMA_AUTO_RELOAD = 0x10000000UL, /* DMA auto-reload descriptor */
    DMA_INTERRUPT_ENABLE = 0x20000000UL, /* DMA completion interrupt enable */
    DMA_CHAIN_MODE = 0x40000000UL, /* DMA descriptor chaining enabled */
    DMA_ENABLE = 0x80000000UL /* DMA channel enable flag */
} DMA_CONTROL_FLAGS;

typedef enum {
    DMA_SINGLE_TRANSFER = 0, /* Single data transfer mode */
    DMA_BLOCK_TRANSFER = 1, /* Block transfer mode */
    DMA_BURST_TRANSFER = 2, /* Burst transfer mode */
    DMA_CONTINUOUS = 3 /* Continuous transfer mode */
} DMA_TRANSFER_MODES;

typedef enum {
    MODULE_DE = 0x4445, /* Hypothetical DE module family */
    MODULE_EN = 0x454E, /* Cummins EN module family (CM550 VP44 ECUs) */
    MODULE_AN = 0x4E41 /* Hypothetical AN module family */
} CUMMINS_MODULE_IDS;

typedef enum {
    VARIANT_A = 0x41, /* InCal calibration variant A */
    VARIANT_B = 0x42, /* InCal calibration variant B */
    VARIANT_C = 0x43 /* InCal calibration variant C (ENC) */
} INCAL_VARIANTS;

typedef enum {
    BLOCK_MULTIPLIER = 0x0100 /* Parameter block size multiplier */
} PARAM_BLOCK_SIZE;

typedef enum {
    EEPROM_TO_TABLE = 1, /* EEPROM parameter → memory table */
    TABLE_TO_BUFFER = 2, /* Memory table → CAN buffer */
    BUFFER_TO_NETWORK = 3 /* CAN buffer → J1939 transmission */
} PARAM_CAN_FLOW;

typedef enum {
    ActiveParameterRead = 1, /* Active EEPROM parameter reading mode */
    CachedParameterRead = 11, /* Cached parameter value retrieval */
    SpecialParameterHandling = 12 /* Special parameter processing mode */
} PARAMETER_SYSTEM_MODES;

typedef enum {
    DWORD_SHIFT = 2, /* 32-bit addressing (lsll #2) */
    BLOCK_SHIFT = 8 /* Block×256 calculation (lsll #8) */
} PARAM_SHIFT_OPERATIONS;

typedef enum {
    SAFETY_LIMIT = 0x7D00, /* Maximum allowed parameter value */
    BLOCK_LIMIT = 0xFFFF /* Block validation limit (Block × 65535) */
} PARAM_VALIDATION;

typedef enum {
    RPM_DIRECT = 1, /* Direct RPM value (no scaling) */
    RPM_HALF = 2, /* RPM divided by 2 */
    RPM_QUARTER = 4 /* RPM divided by 4 (lsll #2) */
} RPM_SCALING;

typedef enum {
    CRANKING_RPM_LIMIT = 0x7D, /* Cold crank sync determination limit (CSCDESTR) */
    RUNNING_RPM_THRESHOLD = 0x012C, /* Engine considered running threshold (CSCKES) */
    PTO_MIN_RPM = 0x02BC, /* PTO minimum RPM setpoint (PTESLOLM) */
    PTO_MAX_RPM = 0x0BB8, /* PTO maximum RPM setpoint (PTESHILM) */
    ASG_MAX_RPM = 0x0BB8 /* ASG maximum allowed speed (ASTLMNMX) */
} ENGINE_RPM_LIMITS;

typedef enum {
    FSMXTHFL = 1, /* Fueling value at 100% throttle (param_lookup_3) */
    ASTHRFES = 2, /* ASG reference speed based on throttle position ... */
    JCTHKCTD = 3 /* JCOMM throttle kickdown threshold (param_lookup_3) */
} THROTTLE_PARAMS;

typedef enum {
    BYTE_OFFSET = 6, /* Data byte position in VP44 message */
    FUEL_TEMP_OFFSET = 0x70 /* Fuel temperature sensor offset */
} VP44_SENSOR_OFFSETS;

typedef enum {
    DERATE_STATUS_BIT2 = 4, /* Derate status bit 2 - maps to INSITE status 0x40 */
    DERATE_STATUS_BIT3 = 8, /* Derate status bit 3 - maps to INSITE status 0x20 */
    DERATE_BIT5 = 0x20, /* Derate status bit 5 - maps to INSITE bit 0x20 */
    DERATE_BIT6 = 0x40, /* Derate status bit 6 - maps to INSITE bit 0x40 */
    DERATE_ACTIVE = 0x80 /* Derate condition is active */
} __attribute__((packed)) DERATE_STATUS_BITS;

typedef enum {
    SECURED_WRITE = 3, /* Secured write operations (requires security check) */
    SECURED_COMMANDS = 3, /* Secured commands - requires systemSecurityCheck... */
    SYSTEM_CONTROL = 4, /* System control operations */
    SYSTEM_CONTROL = 4, /* System control commands - no security check */
    MEMORY_ACCESS = 5, /* Memory read/write operations */
    MEMORY_OPERATIONS = 5, /* Memory read/write with CRC validation */
    SPECIAL_CONTROL = 6, /* Special timing/control functions */
    RETRY_CONTROL = 6, /* Transmission retry control (subfunction 0x74) */
    FUEL_ARBITRATOR = 0x4A, /* fuelArbitratorControlService - fuel system control */
    EXTENDED_4C = 0x4C, /* extendedDiagnosticService4C */
    EXTENDED_4F = 0x4F, /* extendedDiagnosticService4F */
    EXTENDED_51 = 0x51 /* extendedDiagnosticService51 */
} DIAG_SERVICE_ID;

typedef enum {
    WATER_IN_FUEL_CLEAR = 0x40, /* Clear water-in-fuel fault (waterInFuelFaultClear) */
    WATER_IN_FUEL_VALIDATE = 0x41, /* Validate water-in-fuel condition (waterInFuelFa... */
    HIGH_RPM_SHUTDOWN_ACTIVATE = 0x42, /* Activate high RPM shutdown flag (activateHighRp... */
    SYSTEM_RESET_TRIGGER = 0x43, /* Trigger diagnostic system reset (triggerDiagnos... */
    NOP_ACK = 0x50, /* No operation - returns success (0) */
    MEMORY_PATCH = 0x51, /* RAM patching system (memoryPatchingSystem) */
    SECURED_SHUTDOWN_REQUEST = 0x52, /* Request secured shutdown (requestSecuredShutdown) */
    UNSUPPORTED_ERROR = 0x53, /* Unsupported operation - returns error code 4 */
    CAN_BUFFER_LOGGER = 0x54 /* CAN message buffer logger (canMessageBufferLogger) */
} DIAG_SECURED_SUBFUNC;

typedef enum {
    SYSTEM_CONTROL_100 = 0x64, /* System control function 100 (systemControl64) */
    FAULT_SCANNER_ENABLE = 0x65, /* Enable fault flag scanner (enableFaultFlagScanner) */
    CLEAR_COMMAND_STATE = 0x66, /* Clear diagnostic_command_state to 0 */
    WATER_IN_FUEL_INIT = 0x69, /* Water in fuel detection init (waterInFuelDetect... */
    RESERVED_112 = 0x70, /* Reserved - returns error code 4 */
    SET_COMMAND_STATE_BIT0 = 0x71, /* Set bit 0 of diagnostic_command_state */
    RESERVED_114 = 0x72, /* Reserved - returns error code 4 */
    SET_COMMAND_STATE_BIT1 = 0x73, /* Set bit 1 of diagnostic_command_state */
    SYSTEM_CONTROL_116 = 0x74, /* System control function 116 (systemControl74) */
    SYSTEM_CONTROL_117 = 0x75, /* System control function 117 (systemControl75) */
    RESERVED_118 = 0x76 /* Reserved - returns error code 4 */
} DIAG_CONTROL_SUBFUNC;

typedef enum {
    READ_3BYTE_ADDR = 0x60, /* Memory read with 3-byte addressing */
    WRITE_4BYTE_ADDR = 0x80, /* Memory write with 4-byte addressing */
    WRITE_2BYTE_ADDR = 0xA0, /* Memory write with 2-byte addressing */
    MULTI_PKT_RECEIVE = 0xB0, /* Multi-packet data receive */
    READ_2BYTE_ADDR = 0xC0, /* Memory read with 2-byte addressing */
    READ_1BYTE_ADDR = 0xE0, /* Memory read with 1-byte addressing */
    MULTI_PKT_TRANSMIT = 0xF0 /* Multi-packet data transmit */
} DIAG_MEMORY_OP;

typedef enum {
    MEM_READ_2BYTE_4BYTE = 0x43, /* Memory read: 2-byte param + 4-byte offset (diag... */
    MEM_READ_2BYTE_ONLY = 0x46, /* Memory read: 2-byte param only (diagMemoryReadS... */
    MEM_READ_2BYTE_4BYTE_4BYTE = 0x48, /* Memory read: 2-byte + 4-byte + 4-byte params (d... */
    MEM_READ_4BYTE_1BYTE = 0x4A, /* Memory read: 4-byte address + 1-byte length (di... */
    MEM_READ_4BYTE_4BYTE = 0x4C, /* Memory read: 4-byte address + 4-byte length (di... */
    EXTENDED_4F = 0x4F, /* Extended diagnostic service 0x4F */
    EXTENDED_51 = 0x51 /* Extended diagnostic service 0x51 */
} DIAG_EXTENDED_SVC;

typedef enum {
    RESET_MODE = 0, /* Reset/clear arbitrator state */
    MODE_RESET = 0, /* Reset fuel arbitrator - clear all targets and m... */
    RPM_TARGET_MODE = 1, /* Set RPM target mode */
    MODE_RPM_TARGET = 1, /* RPM target mode - set target RPM from diagnosti... */
    THROTTLE_PCT_MODE = 2, /* Throttle percentage control mode */
    MODE_FUEL_PERCENT = 2, /* Fuel percentage mode - control fuel delivery pe... */
    FUEL_LIMIT_MODE = 3, /* Fuel limit control mode */
    MODE_TORQUE_CMD = 3 /* Torque command mode - direct torque control */
} FUEL_ARB_MODE;

typedef enum {
    DTC_STATUS_FLAGS = 2, /* DTC search result status flags */
    DERATE_STATUS = 3, /* Derate status byte bit flags */
    HIGH_RPM_PROTECTION_STATUS = 0x47, /* High RPM protection status flags */
    BOOST_PRESSURE_TARGET = 0x4A, /* Boost pressure target pointer (scaled >>7) */
    DIAGNOSTIC_FUEL_MODE_FLAG = 0x53, /* Diagnostic fuel control mode flag (0x80 if mode... */
    THROTTLE_POSITION = 0x54, /* Throttle position value (scaled >>7) */
    INSITE_STATUS_BYTE = 0x55, /* Combined status byte with sensor/derate flags */
    BOOST_PRESSURE_BASE = 0x56, /* Target boost pressure base (scaled >>7) */
    FUEL_TIMING_LIMIT = 0x57, /* Fuel timing transition limit (scaled >>7) */
    FUEL_TIMING_DISPLAY = 0x58, /* INSITE fuel timing display (scaled >>7) */
    OIL_PRESSURE_STATUS = 0x59, /* Oil pressure protection status byte */
    ACTIVE_DERATE_VALUE = 0x5B, /* Active derate value (scaled *250/400) */
    ASTHRFES_CALC = 0x5C, /* ASTHRFES calculation input (scaled >>7) */
    PARAM_DISPLAY_VALUE = 0x64, /* INSITE parameter display value (scaled >>6) */
    DIAGNOSTIC_SENSOR = 0x66, /* Diagnostic sensor reading (scaled >>4 max 0xFF) */
    INTAKE_MANIFOLD_TEMP = 0x69, /* Intake manifold temp (offset 0x1900 scaled >>7) */
    DIAGNOSTIC_READING = 0x6C, /* INSITE diagnostic reading (scaled >>3) */
    THROTTLE_RAW = 0x6E, /* Throttle position raw (offset 0x1900 scaled >>7) */
    RETARDER_MODE_STATUS = 0x79, /* Retarder mode threshold status */
    RESERVED_9C = 0x9C, /* Reserved two-byte response */
    RESERVED_9D = 0x9D, /* Reserved two-byte response */
    ECU_COMMAND_SELECTOR = 0xA6, /* ECU command selector high/low bytes */
    RETARDER_INPUT = 0xA8, /* Retarder input value (>>1 + *2) */
    RESERVED_AF = 0xAF, /* Reserved two-byte response */
    CLUTCH_OPERATING_STATS = 0xB6, /* Clutch operating statistics output */
    FUEL_STATISTICS_CMD = 0xB7, /* Fuel statistics command value */
    FUEL_ECONOMY_STATS = 0xB8, /* Fuel economy statistics output */
    CLUTCH_TRANSITIONS = 0xB9, /* Clutch transitions per distance */
    OIL_PRESSURE_THRESHOLD = 0xBB, /* Oil pressure RPM limit threshold (scaled >>1) */
    GOVERNOR_RPM_ERROR = 0xBC, /* Governor RPM error value (scaled >>1) */
    AC_HIGH_PRESSURE = 0xBD, /* AC high pressure switch (scaled >>1) */
    CURRENT_RPM_RAW = 0xBE, /* Current engine RPM raw (scaled >>1) */
    ACTIVE_FAULT_LIST = 0xC1, /* Active fault list builder (insiteActiveFaultLis... */
    FAULT_DETAIL = 0xC2, /* Fault detail builder (insiteFaultDetailBuilder) */
    LIVE_DATA_PARAM = 0xC4, /* Live data parameter with lookup state */
    ECU_ID_RESPONSE = 0xEA, /* ECU ID response builder (insiteEcuIdResponseBui... */
    RUNTIME_HOURS = 0xEB, /* Runtime hours accumulator (/0x708) */
    COMMAND_BASE_VALUE = 0xEC, /* INSITE command base value (4 bytes) */
    CAPACITY_RESPONSE = 0xED, /* Capacity response builder (insiteCapacityRespon... */
    VERSION_INFO = 0xF3, /* Version info builder (insiteVersionInfoBuilder) */
    VEHICLE_DISTANCE_CLUTCH = 0xF4, /* Vehicle distance clutch value (proportional calc) */
    VEHICLE_DISTANCE_STATS = 0xF5, /* Vehicle distance statistics value (proportional... */
    VEHICLE_HOURS_STATS = 0xF7, /* Vehicle hours statistics value (/0x708) */
    IDLE_HOURS = 0xF8, /* INSITE idle hours accumulator (/0x708) */
    FUEL_STATS_OUTPUT = 0xFA /* INSITE fuel statistics output */
} __attribute__((packed)) INSITE_PARAM_CODE;

typedef enum {
    SENSOR_BIT4_SET = 1, /* Sensor status register bit 4 (0x10) is set */
    SENSOR_BIT2_SET = 2, /* Sensor status register bit 2 (0x04) is set */
    SENSOR_BIT3_SET = 4, /* Sensor status register bit 3 (0x08) is set */
    SENSOR_BIT0_SET = 8, /* Sensor status register bit 0 (0x01) is set */
    SENSOR_BIT1_SET = 0x10, /* Sensor status register bit 1 (0x02) is set */
    DERATE_BIT3_SET = 0x20, /* Derate status byte bit 3 (0x08) is set */
    DERATE_BIT2_SET = 0x40, /* Derate status byte bit 2 (0x04) is set */
    PROTECTION_ENABLED = 0x80 /* Protection system enable flag is set */
} __attribute__((packed)) INSITE_STATUS_OUTPUT;

typedef enum {
    SINGLE_PARAM = 0, /* Single parameter request */
    EXTENDED_PARAM = 0x80, /* Extended parameter request */
    PID_DTC_REQUEST = 0xC3, /* PID/DTC diagnostic request */
    PID_DTC_ACK = 0xC4 /* PID/DTC acknowledgment */
} INSITE_COMMAND;

typedef enum {
    SUCCESS = 0, /* Operation successful */
    DIAG_INVALID_LENGTH = 2, /* Invalid message length */
    SECURITY_FAILED = 3, /* Security check failed */
    BUFFER_OVERFLOW = 4, /* Buffer overflow or unsupported */
    ADDR_VALIDATION_FAIL = 8, /* Address validation failed */
    INVALID_ADDR_RANGE = 9, /* Invalid address range */
    INVALID_ADDR_ALT = 10, /* Invalid address range (alternate) */
    CHECKSUM_MISMATCH = 0x14, /* Checksum mismatch */
    UNKNOWN_SUBFUNC = 0x18 /* Unknown sub-function - default error in diagnos... */
} DIAG_RESPONSE_CODE;

typedef enum {
    SUCCESS_RESPONSE = 12, /* Operation successful - no error code follows */
    STATUS_RESPONSE = 13 /* Error/status response - error code follows in b... */
} CAN_MULTIPACKET_RESPONSE;

typedef enum {
    CORE_SERVICE_ENABLE = 1, /* Core diagnostic service enable */
    CORE_SERVICES = 1, /* Enable services 0x03-0x06 (secured memory ops d... */
    INSITE_ENABLE = 2, /* Insite live data enable */
    INSITE_LIVE = 2, /* Enable services 0x80+ (Insite live data monitor... */
    EXTENDED_ENABLE = 4, /* Extended diagnostics enable (0x45-0x56) */
    EXTENDED_SERVICES = 4, /* Enable services 0x45-0x56 (fuel arbitrator exte... */
    SPECIAL_MODE = 8 /* Special diagnostic mode (checked in multiple fu... */
} DIAG_ENABLE_FLAGS;

typedef enum {
    SENSOR_STATUS_BIT0 = 1, /* Sensor status bit 0 - maps to INSITE output 0x08 */
    SENSOR_STATUS_BIT1 = 2, /* Sensor status bit 1 - maps to INSITE output 0x10 */
    SENSOR_STATUS_BIT2 = 4, /* Sensor status bit 2 - maps to INSITE output 0x02 */
    SENSOR_STATUS_BIT3 = 8, /* Sensor status bit 3 - maps to INSITE output 0x04 */
    SENSOR_STATUS_BIT4 = 0x10 /* Sensor status bit 4 - maps to INSITE output 0x01 */
} __attribute__((packed)) SENSOR_STATUS_BITS;

typedef enum {
    SECURITY_ACTIVE = 0, /* Normal security - checks enforced */
    BYPASS_ENABLED = 0xFF, /* Security checks completely bypassed */
    BYPASS_MAGIC = 0xB522 /* Alternative bypass magic value (-0x4ADE signed) */
} SECURITY_BYPASS_FLAG;

typedef enum {
    AUTH_SUCCESS = 0, /* Security check passed - operation authorized */
    SECURITY_INVALID_LENGTH = 2, /* Invalid message length for service */
    AUTH_FAILED = 3, /* Security check failed - access denied */
    CONDITION_NOT_MET = 7, /* Pre-condition not satisfied */
    INVALID_ADDR = 10, /* Invalid memory address range */
    BUFFER_WRITE_FAIL = 11, /* Circular buffer write failed */
    PROCEED_TO_HANDLER = 0xFF /* Proceed to handler (auth passed or not required) */
} SECURITY_RESULT;

typedef enum {
    SERVICE_SECURED_WRITE = 3, /* Secured write operations (length=3) */
    SERVICE_SYSTEM_CONTROL = 4 /* System control operations (length=3) */
} SECURED_SERVICE_ID;

typedef enum {
    INIT = 0, /* Initialize transmission - setup buffers and add... */
    WRITE_BUFFER = 1, /* Write buffer data with circular buffer */
    TRANSMIT = 2, /* Execute circular buffer write transmission */
    VP44_COMM_IDLE = 3 /* Idle/complete - transmission inactive */
} __attribute__((packed)) VP44_COMM_STATE;

typedef enum {
    MODE_IDLE = 0, /* Idle mode - transition to state 3 */
    MODE_ACTIVE = 1, /* Active mode - perform mid-buffer transmission */
    MODE_RESET = 2 /* Reset mode - transmit to end address and reset ... */
} __attribute__((packed)) VP44_COMM_MODE;

typedef enum {
    STATUS_BIT10 = 0x0400, /* VP44 status flag bit 10 */
    STATUS_BIT11 = 0x0800, /* VP44 status flag bit 11 */
    STATUS_BIT12 = 0x1000, /* VP44 status flag bit 12 */
    STATUS_BIT13 = 0x2000, /* VP44 status flag bit 13 */
    STATUS_BIT14 = 0x4000, /* VP44 status flag bit 14 - protection mode check */
    STATUS_BIT15 = 0x8000 /* VP44 status flag bit 15 - checked in fuel control */
} VP44_STATUS_FLAGS_1;

typedef enum {
    OVERRIDE_FUEL_MODE = 8 /* VP44 override fuel mode active */
} __attribute__((packed)) VP44_STATUS_FLAGS_2;

typedef enum {
    FLAG_BIT14 = 0x4000 /* VP44 flag register bit 14 - fuel control decision */
} VP44_FLAG_REGISTER_1;

typedef enum {
    DIAG_SYS_FLAG_BIT1 = 2, /* Diagnostic flag bit 1 - high RPM protection check */
    DIAG_FLAG_BIT2 = 4, /* Diagnostic flag bit 2 - used with high RPM prot... */
    DIAG_FLAG_BIT12 = 0x1000, /* Diagnostic flag bit 12 */
    DIAG_FLAG_BIT13 = 0x2000, /* Diagnostic flag bit 13 */
    DIAG_FLAG_BIT14 = 0x4000 /* Diagnostic flag bit 14 */
} DIAGNOSTIC_SYSTEM_FLAGS_1;

typedef enum {
    STATUS_F0 = 0xF0, /* Engine state 11 (0x0B case) */
    VP44_STATUS_F1 = 0xF1, /* Engine state 3/7/8 */
    STATUS_F2 = 0xF2, /* Engine state 9 */
    STATUS_F3 = 0xF3, /* Engine state 4 */
    STATUS_F4 = 0xF4, /* Engine state 10 (0x0A case) */
    STATUS_F5 = 0xF5, /* Fuel mode 3 - limited fueling */
    STATUS_F6 = 0xF6, /* Fuel mode 1 - normal operation */
    STATUS_F7 = 0xF7, /* Fuel mode 2 - transition mode */
    STATUS_F8 = 0xF8, /* Engine state 13-21 (0x0D-0x15 cases) */
    STATUS_F9 = 0xF9, /* Engine state 12 (0x0C case) */
    STATUS_FA = 0xFA, /* Engine state 24 (0x18 case) */
    STATUS_FE = 0xFE /* Default/error state */
} VP44_CMD_STATUS;

typedef enum {
    VP44_STATUS_BYTE = 0, /* Engine status/mode byte (0xF0-0xFE values) */
    FUEL_HIGH = 1, /* Fuel amount high byte (param_table_aux>>8 + 125) */
    FUEL_LOW = 2, /* Fuel amount low byte (param_table_main>>8 + 125) */
    TIMING_3 = 3, /* Timing advance data byte 3 */
    TIMING_4 = 4, /* Timing advance data byte 4 */
    TIMING_5 = 5, /* Timing advance data byte 5 */
    RPM_LOW = 6, /* Engine RPM low byte (current_engine_rpm & 0xFF) */
    RPM_HIGH = 7 /* Engine RPM high byte (current_engine_rpm >> 8) */
} VP44_CMD_BYTE;

typedef enum {
    FUEL_TEMP_LOW = 1, /* Fuel temperature low byte */
    FUEL_TEMP_HIGH = 2, /* Fuel temperature high byte */
    SEQUENCE_NUM = 3, /* Message sequence number */
    MSG_ID_HIGH = 6 /* Message ID high byte (must be 0xEF) */
} VP44_RESP_BYTE;

typedef enum {
    FUEL_TEMP_MSG = 0x10, /* VP44 fuel temperature response (calls vp44FuelT... */
    PARAM_REQUEST_MSG = 0x11, /* Diagnostic parameter request (calls diagnosticP... */
    STATUS_REQUEST_MSG = 0x13, /* Diagnostic status request (calls diagnosticStat... */
    ERROR_MSG = 0xFF /* Error message (calls diagnosticErrorHandler) */
} VP44_CAN_DISPATCH;

typedef enum {
    NO_SYNC = 0, /* No synchronization established */
    HAVE_SYNC = 1, /* Synchronization established and maintained */
    LOST_SYNC = 2 /* Synchronization was established but lost */
} SYNC_STATE;

typedef enum {
    FSO_BIT1_FAULT = 0x10, /* FSO bit 1 fault detected (vp44_status_register ... */
    FSO_CIRCUIT_FAULT = 0x20 /* FSO circuit fault detected (vp44_status_registe... */
} VP44_FSO_FAULT;

typedef enum {
    TRANSPORT_HEADER = 0x18EC, /* J1939 transport protocol header */
    EXPECTED_RESPONSE = 0xEF00, /* Expected VP44 response ID (0xEF byte) */
    MSG_HEADER = 0x00F00400UL /* VP44 command message header constant */
} VP44_PROTOCOL;

typedef enum {
    FAULT_DURATION_COUNT = 0, /* Count fault duration (protectionState0FaultDura... */
    DIAGNOSTIC_VALIDATE = 1, /* Validate diagnostic conditions (protectionState... */
    THRESHOLD_CALC = 2, /* Calculate protection thresholds (protectionStat... */
    PRIMARY_RPM_MONITOR = 3, /* Primary coordinator + RPM monitor (protectionSt... */
    EMERGENCY_HANDLER = 4 /* Emergency shutdown handler (protectionState4Eme... */
} PROTECTION_STATE;

typedef enum {
    STATUS_BIT0_LOAD_INACTIVE = 1, /* Bit 0 set when load calculation inactive */
    STATUS_NORMAL = 0xF0, /* Normal operation - load below threshold */
    PROP_DIAG_STATUS_F1 = 0xF1, /* Status F1 - specific condition */
    STATUS_LOAD_HIGH = 0xF4, /* Load above threshold */
    STATUS_FAULT_ACTIVE = 0xF8 /* Critical fault active (fault 67 or 69) */
} PROP_DIAG_STATUS;

typedef enum {
    HIGH_RPM_WARNING_ACTIVE = 1, /* High RPM protection warning flag set */
    SHUTDOWN_TIMER_ZERO = 2, /* Shutdown active and timer expired */
    FAULT_WITH_DIAG = 4, /* High RPM fault + diagnostic flag bit 2 */
    HIGH_RPM_DIAG_FLAG_BIT1 = 8, /* Diagnostic system flags bit 1 (0x02) is set */
    TIMER_ACTIVE = 0x80 /* High RPM protection timer is running */
} __attribute__((packed)) HIGH_RPM_PROTECTION_FLAGS;

typedef enum {
    FAULT_67_BIT = 8, /* Fault ID 67 - critical fault affecting load status */
    FAULT_68_BIT = 0x10, /* Fault ID 68 - affects FSO detection */
    FAULT_69_BIT = 0x20 /* Fault ID 69 - critical fault affecting load status */
} FAULT_WORD_4_BITS;

typedef enum {
    FUEL_SYNC_IDLE = 0, /* Idle - waiting for VP44 diagnostic fault */
    FAULT_COUNTING = 1, /* Fault counting - increment until threshold reached */
    STATUS_MONITORING = 2, /* Status monitoring - check RPM and injection flags */
    FAULT_CONFIRMED = 3, /* Fault confirmed - wait for VP44 fault clear */
    DELAY_RECOVERY = 4 /* Delay recovery - count down before returning to... */
} FUEL_SYNC_STATE;

typedef enum {
    FUEL_SRC_GOVERNOR_LOW = 9, /* Governor control - low fuel demand */
    FUEL_SRC_GOVERNOR_HIGH = 10, /* Governor control - high fuel demand */
    FUEL_SRC_DIAGNOSTIC = 11, /* Diagnostic mode override (mode 0xB) */
    FUEL_SRC_RAMP_LIMIT = 0x12, /* Ramp rate limited fuel demand */
    FUEL_SRC_CALCULATED = 0x14, /* Calculated fuel demand from tables */
    FUEL_SRC_LOW_RPM = 0x16, /* Low RPM running / transitional mode fuel */
    FUEL_SRC_OVERRIDE = 0x17, /* Manual override fuel command */
    FUEL_SRC_VP44_ACTIVE = 0x18, /* VP44 injection system active fuel */
    FUEL_SRC_HIGH_PERF = 0x19, /* High performance mode fuel */
    FUEL_SRC_IDLE = 0x1A, /* Idle mode - zero fuel command */
    FUEL_SRC_FAULT = 0x1B /* Fault/emergency mode fuel */
} __attribute__((packed)) FUEL_SOURCE_ID;

typedef enum {
    NONE = 0, /* No active diagnostic source */
    FUEL_ARBITRATOR = 1, /* Fuel arbitrator triggered (rpm_target == 2) */
    DIAG_STATUS_2 = 2, /* Diagnostic status 2 condition */
    ENGINE_FLAGS = 5, /* Engine control flags triggered */
    EPS_FAULT = 6, /* Electronic Position Sensor fault */
    DIAG_STATUS_7 = 7, /* Diagnostic status 7 condition */
    DIAG_STATUS_30 = 0x1E /* Diagnostic status 30 condition */
} DIAGNOSTIC_SOURCE_CODE;

typedef enum {
    LOW_RPM_OR_TRANSITIONAL = 0x16, /* Low RPM running or transitional fuel mode */
    MANUAL_OVERRIDE = 0x17, /* Manual override fuel command mode */
    VP44_ACTIVE_MODE = 0x18, /* VP44 injection system active */
    HIGH_PERFORMANCE_MODE = 0x19, /* High performance mode */
    IDLE_STATE = 0x1A, /* Idle/no-fuel state */
    FAULT_EMERGENCY_STATE = 0x1B /* Fault/emergency shutdown state */
} VP44_ENGINE_STATE;

typedef enum {
    FUEL_MODE_INSITE_DISPLAY = 10, /* INSITE live data display mode */
    FUEL_MODE_RPM_THRESHOLD = 11, /* RPM threshold protection mode */
    FUEL_MODE_FUEL_DELIVERY = 12 /* Fuel delivery control mode */
} __attribute__((packed)) DIAGNOSTIC_FUEL_CONTROL_MODE;

typedef enum {
    TIMING_MODE_A = 1, /* PWM output timing mode A */
    TIMING_MODE_B = 2 /* PWM output timing mode B */
} __attribute__((packed)) OUTPUT_CONTROL_TIMING_STATE;

typedef enum {
    RETARDER_DISABLED = 0, /* Retarder control disabled */
    RETARDER_SPEED_SYNC = 1, /* Speed synchronization mode */
    RETARDER_LOAD_BASED = 2, /* Load-based retard mode */
    RETARDER_PROPORTIONAL = 3 /* Proportional control mode */
} __attribute__((packed)) RETARDER_MODE_STATE;

typedef enum {
    OUTPUT_TIMER_IDLE = 0, /* Output timer idle state */
    OUTPUT_TIMER_STATE_1 = 1, /* Output timer state 1 */
    OUTPUT_TIMER_STATE_2 = 2, /* Output timer state 2 */
    OUTPUT_TIMER_STATE_3 = 3, /* Output timer state 3 */
    OUTPUT_TIMER_STATE_4 = 4, /* Output timer state 4 */
    OUTPUT_TIMER_STATE_5 = 5 /* Output timer state 5 */
} __attribute__((packed)) OUTPUT_CONTROL_TIMER_STATE;

typedef enum {
    INITIAL = 0, /* Initial state check angle threshold */
    DZG_ACTIVE = 1, /* Active state monitor for transitions */
    ALTERNATE = 2 /* Alternative mode state */
} DZG_TIMING_STATE;

typedef enum {
    SENSOR_IDLE = 0, /* Initial monitoring state */
    SENSOR_ACTIVE = 1, /* Sensor actively being monitored */
    SENSOR_FAULT_DETECTED = 2, /* Fault condition detected */
    RECOVERY = 3 /* Recovery countdown state */
} SENSOR_HISTORY_STATE;

typedef enum {
    FUEL_DEMAND_MODE_OVERRIDE = 13, /* Fuel demand mode selector override (fuelDemandM... */
    SHUTDOWN_PROTECTION_LIMIT = 15, /* Shutdown protection fuel limit (shutdownMinimum... */
    DIAGNOSTIC_MODE_BUFFER = 0x10, /* Diagnostic mode buffer limit (shutdownMinimumSe... */
    FUEL_LIMIT_SHUTDOWN = 0x11, /* Fuel limit from shutdown calc (shutdownMinimumS... */
    CALCULATED_FUEL_TIMING = 0x13, /* Calculated fuel timing value (shutdownMinimumSe... */
    FUEL_ARBITRATOR_DIAG = 0x14, /* Fuel arbitrator diagnostic mode (shutdownMinimu... */
    SHUTDOWN_LIMIT_SELECTOR = 0x15, /* Shutdown limit selector value (shutdownMinimumS... */
    SHUTDOWN_MINIMUM_INIT = 0x1C, /* Shutdown minimum init value (shutdownMinimumSel... */
    PROTECTION_SHUTDOWN_LIMIT = 0x1D, /* Protection shutdown fuel limit (shutdownMinimum... */
    OIL_PRESSURE_PROTECTION = 0x22 /* Oil pressure protection limit (oilPressureProte... */
} SHUTDOWN_SELECTOR_SOURCE;

typedef enum {
    TABLE_BLEND_CALC = 0, /* Table interpolation blend calculation result */
    RPM_BASED_LIMIT = 1, /* RPM-based fuel demand limit (fuelDemandLimitMin... */
    BLEND_PARAM_FALLBACK = 2, /* Blend parameter 2 fallback value */
    HIGH_RPM_FUEL_LIMIT = 3, /* High RPM fuel limit (fuelLimitMinimumSelector) */
    FUEL_LIMIT_FLOOR = 4, /* Fuel limit floor value (fuelDemandLimitSelector4) */
    ENGINE_MODE_TRANSITION = 5, /* Engine mode transition timing (engineModeTransi... */
    STATE_24_OVERRIDE = 6, /* VP44 active mode state 24 override (fuelDemandS... */
    VP44_FLAG_REGISTER = 11 /* VP44 flag register RPM load lookup (fuelDemandL... */
} FUEL_DEMAND_SOURCE;

typedef enum {
    NO_LIMIT_ACTIVE = 0, /* No fuel limit active / cleared state */
    OVERRIDE_STATE_ACTIVE = 1, /* Override state active from fuel_demand_override... */
    VP44_DIAGNOSTIC_FAULT = 2, /* VP44 diagnostic fault limit (fuelDemandLimitSou... */
    RETARDER_INPUT_LIMIT = 3, /* Retarder input flags based limit (fuelDemandLim... */
    RETARDER_MODE_TABLE = 4, /* Retarder mode table count limit (fuelDemandLimi... */
    PROTECTION_OVERRIDE = 5 /* Protection/override state - init and fault reco... */
} FUEL_DEMAND_LIMIT;

typedef enum {
    NORMAL_OPERATION = 0, /* No diagnostic mode active - normal operation */
    FUEL_ARBITRATOR_SOURCE = 1, /* Fuel arbitrator rpm_target==2 (setDiagnosticSou... */
    DERATE_CONDITION_2 = 2, /* Derate condition 2 active (diagnosticStatus2Ini... */
    DERATE_CONDITION_3 = 3, /* Derate condition 3 - governor PID active mode */
    ENGINE_FLAGS_SOURCE = 5, /* Engine flags diagnostic source (setDiagnosticSo... */
    EPS_FAULT_MODE = 6, /* EPS diagnostic mode from fault registers (epsDi... */
    DIAGNOSTIC_MODE_7 = 7, /* Diagnostic mode 7 - target RPM rate limiting ac... */
    DEFAULT_DIAGNOSTIC = 8, /* Default diagnostic mode (diagnosticStatusDefaul... */
    DERATE_CONDITION_30 = 0x1E /* Derate condition 0x1e active (diagnosticStatus3... */
} DIAGNOSTIC_STATUS;

typedef enum {
    INACTIVE = 0, /* Diagnostic mode inactive / cleared */
    BOOST_PRESSURE_INIT = 1, /* Boost pressure threshold check init (set protec... */
    BOOST_PRESSURE_MONITOR = 2, /* Boost pressure monitoring active */
    SENSOR_BIT8_TRIGGERED = 3, /* Sensor status bit 8 triggered protection */
    SENSOR_BIT2_PROTECTION = 4, /* Sensor status bit 2 protection active */
    SENSOR_TYPE_0_MODE = 5, /* Sensor type 0 mode (vp44_sensor_type_selector==0) */
    SENSOR_TYPE_1_MODE = 6, /* Sensor type 1 mode (vp44_sensor_type_selector!=0) */
    PROTECTION_CONTINUE = 7, /* Protection system continue state */
    EXIT_DISABLED = 8, /* Exit/disabled state - protection clearing */
    UNINITIALIZED = 0x0100 /* Transitional/uninitialized state (0x100) */
} VP44_DIAG_MODE;

typedef enum {
    MONITORING = 0, /* Initial state - monitoring conditions for entry */
    TIMER_COUNTING = 1, /* Timer countdown active - conditions met */
    RPM_PROTECTION_WARNING_ACTIVE = 2, /* Warning threshold reached - protection active */
    FAULT_TRIGGERED = 3, /* Fault triggered - derate change detected during... */
    SHUTDOWN_PENDING = 4 /* Shutdown pending - timer expired waiting for idle */
} HIGH_RPM_PROTECTION_STATE;

typedef enum {
    INIT_SEND = 0, /* Initial send state - start transmission */
    SENDING_DATA = 1, /* Actively sending data bytes */
    CHECKSUM_CALC = 2, /* Checksum calculation state */
    TRANSMISSION_COMPLETE = 3 /* Transmission complete - cleanup */
} __attribute__((packed)) TPU_TRANSMISSION_STATE;

typedef enum {
    CYCLE_PHASE_0 = 0, /* Timing cycle phase 0 */
    CYCLE_PHASE_1 = 1, /* Timing cycle phase 1 */
    CYCLE_PHASE_2 = 2, /* Timing cycle phase 2 */
    CYCLE_PHASE_3 = 3, /* Timing cycle phase 3 */
    CYCLE_PHASE_4 = 4, /* Timing cycle phase 4 */
    CYCLE_PHASE_5 = 5 /* Timing cycle phase 5 */
} __attribute__((packed)) PWM_TIMER_CYCLE_STATE;

typedef enum {
    NO_DERATE = 0, /* No derate condition active */
    TIMING_ACTIVE = 1, /* Derate timing accumulator active */
    EVENT_COUNTED = 2 /* Event counted - counter incremented */
} DERATE_EVENT_STATE;

typedef enum {
    OFF_INACTIVE = 0, /* Output off/inactive - waiting for condition */
    TRANSITIONING = 1, /* Transition state - checking conditions */
    ON_ACTIVE = 2 /* Output on/active - condition met */
} __attribute__((packed)) IO_CONTROL_STATE;

typedef enum {
    INITIALIZING = 0, /* Initial state - buffers being configured */
    CAPTURING = 1, /* Actively capturing timer pulses */
    RPM_FAULT_DETECTED = 2 /* Fault detected in capture sequence */
} __attribute__((packed)) RPM_CAPTURE_STATE;

typedef enum {
    BLEND_RAMP_DEFAULT = 0, /* Default timing protection blend ramp */
    ARBITRATION_VALUE = 1, /* Fuel timing mode arbitration value */
    ARBITRATION_1 = 2, /* Fuel timing mode arbitration 1 (VP44 timing) */
    ARBITRATION_2 = 3, /* Fuel timing mode arbitration 2 (protection mode... */
    PARAM_OVERRIDE = 4 /* Parameter override mode (fuel_timing_mode_arbit... */
} TIMING_MODE_SOURCE;

typedef enum {
    RESET_INACTIVE = 0, /* Reset/inactive state - initialized in vp44Contr... */
    FUEL_CONTROL_A = 1, /* Fuel control condition A - checked with value 2 */
    FUEL_CONTROL_B = 2, /* Fuel control condition B - checked with value 1 */
    TRANSITION_STATE_3 = 3, /* Transition state 3 - triggers mode change on entry */
    TRANSITION_STATE_4 = 4 /* Transition state 4 - triggers mode change on entry */
} VP44_OPERATING_CONDITION;

typedef enum {
    STATE_0_IDLE = 0, /* State 0 - idle/cleared state (returns 0 from ma... */
    STATE_1_ACTIVE = 1, /* State 1 - active state with timer/transition ha... */
    STATE_2_MONITOR = 2, /* State 2 - monitoring state with transition hand... */
    STATE_3_TRANSITION = 3, /* State 3 - transition state */
    STATE_4_DEFAULT = 4, /* State 4 - default init state (set in vp44StateV... */
    STATE_5_FAULT = 5 /* State 5 - fault/error state (returns 1 from map... */
} VP44_STATE;

typedef enum {
    HISTOGRAM_IDLE = 0, /* No histogram update needed */
    INCREMENT = 1, /* Increment histogram index (data < conversion st... */
    DECREMENT = 2 /* Decrement histogram index (counter < conversion... */
} __attribute__((packed)) ENGINE_HISTOGRAM_MODE;

typedef enum {
    GET_STATUS_REQ = 0, /* CLIP Get Status Request - sets response buffer ... */
    DATA_TRANSFER_UNHANDLED = 3, /* DataTransfer - NO HANDLER falls through to else... */
    LIVE_DATA_STREAM = 0x80, /* Multi-frame live data stream with sequence hand... */
    SEQUENCE_HANDLER = 0xC3 /* Sequence handling (0x30/0x31 patterns) */
} __attribute__((packed)) INSITE_LIVE_DATA_MSG_TYPE;

typedef enum {
    UNKNOWN_SERVICE_DEFAULT = 0x18 /* Default error code when service ID not found in... */
} __attribute__((packed)) DIAG_SERVICE_ERROR;

typedef enum {
    QUERY_INITIALIZE = 0, /* Initialize query session */
    QUERY_TERMINATE = 1, /* Terminate query session */
    GET_PARAMETERS_BY_ID = 0x10, /* Read parameters by ID */
    SET_PARAMETERS_BY_ID = 0x11, /* Write parameters by ID */
    EXECUTE_OPERATION = 0x12, /* Execute ECU operation */
    GET_DATA_BY_ADDRESS = 0x13, /* Read memory by address */
    SET_DATA_BY_ADDRESS = 0x14, /* Write memory by address */
    GET_ADDRESS_BY_PARAMETER_ID = 0x15 /* Get parameter address from ID */
} __attribute__((packed)) CLIP_INSTRUCTION;

typedef enum {
    SYNC = 0x80, /* Synchronous frame - wait for response */
    ASYNC = 0xC0 /* Asynchronous frame - no immediate response expe... */
} __attribute__((packed)) DPA_FRAME_TYPE;

typedef enum {
    RECEIVE = 0x48, /* Receive data from ECU (RX instruction) */
    TRANSMIT = 0x49 /* Send data to ECU (TX instruction) */
} __attribute__((packed)) DPA_INSTRUCTION;

typedef enum {
    QUERY_TERMINATE = 1, /* QueryTerminate - CLIP compatible - handler @ 0x... */
    SYSTEM_SERVICE_04 = 4, /* System service 04 - handler @ 0x1b150 */
    SYSTEM_SERVICE_05 = 5, /* System service 05 - handler @ 0x1b160 */
    SYSTEM_SERVICE_06 = 6, /* System service 06 - handler @ 0xf8d8 */
    SYSTEM_SERVICE_07 = 7, /* System service 07 - handler @ 0xf876 */
    SYSTEM_SERVICE_0A = 10, /* System service 0A - handler @ 0xf89c */
    SYSTEM_SERVICE_0B = 11, /* System service 0B - handler @ 0xf8e4 */
    SYSTEM_SERVICE_0F = 15, /* System service 0F - same handler as 0x10 @ 0x1b07e */
    GET_PARAMETERS_BY_ID = 0x10, /* GetParametersByID - CLIP compatible - handler @... */
    GET_ADDRESS_BY_PARAM_ID = 0x15, /* GetAddressByParameterID - CLIP compatible - han... */
    SYSTEM_SERVICE_16 = 0x16, /* System service 16 - handler @ 0xf8b6 */
    SYSTEM_SERVICE_18 = 0x18, /* System service 18 - handler @ 0xf9e4 */
    SERVICE_41 = 0x41, /* Service 41 - handler @ 0x1bc9c */
    SERVICE_43 = 0x43, /* Service 43 - handler @ 0x1bf18 */
    SERVICE_44 = 0x44, /* Service 44 - handler @ 0x1b56e (same as 0x45) */
    SERVICE_45 = 0x45, /* Service 45 - handler @ 0x1b56e (same as 0x44) */
    SERVICE_46 = 0x46, /* Service 46 - handler @ 0x1bf64 */
    SERVICE_47 = 0x47, /* Service 47 - handler @ 0x1b604 */
    SERVICE_48 = 0x48, /* Service 48 - handler @ 0x1bfc8 */
    J1939_DATA_COPY = 0x49, /* j1939DataCopyWrapperExtended @ 0x1b668 - memory... */
    MEM_READ_4B_ADDR_1B_LEN = 0x4A, /* diagMemoryReadService4aHandler @ 0x1c02e - WORK... */
    SERVICE_4B = 0x4B, /* Service 4B - handler @ 0x1b6ce */
    SERVICE_4C = 0x4C, /* Service 4C - handler @ 0x1c076 */
    SERVICE_4D = 0x4D /* Service 4D - handler @ 0x1b716 */
} __attribute__((packed)) EF00_SERVICE_ID;

typedef enum {
    FIRMWARE_START = 0, /* Valid firmware region start (256KB code space) */
    FIRMWARE_END = 0x0003FFFFUL, /* Valid firmware region end */
    RAM_START = 0x00800000UL, /* Valid RAM region start (~37KB data) */
    RAM_END = 0x008091C2UL /* Valid RAM region end */
} VALID_MEMORY_RANGE;

typedef enum {
    INVALID_LENGTH = 2, /* diagnosticServiceSecurityValidator - message le... */
    SECURITY_FAILED = 3, /* diagnosticServiceSecurityValidator - systemSecu... */
    CONDITION_NOT_MET = 7, /* memoryOperationDispatcher - system_logging_stat... */
    ADDR_LOOKUP_FAIL = 8, /* j1939MemoryDataCopyResolver - initial address l... */
    ADDR_RANGE_INVALID = 9, /* addressRangeValidator @ 0x2b544 - address not i... */
    ADDR_ACCESS_DENIED = 10, /* addressRangeValidator @ 0x2b544 - normal_mode_f... */
    BUFFER_WRITE_FAIL = 11, /* memoryOperationDispatcher - circularBufferWrite... */
    PATCH_LIMIT = 14, /* diagnosticResponseBuilder - memory patch count ... */
    UNKNOWN_SERVICE = 0x18 /* diagnosticServiceDispatcher - service ID not in... */
} __attribute__((packed)) DIAG_ERROR_SOURCE;

typedef enum {
    SUCCESS = 0x4B /* Service 0x4A success response code (service ID ... */
} __attribute__((packed)) SERVICE_4A_RESPONSE;

typedef enum {
    DIRECT_ACCESS = 0, /* READ: Allowed | WRITE: Direct access no securit... */
    SECURITY_REQUIRED = 3, /* READ: Allowed | WRITE: Requires security check ... */
    WRITE_DENIED = 4, /* READ: Allowed | WRITE: Denied - returns error 0... */
    LOGGING_MODE = 5, /* READ: Allowed | WRITE: Requires system_logging_... */
    RANGE_INVALID = 9, /* READ: Denied | WRITE: Error - address not in va... */
    ACCESS_DENIED = 10 /* READ: Denied | WRITE: Error - explicitly blocke... */
} __attribute__((packed)) MEMORY_ACCESS_FLAG;

typedef enum {
    LEGACY_BYPASS = 0xFF, /* Legacy security bypass value check in memoryOpe... */
    BYPASS_ENABLED = 0xB522 /* Magic value to bypass security checks (stored a... */
} SECURITY_BYPASS;

typedef enum {
    ENABLE_SPECIAL_MODE = 0x40, /* waterInFuelFaultClear - ENABLES special diagnos... */
    VALIDATE_SPECIAL_MODE = 0x41, /* waterInFuelFaultValidation - validates special ... */
    HIGH_RPM_SHUTDOWN = 0x42, /* activateHighRpmShutdownFlag - trigger high RPM ... */
    SYSTEM_RESET = 0x43, /* triggerDiagnosticSystemReset - diagnostic syste... */
    NOP = 0x50, /* No operation - returns success (0x00) */
    MEMORY_PATCH = 0x51, /* memoryPatchingSystem - apply queued memory patches */
    SECURED_SHUTDOWN = 0x52, /* requestSecuredShutdown - request secured engine... */
    RESERVED_ERROR = 0x53, /* Reserved - always returns error 0x04 */
    CAN_BUFFER_LOG = 0x54 /* canMessageBufferLogger - log CAN message buffer */
} __attribute__((packed)) DIAG_SERVICE_3_CMD;

typedef enum {
    CONTROL_64 = 0x64, /* systemControl64 - system control function */
    FAULT_SCANNER = 0x65, /* enableFaultFlagScanner - enable fault flag scan... */
    STATE_RESET = 0x66, /* Reset diagnostic_command_state to 0 */
    DISABLE_SPECIAL_MODE = 0x69, /* waterInFuelDetectionStateInit - DISABLES specia... */
    RESERVED_70 = 0x70, /* Reserved - returns error 0x04 */
    STATE_BIT0 = 0x71, /* Set diagnostic_command_state bit 0 */
    RESERVED_72 = 0x72, /* Reserved - returns error 0x04 */
    STATE_BIT1 = 0x73, /* Set diagnostic_command_state bit 1 */
    CONTROL_74 = 0x74, /* systemControl74 - system control function */
    CONTROL_75 = 0x75, /* systemControl75 - system control function */
    RESERVED_76 = 0x76 /* Reserved - returns error 0x04 */
} __attribute__((packed)) DIAG_SERVICE_4_CMD;

typedef enum {
    MEM_READ_MODE3 = 0x60, /* diagnosticMemoryReadHandler mode 3 - standard read */
    MEM_WRITE_MODE4 = 0x80, /* diagnosticMemoryWriteHandler mode 4 - 4-byte ad... */
    MEM_WRITE_MODE2 = 0xA0, /* diagnosticMemoryWriteHandler mode 2 - 2-byte ad... */
    MULTI_PKT_RX = 0xB0, /* multiPacketReceiveHandler - multi-packet receive */
    MEM_READ_MODE2 = 0xC0, /* diagnosticMemoryReadHandler mode 2 - compact read */
    MEM_READ_MODE1 = 0xE0, /* diagnosticMemoryReadHandler mode 1 - extended read */
    MULTI_PKT_TX = 0xF0 /* multiPacketTransmitHandler - multi-packet transmit */
} __attribute__((packed)) DIAG_SERVICE_5_MODE;

typedef enum {
    THROTTLE_OVERRIDE = 4, /* Override throttle control when set */
    SPEED_LIMIT_ACTIVE = 8, /* Activate speed limiter when set */
    FUEL_LIMIT_ACTIVE = 0x10 /* Activate fuel limiter when set */
} __attribute__((packed)) FUEL_ARB_FLAGS;

typedef enum {
    PARAM_STANDARD = 0, /* Standard parameter read (0x00-0x7F) - response ... */
    PARAM_EXTENDED = 0x80, /* Extended parameter read (0x80-0xBF) - response ... */
    ACTIVE_FAULT_LIST = 0xC1, /* insiteActiveFaultListBuilder - list of active DTCs */
    FAULT_DETAIL = 0xC2, /* insiteFaultDetailBuilder - detailed fault infor... */
    PID_DTC_REQUEST = 0xC3, /* PID/DTC handler request - triggers insitePidDtc... */
    PID_DTC_RESPONSE = 0xC4, /* PID/DTC response - response length 4 or 7 */
    CAPACITY_INFO = 0xEA, /* insiteCapacityResponseBuilder - response length... */
    ECU_ID = 0xED, /* insiteEcuIdResponseBuilder - ECU identification... */
    VERSION_INFO = 0xF3 /* insiteVersionInfoBuilder - response length 0x1F... */
} __attribute__((packed)) INSITE_CMD;

/* ============================================================ */
/* Forward Struct Declarations                                  */
/* ============================================================ */

typedef struct ad_sensor_config_t ad_sensor_config_t;
typedef struct address_range_entry_t address_range_entry_t;
typedef struct boost_pressure_control_t boost_pressure_control_t;
typedef struct calterm_protocol_t calterm_protocol_t;
typedef struct can_message_log_buffer_t can_message_log_buffer_t;
typedef struct can_param_msg_t can_param_msg_t;
typedef struct can_priority_lookup_table_t can_priority_lookup_table_t;
typedef struct can_std_rx_desc_t can_std_rx_desc_t;
typedef struct circular_buffer_t circular_buffer_t;
typedef struct cummins_data_plate_header_t cummins_data_plate_header_t;
typedef struct cummins_data_plate_t cummins_data_plate_t;
typedef struct derate_table_EPFLTB derate_table_EPFLTB;
typedef struct desired_cylinder_pressure_CPDSZA desired_cylinder_pressure_CPDSZA;
typedef struct diag_service_request_t diag_service_request_t;
typedef struct diag_tp_state_t diag_tp_state_t;
typedef struct diag_transfer_state_t diag_transfer_state_t;
typedef struct diagnostic_source_t diagnostic_source_t;
typedef struct diagnostic_state_buffer_t diagnostic_state_buffer_t;
typedef struct dma_control_block_t dma_control_block_t;
typedef struct dma_descriptor_t dma_descriptor_t;
typedef struct duty_cycle_monitor_DCMNESTB duty_cycle_monitor_DCMNESTB;
typedef struct eeprom_param_t eeprom_param_t;
typedef struct engine_control_flags_t engine_control_flags_t;
typedef struct engine_operating_mode_t engine_operating_mode_t;
typedef struct fault_latch_registers_t fault_latch_registers_t;
typedef struct fault_persistence_counters_t fault_persistence_counters_t;
typedef struct fault_status_registers_t fault_status_registers_t;
typedef struct fuel_arbitrator_diag_t fuel_arbitrator_diag_t;
typedef struct fuel_demand_state_t fuel_demand_state_t;
typedef struct fuel_governor_state_t fuel_governor_state_t;
typedef struct fuel_limit_arbitration_t fuel_limit_arbitration_t;
typedef struct fueling_table_5dfl_t fueling_table_5dfl_t;
typedef struct governor_pid_integral_t governor_pid_integral_t;
typedef struct high_rpm_calibration_t high_rpm_calibration_t;
typedef struct high_rpm_fuel_lookup_args_t high_rpm_fuel_lookup_args_t;
typedef struct high_rpm_protection_t high_rpm_protection_t;
typedef struct high_rpm_threshold_calibration_t high_rpm_threshold_calibration_t;
typedef struct insite_protocol_t insite_protocol_t;
typedef struct insite_session_t insite_session_t;
typedef struct j1939_diagnostic_buffer_t j1939_diagnostic_buffer_t;
typedef struct j1939_header_t j1939_header_t;
typedef struct j1939_source_addresses_t j1939_source_addresses_t;
typedef struct j1939_tx_msg_buffer_t j1939_tx_msg_buffer_t;
typedef struct j1939_vp44_msg_t j1939_vp44_msg_t;
typedef struct low_rpm_calibration_t low_rpm_calibration_t;
typedef struct mc68336_dual_can_t mc68336_dual_can_t;
typedef struct memory_operation_request_t memory_operation_request_t;
typedef struct memory_patch_entry_t memory_patch_entry_t;
typedef struct module_variant_offsets_t module_variant_offsets_t;
typedef struct network_type_switches_t network_type_switches_t;
typedef struct oil_pressure_protection_t oil_pressure_protection_t;
typedef struct param_lookup_args_t param_lookup_args_t;
typedef struct parameter_request_t parameter_request_t;
typedef struct parameter_response_t parameter_response_t;
typedef struct q16_fixed_point_t q16_fixed_point_t;
typedef struct reference_table_t reference_table_t;
typedef struct rpm_calibration_params_t rpm_calibration_params_t;
typedef struct rpm_control_timers_t rpm_control_timers_t;
typedef struct rpm_fuel_protection_t rpm_fuel_protection_t;
typedef struct rpm_rate_limits_t rpm_rate_limits_t;
typedef struct scheduler_phase_slot_t scheduler_phase_slot_t;
typedef struct scheduler_phase_table_t scheduler_phase_table_t;
typedef struct sensor_debounce_state_t sensor_debounce_state_t;
typedef struct sensor_fault_config_t sensor_fault_config_t;
typedef struct shutdown_fuel_lookup_args_t shutdown_fuel_lookup_args_t;
typedef struct shutdown_minimum_selector_t shutdown_minimum_selector_t;
typedef struct system_callback_table_t system_callback_table_t;
typedef struct system_protected_area_t system_protected_area_t;
typedef struct table_interp_args_t table_interp_args_t;
typedef struct timing_mode_control_t timing_mode_control_t;
typedef struct timing_table_4dta_t timing_table_4dta_t;
typedef struct vp44_fault_state_t vp44_fault_state_t;
typedef struct vp44_message_t vp44_message_t;

/* ============================================================ */
/* Struct Definitions (from structure_definitions.csv)         */
/* ============================================================ */

struct eeprom_param_t {
    uint16_t pteshilm; /* PTO setpoint high limit (3000.0 RPM) */
    uint16_t pteslolm; /* PTO setpoint low limit (700.0 RPM) */
    uint16_t ptmnrfes; /* PTO minimum RPM for engagement (700.0 RPM) */
    uint16_t pttlslmx; /* PTO throttle limit maximum (0.101) */
} __attribute__((packed));

struct j1939_header_t {
    uint32_t id; /* CAN identifier containing PGN and addressing info */
    uint16_t length; /* Message data length for single/multi-frame deci... */
} __attribute__((packed));

/* Instance at 0x809654 */
struct diagnostic_state_buffer_t {
    uint16_t diagnostic_mode; /* Parameter system operation mode (state machine ... */
    uint16_t reserved; /* Padding/reserved space */
    uint16_t computed_value; /* Calculated parameter value from table lookups */
} __attribute__((packed));

/* Instance at 0x8071A8 */
struct derate_table_EPFLTB {
    uint16_t derate_values[17]; /* Max fueling derate lookup table - RPM vs %FU (1... */
} __attribute__((packed));

/* Instance at 0x807d1e */
struct duty_cycle_monitor_DCMNESTB {
    uint16_t rpm_thresholds[9]; /* Duty cycle monitor RPM threshold points (9 entr... */
} __attribute__((packed));

/* Instance at 0x606a4 */
struct desired_cylinder_pressure_CPDSZA {
    uint16_t pressure_table[91]; /* Desired cylinder pressure lookup table - PSIA v... */
} __attribute__((packed));

struct parameter_response_t {
    uint8_t error_code; /* Error code (0=success non-zero=error) */
    uint16_t param_value; /* Retrieved parameter value */
    uint8_t scaling_applied; /* Flag indicating if scaling was applied */
    uint32_t timestamp; /* Response generation timestamp */
} __attribute__((packed));

/* Instance at 0x803036 */
struct j1939_vp44_msg_t {
    uint8_t j1939_status_byte; /* J1939 transmission message status/header byte */
    uint8_t fuel_amount_high; /* Fuel amount high byte (param_table_aux>>8 + 125) */
    uint8_t fuel_amount_low; /* Fuel amount low byte (param_table_main>>8 + 125) */
    uint8_t rpm_low; /* Engine RPM low byte (current_engine_rpm & 0xFF) */
    uint8_t rpm_high; /* Engine RPM high byte (current_engine_rpm >> 8) */
    uint32_t vp44_header; /* VP44 0x100 command message header (0xF00400 base) */
    uint8_t vp44_fuel_high; /* VP44 fuel amount high byte (same as fuel_amount... */
    uint8_t vp44_fuel_low; /* VP44 fuel amount low byte (same as fuel_amount_... */
    uint8_t timing_byte3; /* VP44 timing advance data byte 3 */
    uint8_t timing_byte4; /* VP44 timing advance data byte 4 */
    uint8_t timing_byte5; /* VP44 timing advance data byte 5 */
    uint8_t timing_byte6; /* VP44 timing advance data byte 6 */
    uint8_t vp44_rpm_low; /* VP44 RPM×4 low byte (current_engine_rpm & 0xFF) */
    uint8_t vp44_rpm_high; /* VP44 RPM×4 high byte (current_engine_rpm >> 8) */
} __attribute__((packed));

struct calterm_protocol_t {
    uint8_t checksum; /* Message integrity checksum */
    uint8_t command_id; /* CalTerm command identifier */
    uint8_t data_payload[8]; /* Parameter data payload (up to 8 bytes) */
    uint8_t parameter_count; /* Number of parameters in request/response */
} __attribute__((packed));

struct j1939_source_addresses_t {
    uint16_t jcsa1_source_addr_1; /* J1939 source address 1 (JCSA1) */
    uint16_t jcsa2_source_addr_2; /* J1939 source address 2 (JCSA2) */
    uint16_t jcsa3_source_addr_3; /* J1939 source address 3 (JCSA3) */
    uint16_t jcsa4_source_addr_4; /* J1939 source address 4 (JCSA4) */
    uint16_t jcsa5_source_addr_5; /* J1939 source address 5 (JCSA5) */
} __attribute__((packed));

struct param_lookup_args_t {
    uint32_t calculated_block; /* Block × 256 × 4 calculation result */
    uint16_t offset; /* Parameter offset within block */
    uint16_t result_value; /* Retrieved parameter value (capped at 32000) */
} __attribute__((packed));

struct can_param_msg_t {
    uint8_t checksum; /* Message checksum */
    uint8_t msg_id; /* Message identifier */
    uint8_t param_1; /* First parameter byte */
    uint8_t param_2; /* Second parameter byte */
    uint8_t param_3; /* Third parameter byte */
    uint8_t param_4; /* Fourth parameter byte */
    uint16_t timestamp; /* Message timestamp */
} __attribute__((packed));

struct insite_protocol_t {
    uint8_t function_code; /* Insite function code */
    uint8_t live_data_request; /* Live data monitoring request flag */
    uint8_t response_data[6]; /* Live parameter response data */
    uint8_t status_flags; /* Monitoring status flags */
} __attribute__((packed));

/* Instance at 0x8086F6 */
struct reference_table_t {
    uint16_t base_reference; /* Base reference value */
    uint8_t config_byte; /* Configuration flags */
    uint16_t limit_value; /* Parameter limits */
    uint16_t scale_factor; /* Scaling factor */
} __attribute__((packed));

struct mc68336_dual_can_t {
    uint16_t ssc1ltob_controller_1; /* CAN controller 1 last message object (SSC1LTOB) */
    uint16_t sscnltob_main_controller; /* Main CAN controller last message object (SSCNLTOB) */
} __attribute__((packed));

/* Instance at 0x803036 */
struct j1939_tx_msg_buffer_t {
    uint8_t data[8]; /* J1939 message payload data array */
    j1939_header_t header; /* CAN message header (ID + length) */
} __attribute__((packed));

struct network_type_switches_t {
    uint8_t jcnes1sw_type_1; /* Network type switch 1 (0=J1922 1=J1939) */
    uint8_t jcnes2sw_type_2; /* Network type switch 2 (0=J1922 1=J1939) */
    uint8_t jcnes3sw_type_3; /* Network type switch 3 (0=J1922 1=J1939) */
    uint8_t jcnes4sw_type_4; /* Network type switch 4 (0=J1922 1=J1939) */
    uint8_t jcnes5sw_type_5; /* Network type switch 5 (0=J1922 1=J1939) */
} __attribute__((packed));

struct parameter_request_t {
    uint16_t eeprom_block; /* Target EEPROM memory block */
    uint8_t lookup_function; /* Function ID (1=lookup1 2=lookup2 3=lookup3) */
    uint16_t param_offset; /* Parameter offset within block */
    uint8_t validation_result; /* Parameter validation status */
} __attribute__((packed));

/* Instance at 0x0100003A */
struct cummins_data_plate_header_t {
    uint16_t data_plt_module_id; /* Module identifier (EN=0x454E for CM550/VP44 ECUs) */
} __attribute__((packed));

struct module_variant_offsets_t {
    uint16_t cm550_data_plate_offset; /* CM550 data plate offset (0x2C0) */
    uint16_t vp44_data_plate_offset; /* VP44 data plate offset (0x2C0-0x22=0x29E) */
    uint8_t incal_variant_code; /* InCal calibration variant (A/B/C) */
} __attribute__((packed));

/* Instance at 0x010002C0 */
struct cummins_data_plate_t {
    uint16_t data_plate_length; /* Data plate length field */
    uint8_t engine_make[5]; /* Engine manufacturer identifier */
    uint8_t engine_model[17]; /* Engine model designation */
    uint32_t engine_serial_number; /* Engine serial number */
    uint8_t engine_build_month; /* Engine manufacturing month */
    uint8_t engine_build_day; /* Engine manufacturing day */
    uint8_t engine_build_year; /* Engine manufacturing year */
    uint16_t engine_cpl; /* Engine CPL (Component Parts List) */
    uint16_t peak_torque_low_range; /* Peak torque low range value */
    uint16_t peak_torque_high_range; /* Peak torque high range value */
    uint16_t peak_torque_rpm_low; /* Peak torque RPM low range */
    uint16_t peak_torque_rpm_high; /* Peak torque RPM high range */
    uint16_t governed_speed_low; /* Governed speed low range */
    uint16_t governed_speed_high; /* Governed speed high range */
    uint16_t horsepower_low_range; /* Horsepower low range value */
    uint16_t horsepower_high_range; /* Horsepower high range value */
    uint16_t horsepower_rpm_low; /* Horsepower RPM low range */
    uint16_t horsepower_rpm_high; /* Horsepower RPM high range */
    uint8_t fuel_code_part_number[7]; /* Fuel code part number */
    uint8_t percent_torque_rise; /* Percent torque rise specification */
    uint16_t peak_torque; /* Peak torque specification */
    uint16_t peak_torque_rpm; /* Peak torque RPM specification */
    uint16_t governed_speed; /* Governed speed specification */
    uint16_t ecm_id; /* ECM identification number */
    uint32_t ecm_part_number; /* ECM part number */
    uint32_t ecm_serial_number; /* ECM serial number */
    uint8_t ecm_voltage_low_range; /* ECM voltage low range */
    uint8_t ecm_voltage_high_range; /* ECM voltage high range */
    uint8_t ecm_code[10]; /* ECM identification code */
    uint8_t engine_calibration_time[12]; /* Engine calibration timestamp */
    uint16_t sc_option_number; /* SC option number */
    uint16_t do_option_number; /* DO option number */
    uint8_t other_options[40]; /* Other options field */
    uint8_t oem_name[15]; /* Original equipment manufacturer name */
    uint8_t oem_vehicle[15]; /* OEM vehicle designation */
    uint8_t vin[20]; /* Vehicle identification number */
    uint8_t vehicle_year[10]; /* Vehicle manufacturing year */
    uint8_t customer_name[15]; /* Customer name */
    uint8_t location[15]; /* Installation location */
    uint8_t unit_number[10]; /* Unit identification number */
    uint8_t sc_file_b_part_1[10]; /* SC file B part number 1 */
    uint8_t sc_file_b_part_2[10]; /* SC file B part number 2 */
    uint8_t sc_file_b_part_3[10]; /* SC file B part number 3 */
    uint8_t sc_file_b_part_4[10]; /* SC file B part number 4 */
    uint8_t sc_file_b_part_5[10]; /* SC file B part number 5 */
    uint8_t sc_file_b_part_6[10]; /* SC file B part number 6 */
    uint8_t do_file_b_part_1[10]; /* DO file B part number 1 */
    uint8_t do_file_b_part_2[10]; /* DO file B part number 2 */
    uint8_t pad; /* Unused padding byte */
} __attribute__((packed));

/* Instance at 0x80c3fc */
struct circular_buffer_t {
    uint16_t write_index; /* Current write position (0-511) */
    uint16_t entry_count; /* Number of entries in buffer */
    uint16_t data_buffer_0; /* Sensor data offset 0 */
    uint16_t data_buffer_2; /* Sensor data offset 2 */
    uint16_t data_buffer_4; /* Sensor data offset 4 */
    uint16_t current_engine_rpm; /* Current engine RPM sample (offset 6) */
    uint16_t data_buffer_8; /* Sensor data offset 8 (throttle or RPM comparison) */
    uint8_t data_buffer_rest[500]; /* Remaining circular buffer data */
    uint16_t metadata_buffer[256]; /* Metadata/timestamp array */
} __attribute__((packed));

/* Instance at 0x8034f8 */
struct can_message_log_buffer_t {
    uint8_t j1939_msg_buffers[906]; /* Complete CAN message buffer array for diagnosti... */
} __attribute__((packed));

struct memory_patch_entry_t {
    uint32_t target_address; /* Memory address to patch (supports high memory m... */
    uint8_t patch_size; /* Number of bytes to copy to target address */
    uint8_t reserved; /* Unused padding byte for 6-byte alignment */
} __attribute__((packed));

/* Instance at 0x8062cb */
struct system_protected_area_t {
    uint8_t protected_flags[4]; /* Critical system state area (write-protected dur... */
} __attribute__((packed));

struct memory_operation_request_t {
    uint32_t source_data_ptr; /* Pointer to source data for memory operation */
    uint32_t target_data_ptr; /* Pointer to destination memory location */
    uint16_t operation_size; /* Number of bytes to copy (max 1764 bytes) */
    uint16_t metadata_value; /* Logging metadata/timestamp for circular buffer */
} __attribute__((packed));

struct dma_descriptor_t {
    uint32_t source_address; /* DMA transfer source memory address */
    uint32_t dest_address; /* DMA transfer destination memory address */
    uint16_t transfer_count; /* Number of bytes/words to transfer */
    uint16_t control_flags; /* DMA control flags (mode type enable etc) */
    uint32_t next_descriptor; /* Pointer to next descriptor in chain */
} __attribute__((packed));

/* Instance at 0x800026 */
struct dma_control_block_t {
    uint32_t descriptor_ptr1; /* Pointer to first DMA descriptor chain */
    uint32_t control_flags1; /* Control/enable flags for DMA channel 1 */
    uint32_t descriptor_ptr2; /* Pointer to second DMA descriptor chain */
    uint32_t control_flags2; /* Control/enable flags for DMA channel 2 */
} __attribute__((packed));

/* Instance at 0x803056 */
struct j1939_diagnostic_buffer_t {
    uint32_t can_id; /* J1939 CAN identifier with PGN priority and sour... */
    uint16_t message_length; /* Message data length (typically 3 bytes for diag... */
    uint32_t data_ptr; /* Pointer to diagnostic status data buffer */
    uint32_t unused_ptr; /* Pointer to unused buffer space */
} __attribute__((packed));

/* Instance at 0x8037b6 */
struct can_priority_lookup_table_t {
    uint8_t dm983_priority; /* Priority for Cummins DM-983 diagnostic message */
    uint8_t fedf_priority; /* Priority for PGN FEDF00 secondary parameter mes... */
    uint8_t fee3_priority; /* Priority for PGN FEE300 extended diagnostic mes... */
    uint8_t fef1_priority; /* Priority for PGN FEF100 message */
    uint8_t feeb_priority; /* Priority for PGN FEEB00 message */
    uint8_t feca_priority; /* Priority for PGN FECA00 (DM1) message */
} __attribute__((packed));

/* Instance at 0x809782 */
struct scheduler_phase_slot_t {
    uint32_t last_execution_time; /* Timer value of last task execution */
    uint16_t runtime_ticks; /* Task runtime duration in timer ticks */
    uint16_t deadline_ticks; /* Task execution deadline (0xFFFF = disabled) */
    uint16_t execution_count; /* Number of times task has been executed */
    uint16_t overrun_count; /* Number of deadline overruns detected */
    uint32_t reserved; /* Reserved/padding bytes for alignment */
} __attribute__((packed));

/* Instance at 0x809782 */
struct scheduler_phase_table_t {
    scheduler_phase_slot_t phase_slots; /* Array of 40 scheduler phase slots (16 bytes each) */
} __attribute__((packed));

/* Instance at 0x800F5F */
struct vp44_message_t {
    uint8_t sequence_number; /* VP44 message sequence number for retry logic */
    uint16_t message_id; /* VP44 message identifier */
    uint8_t retry_flag; /* VP44 retry flag (1 when response pending) */
    uint8_t retry_count; /* VP44 actual retry count (max 5) */
    uint8_t timeout_counter; /* VP44 timeout countdown (112 ticks) */
    uint32_t message_data; /* VP44 stored command/data */
    uint8_t expected_sequence; /* Expected sequence for validation */
    uint16_t additional_data; /* Additional message data */
} __attribute__((packed));

struct can_std_rx_desc_t {
    uint32_t id; /* 11-bit CAN ID stored in 32-bit (ABI) */
    uint16_t length; /* DLC */
    uint8_t* data_ptr; /* Pointer to payload bytes */
} __attribute__((packed));

/* Instance at 0x800F34 */
struct diag_tp_state_t {
    uint8_t diag_state; /* State flag: 0=idle 1=active */
    uint8_t expected_id_low; /* Expected low byte of std CAN ID */
    uint16_t expected_guard; /* Guard word; must match (payload[6]<<8) */
    uint8_t total_packets; /* ((total_bytes-1)/7)+1 */
    uint8_t req_start; /* Current sequence index (1-based) */
    uint8_t req_count; /* Remaining packets to send */
    uint8_t pre_status; /* Abort/status flag (non-zero aborts with 7) */
    uint16_t total_bytes; /* Total payload length */
    uint8_t* src_data_ptr; /* Pointer to source payload */
    uint8_t* resp_byte_ptr; /* Pointer to 1-byte response/status */
    uint8_t status_code; /* Countdown/NACK (0x37 init or 0x70 delay) */
    uint8_t reserved_0x47; /* Padding */
    uint32_t tx_header_id; /* Composed CAN ID for TP.CM/TP.DT */
    uint16_t tx_length; /* DLC for frame (8 or tail) */
    uint8_t* tx_cm_buf; /* Scratch 8-byte CM/DT buffer */
} __attribute__((packed));

/* Instance at 0x80D05C */
struct fuel_governor_state_t {
    int16_t out_cmd; /* Final clamped output (governor/fueling command) */
    int16_t cmd_raw; /* Current raw command (signed) */
    int16_t term_ff; /* Feed-forward/scaling term (signed) */
    int16_t term_rate; /* Rate/derivative term (signed saturating) */
    uint16_t accum_lo; /* Q16.16 accumulator low 16 bits (fractional part) */
    uint16_t accum_hi; /* Q16.16 accumulator high 16 bits (integer part /... */
    int16_t limit_hi; /* Accumulator integer ceiling (upper clamp) */
    int16_t limit_cap; /* Accumulator/output cap */
    int16_t rpm_window; /* RPM window/threshold term used for gating */
} __attribute__((packed));

/* Instance at 0x00806C00 */
struct ad_sensor_config_t {
    uint16_t channel_addr; /* A/D channel address for sensor input */
    uint16_t filter_const; /* Digital filter constant (0-1) */
    uint16_t fault_clear_count; /* Fault clear counter threshold */
    uint16_t fault_decrement; /* Fault counter decrement value */
    uint16_t fault_increment; /* Fault counter increment value */
    uint16_t fault_set_threshold; /* Fault set threshold */
    uint16_t high_error_limit; /* A/D high error limit (0-1023) */
    uint16_t low_error_limit; /* A/D low error limit (0-1023) */
} __attribute__((packed));

/* Instance at 0x00060D1E */
struct timing_table_4dta_t {
    uint16_t rpm_axis[9]; /* Engine speed axis for timing table (0-3000 RPM) */
    uint16_t fuel_axis[8]; /* Fueling axis for timing table (0-100 MM3S) */
    uint16_t timing_values[152]; /* Timing advance lookup values (19x16 table) */
} __attribute__((packed));

/* Instance at 0x00060982 */
struct fueling_table_5dfl_t {
    uint16_t rpm_axis[10]; /* Engine speed axis for 4D fueling (0-3000 RPM) */
    uint16_t throttle_axis[2]; /* Throttle position axis (0-100%) */
    uint16_t fuel_values[42]; /* Fueling lookup values (21x4 table) */
} __attribute__((packed));

/* Instance at 0x80d2c0 */
struct diag_service_request_t {
    uint8_t message_length; /* Total message length including header */
    uint8_t service_id; /* Service identifier (3=secured 4=control 5=memory) */
    uint8_t sub_function; /* Sub-function code for service routing */
    uint8_t data_payload[16]; /* Variable-length request data payload */
} __attribute__((packed));

/* Instance at 0x80d3f8 */
struct diag_transfer_state_t {
    uint16_t target_address; /* Target memory address for transfer */
    uint32_t data_pointer; /* Pointer to source/dest data buffer */
    uint16_t remaining_length; /* Remaining bytes to transfer */
    uint16_t byte_count; /* Total byte count for operation */
    uint8_t tx_active_flag; /* Transmit operation active (0/1) */
    uint8_t rx_active_flag; /* Receive operation active (0/1) */
} __attribute__((packed));

/* Instance at 0x80d407 */
struct insite_session_t {
    uint8_t command_byte; /* Current Insite command code */
    uint8_t session_active; /* Session active flag (1=active) */
    uint32_t response_ptr; /* Response buffer pointer */
    uint32_t tx_buffer_ptr; /* Transmit buffer pointer */
    uint32_t rx_buffer_ptr; /* Receive buffer pointer */
    uint8_t buffer_offset; /* Current buffer offset */
    uint8_t param_count; /* Number of parameters in response */
    uint8_t buffer_space; /* Available buffer space */
    uint8_t param_result; /* Last parameter lookup result */
} __attribute__((packed));

/* Instance at 0x80cff8 */
struct fuel_arbitrator_diag_t {
    uint16_t control_flags; /* Control mode flags from request */
    uint16_t fuel_mode; /* Current fuel control mode (0-3) */
    uint16_t rpm_target; /* Target RPM for mode 1 */
    uint16_t throttle_mode; /* Throttle control mode flag */
    uint16_t speed_limit; /* Speed limit for mode 3 */
    uint16_t fuel_limit; /* Fuel limit for mode 2 */
    uint16_t session_counter; /* Diagnostic session counter */
    uint16_t command_counter; /* Command received counter */
    uint8_t last_command; /* Last command ID (0x4A etc) */
    uint32_t state_pointer; /* Current state table pointer */
    uint32_t prev_state_pointer; /* Previous state table pointer */
    uint16_t countdown_timer; /* Mode operation countdown */
    uint16_t secondary_timer; /* Secondary countdown timer */
    uint16_t target_value; /* Calculated target value */
    uint16_t limited_value; /* Limited/clamped target value */
} __attribute__((packed));

/* Instance at 0x008000C8 */
struct fault_persistence_counters_t {
    uint8_t periodic_monitor_phase; /* 5-phase counter for periodic fault monitoring */
    uint8_t can_pin_fault; /* CAN pin switching fault persistence counter */
    uint8_t io_fault_1; /* I/O control fault 1 persistence counter */
    uint8_t io_fault_2; /* I/O control fault 2 persistence counter */
    uint8_t io_fault_3; /* I/O control fault 3 persistence counter */
    uint8_t io_fault_4; /* I/O control fault 4 persistence counter */
    uint8_t io_fault_5; /* I/O control fault 5 persistence counter */
    uint8_t io_fault_6; /* I/O control fault 6 persistence counter */
} __attribute__((packed));

/* Instance at 0x00805DF2 */
struct fault_status_registers_t {
    uint16_t sensor_fault_status; /* Sensor fault status register */
    uint16_t fault_status_2; /* Fault status flags register 2 */
    uint16_t engine_fault_status; /* Engine fault status register */
    uint16_t reserved_06; /* Reserved/gap */
    uint16_t io_fault_status_1; /* IO fault status register 1 */
    uint16_t io_fault_status_2; /* IO fault status register 2 */
    uint16_t io_fault_status_3; /* IO fault status register 3 */
    uint16_t io_fault_status_4; /* IO fault status register 4 */
} __attribute__((packed));

/* Instance at 0x00805E32 */
struct fault_latch_registers_t {
    uint16_t sensor_fault_latch; /* Sensor fault latch register */
    uint16_t fault_status_8_previous; /* Previous state for edge detection */
    uint16_t engine_fault_latch; /* Engine fault latch register */
    uint16_t reserved_06; /* Reserved/gap */
    uint16_t io_fault_latch_1; /* IO fault latch register 1 */
    uint16_t io_fault_latch_2; /* IO fault latch register 2 */
    uint16_t io_fault_latch_3; /* IO fault latch register 3 */
    uint16_t io_fault_latch_4; /* IO fault latch register 4 */
} __attribute__((packed));

/* Instance at 0x0080C810 */
struct engine_operating_mode_t {
    uint16_t state; /* Engine operating mode state 1-8 */
    uint16_t shutdown_complete_flag; /* Engine shutdown complete flag */
} __attribute__((packed));

/* Instance at 0x0080CC6A */
struct high_rpm_protection_t {
    uint16_t fault_flag; /* High RPM protection fault active flag */
    uint16_t state; /* State machine state */
    uint16_t timer; /* Countdown timer */
    uint16_t reserved_06; /* Reserved/gap */
    uint16_t warning_flag; /* Warning active flag */
} __attribute__((packed));

/* Instance at 0x00809746 */
struct boost_pressure_control_t {
    uint16_t state_machine; /* Boost pressure state machine */
    uint16_t active_flag; /* Calculation active flag */
    uint16_t interpolation_result; /* Interpolation result */
} __attribute__((packed));

/* Instance at 0x0080CC4A */
struct fuel_limit_arbitration_t {
    uint16_t source_id; /* ID of current fuel limit source (arbitrator out... */
    uint16_t demand_limited; /* Rate-limited fuel demand */
    uint16_t arbitration_threshold; /* Fuel limit arbitration threshold */
    uint16_t demand_delta; /* Fuel demand delta for rate limiting */
    uint16_t maximum_limit; /* Maximum fuel demand limit */
    uint16_t offset_value; /* Fuel limit offset value */
    uint16_t comparison_low; /* Fuel limit comparison low value */
    uint16_t comparison_high; /* Fuel limit comparison high value */
    uint16_t rate_limit; /* Fuel demand rate limiting value */
} __attribute__((packed));

/* Instance at 0x0080C9A4 */
struct fuel_demand_state_t {
    uint16_t command; /* Current fuel demand value */
    uint8_t source_identifier; /* Source of fuel command (FUEL_SOURCE_ID enum) */
    uint8_t reserved_03; /* Padding byte */
    uint16_t diagnostic_buffer; /* Diagnostic parameter buffer */
    uint16_t timing_blend_factor; /* Fuel timing blend factor 0-16384 */
    uint16_t table_output; /* Fuel demand table output */
    uint16_t limit_minimum; /* Fuel limit minimum value */
    uint16_t demand_source_id; /* Fuel demand source identifier */
    uint16_t adjustment_active; /* Fuel adjustment active flag */
} __attribute__((packed));

/* Instance at 0x00805E14 */
struct vp44_fault_state_t {
    uint16_t fault_status; /* VP44 fault status register */
    uint16_t fso_fault_status; /* VP44 FSO fault status register 2 */
} __attribute__((packed));

/* Instance at 0x0080965A */
struct timing_mode_control_t {
    uint16_t blend_factor; /* Fuel timing mode blend factor Q14 */
    uint16_t protection_blend_ramp; /* Timing protection blend ramp 0-16384 */
    uint16_t source_selector; /* Timing mode source selector 0-4 */
    uint16_t transition_result; /* Timing mode transition result */
    uint16_t fuel_blend_result; /* Timing fuel blend result */
    uint16_t oil_pressure_result; /* Timing oil pressure condition result */
    uint16_t mode_11_result; /* Timing mode 11 countdown result */
    uint16_t protection_counter_1; /* Timing protection counter 1 */
    uint16_t protection_counter_2; /* Timing protection counter 2 */
    uint16_t blend_state; /* Timing blend state */
    uint16_t reserved_14; /* Gap/reserved */
    uint16_t reserved_16; /* Gap/reserved */
    uint16_t blend_accumulator; /* Timing blend accumulator */
    uint16_t reserved_1A; /* Gap/reserved */
    uint16_t fuel_source_mode_11_state; /* Fuel source mode 11 state */
    uint16_t fuel_source_mode_11_timer; /* Fuel source mode 11 timer */
    uint16_t fuel_mode_transition_state; /* Fuel mode transition state */
    uint16_t fuel_mode_transition_timer; /* Fuel mode transition timer */
} __attribute__((packed));

/* Instance at 0x008091C4 */
struct rpm_fuel_protection_t {
    uint16_t fuel_limit_shutdown; /* Fuel limit during shutdown */
    uint16_t high_rpm_fuel_limit; /* High RPM fuel control limit */
    uint16_t low_rpm_fuel_protection_limit; /* Low RPM fuel protection limit */
    uint16_t rpm_rate_limiter_output; /* RPM rate limiter output */
    uint16_t rpm_rate_limited_value; /* RPM rate limited value */
    uint16_t rpm_rate_secondary_calc; /* Secondary RPM rate calculation */
    uint16_t rpm_state_accumulator; /* RPM state accumulator */
    uint16_t high_rpm_fuel_accumulator; /* High RPM fuel accumulator */
    uint16_t low_rpm_fuel_accumulator; /* Low RPM fuel accumulator */
    uint16_t fuel_demand_before_limiting; /* Fuel demand saved before limiting */
    uint16_t low_rpm_threshold_exceeded_flag; /* Low RPM threshold exceeded flag (reserved_14) */
    uint16_t rpm_threshold_exceeded_flag; /* RPM threshold exceeded flag */
    uint16_t high_rpm_threshold_exceeded_flag; /* High RPM threshold exceeded flag */
    uint16_t fuel_protection_timer_enable; /* Timer enable for protection state machines */
    uint16_t fuel_system_protection_enabled; /* Master fuel protection system enable (1=active) */
} __attribute__((packed));

/* Instance at 0x008035D6 */
struct engine_control_flags_t {
    uint16_t fuel_demand_control; /* Fuel demand mode control flags */
    uint16_t protection_system; /* Protection system status flags */
    uint16_t engine_operating_state; /* Engine operating state flags */
    uint16_t reserved_06; /* Gap/reserved */
    uint16_t reserved_08; /* Gap/reserved */
    uint16_t fuel_temp_control; /* Fuel temp control bit flags */
} __attribute__((packed));

/* Instance at 0x00803430 */
struct oil_pressure_protection_t {
    uint32_t sensor_status_history_bits; /* Sensor status history bits - shifting record */
    uint16_t rpm_ramp_complete; /* Flag indicating RPM ramp complete */
    uint16_t rpm_limit_current; /* Current RPM limit from oil pressure */
    uint16_t rpm_limit_target; /* Target RPM limit for oil pressure */
    uint16_t rpm_limit_previous; /* Previous RPM limit for tracking */
    uint16_t state_index; /* State index for oil pressure protection */
    uint16_t validation_timer; /* Timer for oil pressure validation */
    uint16_t sensor_validation_counter; /* Sensor status validation counter */
} __attribute__((packed));

/* Instance at 0x00800000 */
struct rpm_control_timers_t {
    uint16_t low_rpm_threshold_timer; /* Low RPM threshold exceeded timer */
    uint16_t timer_1; /* Timer 1 for shutdown RPM-based control logic */
    uint16_t high_rpm_timer; /* High RPM protection timer */
    uint16_t timer_2; /* Timer 2 for shutdown RPM-based control logic */
    uint16_t high_rpm_accumulator_timer; /* High RPM accumulator holdoff timer */
    uint16_t low_rpm_accumulator_timer; /* Low RPM accumulator holdoff timer */
    uint16_t previous_engine_rpm; /* Previous engine RPM for delta calc */
} __attribute__((packed));

/* Instance at 0x0080000E */
struct shutdown_fuel_lookup_args_t {
    uint16_t table_index; /* Current interpolation index */
    uint32_t x_axis_ptr; /* Pointer to RPM axis table */
    uint16_t input_rpm; /* Input RPM for lookup (copied from current_engin... */
    uint32_t y_axis_ptr; /* Pointer to fuel limit table */
} __attribute__((packed));

/* Instance at 0x0080001A */
struct high_rpm_fuel_lookup_args_t {
    uint16_t table_index; /* Current interpolation index */
    uint32_t x_axis_ptr; /* Pointer to RPM axis table */
    uint16_t input_rpm; /* Input RPM for lookup (copied from current_engin... */
    uint32_t y_axis_ptr; /* Pointer to fuel limit table */
} __attribute__((packed));

/* Instance at 0x008062D4 */
struct rpm_calibration_params_t {
    uint16_t shutdown_timer_reload; /* Timer reload for shutdown protection */
    uint16_t shutdown_fuel_ramp_increment; /* Fuel ramp increment during shutdown recovery */
    uint16_t shutdown_rate_threshold; /* RPM rate threshold for shutdown protection */
    uint16_t shutdown_secondary_threshold; /* Secondary RPM rate threshold for shutdown */
    uint16_t shutdown_rpm_upper_threshold; /* Upper RPM threshold for shutdown protection */
} __attribute__((packed));

/* Instance at 0x008062DE */
struct low_rpm_calibration_t {
    uint16_t low_rpm_fuel_limit; /* Low RPM fuel limit value */
    uint16_t low_rpm_timer_reload; /* Timer reload for low RPM protection */
    uint16_t low_rpm_fuel_ramp_increment; /* Fuel ramp increment for low RPM recovery */
    uint16_t low_rpm_secondary_threshold; /* Secondary RPM rate threshold for low RPM */
    uint16_t low_rpm_upper_threshold; /* Upper RPM threshold for low RPM protection */
    uint16_t low_rpm_rate_threshold; /* RPM rate threshold for low RPM protection */
} __attribute__((packed));

/* Instance at 0x008062EA */
struct high_rpm_calibration_t {
    uint16_t high_rpm_upper_threshold; /* Upper RPM threshold for high RPM protection */
    uint16_t high_rpm_timer_reload; /* Timer reload for high RPM accumulator */
    uint16_t high_rpm_fuel_ramp_increment; /* Fuel ramp increment for high RPM recovery */
    uint16_t high_rpm_secondary_threshold; /* Secondary RPM rate threshold for high RPM */
    uint16_t reserved_08; /* Reserved/gap */
    uint16_t reserved_0a; /* Reserved/gap */
} __attribute__((packed));

/* Instance at 0x008062F8 */
struct rpm_rate_limits_t {
    uint16_t maximum; /* Maximum RPM rate of change limit */
    uint16_t minimum; /* Minimum RPM rate of change limit */
    uint16_t threshold_timer_reload; /* Timer reload when RPM threshold exceeded */
} __attribute__((packed));

/* Instance at 0x00808f02 */
struct system_callback_table_t {
    uint32_t engine_position_sensor_isr; /* EPS position sensor ISR handler (epsPositionSen... */
    uint32_t tpu_adc_isr; /* TPU/QADC interrupt handler (tpuQadcInterruptHan... */
    uint32_t main_loop_callback; /* Main scheduler loop callback (main_loop) */
} __attribute__((packed));

/* Instance at 0x00806300 */
struct high_rpm_threshold_calibration_t {
    uint16_t threshold_timer_reload; /* Timer reload when high RPM threshold exceeded */
    uint16_t rate_threshold; /* RPM rate threshold for high RPM detection */
} __attribute__((packed));

/* Instance at 0x0080d494 */
struct shutdown_minimum_selector_t {
    uint16_t fuel_value; /* Current minimum fuel limit value selected by ar... */
    uint16_t source_id; /* Source ID that set minimum (17=selector17 16=se... */
    uint16_t previous_value; /* Previous minimum value for change tracking */
} __attribute__((packed));

/* Instance at 0x0080d49a */
struct diagnostic_source_t {
    uint16_t value; /* Data/threshold value associated with the diagno... */
    uint16_t code; /* Subsystem code that triggered diagnostic (see D... */
} __attribute__((packed));

struct q16_fixed_point_t {
    uint16_t integer_part; /* High 16 bits - integer/whole number portion (._... */
    uint16_t fractional_part; /* Low 16 bits - fractional portion (._2_2_) */
} __attribute__((packed));

/* Instance at 0x008016e2 */
struct governor_pid_integral_t {
    uint16_t integer_part; /* Integer portion of PID integral (governor_fuel_... */
    uint16_t fractional_part; /* Fractional portion of PID integral (governor_fu... */
} __attribute__((packed));

struct table_interp_args_t {
    uint16_t current_index; /* Current interpolation index into table */
    uint32_t x_axis_ptr; /* Pointer to X-axis table (input values) */
    uint16_t input_value; /* Input value for table lookup */
    uint32_t y_axis_ptr; /* Pointer to Y-axis table (output values) */
} __attribute__((packed));

struct sensor_fault_config_t {
    uint16_t reserved_00; /* Reserved/padding at offset 0x00 */
    uint16_t default_value; /* Default sensor value on fault (offset 0x02) */
    uint16_t clear_threshold; /* Threshold for fault clear (offset 0x04) */
    uint16_t decrement_value; /* Debounce counter decrement (offset 0x06) */
    uint16_t increment_value; /* Debounce counter increment (offset 0x08) */
    uint16_t set_threshold; /* Threshold for fault set (offset 0x0a) */
    uint16_t high_limit; /* High error limit (offset 0x0c) */
    uint16_t low_limit; /* Low error limit (offset 0x0e) */
    uint16_t adc_lookup_index; /* A/D channel lookup table index (offset 0x10) */
    uint8_t reserved_12; /* Reserved byte at offset 0x12 */
    uint8_t alt_fault_enable; /* Alternative fault enable flag (offset 0x13) */
    uint8_t primary_fault_id; /* Primary fault code packed bit/word (offset 0x14) */
    uint8_t secondary_fault_id; /* Secondary fault code (offset 0x15) */
    uint8_t tertiary_fault_id; /* Tertiary fault code (offset 0x16) */
    uint8_t debounce_max; /* Maximum debounce count (offset 0x17) */
} __attribute__((packed));

struct sensor_debounce_state_t {
    uint8_t reserved_00[8]; /* Reserved bytes at offset 0x00-0x07 */
    uint16_t interpolated_value; /* Interpolated sensor value (offset 0x08) */
    uint16_t lookup_result; /* Table lookup result (offset 0x0a) */
    uint16_t debounce_counter; /* Current debounce count (offset 0x0c) */
    uint8_t fault_active_flag; /* Fault currently active flag (offset 0x0e) */
    uint8_t sample_counter; /* Sample phase counter (offset 0x0f) */
    uint16_t adc_raw_value; /* Raw A/D conversion value (offset 0x10) */
    uint8_t reserved_12[4]; /* Reserved bytes at offset 0x12-0x15 */
} __attribute__((packed));

/* Instance at 0x0002b512 */
struct address_range_entry_t {
    uint32_t start_address; /* Start of valid address range (big-endian) */
    uint32_t end_address; /* End of valid address range (big-endian) */
    uint8_t special_mode_flag; /* Access flag when water_in_fuel_detection_flag==... */
    uint8_t normal_mode_flag; /* Access flag in normal operation (0x09=invalid 0... */
} __attribute__((packed));

/* ============================================================ */
/* Struct Instance Macros (for Ghidra structtype_t_ADDRESS refs) */
/* ============================================================ */

#define diagnostic_state_buffer_t_00809654 (*(volatile diagnostic_state_buffer_t*)0X809654UL)
#define derate_table_EPFLTB_008071a8 (*(volatile derate_table_EPFLTB*)0X8071A8UL)
#define duty_cycle_monitor_DCMNESTB_00807d1e (*(volatile duty_cycle_monitor_DCMNESTB*)0X807D1EUL)
#define desired_cylinder_pressure_CPDSZA_000606a4 (*(volatile desired_cylinder_pressure_CPDSZA*)0X606A4UL)
#define j1939_vp44_msg_t_00803036 (*(volatile j1939_vp44_msg_t*)0X803036UL)
#define reference_table_t_008086f6 (*(volatile reference_table_t*)0X8086F6UL)
#define j1939_tx_msg_buffer_t_00803036 (*(volatile j1939_tx_msg_buffer_t*)0X803036UL)
#define cummins_data_plate_header_t_0100003a (*(volatile cummins_data_plate_header_t*)0X0100003AUL)
#define cummins_data_plate_t_010002c0 (*(volatile cummins_data_plate_t*)0X010002C0UL)
#define circular_buffer_t_0080c3fc (*(volatile circular_buffer_t*)0X80C3FCUL)
#define can_message_log_buffer_t_008034f8 (*(volatile can_message_log_buffer_t*)0X8034F8UL)
#define system_protected_area_t_008062cb (*(volatile system_protected_area_t*)0X8062CBUL)
#define dma_control_block_t_00800026 (*(volatile dma_control_block_t*)0X800026UL)
#define j1939_diagnostic_buffer_t_00803056 (*(volatile j1939_diagnostic_buffer_t*)0X803056UL)
#define can_priority_lookup_table_t_008037b6 (*(volatile can_priority_lookup_table_t*)0X8037B6UL)
#define scheduler_phase_slot_t_00809782 (*(volatile scheduler_phase_slot_t*)0X809782UL)
#define scheduler_phase_table_t_00809782 (*(volatile scheduler_phase_table_t*)0X809782UL)
#define vp44_message_t_00800f5f (*(volatile vp44_message_t*)0X800F5FUL)
#define diag_tp_state_t_00800f34 (*(volatile diag_tp_state_t*)0X800F34UL)
#define fuel_governor_state_t_0080d05c (*(volatile fuel_governor_state_t*)0X80D05CUL)
#define ad_sensor_config_t_00806c00 (*(volatile ad_sensor_config_t*)0X00806C00UL)
#define timing_table_4dta_t_00060d1e (*(volatile timing_table_4dta_t*)0X00060D1EUL)
#define fueling_table_5dfl_t_00060982 (*(volatile fueling_table_5dfl_t*)0X00060982UL)
#define diag_service_request_t_0080d2c0 (*(volatile diag_service_request_t*)0X80D2C0UL)
#define diag_transfer_state_t_0080d3f8 (*(volatile diag_transfer_state_t*)0X80D3F8UL)
#define insite_session_t_0080d407 (*(volatile insite_session_t*)0X80D407UL)
#define fuel_arbitrator_diag_t_0080cff8 (*(volatile fuel_arbitrator_diag_t*)0X80CFF8UL)
#define fault_persistence_counters_t_008000c8 (*(volatile fault_persistence_counters_t*)0X008000C8UL)
#define fault_status_registers_t_00805df2 (*(volatile fault_status_registers_t*)0X00805DF2UL)
#define fault_latch_registers_t_00805e32 (*(volatile fault_latch_registers_t*)0X00805E32UL)
#define engine_operating_mode_t_0080c810 (*(volatile engine_operating_mode_t*)0X0080C810UL)
#define high_rpm_protection_t_0080cc6a (*(volatile high_rpm_protection_t*)0X0080CC6AUL)
#define boost_pressure_control_t_00809746 (*(volatile boost_pressure_control_t*)0X00809746UL)
#define fuel_limit_arbitration_t_0080cc4a (*(volatile fuel_limit_arbitration_t*)0X0080CC4AUL)
#define fuel_demand_state_t_0080c9a4 (*(volatile fuel_demand_state_t*)0X0080C9A4UL)
#define vp44_fault_state_t_00805e14 (*(volatile vp44_fault_state_t*)0X00805E14UL)
#define timing_mode_control_t_0080965a (*(volatile timing_mode_control_t*)0X0080965AUL)
#define rpm_fuel_protection_t_008091c4 (*(volatile rpm_fuel_protection_t*)0X008091C4UL)
#define engine_control_flags_t_008035d6 (*(volatile engine_control_flags_t*)0X008035D6UL)
#define oil_pressure_protection_t_00803430 (*(volatile oil_pressure_protection_t*)0X00803430UL)
#define rpm_control_timers_t_00800000 (*(volatile rpm_control_timers_t*)0X00800000UL)
#define shutdown_fuel_lookup_args_t_0080000e (*(volatile shutdown_fuel_lookup_args_t*)0X0080000EUL)
#define high_rpm_fuel_lookup_args_t_0080001a (*(volatile high_rpm_fuel_lookup_args_t*)0X0080001AUL)
#define rpm_calibration_params_t_008062d4 (*(volatile rpm_calibration_params_t*)0X008062D4UL)
#define low_rpm_calibration_t_008062de (*(volatile low_rpm_calibration_t*)0X008062DEUL)
#define high_rpm_calibration_t_008062ea (*(volatile high_rpm_calibration_t*)0X008062EAUL)
#define rpm_rate_limits_t_008062f8 (*(volatile rpm_rate_limits_t*)0X008062F8UL)
#define system_callback_table_t_00808f02 (*(volatile system_callback_table_t*)0X00808F02UL)
#define high_rpm_threshold_calibration_t_00806300 (*(volatile high_rpm_threshold_calibration_t*)0X00806300UL)
#define shutdown_minimum_selector_t_0080d494 (*(volatile shutdown_minimum_selector_t*)0X0080D494UL)
#define diagnostic_source_t_0080d49a (*(volatile diagnostic_source_t*)0X0080D49AUL)
#define governor_pid_integral_t_008016e2 (*(volatile governor_pid_integral_t*)0X008016E2UL)
#define address_range_entry_t_0002b512 (*(volatile address_range_entry_t*)0X0002B512UL)

/* ============================================================ */
/* Global Variables (Memory-Mapped via Pointer Macros)         */
/* ============================================================ */

#define calibration_download_size_n_a (*(volatile uint32_t*)0x00000000UL) /* CALIBRATION DOWNLOAD SIZE */
#define exception_vector_bus_error (*(volatile uint32_t*)0x00000008UL) /* MC68000 Bus Error exception vector - called fro... */
#define ROM_DATE ((volatile uint8_t*)0x00000010UL) /* [6] CalTerm ROM_DATE: BOOT LOADER RELEASE DATE */
#define bootloader_code_end_address (*(volatile uint32_t*)0x00000014UL) /* End address of bootloader code - used by flashB... */
#define eeprom_primary_base_address (*(volatile uint32_t*)0x00004000UL) /* EEPROM primary calibration data base address - ... */
#define eeprom_insite_data_base_address (*(volatile uint32_t*)0x00004400UL) /* EEPROM INSITE version/ID data base - copied to ... */
#define insite_version_string_part_1 ((volatile uint8_t*)0x00004404UL) /* [5] INSITE version string part 1 - 5 bytes copied b... */
#define insite_version_string_part_2 ((volatile uint8_t*)0x00004409UL) /* [17] INSITE version string part 2 - 17 bytes softwar... */
#define insite_version_string_part_3 ((volatile uint8_t*)0x0000441AUL) /* [4] INSITE version string part 3 - 4 bytes copied b... */
#define insite_ecu_command_selector_low (*(volatile uint8_t*)0x00004445UL) /* INSITE ECU command selector low byte - used by ... */
#define insite_ecu_command_selector_high (*(volatile uint8_t*)0x00004446UL) /* INSITE ECU command selector high byte - used by... */
#define insite_ecu_id_part_1 ((volatile uint8_t*)0x0000444BUL) /* [4] INSITE ECU ID part 1 - 4 bytes copied by insite... */
#define insite_ecu_id_part_2 ((volatile uint8_t*)0x0000444FUL) /* [4] INSITE ECU ID part 2 - 4 bytes copied by insite... */
#define insite_ecu_id_part_3 ((volatile uint8_t*)0x0000445FUL) /* [12] INSITE ECU ID part 3 - 12 bytes copied by insit... */
#define hour_meter_conversion_base (*(volatile uint32_t*)0x00004650UL) /* Hour meter conversion calculation base value (4... */
#define fuel_timing_mode_blend_table (*(volatile uint16_t*)0x00004CAAUL) /* Fuel timing mode blend lookup table - used by f... */
#define cold_ambient_air_temperature_threshold_100_255 (*(volatile uint16_t*)0x00004F6CUL) /* COLD AMBIENT AIR TEMPERATURE THRESHOLD */
#define overrides_authorized_above_this_limit_100_255 (*(volatile uint16_t*)0x00004F6EUL) /* OVERRIDES AUTHORIZED ABOVE THIS LIMIT */
#define overrides_authorized_below_this_limit_100_255 (*(volatile uint16_t*)0x00004F70UL) /* OVERRIDES AUTHORIZED BELOW THIS LIMIT */
#define can_memory_pointer_table_entry_1 (*(volatile uint32_t*)0x00005E3EUL) /* CAN memory pointer table entry - used by canMem... */
#define calibration_checksum_end_marker (*(volatile uint16_t*)0x00005E42UL) /* Calibration area checksum end marker (0xA1A1) (... */
#define eeprom_secondary_base_address (*(volatile uint32_t*)0x00006000UL) /* EEPROM secondary calibration data base - used b... */
#define firmware_vector_table_base (*(volatile uint32_t*)0x00006400UL) /* Firmware vector table base address (5 refs) */
#define can_memory_pointer_table_entry_2 (*(volatile uint32_t*)0x00007E3EUL) /* CAN memory pointer table entry 2 - used by canM... */
#define BLOKDATA ((volatile uint8_t*)0x0000800EUL) /* NONE */
#define hour_meter_conversion_table (*(volatile uint16_t*)0x00008CA0UL) /* Hour meter conversion lookup table - used by wr... */
#define governor_pid_fuel_lookup_table (*(volatile uint16_t*)0x00009C40UL) /* Governor fuel PID lookup table - used by govern... */
#define software_build_date_time_0_4294967296 (*(volatile uint32_t*)0x0000EC1AUL) /* SOFTWARE BUILD DATE & TIME */
#define crc16_lookup_table ((volatile uint16_t*)0x0000FAB0UL) /* [256] CRC-16 lookup table for crc16Calculate (2 refs) */
#define diag_memory_read_response_code_table (*(volatile uint8_t*)0x0001BD6CUL) /* Memory read response code lookup table (diagMem... */
#define hour_meter_fault_category_mask (*(volatile uint8_t*)0x000202A2UL) /* Bitmask for fault category filtering in hour me... */
#define flash_bootloader_code_start (*(volatile uint8_t*)0x000214EAUL) /* Start address of flash bootloader code region (... */
#define flash_bootloader_code_limit (*(volatile uint32_t*)0x000214FEUL) /* Upper limit address for bootloader programming ... */
#define huffman_symbol_frequency_table (*(volatile uint8_t*)0x0002160EUL) /* Huffman symbol frequency table - 256 byte entri... */
#define huffman_compressed_data_start (*(volatile uint8_t*)0x0002170DUL) /* Start of Huffman compressed data stream (huffma... */
#define huffman_compressed_data_end (*(volatile uint8_t*)0x00024D04UL) /* End marker/limit for Huffman compressed data (h... */
#define qadc_channel_config_table (*(volatile uint8_t*)0x00026E56UL) /* QADC channel configuration table - 40 entries f... */
#define internal_ram_init_data_block_1 (*(volatile uint32_t*)0x00028C10UL) /* Internal RAM initialization data block 1 for EB... */
#define internal_ram_init_data_block_2 (*(volatile uint32_t*)0x0002929CUL) /* Internal RAM initialization data block 2 for CA... */
#define diag_multi_packet_status_code_table (*(volatile uint8_t*)0x000298BEUL) /* Status code table for diagnostic multi-packet r... */
#define address_range_validation_table ((volatile uint8_t*)0x0002B512UL) /* Service 0x4A memory read validation - 5x10-byte... */
#define crank_protection_sequence_table (*(volatile uint8_t*)0x0002DE86UL) /* Expected crank protection state sequence table ... */
#define firmware_data_source (*(volatile uint8_t*)0x00037EAEUL) /* Source address for firmware data copying to wor... */
#define service_tool_adjustable_parameter_range_limits_n_a (*(volatile uint16_t*)0x00060000UL) /* SERVICE TOOL ADJUSTABLE PARAMETER RANGE LIMITS ... */
#define lower_limit_of_hsg_breakpoint_speed_0_5000 (*(volatile uint16_t*)0x00060002UL) /* LOWER LIMIT OF HSG BREAKPOINT SPEED */
#define upper_limit_of_hsg_breakpoint_speed_0_5000 (*(volatile uint16_t*)0x00060004UL) /* UPPER LIMIT OF HSG BREAKPOINT SPEED */
#define max_range_limit_for_pto_setpoints_600_2500_6 (*(volatile uint16_t*)0x00060006UL) /* MAX RANGE LIMIT FOR PTO SETPOINTS */
#define max_range_limit_for_pto_setpoints_600_2500_8 (*(volatile uint16_t*)0x00060008UL) /* MAX RANGE LIMIT FOR PTO SETPOINTS */
#define min_range_limit_for_pto_setpoints_600_2500_a (*(volatile uint16_t*)0x0006000AUL) /* MIN RANGE LIMIT FOR PTO SETPOINTS */
#define tool_minimum_limit_for_pto_droop_slope_adjustable_parameter_0_1_9 (*(volatile uint16_t*)0x0006000CUL) /* TOOL MINIMUM LIMIT FOR PTO DROOP SLOPE ADJUSTAB... */
#define tool_maximum_limit_for_pto_droop_slope_adjustable_parameter_0_1_9 (*(volatile uint16_t*)0x0006000EUL) /* TOOL MAXIMUM LIMIT FOR PTO DROOP SLOPE ADJUSTAB... */
#define tool_minimum_limit_for_pto_droop_adjust_offset_adjustable_par_0_0_2 (*(volatile uint16_t*)0x00060010UL) /* TOOL MINIMUM LIMIT FOR PTO DROOP ADJUST OFFSET ... */
#define tool_maximum_limit_for_pto_droop_adjust_offset_adjustable_par_0_0_2 (*(volatile uint16_t*)0x00060012UL) /* TOOL MAXIMUM LIMIT FOR PTO DROOP ADJUST OFFSET ... */
#define tool_minimum_limit_for_pto_droop_adjust_offset_adjustable_p_0_0_0_05 (*(volatile uint16_t*)0x00060014UL) /* TOOL MINIMUM LIMIT FOR PTO DROOP ADJUST OFFSET ... */
#define tool_maximum_limit_for_pto_droop_adjust_offset_adjustable_p_0_0_0_05 (*(volatile uint16_t*)0x00060016UL) /* TOOL MAXIMUM LIMIT FOR PTO DROOP ADJUST OFFSET ... */
#define minimum_for_asg_droop_gain1_0_4000 (*(volatile uint16_t*)0x00060018UL) /* MINIMUM FOR ASG_DROOP_GAIN1 [CalTerm: ASTL01MN] */
#define maximum_for_asg_droop_gain1_0_4000 (*(volatile uint16_t*)0x0006001AUL) /* MAXIMUM FOR ASG_DROOP_GAIN1 [CalTerm: ASTL01MX] */
#define minimum_for_asg_droop_gain2_none (*(volatile uint16_t*)0x0006001CUL) /* MINIMUM FOR ASG_DROOP_GAIN2 [CalTerm: ASTL02MN] */
#define maximum_for_asg_droop_gain2_none (*(volatile uint16_t*)0x0006001EUL) /* MAXIMUM FOR ASG_DROOP_GAIN2 [CalTerm: ASTL02MX] */
#define minimum_allowed_speed_for_asg_minimum_speed_0_3000 (*(volatile uint16_t*)0x00060020UL) /* MINIMUM ALLOWED SPEED FOR ASG_MINIMUM_SPEED [Ca... */
#define maximum_allowed_speed_for_asg_minimum_speed_0_3000 (*(volatile uint16_t*)0x00060022UL) /* MAXIMUM ALLOWED SPEED FOR ASG_MINIMUM_SPEED [Ca... */
#define minimum_allowed_speed_for_asg_maximum_speed_0_3000 (*(volatile uint16_t*)0x00060024UL) /* MINIMUM ALLOWED SPEED FOR ASG_MAXIMUM_SPEED [Ca... */
#define maximum_allowed_speed_for_asg_maximum_speed_0_3000 (*(volatile uint16_t*)0x00060026UL) /* MAXIMUM ALLOWED SPEED FOR ASG_MAXIMUM_SPEED [Ca... */
#define tool_lowest_allowable_low_idle_speed_300_1000 (*(volatile uint16_t*)0x00060028UL) /* TOOL LOWEST ALLOWABLE LOW IDLE SPEED */
#define tool_highest_allowable_low_idle_speed_300_1000 (*(volatile uint16_t*)0x0006002AUL) /* TOOL HIGHEST ALLOWABLE LOW IDLE SPEED */
#define minimum_value_of_slope_of_hsg_droop_line_0_69 (*(volatile uint16_t*)0x0006002CUL) /* MINIMUM VALUE OF SLOPE OF HSG DROOP LINE */
#define maximum_value_of_slope_of_line_defining_hsg_droop_line_0_69 (*(volatile uint16_t*)0x0006002EUL) /* MAXIMUM VALUE OF SLOPE OF LINE DEFINING HSG DRO... */
#define minimum_of_fueling_intercept_used_in_determining_hsg_droop_ref_0_500 (*(volatile uint16_t*)0x00060030UL) /* MINIMUM OF FUELING INTERCEPT USED IN DETERMININ... */
#define maximum_of_fueling_intercept_used_in_determining_hsg_droop_ref_0_500 (*(volatile uint16_t*)0x00060032UL) /* MAXIMUM OF FUELING INTERCEPT USED IN DETERMININ... */
#define minimum_value_of_indicator_of_what_type_switch_is_connected_1_3 (*(volatile uint16_t*)0x00060034UL) /* MINIMUM VALUE OF INDICATOR OF WHAT TYPE SWITCH ... */
#define maximum_value_of_indicator_of_what_type_switch_is_connected_1_3 (*(volatile uint16_t*)0x00060036UL) /* MAXIMUM VALUE OF INDICATOR OF WHAT TYPE SWITCH ... */
#define tool_minimum_limit_for_all_governors_droop_percent_adjustab_0_0_50_0 (*(volatile uint16_t*)0x00060038UL) /* TOOL MINIMUM LIMIT FOR ALL GOVERNORS DROOP PERC... */
#define tool_maximum_limit_for_all_governors_droop_percent_adjustab_0_0_50_0 (*(volatile uint16_t*)0x0006003AUL) /* TOOL MAXIMUM LIMIT FOR ALL GOVERNORS DROOP PERC... */
#define apli00_param (*(volatile uint16_t*)0x0006003CUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETER_LIMITS.H... */
#define apli01_param (*(volatile uint16_t*)0x0006003EUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETER_LIMITS.H... */
#define most_time_lfrom_start_to_shutdown_flag_active_1_6550 (*(volatile uint16_t*)0x00060040UL) /* MOST TIME LFROM START TO SHUTDOWN FLAG ACTIVE */
#define least_time_from_start_to_shutdown_flag_active_1_6550 (*(volatile uint16_t*)0x00060042UL) /* LEAST TIME FROM START TO SHUTDOWN FLAG ACTIVE */
#define pto_set_speed_display_value_lower_limit_none (*(volatile uint16_t*)0x0006004CUL) /* PTO SET SPEED DISPLAY VALUE LOWER LIMIT */
#define pto_set_speed_display_value_upper_limit_none (*(volatile uint16_t*)0x0006004EUL) /* PTO SET SPEED DISPLAY VALUE UPPER LIMIT */
#define tool_lower_limit_on_pto_ramp_rate_100_5000 (*(volatile uint16_t*)0x00060050UL) /* TOOL LOWER LIMIT ON PTO_RAMP_RATE [CalTerm: APL... */
#define tool_upper_limit_on_pto_ramp_rate_100_5000 (*(volatile uint16_t*)0x00060052UL) /* TOOL UPPER LIMIT ON PTO_RAMP_RATE [CalTerm: APL... */
#define tool_lower_limit_on_pto_engagement_slew_rate_100_5000 (*(volatile uint16_t*)0x00060054UL) /* TOOL LOWER LIMIT ON PTO_ENGAGEMENT_SLEW_RATE [C... */
#define tool_upper_limit_on_pto_engagement_slew_rate_100_5000 (*(volatile uint16_t*)0x00060056UL) /* TOOL UPPER LIMIT ON PTO_ENGAGEMENT_SLEW_RATE [C... */
#define apli21_param (*(volatile uint16_t*)0x00060058UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETER_LIMITS.H... */
#define apli22_param (*(volatile uint16_t*)0x0006005AUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETER_LIMITS.H... */
#define blank_spot_in_the_adjustable_parameter_limits_h_file_none_5c (*(volatile uint16_t*)0x0006005CUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETER_LIMITS.H... */
#define blank_spot_in_the_adjustable_parameter_limits_h_file_none_5e (*(volatile uint16_t*)0x0006005EUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETER_LIMITS.H... */
#define min_range_value_22413312_112066560 (*(volatile uint32_t*)0x00060060UL) /* MIN RANGE VALUE [CalTerm: APLI25] */
#define max_range_value_22413312_112066560 (*(volatile uint32_t*)0x00060064UL) /* MAX RANGE VALUE [CalTerm: APLI26] */
#define apli27_param (*(volatile uint16_t*)0x00060068UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETER_LIMITS.H... */
#define apli28_param (*(volatile uint16_t*)0x0006006AUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETER_LIMITS.H... */
#define min_range_value_assigned_for_tire_size_300_700 (*(volatile uint16_t*)0x0006006CUL) /* MIN RANGE VALUE ASSIGNED FOR TIRE_SIZE [CalTerm... */
#define max_range_value_assigned_for_tire_size_300_700 (*(volatile uint16_t*)0x0006006EUL) /* MAX RANGE VALUE ASSIGNED FOR TIRE_SIZE [CalTerm... */
#define lowest_extremely_cold_temperature_50_to_293 (*(volatile uint16_t*)0x00060070UL) /* LOWEST  EXTREMELY COLD TEMPERATURE */
#define highest_extremely_cold_temperature_50_to_293 (*(volatile uint16_t*)0x00060072UL) /* HIGHEST EXTREMELY COLD TEMPERATURE */
#define lowest_extremely_warm_temperature_50_to_293 (*(volatile uint16_t*)0x00060074UL) /* LOWEST  EXTREMELY WARM TEMPERATURE */
#define highest_extremely_warm_temperature_50_to_293 (*(volatile uint16_t*)0x00060076UL) /* HIGHEST EXTREMELY WARM TEMPERATURE */
#define CRBDWDMX (*(volatile uint16_t*)0x00060080UL) /* MAXMIMUM WIDTH OF THE BOTTOM DROOP IN CRUISE. */
#define min_value_for_default_multi_factor_set_by_service_tool_0_5_5 (*(volatile uint16_t*)0x00060088UL) /* MIN VALUE FOR DEFAULT MULTI_FACTOR SET BY SERVI... */
#define max_value_for_default_multi_factor_set_by_service_tool_0_5_5 (*(volatile uint16_t*)0x0006008AUL) /* MAX VALUE FOR DEFAULT MULTI_FACTOR SET BY SERVI... */
#define lower_limit_for_tool_input_of_user_hours_manual_mode_1_2000 (*(volatile uint16_t*)0x0006008CUL) /* LOWER LIMIT FOR TOOL INPUT OF USER HOURS (MANUA... */
#define upper_limit_for_tool_input_of_user_hours_manual_mode_1_2000 (*(volatile uint16_t*)0x0006008EUL) /* UPPER LIMIT FOR TOOL INPUT OF USER HOURS (MANUA... */
#define lower_limit_on_tool_input_of_pct_interval_to_set_warning_flag_1_100 (*(volatile uint16_t*)0x00060090UL) /* LOWER LIMIT ON TOOL INPUT OF PCT INTERVAL TO SE... */
#define upper_limit_on_tool_input_of_pct_interval_to_set_warning_flag_1_100 (*(volatile uint16_t*)0x00060092UL) /* UPPER LIMIT ON TOOL INPUT OF PCT INTERVAL TO SE... */
#define lowest_allowed_value_for_pto_minimum_reference_speed_entered_on_0_5000 (*(volatile uint16_t*)0x00060094UL) /* LOWEST ALLOWED VALUE FOR PTO_MINIMUM_REFERENCE_... */
#define tool_minimum_for_hot_shutdown_load_factor_threshold_0_150_9a (*(volatile uint16_t*)0x0006009AUL) /* TOOL MINIMUM FOR HOT SHUTDOWN LOAD FACTOR THRES... */
#define tool_minimum_for_hot_shutdown_load_factor_threshold_0_150_9c (*(volatile uint16_t*)0x0006009CUL) /* TOOL MINIMUM FOR HOT SHUTDOWN LOAD FACTOR THRES... */
#define AFFLLMZA (*(volatile uint16_t*)0x00060138UL) /* AFC LOOK-UP TABLE DEFINING FUELING LIMIT AS A F... */
#define ATAAPRYA (*(volatile uint32_t*)0x000603BAUL) /* AMBIENT AIR PRESSURE AXIS VALUES (4 VALUES) FOR... */
#define ASALDPXA ((volatile uint16_t*)0x00060472UL) /* [3] ASG ALTERNATE DROOP TABLE INPUT AXIS */
#define ASDPTBXA ((volatile uint16_t*)0x00060492UL) /* [3] ASG DROOP TABLE INPUT AXIS (F(REFERENCE SPEED)) */
#define JC3BCOXA (*(volatile uint32_t*)0x000604D0UL) /* CalTerm JC3BCOXA: JCOMM 246 BRAKE CONTROL RPM A... */
#define JC2BCOXA (*(volatile uint32_t*)0x000604F8UL) /* CalTerm JC2BCOXA: JCOMM 36 BRAKE CONTROL RPM AX... */
#define JCBCRPXA (*(volatile uint32_t*)0x00060534UL) /* CalTerm JCBCRPXA: JCOMM BRAKE CONTROL RPM INDEP... */
#define JC3CTQYA (*(volatile uint16_t*)0x00060548UL) /* CalTerm JC3CTQYA: JCOMM BRAKE MAP 3 AXIS DEP. A... */
#define JC5CTQYA (*(volatile uint16_t*)0x0006055CUL) /* CalTerm JC5CTQYA: JCOMM BRAKE MAP 5 AXIS DEP. A... */
#define coolant_advance_place_holder_number_one_0_100 (*(volatile uint16_t*)0x00060570UL) /* COOLANT ADVANCE PLACE HOLDER NUMBER ONE [CalTer... */
#define ADCLXA (*(volatile uint64_t*)0x00060584UL) /* COOLANT TEMPERATURE AXIS FOR THE COOLANT ADVANC... */
#define CPCS01XA ((volatile uint8_t*)0x000605B2UL) /* REF. AXIS FOR RATIO OF CYL. PRESS. TO COMPRESSI... */
#define CPCS02YA (*(volatile uint16_t*)0x000605F2UL) /* DATA AXIS FOR COMPRESSION RATIO RAISED TO POWER... */
#define CPCS03XA ((volatile uint8_t*)0x0006065CUL) /* REFERENCE AXIS FOR RATIO OF DEG. F TO DEG. TVC ... */
#define CPDSXA ((volatile uint8_t*)0x000606A4UL) /* ENGINE SPEED REFERENCE AXIS FOR DESIRED CYLINDE... */
#define CPBS03 (*(volatile uint16_t*)0x00060776UL) /* BLANK SPOT FOR START_OF_INJECTION_AXIS */
#define JCFCAJFL (*(volatile uint16_t*)0x000607A6UL) /* CalTerm JCFCAJFL: JCOMM FRICT LOAD TVO AXIS FRI... */
#define minimum_boost_voltage_recovery_time_0_10 (*(volatile uint16_t*)0x000607BAUL) /* MINIMUM BOOST VOLTAGE RECOVERY TIME */
#define kick_out_of_the_double_pulsing_if_engine_speed_is_greater_th_850_950 (*(volatile uint16_t*)0x000607C4UL) /* KICK OUT OF THE DOUBLE PULSING IF ENGINE SPEED ... */
#define kick_out_of_the_double_pulsing_if_engine_speed_is_less_than_250_350 (*(volatile uint16_t*)0x000607C6UL) /* KICK OUT OF THE DOUBLE PULSING IF ENGINE SPEED ... */
#define double_pulsing_shall_be_kicked_out_if_tvc_is_greater_than_this_0_120 (*(volatile uint16_t*)0x000607CEUL) /* DOUBLE PULSING SHALL BE KICKED OUT IF TVC IS GR... */
#define degree_of_the_first_time_sol_valve_open_after_tdc_for_double_30_690 (*(volatile uint16_t*)0x000607D0UL) /* DEGREE OF THE FIRST TIME SOL VALVE OPEN AFTER T... */
#define degree_of_the_second_time_sol_valve_open_after_tdc_for_double_30_690 (*(volatile uint16_t*)0x000607D2UL) /* DEGREE OF THE SECOND TIME SOL VALVE OPEN AFTER ... */
#define table_5DFL01ZA (*(volatile uint16_t*)0x000608A4UL) /* SS FUEL LOOK-UP TABLE USED BY 4D FUELING TO DET... */
#define table_5DFL00ZA (*(volatile uint16_t*)0x00060982UL) /* TRANSIENT FUEL LOOK-UP TABLE USED BY 4D FUELING... */
#define table_4DTA01XA ((volatile uint8_t*)0x00060A74UL) /* ENGINE SPEED AXIS FOR THE STEADY STATE TIMING A... */
#define table_4DTA00ZA (*(volatile uint16_t*)0x00060D1EUL) /* TIMING ADVANCE LOOK-UP TABLE FOR TRANSIENT ENGI... */
#define default_j1939_network_address_for_ecm_as_engine_node_0_255 (*(volatile uint16_t*)0x00060F7EUL) /* DEFAULT J1939 NETWORK ADDRESS FOR ECM AS ENGINE... */
#define default_j1939_network_address_for_ecm_as_retarder_node_upon_po_0_255 (*(volatile uint16_t*)0x00060F80UL) /* DEFAULT J1939 NETWORK ADDRESS FOR ECM AS RETARD... */
#define JCDFEGNM ((volatile uint8_t*)0x00060F88UL) /* [8] CalTerm JCDFEGNM: DEFAULT J1939 NETWORK NAME FO... */
#define JCDFRDNM ((volatile uint8_t*)0x00060F90UL) /* [8] CalTerm JCDFRDNM: DEFAULT J1939 NETWORK NAME FO... */
#define bit_mapped_parameter_determining_access_restriction_of_comman_0_2_32 (*(volatile uint32_t*)0x00060F98UL) /* BIT-MAPPED PARAMETER DETERMINING ACCESS RESTRIC... */
#define JC39ENFG (*(volatile uint16_t*)0x00060F9CUL) /* CalTerm JC39ENFG: J1939 MESSAGE ENABLE FLAGS TABLE */
#define enable_for_fuel_economy_message_0_1 (*(volatile uint16_t*)0x00060F9EUL) /* ENABLE FOR FUEL ECONOMY MESSAGE */
#define indicator_of_freeze_frame_format_0_255 (*(volatile uint16_t*)0x00060FA0UL) /* INDICATOR OF FREEZE FRAME FORMAT */
#define JCNTCTMR (*(volatile uint16_t*)0x00060FA8UL) /* CalTerm JCNTCTMR: INDICATOR OF SOFTWARE'S SUPPO... */
#define fault_data_j1939_record_0_n_a (*(volatile uint32_t*)0x00060FACUL) /* FAULT DATA J1939 RECORD   0 */
#define fault_data_j1939_record_1_n_a (*(volatile uint32_t*)0x00060FB0UL) /* FAULT DATA J1939 RECORD   1 */
#define fault_data_j1939_record_2_n_a (*(volatile uint32_t*)0x00060FB4UL) /* FAULT DATA J1939 RECORD   2 */
#define fault_data_j1939_record_3_n_a (*(volatile uint32_t*)0x00060FB8UL) /* FAULT DATA J1939 RECORD   3 */
#define fault_data_j1939_record_4_n_a (*(volatile uint32_t*)0x00060FBCUL) /* FAULT DATA J1939 RECORD   4 */
#define fault_data_j1939_record_5_n_a (*(volatile uint32_t*)0x00060FC0UL) /* FAULT DATA J1939 RECORD   5 */
#define fault_data_j1939_record_6_n_a (*(volatile uint32_t*)0x00060FC4UL) /* FAULT DATA J1939 RECORD   6 */
#define fault_data_j1939_record_7_n_a (*(volatile uint32_t*)0x00060FC8UL) /* FAULT DATA J1939 RECORD   7 */
#define fault_data_j1939_record_8_n_a (*(volatile uint32_t*)0x00060FCCUL) /* FAULT DATA J1939 RECORD   8 */
#define fault_data_j1939_record_9_n_a (*(volatile uint32_t*)0x00060FD0UL) /* FAULT DATA J1939 RECORD   9 */
#define fault_data_j1939_record_10_n_a (*(volatile uint32_t*)0x00060FD4UL) /* FAULT DATA J1939 RECORD  10 */
#define fault_data_j1939_record_11_n_a (*(volatile uint32_t*)0x00060FD8UL) /* FAULT DATA J1939 RECORD  11 */
#define fault_data_j1939_record_12_n_a (*(volatile uint32_t*)0x00060FDCUL) /* FAULT DATA J1939 RECORD  12 */
#define fault_data_j1939_record_13_n_a (*(volatile uint32_t*)0x00060FE0UL) /* FAULT DATA J1939 RECORD  13 */
#define fault_data_j1939_record_14_n_a (*(volatile uint32_t*)0x00060FE4UL) /* FAULT DATA J1939 RECORD  14 */
#define fault_data_j1939_record_15_n_a (*(volatile uint32_t*)0x00060FE8UL) /* FAULT DATA J1939 RECORD  15 */
#define fault_data_j1939_record_16_n_a (*(volatile uint32_t*)0x00060FECUL) /* FAULT DATA J1939 RECORD  16 */
#define fault_data_j1939_record_17_n_a (*(volatile uint32_t*)0x00060FF0UL) /* FAULT DATA J1939 RECORD  17 */
#define fault_data_j1939_record_18_n_a (*(volatile uint32_t*)0x00060FF4UL) /* FAULT DATA J1939 RECORD  18 */
#define fault_data_j1939_record_19_n_a (*(volatile uint32_t*)0x00060FF8UL) /* FAULT DATA J1939 RECORD  19 */
#define fault_data_j1939_record_20_n_a (*(volatile uint32_t*)0x00060FFCUL) /* FAULT DATA J1939 RECORD  20 */
#define fault_data_j1939_record_21_n_a (*(volatile uint32_t*)0x00061000UL) /* FAULT DATA J1939 RECORD  21 */
#define fault_data_j1939_record_22_n_a (*(volatile uint32_t*)0x00061004UL) /* FAULT DATA J1939 RECORD  22 */
#define fault_data_j1939_record_23_n_a (*(volatile uint32_t*)0x00061008UL) /* FAULT DATA J1939 RECORD  23 */
#define fault_data_j1939_record_24_n_a (*(volatile uint32_t*)0x0006100CUL) /* FAULT DATA J1939 RECORD  24 */
#define fault_data_j1939_record_25_n_a (*(volatile uint32_t*)0x00061010UL) /* FAULT DATA J1939 RECORD  25 */
#define fault_data_j1939_record_26_n_a (*(volatile uint32_t*)0x00061014UL) /* FAULT DATA J1939 RECORD  26 */
#define fault_data_j1939_record_27_n_a (*(volatile uint32_t*)0x00061018UL) /* FAULT DATA J1939 RECORD  27 */
#define fault_data_j1939_record_28_n_a (*(volatile uint32_t*)0x0006101CUL) /* FAULT DATA J1939 RECORD  28 */
#define fault_data_j1939_record_29_n_a (*(volatile uint32_t*)0x00061020UL) /* FAULT DATA J1939 RECORD  29 */
#define fault_data_j1939_record_30_n_a (*(volatile uint32_t*)0x00061024UL) /* FAULT DATA J1939 RECORD  30 */
#define fault_data_j1939_record_31_n_a (*(volatile uint32_t*)0x00061028UL) /* FAULT DATA J1939 RECORD  31 */
#define fault_data_j1939_record_32_n_a (*(volatile uint32_t*)0x0006102CUL) /* FAULT DATA J1939 RECORD  32 */
#define fault_data_j1939_record_33_n_a (*(volatile uint32_t*)0x00061030UL) /* FAULT DATA J1939 RECORD  33 */
#define fault_data_j1939_record_34_n_a (*(volatile uint32_t*)0x00061034UL) /* FAULT DATA J1939 RECORD  34 */
#define fault_data_j1939_record_35_n_a (*(volatile uint32_t*)0x00061038UL) /* FAULT DATA J1939 RECORD  35 */
#define fault_data_j1939_record_36_n_a (*(volatile uint32_t*)0x0006103CUL) /* FAULT DATA J1939 RECORD  36 */
#define fault_data_j1939_record_37_n_a (*(volatile uint32_t*)0x00061040UL) /* FAULT DATA J1939 RECORD  37 */
#define fault_data_j1939_record_38_n_a (*(volatile uint32_t*)0x00061044UL) /* FAULT DATA J1939 RECORD  38 */
#define fault_data_j1939_record_39_n_a (*(volatile uint32_t*)0x00061048UL) /* FAULT DATA J1939 RECORD  39 */
#define fault_data_j1939_record_40_n_a (*(volatile uint32_t*)0x0006104CUL) /* FAULT DATA J1939 RECORD  40 */
#define fault_data_j1939_record_41_n_a (*(volatile uint32_t*)0x00061050UL) /* FAULT DATA J1939 RECORD  41 */
#define fault_data_j1939_record_42_n_a (*(volatile uint32_t*)0x00061054UL) /* FAULT DATA J1939 RECORD  42 */
#define fault_data_j1939_record_43_n_a (*(volatile uint32_t*)0x00061058UL) /* FAULT DATA J1939 RECORD  43 */
#define fault_data_j1939_record_44_n_a (*(volatile uint32_t*)0x0006105CUL) /* FAULT DATA J1939 RECORD  44 */
#define fault_data_j1939_record_45_n_a (*(volatile uint32_t*)0x00061060UL) /* FAULT DATA J1939 RECORD  45 */
#define fault_data_j1939_record_46_n_a (*(volatile uint32_t*)0x00061064UL) /* FAULT DATA J1939 RECORD  46 */
#define fault_data_j1939_record_47_n_a (*(volatile uint32_t*)0x00061068UL) /* FAULT DATA J1939 RECORD  47 */
#define fault_data_j1939_record_48_n_a (*(volatile uint32_t*)0x0006106CUL) /* FAULT DATA J1939 RECORD  48 */
#define fault_data_j1939_record_49_n_a (*(volatile uint32_t*)0x00061070UL) /* FAULT DATA J1939 RECORD  49 */
#define fault_data_j1939_record_50_n_a (*(volatile uint32_t*)0x00061074UL) /* FAULT DATA J1939 RECORD  50 */
#define fault_data_j1939_record_51_n_a (*(volatile uint32_t*)0x00061078UL) /* FAULT DATA J1939 RECORD  51 */
#define fault_data_j1939_record_52_n_a (*(volatile uint32_t*)0x0006107CUL) /* FAULT DATA J1939 RECORD  52 */
#define fault_data_j1939_record_53_n_a (*(volatile uint32_t*)0x00061080UL) /* FAULT DATA J1939 RECORD  53 */
#define fault_data_j1939_record_54_n_a (*(volatile uint32_t*)0x00061084UL) /* FAULT DATA J1939 RECORD  54 */
#define fault_data_j1939_record_55_n_a (*(volatile uint32_t*)0x00061088UL) /* FAULT DATA J1939 RECORD  55 */
#define fault_data_j1939_record_56_n_a (*(volatile uint32_t*)0x0006108CUL) /* FAULT DATA J1939 RECORD  56 */
#define fault_data_j1939_record_57_n_a (*(volatile uint32_t*)0x00061090UL) /* FAULT DATA J1939 RECORD  57 */
#define fault_data_j1939_record_58_n_a (*(volatile uint32_t*)0x00061094UL) /* FAULT DATA J1939 RECORD  58 */
#define fault_data_j1939_record_59_n_a (*(volatile uint32_t*)0x00061098UL) /* FAULT DATA J1939 RECORD  59 */
#define fault_data_j1939_record_60_n_a (*(volatile uint32_t*)0x0006109CUL) /* FAULT DATA J1939 RECORD  60 */
#define fault_data_j1939_record_61_n_a (*(volatile uint32_t*)0x000610A0UL) /* FAULT DATA J1939 RECORD  61 */
#define fault_data_j1939_record_62_n_a (*(volatile uint32_t*)0x000610A4UL) /* FAULT DATA J1939 RECORD  62 */
#define fault_data_j1939_record_63_n_a (*(volatile uint32_t*)0x000610A8UL) /* FAULT DATA J1939 RECORD  63 */
#define fault_data_j1939_record_64_n_a (*(volatile uint32_t*)0x000610ACUL) /* FAULT DATA J1939 RECORD  64 */
#define fault_data_j1939_record_65_n_a (*(volatile uint32_t*)0x000610B0UL) /* FAULT DATA J1939 RECORD  65 */
#define fault_data_j1939_record_66_n_a (*(volatile uint32_t*)0x000610B4UL) /* FAULT DATA J1939 RECORD  66 */
#define fault_data_j1939_record_67_n_a (*(volatile uint32_t*)0x000610B8UL) /* FAULT DATA J1939 RECORD  67 */
#define fault_data_j1939_record_68_n_a (*(volatile uint32_t*)0x000610BCUL) /* FAULT DATA J1939 RECORD  68 */
#define fault_data_j1939_record_69_n_a (*(volatile uint32_t*)0x000610C0UL) /* FAULT DATA J1939 RECORD  69 */
#define fault_data_j1939_record_70_n_a (*(volatile uint32_t*)0x000610C4UL) /* FAULT DATA J1939 RECORD  70 */
#define fault_data_j1939_record_71_n_a (*(volatile uint32_t*)0x000610C8UL) /* FAULT DATA J1939 RECORD  71 */
#define fault_data_j1939_record_72_n_a (*(volatile uint32_t*)0x000610CCUL) /* FAULT DATA J1939 RECORD  72 */
#define fault_data_j1939_record_73_n_a (*(volatile uint32_t*)0x000610D0UL) /* FAULT DATA J1939 RECORD  73 */
#define fault_data_j1939_record_74_n_a (*(volatile uint32_t*)0x000610D4UL) /* FAULT DATA J1939 RECORD  74 */
#define fault_data_j1939_record_75_n_a (*(volatile uint32_t*)0x000610D8UL) /* FAULT DATA J1939 RECORD  75 */
#define fault_data_j1939_record_76_n_a (*(volatile uint32_t*)0x000610DCUL) /* FAULT DATA J1939 RECORD  76 */
#define fault_data_j1939_record_77_n_a (*(volatile uint32_t*)0x000610E0UL) /* FAULT DATA J1939 RECORD  77 */
#define fault_data_j1939_record_78_n_a (*(volatile uint32_t*)0x000610E4UL) /* FAULT DATA J1939 RECORD  78 */
#define fault_data_j1939_record_79_n_a (*(volatile uint32_t*)0x000610E8UL) /* FAULT DATA J1939 RECORD  79 */
#define fault_data_j1939_record_80_n_a (*(volatile uint32_t*)0x000610ECUL) /* FAULT DATA J1939 RECORD  80 */
#define fault_data_j1939_record_81_n_a (*(volatile uint32_t*)0x000610F0UL) /* FAULT DATA J1939 RECORD  81 */
#define fault_data_j1939_record_82_n_a (*(volatile uint32_t*)0x000610F4UL) /* FAULT DATA J1939 RECORD  82 */
#define fault_data_j1939_record_83_n_a (*(volatile uint32_t*)0x000610F8UL) /* FAULT DATA J1939 RECORD  83 */
#define fault_data_j1939_record_84_n_a (*(volatile uint32_t*)0x000610FCUL) /* FAULT DATA J1939 RECORD  84 */
#define fault_data_j1939_record_85_n_a (*(volatile uint32_t*)0x00061100UL) /* FAULT DATA J1939 RECORD  85 */
#define fault_data_j1939_record_86_n_a (*(volatile uint32_t*)0x00061104UL) /* FAULT DATA J1939 RECORD  86 */
#define fault_data_j1939_record_87_n_a (*(volatile uint32_t*)0x00061108UL) /* FAULT DATA J1939 RECORD  87 */
#define fault_data_j1939_record_88_n_a (*(volatile uint32_t*)0x0006110CUL) /* FAULT DATA J1939 RECORD  88 */
#define fault_data_j1939_record_89_n_a (*(volatile uint32_t*)0x00061110UL) /* FAULT DATA J1939 RECORD  89 */
#define fault_data_j1939_record_90_n_a (*(volatile uint32_t*)0x00061114UL) /* FAULT DATA J1939 RECORD  90 */
#define fault_data_j1939_record_91_n_a (*(volatile uint32_t*)0x00061118UL) /* FAULT DATA J1939 RECORD  91 */
#define fault_data_j1939_record_92_n_a (*(volatile uint32_t*)0x0006111CUL) /* FAULT DATA J1939 RECORD  92 */
#define fault_data_j1939_record_93_n_a (*(volatile uint32_t*)0x00061120UL) /* FAULT DATA J1939 RECORD  93 */
#define fault_data_j1939_record_94_n_a (*(volatile uint32_t*)0x00061124UL) /* FAULT DATA J1939 RECORD  94 */
#define fault_data_j1939_record_95_n_a (*(volatile uint32_t*)0x00061128UL) /* FAULT DATA J1939 RECORD  95 */
#define fault_data_j1939_record_96_n_a (*(volatile uint32_t*)0x0006112CUL) /* FAULT DATA J1939 RECORD  96 */
#define fault_data_j1939_record_97_n_a (*(volatile uint32_t*)0x00061130UL) /* FAULT DATA J1939 RECORD  97 */
#define fault_data_j1939_record_98_n_a (*(volatile uint32_t*)0x00061134UL) /* FAULT DATA J1939 RECORD  98 */
#define fault_data_j1939_record_99_n_a (*(volatile uint32_t*)0x00061138UL) /* FAULT DATA J1939 RECORD  99 */
#define fault_data_j1939_record_100_n_a (*(volatile uint32_t*)0x0006113CUL) /* FAULT DATA J1939 RECORD 100 */
#define fault_data_j1939_record_101_n_a (*(volatile uint32_t*)0x00061140UL) /* FAULT DATA J1939 RECORD 101 */
#define fault_data_j1939_record_102_n_a (*(volatile uint32_t*)0x00061144UL) /* FAULT DATA J1939 RECORD 102 */
#define fault_data_j1939_record_103_n_a (*(volatile uint32_t*)0x00061148UL) /* FAULT DATA J1939 RECORD 103 */
#define fault_data_j1939_record_104_n_a (*(volatile uint32_t*)0x0006114CUL) /* FAULT DATA J1939 RECORD 104 */
#define fault_data_j1939_record_105_n_a (*(volatile uint32_t*)0x00061150UL) /* FAULT DATA J1939 RECORD 105 */
#define fault_data_j1939_record_106_n_a (*(volatile uint32_t*)0x00061154UL) /* FAULT DATA J1939 RECORD 106 */
#define fault_data_j1939_record_107_n_a (*(volatile uint32_t*)0x00061158UL) /* FAULT DATA J1939 RECORD 107 */
#define fault_data_j1939_record_108_n_a (*(volatile uint32_t*)0x0006115CUL) /* FAULT DATA J1939 RECORD 108 */
#define fault_data_j1939_record_109_n_a (*(volatile uint32_t*)0x00061160UL) /* FAULT DATA J1939 RECORD 109 */
#define fault_data_j1939_record_110_n_a (*(volatile uint32_t*)0x00061164UL) /* FAULT DATA J1939 RECORD 110 */
#define fault_data_j1939_record_111_n_a (*(volatile uint32_t*)0x00061168UL) /* FAULT DATA J1939 RECORD 111 */
#define fault_data_j1939_record_112_n_a (*(volatile uint32_t*)0x0006116CUL) /* FAULT DATA J1939 RECORD 112 */
#define fault_data_j1939_record_113_n_a (*(volatile uint32_t*)0x00061170UL) /* FAULT DATA J1939 RECORD 113 */
#define fault_data_j1939_record_114_n_a (*(volatile uint32_t*)0x00061174UL) /* FAULT DATA J1939 RECORD 114 */
#define fault_data_j1939_record_115_n_a (*(volatile uint32_t*)0x00061178UL) /* FAULT DATA J1939 RECORD 115 */
#define fault_data_j1939_record_116_n_a (*(volatile uint32_t*)0x0006117CUL) /* FAULT DATA J1939 RECORD 116 */
#define fault_data_j1939_record_117_n_a (*(volatile uint32_t*)0x00061180UL) /* FAULT DATA J1939 RECORD 117 */
#define fault_data_j1939_record_118_n_a (*(volatile uint32_t*)0x00061184UL) /* FAULT DATA J1939 RECORD 118 */
#define fault_data_j1939_record_119_n_a (*(volatile uint32_t*)0x00061188UL) /* FAULT DATA J1939 RECORD 119 */
#define fault_data_j1939_record_120_n_a (*(volatile uint32_t*)0x0006118CUL) /* FAULT DATA J1939 RECORD 120 */
#define fault_data_j1939_record_121_n_a (*(volatile uint32_t*)0x00061190UL) /* FAULT DATA J1939 RECORD 121 */
#define fault_data_j1939_record_122_n_a (*(volatile uint32_t*)0x00061194UL) /* FAULT DATA J1939 RECORD 122 */
#define fault_data_j1939_record_123_n_a (*(volatile uint32_t*)0x00061198UL) /* FAULT DATA J1939 RECORD 123 */
#define fault_data_j1939_record_124_n_a (*(volatile uint32_t*)0x0006119CUL) /* FAULT DATA J1939 RECORD 124 */
#define length_of_time_the_warning_or_stop_lamp_is_on_when_flashing_0_4800 (*(volatile uint16_t*)0x000611A0UL) /* LENGTH OF TIME THE WARNING OR STOP LAMP IS ON W... */
#define length_of_time_the_warning_or_stop_lamp_is_off_when_flashing_0_4800 (*(volatile uint16_t*)0x000611A2UL) /* LENGTH OF TIME THE WARNING OR STOP LAMP IS OFF ... */
#define length_of_time_the_fluids_lamp_is_on_when_flashing_0_4800 (*(volatile uint16_t*)0x000611A4UL) /* LENGTH OF TIME THE FLUIDS_LAMP IS ON WHEN FLASH... */
#define length_of_time_the_fluids_lamp_is_off_when_flashing_0_4800 (*(volatile uint16_t*)0x000611A6UL) /* LENGTH OF TIME THE FLUIDS_LAMP IS OFF WHEN FLAS... */
#define number_of_bad_samples_before_setting_of_lamp_driver_error_1_1000 (*(volatile uint16_t*)0x000611C8UL) /* NUMBER OF BAD SAMPLES BEFORE SETTING OF LAMP DR... */
#define number_of_good_samples_before_clearing_of_lamp_driver_error_1_1000 (*(volatile uint16_t*)0x000611CAUL) /* NUMBER OF GOOD SAMPLES BEFORE CLEARING OF LAMP ... */
#define allows_use_of_diagnostic_switch_to_reset_maintenance_features_0_1_11cc (*(volatile uint16_t*)0x000611CCUL) /* ALLOWS USE OF  DIAGNOSTIC SWITCH TO RESET MAINT... */
#define EPO2LOTB (*(volatile uint16_t*)0x000611DEUL) /* CalTerm EPO2LOTB: 2X6 TABLEDEFINING LOW OIL PRE... */
#define NLCLFLYA (*(volatile uint16_t*)0x00061236UL) /* COOLANT TEMPERATURE BASED FUEL ADJUSTMENT TO NO... */
#define FLCDTPXA ((volatile uint8_t*)0x0006126AUL) /* [9] CalTerm FLCDTPXA: COOLANT TEMP AXIS FOR COLD TE... */
#define OCHRTDTB (*(volatile uint16_t*)0x000612D4UL) /* CalTerm OCHRTDTB: AUTOMATIC MODE TIME THRESHOLDS */
#define OCFLTDTB (*(volatile uint16_t*)0x000612E0UL) /* CalTerm OCFLTDTB: AUTOMATIC MODE FUEL THRESHOLDS */
#define JCPBBCTB (*(volatile uint16_t*)0x000612ECUL) /* CalTerm JCPBBCTB: TABLE CONTAINING LIST OF PIDS... */
#define JCWRPITB (*(volatile uint16_t*)0x0006136AUL) /* CalTerm JCWRPITB: TABLE CONTAINING LIST OF MIDS... */
#define rpm_rate_limit_countdown (*(volatile uint16_t*)0x00800000UL) /* RPM rate limit threshold countdown timer (7 refs) */
#define rpm_control_timer_1 (*(volatile uint16_t*)0x00800002UL) /* Timer 1 for RPM-based control logic */
#define high_rpm_threshold_countdown (*(volatile uint16_t*)0x00800004UL) /* High RPM threshold countdown timer (4 refs) */
#define rpm_control_timer_2 (*(volatile uint16_t*)0x00800006UL) /* Timer 2 for RPM-based control logic */
#define rpm_control_timer_previous (*(volatile uint16_t*)0x00800008UL) /* RPM control timer previous value (5 refs) */
#define rpm_control_timer_delta (*(volatile uint16_t*)0x0080000AUL) /* RPM control timer delta value (5 refs) */
#define previous_engine_rpm (*(volatile uint16_t*)0x0080000CUL) /* Previous engine RPM value for delta calculation */
#define dma_descriptor_base1 (*(volatile uint16_t*)0x0080000EUL) /* DMA descriptor table 1 base address */
#define dma_desc1_source_ptr (*(volatile uint32_t*)0x00800010UL) /* DMA descriptor 1 source address pointer (dmaDes... */
#define rpm_state_lookup_input (*(volatile uint16_t*)0x00800014UL) /* RPM input for fuel lookup in rpm_system_state_c... */
#define dma_desc1_dest_ptr (*(volatile uint32_t*)0x00800016UL) /* DMA descriptor 1 destination address pointer (d... */
#define dma_descriptor_base2 (*(volatile uint16_t*)0x0080001AUL) /* DMA descriptor table 2 base address */
#define dma_desc2_source_ptr (*(volatile uint32_t*)0x0080001CUL) /* DMA descriptor 2 source address pointer (dmaDes... */
#define high_rpm_lookup_input (*(volatile uint16_t*)0x00800020UL) /* RPM input for fuel lookup in highRpmFuelControl... */
#define dma_desc2_dest_ptr (*(volatile uint32_t*)0x00800022UL) /* DMA descriptor 2 destination address pointer (d... */
#define dma_descriptor_ptr1 (*(volatile uint32_t*)0x00800026UL) /* DMA descriptor chain pointer 1 */
#define dma_control_flags1 (*(volatile uint32_t*)0x0080002AUL) /* DMA control/enable flags 1 (0x80000000=enabled) */
#define dma_descriptor_ptr2 (*(volatile uint32_t*)0x0080002EUL) /* DMA descriptor chain pointer 2 */
#define dma_control_flags2 (*(volatile uint32_t*)0x00800032UL) /* DMA control/enable flags 2 (0x80000000=enabled) */
#define sensor_fault_debounce_counter_base (*(volatile uint8_t*)0x00800036UL) /* Sensor fault debounce counter array base (senso... */
#define timing_table_1_ptr (*(volatile uint32_t*)0x00800052UL) /* Timing parameter table 1 pointer 0x806e34 (timi... */
#define timing_table_2_base (*(volatile uint16_t*)0x00800058UL) /* Timing parameter table 2 base value (timingPara... */
#define timing_table_2_ptr (*(volatile uint32_t*)0x0080005AUL) /* Timing parameter table 2 pointer 0x806e20 (timi... */
#define timing_table_3_ptr (*(volatile uint32_t*)0x00800060UL) /* Timing parameter table 3 pointer 0x806e5a (timi... */
#define timing_table_4_ptr (*(volatile uint32_t*)0x00800066UL) /* Timing parameter table 4 pointer 0x808862 (timi... */
#define timing_table_5_ptr (*(volatile uint32_t*)0x0080006CUL) /* Timing parameter table 5 pointer 0x808876 (timi... */
#define diagnostic_timing_increment_state (*(volatile uint16_t*)0x00800070UL) /* Diagnostic timing increment controller state - ... */
#define diagnostic_timing_increment_reserved (*(volatile uint16_t*)0x00800072UL) /* Diagnostic timing increment reserved */
#define fuel_parameter_pointer_3 (*(volatile uint32_t*)0x00800074UL) /* Fuel parameter pointer setup value 3 (1 ref) */
#define shutdown_protection_rpm_input (*(volatile uint16_t*)0x0080007AUL) /* RPM input for shutdown protection fuel lookup (... */
#define fuel_parameter_pointer_2 (*(volatile uint32_t*)0x0080007CUL) /* Fuel parameter pointer setup value 2 (1 ref) */
#define shutdown_protection_diag_input (*(volatile uint16_t*)0x00800082UL) /* Diagnostic reading input for shutdown protectio... */
#define fuel_parameter_pointer_1 (*(volatile uint32_t*)0x00800084UL) /* Fuel parameter pointer setup value 1 (1 ref) */
#define governor_proportional_state (*(volatile uint32_t*)0x00800088UL) /* Governor proportional calculation state (4 refs) */
#define governor_pid_proportional_accum (*(volatile uint32_t*)0x0080008AUL) /* Governor PID proportional accumulator (10 refs) */
#define governor_pid_integral (*(volatile uint32_t*)0x0080008EUL) /* Engine speed governor PID integral term */
#define governor_integral_accumulator (*(volatile uint32_t*)0x00800090UL) /* Governor integral accumulator state (6 refs) */
#define diagnostic_status_previous (*(volatile uint16_t*)0x00800092UL) /* Previous diagnostic status register for comparison */
#define governor_derivative_state (*(volatile uint32_t*)0x00800094UL) /* Governor derivative calculation state (4 refs) */
#define rpm_interpolation_lookup_arg (*(volatile uint16_t*)0x00800096UL) /* RPM interpolation table lookup argument (1 ref) */
#define rpm_parameter_pointer (*(volatile uint32_t*)0x00800098UL) /* RPM parameter pointer setup value (1 ref) */
#define target_rpm_rate_limiter_output (*(volatile uint16_t*)0x0080009CUL) /* Target RPM rate limiter output - accessed via m... */
#define target_rpm_rate_limiter_reserved_9e (*(volatile uint16_t*)0x0080009EUL) /* Target RPM rate limiter reserved */
#define governor_interpolation_factor (*(volatile uint16_t*)0x008000A2UL) /* Governor calculation interpolation factor */
#define governor_fuel_output_state (*(volatile uint32_t*)0x008000A4UL) /* Governor fuel output state (7 refs) */
#define target_rpm_rate_limiter_previous (*(volatile uint16_t*)0x008000A6UL) /* Target RPM rate limiter previous value (4 refs) */
#define target_rpm_rate_limiter_state (*(volatile uint16_t*)0x008000A8UL) /* Target RPM rate limiter state value (11 refs) */
#define target_rpm_rate_limiter_reserved_aa (*(volatile uint16_t*)0x008000AAUL) /* Reserved padding after rate limiter state */
#define diagnostic_table_pointer_4 (*(volatile uint16_t*)0x008000ACUL) /* Diagnostic table pointer setup value 4 (1 ref) */
#define diagnostic_table_5_ptr (*(volatile uint32_t*)0x008000AEUL) /* Diagnostic table 5 pointer 0x8078b6 (diagnostic... */
#define diag_mode_0_target_rpm_arg (*(volatile uint16_t*)0x008000B2UL) /* Diagnostic mode 0 target RPM lookup arg (1 ref) */
#define diagnostic_table_pointer_3 (*(volatile uint16_t*)0x008000B4UL) /* Diagnostic table pointer setup value 3 (1 ref) */
#define diagnostic_table_pointer_2 (*(volatile uint16_t*)0x008000B8UL) /* Diagnostic table pointer setup value 2 (1 ref) */
#define diagnostic_table_6_ptr (*(volatile uint32_t*)0x008000BAUL) /* Diagnostic table 6 pointer 0x8078d6 (diagnostic... */
#define diag_mode_1_target_rpm_arg (*(volatile uint16_t*)0x008000BEUL) /* Diagnostic mode 1 target RPM lookup arg (1 ref) */
#define diagnostic_table_pointer_1 (*(volatile uint16_t*)0x008000C0UL) /* Diagnostic table pointer setup value 1 (1 ref) */
#define tpu_timer_channel_config (*(volatile uint16_t*)0x008000C4UL) /* TPU timer channel configuration (23 refs) */
#define io_can_fault_monitor_state (*(volatile uint16_t*)0x008000C8UL) /* I/O and CAN fault monitor state (4 refs) */
#define can_pin_fault_persistence_counter (*(volatile uint8_t*)0x008000C9UL) /* Persistence counter for CAN pin switching fault... */
#define io_control_fault_persistence_counter_1 (*(volatile uint8_t*)0x008000CAUL) /* Persistence counter for I/O control fault 1 */
#define io_control_fault_persistence_counter_2 (*(volatile uint8_t*)0x008000CBUL) /* Persistence counter for I/O control fault 2 */
#define can_fault_monitor_counter (*(volatile uint16_t*)0x008000CCUL) /* CAN fault monitor periodic counter (3 refs) */
#define io_control_fault_persistence_counter_4 (*(volatile uint8_t*)0x008000CDUL) /* Persistence counter for I/O control fault 4 */
#define io_control_fault_persistence_counter_5 (*(volatile uint8_t*)0x008000CEUL) /* Persistence counter for I/O control fault 5 */
#define io_control_fault_persistence_counter_6 (*(volatile uint8_t*)0x008000CFUL) /* Persistence counter for I/O control fault 6 */
#define accelerator_throttle_fault_counter (*(volatile uint8_t*)0x008000D0UL) /* Accelerator throttle fault persistence counter ... */
#define io_control_fault_persistence_counter_7 (*(volatile uint8_t*)0x008000D1UL) /* Persistence counter for I/O control fault 7 */
#define accel_throttle_fault_delay_counter (*(volatile uint16_t*)0x008000D2UL) /* Accelerator throttle fault delay counter (5 refs) */
#define accelerator_throttle_fault_state (*(volatile uint16_t*)0x008000D4UL) /* Accelerator throttle fault detector state (10 r... */
#define diagnostic_message_alternation_counter (*(volatile uint8_t*)0x008000D6UL) /* Alternates between diagnostic message 45 and 53... */
#define main_loop_iteration_counter (*(volatile uint8_t*)0x008000D7UL) /* Main loop iteration counter for timing (4 refs) */
#define diagnostic_param_lookup_value (*(volatile uint16_t*)0x008000D8UL) /* Diagnostic parameter lookup value (2 refs) */
#define diagnostic_data_table_1_ptr (*(volatile uint32_t*)0x008000DAUL) /* Diagnostic data table 1 pointer 0x807f42 (diagn... */
#define param_lookup_rpm_input (*(volatile uint16_t*)0x008000DEUL) /* Engine RPM input for param_lookup_2 table inter... */
#define diagnostic_data_table_1_base (*(volatile uint16_t*)0x008000E0UL) /* Diagnostic data table 1 base value (diagnosticD... */
#define diagnostic_data_table_2_ptr (*(volatile uint32_t*)0x008000E2UL) /* Diagnostic data table 2 pointer 0x807f68 (diagn... */
#define diagnostic_data_table_limit (*(volatile uint16_t*)0x008000E6UL) /* Diagnostic data table limit value 400 (diagnost... */
#define diagnostic_data_intake_temp_ptr (*(volatile uint32_t*)0x008000E8UL) /* Diagnostic data intake manifold temp limit poin... */
#define fuel_blend_table_1_base (*(volatile uint16_t*)0x008000ECUL) /* Fuel blend table 1 base value (fuelBlendTablePo... */
#define fuel_blend_table_1_ptr (*(volatile uint32_t*)0x008000EEUL) /* Fuel blend table 1 pointer 0x807f42 (fuelBlendT... */
#define fuel_blend_lookup_input (*(volatile uint16_t*)0x008000F2UL) /* Fuel blend table lookup input (fuelTableBlendIn... */
#define fuel_blend_table_2_base (*(volatile uint16_t*)0x008000F4UL) /* Fuel blend table 2 base value (fuelBlendTablePo... */
#define fuel_blend_table_2_ptr (*(volatile uint32_t*)0x008000F6UL) /* Fuel blend table 2 pointer 0x807f68 (fuelBlendT... */
#define fuel_blend_table_1_limit (*(volatile uint16_t*)0x008000FAUL) /* Fuel blend table 1 limit value 400 (fuelBlendTa... */
#define fuel_blend_intake_temp_ptr (*(volatile uint32_t*)0x008000FCUL) /* Fuel blend intake manifold temp limit pointer (... */
#define fuel_blend_table_3_base (*(volatile uint16_t*)0x00800100UL) /* Fuel blend table 3 base value (fuelBlendTablePo... */
#define fuel_blend_table_3_ptr (*(volatile uint32_t*)0x00800102UL) /* Fuel blend table 3 pointer 0x808002 (fuelBlendT... */
#define fuel_blend_lookup_input_2 (*(volatile uint16_t*)0x00800106UL) /* Fuel blend table lookup input 2 (fuelTableBlend... */
#define fuel_blend_table_4_base (*(volatile uint16_t*)0x00800108UL) /* Fuel blend table 4 base value (fuelBlendTablePo... */
#define fuel_blend_table_4_ptr (*(volatile uint32_t*)0x0080010AUL) /* Fuel blend table 4 pointer 0x808028 (fuelBlendT... */
#define fuel_blend_table_3_limit (*(volatile uint16_t*)0x0080010EUL) /* Fuel blend table 3 limit value 400 (fuelBlendTa... */
#define fuel_blend_table_5_ptr (*(volatile uint32_t*)0x00800110UL) /* Fuel blend table 5 pointer 0x808032 (fuelBlendT... */
#define io_control_fuel_table_1_lookup_arg (*(volatile uint16_t*)0x00800114UL) /* IO control fuel calculation table 1 lookup argu... */
#define retarder_mode_lookup_table_pointer (*(volatile uint32_t*)0x00800116UL) /* Retarder mode lookup table pointer (0x807952/0x... */
#define io_control_fuel_rpm_input (*(volatile uint16_t*)0x0080011AUL) /* RPM input for I/O control fuel lookup (ioContro... */
#define retarder_lookup_table_ptr (*(volatile uint32_t*)0x0080011CUL) /* Pointer to retarder mode lookup table (7 refs) */
#define io_control_fuel_table_2_lookup_arg (*(volatile uint16_t*)0x00800120UL) /* IO control fuel calculation table 2 lookup argu... */
#define retarder_lookup_table_pointer (*(volatile uint32_t*)0x00800122UL) /* Pointer to retarder lookup table (0x807952 or 0... */
#define io_control_fuel_table_param (*(volatile uint16_t*)0x00800126UL) /* I/O control fuel table parameter (ioControlBase... */
#define io_control_fuel_calculator_ptr (*(volatile uint16_t*)0x00800128UL) /* I/O control fuel calculator pointer (3 refs) */
#define throttle_validation_state (*(volatile uint16_t*)0x0080012CUL) /* Throttle position validation state (3 refs) */
#define throttle_position_raw_value (*(volatile uint16_t*)0x00800130UL) /* Throttle position raw ADC value (9 refs) */
#define throttle_position_validator_state (*(volatile uint16_t*)0x00800134UL) /* Throttle position validator state (10 refs) */
#define throttle_buffer_validation_value (*(volatile uint16_t*)0x00800138UL) /* Throttle position buffer validation value (9 refs) */
#define throttle_buffer_decreasing_value (*(volatile uint16_t*)0x0080013CUL) /* Throttle buffer decreasing pattern check value ... */
#define throttle_position_validation_buffer (*(volatile uint16_t*)0x00800140UL) /* Throttle position validator buffer value (6 refs) */
#define derate_fault_counter_1 (*(volatile uint16_t*)0x00800144UL) /* Derate fault counter type 1 (4 refs) */
#define derate_fault_counter_2 (*(volatile uint16_t*)0x00800146UL) /* Derate fault counter type 2 (4 refs) */
#define derate_fault_counter_3 (*(volatile uint16_t*)0x00800148UL) /* Derate fault counter type 3 (4 refs) */
#define derate_target_snapshot (*(volatile uint16_t*)0x0080014AUL) /* Derate target snapshot for monitoring (4 refs) */
#define derate_lower_limit (*(volatile uint16_t*)0x0080014CUL) /* Derate lower limit calculated value (4 refs) */
#define derate_upper_limit (*(volatile uint16_t*)0x0080014EUL) /* Derate upper limit calculated value (4 refs) */
#define current_derate_target (*(volatile uint16_t*)0x00800150UL) /* Current derate target value (25 refs) */
#define current_derate_flag (*(volatile uint8_t*)0x00800152UL) /* Current derate state flag (1 ref) */
#define current_derate_reserved (*(volatile uint8_t*)0x00800153UL) /* Reserved padding byte */
#define ac_control_table_size (*(volatile uint16_t*)0x00800160UL) /* AC control system table size init (initAcContro... */
#define ac_control_kickdown_ptr (*(volatile uint32_t*)0x00800162UL) /* AC control kickdown speed parameter pointer (in... */
#define kickdown_throttle_input (*(volatile uint16_t*)0x00800166UL) /* Kickdown signal throttle input (kickdownSignalS... */
#define ac_control_accel_threshold_ptr (*(volatile uint32_t*)0x00800168UL) /* AC control accel threshold parameter pointer (i... */
#define timing_accumulator_flag_mask (*(volatile uint16_t*)0x0080016CUL) /* Flag mask OR'd with fuel_adjustment_active_flag... */
#define redundant_sensor_validation_index (*(volatile uint16_t*)0x0080016EUL) /* Redundant sensor validation loop index */
#define anc_speed_limit_table_1_size (*(volatile uint16_t*)0x00800170UL) /* ANC speed limit table 1 size (initAncSpeedLimit... */
#define anc_speed_limit_table_1_ptr (*(volatile uint32_t*)0x00800172UL) /* ANC speed limit table 1 pointer 0x807af4 (initA... */
#define cold_start_rpm_snapshot_1 (*(volatile uint16_t*)0x00800176UL) /* Cold start RPM snapshot 1 for fuel control (col... */
#define anc_speed_limit_table_2_base (*(volatile uint16_t*)0x00800178UL) /* ANC speed limit table 2 base value (initAncSpee... */
#define anc_speed_limit_table_2_ptr (*(volatile uint32_t*)0x0080017AUL) /* ANC speed limit table 2 pointer 0x807b10 (initA... */
#define cold_start_fuel_demand_snapshot (*(volatile uint16_t*)0x0080017EUL) /* Cold start fuel demand snapshot (coldStartFuelC... */
#define anc_speed_limit_table_3_ptr (*(volatile uint32_t*)0x00800180UL) /* ANC speed limit table 3 pointer 0x807b20 (initA... */
#define anc_altitude_table_1_size (*(volatile uint16_t*)0x00800184UL) /* ANC altitude table 1 size (initAncSpeedLimitAnd... */
#define anc_duty_cycle_ptr (*(volatile uint32_t*)0x00800186UL) /* ANC duty cycle conversion factor pointer (initA... */
#define cold_start_rpm_snapshot_2 (*(volatile uint16_t*)0x0080018AUL) /* Cold start RPM snapshot 2 for fuel control (col... */
#define anc_min_active_time_ptr (*(volatile uint32_t*)0x0080018CUL) /* ANC minimum active time parameter pointer (init... */
#define anc_disable_duration_table_size (*(volatile uint16_t*)0x00800190UL) /* ANC disable duration table size (initAncSpeedLi... */
#define anc_disable_duration_ptr (*(volatile uint32_t*)0x00800192UL) /* ANC disable duration parameter pointer (initAnc... */
#define cold_start_rpm_snapshot_3 (*(volatile uint16_t*)0x00800196UL) /* Cold start RPM snapshot 3 for fuel control (col... */
#define anc_altitude_table_1_base (*(volatile uint16_t*)0x00800198UL) /* ANC altitude derate table 1 base (initAncSpeedL... */
#define anc_altitude_table_1_ptr (*(volatile uint32_t*)0x0080019AUL) /* ANC altitude derate table 1 pointer 0x807a66 (i... */
#define cold_start_sensor_sum_saved (*(volatile uint16_t*)0x0080019EUL) /* Cold start sensor reading sum saved (2 refs) */
#define anc_altitude_table_2_ptr (*(volatile uint32_t*)0x008001A0UL) /* ANC altitude derate table 2 pointer 0x807a6e (i... */
#define anc_altitude_table_3_size (*(volatile uint16_t*)0x008001A4UL) /* ANC altitude table 3 size (initAncSpeedLimitAnd... */
#define anc_default_fueling_ptr (*(volatile uint32_t*)0x008001A6UL) /* ANC default fueling parameter pointer (initAncS... */
#define cold_start_rpm_snapshot (*(volatile uint16_t*)0x008001AAUL) /* Cold start engine RPM snapshot (2 refs) */
#define anc_altitude_table_3_ptr (*(volatile uint32_t*)0x008001ACUL) /* ANC altitude derate table 3 pointer 0x807ad8 (i... */
#define cold_start_fuel_control_result (*(volatile uint16_t*)0x008001B0UL) /* Cold start fuel control slow cycle result (6 refs) */
#define cold_start_sensor_reading_sum (*(volatile uint16_t*)0x008001B2UL) /* Cold start fuel control sensor reading sum (5 r... */
#define vp44_comm_buffer_status (*(volatile uint16_t*)0x008001B8UL) /* VP44 communication buffer status */
#define vp44_buffer_count (*(volatile uint16_t*)0x008001C0UL) /* VP44 buffer entry count - accessed via addq.w/m... */
#define vp44_buffer_total_size (*(volatile uint16_t*)0x008001C2UL) /* VP44 buffer total size (block_size * buffer_count) */
#define vp44_block_size (*(volatile uint16_t*)0x008001C4UL) /* VP44 block size (0x2000 / buffer_count) - acces... */
#define engine_runtime_histogram_delta (*(volatile uint32_t*)0x008001C6UL) /* Engine runtime histogram time delta calculation */
#define engine_runtime_histogram_accumulator (*(volatile uint16_t*)0x008001CAUL) /* Engine run time histogram accumulator value (6 ... */
#define hour_meter_conversion_state (*(volatile uint32_t*)0x008001CCUL) /* Hour meter conversion data state (10 refs) */
#define hour_meter_tick_counter (*(volatile uint16_t*)0x008001D0UL) /* Hour meter tick accumulator counter - accessed ... */
#define hour_meter_tick_divider (*(volatile uint16_t*)0x008001D2UL) /* Hour meter tick divider value */
#define engine_runtime_histogram_interpolation_b (*(volatile uint16_t*)0x008001D4UL) /* Engine runtime histogram interpolation value B */
#define engine_runtime_histogram_config_type_a (*(volatile uint16_t*)0x008001D6UL) /* Engine runtime config table A type */
#define hour_meter_table_1_ptr (*(volatile uint32_t*)0x008001D8UL) /* Hour meter conversion table 1 pointer 0x807f42 ... */
#define rpm_histogram_threshold_saved (*(volatile uint16_t*)0x008001DCUL) /* RPM histogram threshold saved (2 refs) */
#define hour_meter_table_2_base (*(volatile uint16_t*)0x008001DEUL) /* Hour meter conversion table 2 base (initHourMet... */
#define hour_meter_table_2_ptr (*(volatile uint32_t*)0x008001E0UL) /* Hour meter conversion table 2 pointer 0x807f68 ... */
#define hour_meter_table_1_limit (*(volatile uint16_t*)0x008001E4UL) /* Hour meter conversion table 1 limit 400 (initHo... */
#define hour_meter_intake_temp_ptr (*(volatile uint32_t*)0x008001E6UL) /* Hour meter intake temp limit pointer (initHourM... */
#define hour_meter_table_3_size (*(volatile uint16_t*)0x008001EAUL) /* Hour meter table 3 size (initHourMeterConversio... */
#define hour_meter_table_3_ptr (*(volatile uint32_t*)0x008001ECUL) /* Hour meter conversion table 3 pointer 0x808002 ... */
#define engine_rpm_histogram_threshold_select (*(volatile uint16_t*)0x008001F0UL) /* Selected RPM threshold for histogram binning (4... */
#define hour_meter_table_4_base (*(volatile uint16_t*)0x008001F2UL) /* Hour meter conversion table 4 base (initHourMet... */
#define hour_meter_table_4_ptr (*(volatile uint32_t*)0x008001F4UL) /* Hour meter conversion table 4 pointer 0x808028 ... */
#define hour_meter_table_3_limit (*(volatile uint16_t*)0x008001F8UL) /* Hour meter conversion table 3 limit 400 (initHo... */
#define hour_meter_table_5_ptr (*(volatile uint32_t*)0x008001FAUL) /* Hour meter conversion table 5 pointer 0x808032 ... */
#define manifold_temp_table_1_type (*(volatile uint16_t*)0x008001FEUL) /* Manifold temp limit table 1 type (1 ref) */
#define manifold_temp_table_1_x_ptr (*(volatile uint32_t*)0x00800200UL) /* Manifold temp limit table 1 X-axis pointer (1 ref) */
#define speed_diff_interp_input (*(volatile uint16_t*)0x00800204UL) /* Speed difference interpolator input (speedDiffe... */
#define manifold_temp_table_1_y_type (*(volatile uint16_t*)0x00800206UL) /* Manifold temp limit table 1 Y type (1 ref) */
#define manifold_temp_table_1_y_ptr (*(volatile uint32_t*)0x00800208UL) /* Manifold temp limit table 1 Y-axis pointer (1 ref) */
#define manifold_temp_table_1_count (*(volatile uint16_t*)0x0080020CUL) /* Manifold temp limit table 1 element count (1 ref) */
#define manifold_temp_table_1_z_ptr (*(volatile uint32_t*)0x0080020EUL) /* Manifold temp limit table 1 Z-axis pointer (1 ref) */
#define manifold_temp_table_2_type (*(volatile uint16_t*)0x00800212UL) /* Manifold temp limit table 2 type (1 ref) */
#define manifold_temp_table_2_x_ptr (*(volatile uint32_t*)0x00800214UL) /* Manifold temp limit table 2 X-axis pointer (1 ref) */
#define speed_based_parameter_lookup_result (*(volatile uint16_t*)0x00800218UL) /* Speed-based parameter lookup result value (6 refs) */
#define manifold_temp_table_2_z_ptr (*(volatile uint32_t*)0x0080021AUL) /* Manifold temp limit table 2 Z-axis pointer (1 ref) */
#define manifold_temp_table_3_type (*(volatile uint16_t*)0x0080021EUL) /* Manifold temp limit table 3 type (1 ref) */
#define manifold_temp_table_3_x_ptr (*(volatile uint32_t*)0x00800220UL) /* Manifold temp limit table 3 X-axis pointer (1 ref) */
#define multi_speed_throttle_input (*(volatile uint16_t*)0x00800224UL) /* Multi-speed parameter throttle input (multiSpee... */
#define manifold_temp_table_3_z_ptr (*(volatile uint32_t*)0x00800226UL) /* Manifold temp limit table 3 Z-axis pointer (1 ref) */
#define speed_difference_interpolation_result (*(volatile uint16_t*)0x0080022AUL) /* Speed difference interpolation result (multiSpe... */
#define fault_scanner_loop_timestamp (*(volatile uint16_t*)0x0080022CUL) /* Fault scanner loop counter timestamp (2 refs) */
#define diagnostic_queue_index (*(volatile uint8_t*)0x00800230UL) /* Diagnostic queue current index for debounce han... */
#define diagnostic_fault_group_index (*(volatile uint16_t*)0x00800232UL) /* Index for diagnostic fault group processing */
#define vp44_comm_bit0_prev_state (*(volatile uint8_t*)0x00800234UL) /* VP44 communication bit 0 previous state (2 refs) */
#define vp44_comm_bit2_debounce_timer (*(volatile uint16_t*)0x00800236UL) /* VP44 communication bit 2 debounce timer (4 refs) */
#define vp44_comm_bit1_debounce_timer (*(volatile uint16_t*)0x00800238UL) /* VP44 communication bit 1 debounce timer (4 refs) */
#define vp44_sensor_fault_debounce_timer (*(volatile uint16_t*)0x0080023AUL) /* VP44 sensor fault debounce timer (3 refs) */
#define vp44_derate_fault_debounce_timer (*(volatile uint16_t*)0x0080023CUL) /* VP44 derate fault debounce timer (3 refs) */
#define vp44_status_mask_array ((volatile uint8_t*)0x0080023EUL) /* [10] Array of masks for VP44 status bit filtering */
#define vp44_buffer_index (*(volatile uint8_t*)0x00800242UL) /* VP44 status data collector buffer index - acces... */
#define vp44_buffer_index_reserved (*(volatile uint8_t*)0x00800243UL) /* VP44 buffer index reserved byte */
#define vp44_status_data_table (*(volatile uint32_t*)0x00800244UL) /* VP44 status data collection table base */
#define vp44_third_array_1 (*(volatile uint32_t*)0x00800268UL) /* VP44 third status array element 1 (vp44_status_... */
#define vp44_third_array_2 (*(volatile uint32_t*)0x0080026CUL) /* VP44 third status array element 2 (vp44_status_... */
#define vp44_third_array_3 (*(volatile uint32_t*)0x00800270UL) /* VP44 third status array element 3 (vp44_status_... */
#define engine_rpm_source_max_ptr (*(volatile uint32_t*)0x00800280UL) /* Engine RPM source max fuel limit pointer (engin... */
#define engine_rpm_source_init_value (*(volatile uint16_t*)0x00800284UL) /* Engine RPM source initial value (engineRpmSourc... */
#define peak_torque_correction_applied_flag (*(volatile uint16_t*)0x00800288UL) /* Peak torque correction applied one-shot flag */
#define load_trending_table_1_size (*(volatile uint16_t*)0x0080028AUL) /* Load trending table 1 size (initLoadTrendingSys... */
#define load_trending_kickdown_ptr (*(volatile uint32_t*)0x0080028CUL) /* Load trending kickdown speed pointer (initLoadT... */
#define fuel_timing_blend_throttle_input (*(volatile uint16_t*)0x00800290UL) /* Fuel timing blend throttle input (fuelTimingMod... */
#define load_trending_accel_ptr (*(volatile uint32_t*)0x00800292UL) /* Load trending accel threshold pointer (initLoad... */
#define load_trending_lower_limit_size (*(volatile uint16_t*)0x00800296UL) /* Load trending lower limit table size (initLoadT... */
#define load_trending_lower_limit_ptr (*(volatile uint32_t*)0x00800298UL) /* Load trending lower limit pointer (initLoadTren... */
#define fuel_timing_intake_temp_input (*(volatile uint16_t*)0x0080029CUL) /* Fuel timing intake temp input (fuelTimingModeBl... */
#define load_trending_count_min_ptr (*(volatile uint32_t*)0x0080029EUL) /* Load trending count minimum pointer (initLoadTr... */
#define load_trending_table_2_size (*(volatile uint16_t*)0x008002A2UL) /* Load trending table 2 size (initLoadTrendingSys... */
#define load_trending_table_1_ptr (*(volatile uint32_t*)0x008002A4UL) /* Load trending table 1 pointer 0x8080c2 (initLoa... */
#define fuel_timing_blend_rpm_input_1 (*(volatile uint16_t*)0x008002A8UL) /* Fuel timing blend RPM input 1 (fuelTimingModeBl... */
#define load_trending_table_2_base (*(volatile uint16_t*)0x008002AAUL) /* Load trending table 2 base value (initLoadTrend... */
#define load_trending_table_2_ptr (*(volatile uint32_t*)0x008002ACUL) /* Load trending table 2 pointer 0x8080e8 (initLoa... */
#define fuel_timing_blend_offset_input_1 (*(volatile uint16_t*)0x008002B0UL) /* Fuel timing blend offset input 1 (fuelTimingMod... */
#define load_trending_table_3_ptr (*(volatile uint32_t*)0x008002B2UL) /* Load trending table 3 pointer 0x808100 (initLoa... */
#define load_trending_table_4_size (*(volatile uint16_t*)0x008002B6UL) /* Load trending table 4 size (initLoadTrendingSys... */
#define load_trending_table_4_ptr (*(volatile uint32_t*)0x008002B8UL) /* Load trending table 4 pointer 0x80828c (initLoa... */
#define fuel_timing_blend_rpm_input_2 (*(volatile uint16_t*)0x008002BCUL) /* Fuel timing blend RPM input 2 (fuelTimingModeBl... */
#define load_trending_table_5_base (*(volatile uint16_t*)0x008002BEUL) /* Load trending table 5 base value (initLoadTrend... */
#define load_trending_table_5_ptr (*(volatile uint32_t*)0x008002C0UL) /* Load trending table 5 pointer 0x8082b2 (initLoa... */
#define fuel_timing_blend_offset_input_2 (*(volatile uint16_t*)0x008002C4UL) /* Fuel timing blend offset input 2 (fuelTimingMod... */
#define load_trending_table_6_ptr (*(volatile uint32_t*)0x008002C6UL) /* Load trending table 6 pointer 0x8082ca (initLoa... */
#define peak_torque_engine_mode_input (*(volatile uint8_t*)0x008002CAUL) /* Engine mode snapshot for peak torque correction... */
#define engine_operating_mode_previous (*(volatile uint8_t*)0x008002CCUL) /* Previous engine operating mode for transition d... */
#define engine_mode_previous_0 (*(volatile uint8_t*)0x008002CEUL) /* Engine operating mode previous 0 (2 refs) */
#define engine_mode_previous_1 (*(volatile uint8_t*)0x008002D0UL) /* Engine operating mode previous 1 (2 refs) */
#define protection_reserved_1 (*(volatile uint8_t*)0x008002D1UL) /* Reserved padding byte */
#define engine_mode_previous_state_2d2 (*(volatile uint16_t*)0x008002D2UL) /* Engine mode previous state for transition detec... */
#define engine_mode_previous_2 (*(volatile uint8_t*)0x008002D4UL) /* Engine operating mode previous 2 (2 refs) */
#define protection_reserved_2 (*(volatile uint8_t*)0x008002D5UL) /* Reserved padding byte */
#define engine_overspeed_counter (*(volatile uint16_t*)0x008002D6UL) /* Engine overspeed detection counter */
#define vp44_communication_status_latch (*(volatile uint8_t*)0x008002D8UL) /* VP44 communication status latch flag (engineOpe... */
#define protection_reserved_3 (*(volatile uint8_t*)0x008002D9UL) /* Reserved padding byte */
#define protection_state_machine_index (*(volatile PROTECTION_STATE*)0x008002DAUL) /* Protection state machine cycle index (0-4) (7 r... */
#define protection_reserved_5 (*(volatile uint16_t*)0x008002DCUL) /* Reserved padding word */
#define protection_threshold_table_ptr (*(volatile uint32_t*)0x008002DEUL) /* Protection threshold table pointer 0x807e6e (pr... */
#define system_timer_array ((volatile uint16_t*)0x008002E0UL) /* System scheduler timer array - all initialized ... */
#define protection_threshold_status_shifted (*(volatile uint32_t*)0x008002E2UL) /* Protection threshold status shifted value (prot... */
#define engine_rpm_previous_nonzero (*(volatile uint16_t*)0x008002E6UL) /* Engine RPM previous nonzero check (2 refs) */
#define high_rpm_shutdown_previous (*(volatile uint8_t*)0x008002E8UL) /* High RPM shutdown flag previous (2 refs) */
#define diagnostic_protection_previous (*(volatile uint8_t*)0x008002EAUL) /* Diagnostic protection state previous (2 refs) */
#define engine_mode_transition_flag (*(volatile uint16_t*)0x008002ECUL) /* Engine mode transition detection flag (3 refs) */
#define protection_fault_id_table ((volatile uint16_t*)0x008002EEUL) /* [5] Table of protection fault IDs */
#define engine_state_timer (*(volatile uint16_t*)0x008002F2UL) /* Engine state transition timer */
#define engine_mode_transition_timer (*(volatile uint16_t*)0x008002F6UL) /* Engine mode transition timer */
#define protection_state2_rpm_timer (*(volatile uint16_t*)0x008002FAUL) /* Protection state 2 RPM-based timer counter (5 r... */
#define protection_state2_threshold (*(volatile uint16_t*)0x008002FCUL) /* Protection state 2 threshold calculator value (... */
#define protection_state2_lookup_args (*(volatile uint16_t*)0x008002FEUL) /* Protection state 2 lookup table arguments (1 ref) */
#define protection_state2_table_ptr_1 (*(volatile uint32_t*)0x00800300UL) /* Protection state 2 threshold table pointer 1 (1... */
#define protection_state2_rpm_snapshot (*(volatile uint16_t*)0x00800304UL) /* Protection state 2 RPM snapshot for lookup (1 ref) */
#define protection_state2_table_ptr_2 (*(volatile uint32_t*)0x00800306UL) /* Protection state 2 threshold table pointer 2 (1... */
#define throttle_zero_position_counter (*(volatile uint16_t*)0x00800322UL) /* Throttle zero position sample counter (5 refs) */
#define throttle_timer_capture_backup (*(volatile uint32_t*)0x0080032AUL) /* Throttle timer capture backup value (2 refs) */
#define rpm_filter_buffer_ptr (*(volatile uint32_t*)0x00800332UL) /* RPM filter buffer current pointer (can1TimerBuf... */
#define oil_pressure_crank_exit_ptr (*(volatile uint32_t*)0x0080033AUL) /* Oil pressure crank exit time pointer (initOilPr... */
#define oil_pressure_mode_init_flag (*(volatile uint32_t*)0x0080033EUL) /* Oil pressure mode init flag 0x80000000 (initOil... */
#define crank_exit_rpm_threshold (*(volatile uint16_t*)0x00800342UL) /* Crank exit RPM threshold value (3 refs) */
#define engine_rpm_previous_sample (*(volatile uint16_t*)0x00800344UL) /* Engine RPM previous sample for delta (2 refs) */
#define engine_rpm_delta (*(volatile uint16_t*)0x00800346UL) /* Engine RPM delta for fuel timing (fuelTimingOil... */
#define scheduler_phase_execution_time (*(volatile uint16_t*)0x00800354UL) /* Scheduler phase execution time measurement (7 r... */
#define scheduler_reserved_padding (*(volatile uint16_t*)0x00800356UL) /* Reserved padding before phase index */
#define main_loop_phase_index (*(volatile MAIN_LOOP_PHASE*)0x00800358UL) /* Main loop scheduler phase index 0-39 (41 refs) */
#define main_loop_reserved (*(volatile uint16_t*)0x0080035AUL) /* Reserved padding after phase index */
#define scheduler_phase_pointer (*(volatile uint32_t*)0x0080035CUL) /* Pointer to current scheduler phase table entry ... */
#define engine_operating_mode_cached (*(volatile uint8_t*)0x00800360UL) /* Cached engine operating mode for comparison (3 ... */
#define flash_control_register_ptr (*(volatile uint32_t*)0x00800362UL) /* Flash erase command register pointer (0x2020 0x... */
#define flash_write_data_pointer (*(volatile uint32_t*)0x00800366UL) /* Flash write data source pointer (2 refs) */
#define flash_write_end_address (*(volatile uint32_t*)0x0080036AUL) /* Flash write end address limit (2 refs) */
#define fuel_demand_rating_table_size (*(volatile uint16_t*)0x0080036EUL) /* Fuel demand rating table size (initFuelDemandCa... */
#define fuel_demand_table_1_ptr_370 (*(volatile uint32_t*)0x00800370UL) /* Fuel demand table 1 pointer 0x807c9a (initFuelD... */
#define fuel_demand_blend_input (*(volatile uint16_t*)0x00800374UL) /* Fuel demand value for blending (fuelDemandTable... */
#define fuel_demand_rating_ptr (*(volatile uint32_t*)0x00800376UL) /* Fuel demand rating parameter pointer CCRFRTNG (... */
#define fuel_demand_blend_table_1_size (*(volatile uint16_t*)0x0080037AUL) /* Fuel demand blend table 1 size (initFuelDemandC... */
#define fuel_demand_table_2_ptr_37c (*(volatile uint32_t*)0x0080037CUL) /* Fuel demand table 2 pointer 0x8080c2 (initFuelD... */
#define rpm_snapshot_0 (*(volatile uint16_t*)0x00800380UL) /* Engine RPM snapshot 0 (2 refs) */
#define fuel_demand_table_2_base (*(volatile uint16_t*)0x00800382UL) /* Fuel demand table 2 base value (initFuelDemandC... */
#define fuel_demand_table_3_ptr_384 (*(volatile uint32_t*)0x00800384UL) /* Fuel demand table 3 pointer 0x8080e8 (initFuelD... */
#define fuel_snapshot_0 (*(volatile uint16_t*)0x00800388UL) /* Fuel value snapshot 0 (2 refs) */
#define fuel_demand_table_4_ptr (*(volatile uint32_t*)0x0080038AUL) /* Fuel demand table 4 pointer 0x808100 (initFuelD... */
#define fuel_demand_blend_table_2_size (*(volatile uint16_t*)0x0080038EUL) /* Fuel demand blend table 2 size (initFuelDemandC... */
#define fuel_demand_table_5_ptr (*(volatile uint32_t*)0x00800390UL) /* Fuel demand table 5 pointer 0x80828c (initFuelD... */
#define rpm_snapshot_1 (*(volatile uint16_t*)0x00800394UL) /* Engine RPM snapshot 1 (2 refs) */
#define fuel_demand_table_5_base (*(volatile uint16_t*)0x00800396UL) /* Fuel demand table 5 base value (initFuelDemandC... */
#define fuel_demand_table_6_ptr (*(volatile uint32_t*)0x00800398UL) /* Fuel demand table 6 pointer 0x8082b2 (initFuelD... */
#define fuel_snapshot_1 (*(volatile uint16_t*)0x0080039CUL) /* Fuel value snapshot 1 (2 refs) */
#define fuel_demand_table_7_ptr (*(volatile uint32_t*)0x0080039EUL) /* Fuel demand table 7 pointer 0x8082ca (initFuelD... */
#define fuel_limit_table_1_ptr (*(volatile uint32_t*)0x008003A4UL) /* Fuel limit table 1 pointer 0x808862 (fuelLimitP... */
#define fuel_limit_table_2_ptr (*(volatile uint32_t*)0x008003ACUL) /* Fuel limit table 2 pointer 0x808876 (fuelLimitP... */
#define fuel_limit_table_1_base_ptr (*(volatile uint32_t*)0x008003B0UL) /* Fuel limit table 1 base pointer 0x807f42 (fuelL... */
#define fuel_limit_lookup_1_base (*(volatile uint16_t*)0x008003B2UL) /* Fuel limit lookup table 1 base value 2 (fuelLim... */
#define fuel_limit_lookup_1_divisor (*(volatile uint16_t*)0x008003B8UL) /* Fuel limit lookup table 1 divisor value 2 (fuel... */
#define fuel_limit_table_3_ptr (*(volatile uint32_t*)0x008003BAUL) /* Fuel limit table 3 pointer 0x807f68 (fuelLimitP... */
#define fuel_limit_table_1_limit (*(volatile uint16_t*)0x008003BEUL) /* Fuel limit table 1 limit value 400 (fuelLimitPa... */
#define fuel_limit_intake_temp_ptr (*(volatile uint32_t*)0x008003C0UL) /* Fuel limit intake temp limit pointer (fuelLimit... */
#define fuel_limit_table_4_ptr (*(volatile uint32_t*)0x008003C6UL) /* Fuel limit table 4 pointer 0x808002 (fuelLimitP... */
#define fuel_limit_lookup_2_divisor (*(volatile uint16_t*)0x008003CCUL) /* Fuel limit lookup table 2 divisor value 2 (fuel... */
#define fuel_limit_table_5_ptr (*(volatile uint32_t*)0x008003CEUL) /* Fuel limit table 5 pointer 0x808028 (fuelLimitP... */
#define fuel_limit_table_2_limit (*(volatile uint16_t*)0x008003D2UL) /* Fuel limit table 2 limit value 400 (fuelLimitPa... */
#define fuel_limit_table_6_ptr (*(volatile uint32_t*)0x008003D4UL) /* Fuel limit table 6 pointer 0x808032 (fuelLimitP... */
#define fuel_delivery_param_ptr (*(volatile uint32_t*)0x008003D8UL) /* Fuel delivery parameter pointer 0x808464 (fuelD... */
#define fuel_delivery_pid_integral (*(volatile uint32_t*)0x008003E0UL) /* Fuel delivery PID controller integral term */
#define derate_bit4_previous_state (*(volatile uint16_t*)0x008003E4UL) /* Derate bit 4 previous state */
#define derate_bit4_changed_flag (*(volatile uint16_t*)0x008003E6UL) /* Derate bit 4 changed flag */
#define derate_bit8_previous_state (*(volatile uint16_t*)0x008003E8UL) /* Derate bit 8 previous state */
#define derate_bit8_changed_flag (*(volatile uint16_t*)0x008003EAUL) /* Derate bit 8 changed flag */
#define derate_reference_value (*(volatile uint16_t*)0x008003ECUL) /* Derate reference value for change detection */
#define derate_value_changed_flag (*(volatile uint16_t*)0x008003EEUL) /* Derate value changed flag */
#define interpolation_table_1_base (*(volatile uint16_t*)0x008003F0UL) /* Interpolation lookup table 1 base (4 refs) */
#define fuel_timing_mode_table_1_ptr (*(volatile uint32_t*)0x008003F2UL) /* Fuel timing mode table 1 pointer 0x807f42 (fuel... */
#define fuel_timing_mode_rpm_input_1 (*(volatile uint16_t*)0x008003F6UL) /* Fuel timing mode RPM input 1 (activeParamReadFu... */
#define fuel_timing_mode_lookup_1_base (*(volatile uint16_t*)0x008003F8UL) /* Fuel timing mode lookup 1 divisor value 2 (fuel... */
#define fuel_timing_mode_table_2_ptr (*(volatile uint32_t*)0x008003FAUL) /* Fuel timing mode table 2 pointer 0x807f68 (fuel... */
#define derate_interpolation_value_1 (*(volatile uint16_t*)0x008003FEUL) /* Derate interpolation input value 1 (3 refs) */
#define fuel_timing_mode_intake_temp_ptr (*(volatile uint32_t*)0x00800400UL) /* Fuel timing mode intake temp limit pointer (fue... */
#define interpolation_table_2_base (*(volatile uint16_t*)0x00800404UL) /* Interpolation lookup table 2 base (4 refs) */
#define fuel_timing_mode_table_3_ptr (*(volatile uint32_t*)0x00800406UL) /* Fuel timing mode table 3 pointer 0x808002 (fuel... */
#define fuel_timing_mode_rpm_input_2 (*(volatile uint16_t*)0x0080040AUL) /* Fuel timing mode RPM input 2 (activeParamReadFu... */
#define fuel_timing_mode_lookup_2_base (*(volatile uint16_t*)0x0080040CUL) /* Fuel timing mode lookup 2 divisor value 2 (fuel... */
#define fuel_timing_mode_table_4_ptr (*(volatile uint32_t*)0x0080040EUL) /* Fuel timing mode table 4 pointer 0x808028 (fuel... */
#define derate_interpolation_value_2 (*(volatile uint16_t*)0x00800412UL) /* Derate interpolation input value 2 (3 refs) */
#define fuel_timing_mode_table_5_ptr (*(volatile uint32_t*)0x00800414UL) /* Fuel timing mode table 5 pointer 0x808032 (fuel... */
#define general_counter_0 (*(volatile uint16_t*)0x00800418UL) /* General purpose counter 0 (2 refs) */
#define general_counter_1 (*(volatile uint16_t*)0x0080061AUL) /* General purpose counter 1 (2 refs) */
#define diagnostic_buffer_write_pointer (*(volatile uint32_t*)0x00800624UL) /* Diagnostic buffer write position pointer (3 refs) */
#define bit_pattern_input_value (*(volatile uint8_t*)0x00800628UL) /* Bit pattern to index converter input (5 refs) */
#define bit_pattern_index_counter (*(volatile uint8_t*)0x00800629UL) /* Bit pattern to index converter counter (7 refs) */
#define bit_pattern_index_result (*(volatile uint8_t*)0x0080062AUL) /* Bit pattern to index converter result (5 refs) */
#define insite_multiframe_response_index (*(volatile uint8_t*)0x0080062BUL) /* INSITE multi-frame response builder index (6 refs) */
#define arbitrated_fuel_previous (*(volatile uint16_t*)0x00800638UL) /* Arbitrated fuel limit previous value (2 refs) */
#define governor_rpm_error_previous (*(volatile uint16_t*)0x0080063AUL) /* Governor RPM error previous value (2 refs) */
#define timer_scheduler_phase3_count_1 (*(volatile uint8_t*)0x00800768UL) /* Timer scheduler phase 3 count 1 (phase3_periodi... */
#define timer_scheduler_phase3_count_2 (*(volatile uint8_t*)0x00800769UL) /* Timer scheduler phase 3 count 2 (phase3_periodi... */
#define throttle_histogram_bin_index_1 (*(volatile uint16_t*)0x0080076AUL) /* Throttle histogram bin index counter 1 (3 refs) */
#define throttle_histogram_bin_index_2 (*(volatile uint16_t*)0x0080076CUL) /* Throttle histogram bin index counter 2 (3 refs) */
#define task_scheduler_dispatch_table_ptr (*(volatile uint32_t*)0x0080076EUL) /* Task scheduler dispatch table pointer (timerBas... */
#define task_scheduler_dispatch_count (*(volatile uint8_t*)0x008007AAUL) /* Task scheduler dispatch handler count (timerBas... */
#define fuel_arbitrator_previous_rpm_target (*(volatile uint16_t*)0x008007ACUL) /* Fuel arbitrator previous RPM target value (3 refs) */
#define fuel_arbitrator_previous_state_2 (*(volatile uint16_t*)0x008007AEUL) /* Fuel arbitrator previous state for comparison 2... */
#define fuel_arbitrator_previous_state (*(volatile uint16_t*)0x008007B0UL) /* Fuel arbitrator previous state for comparison (... */
#define fuel_arbitrator_limited_value_prev (*(volatile uint8_t*)0x008007B2UL) /* Previous fuel arbitrator limited value (memoryR... */
#define retarder_control_source_previous (*(volatile uint8_t*)0x008007B3UL) /* Retarder control CAN source previous value (3 r... */
#define multi_packet_buffer_size (*(volatile uint16_t*)0x008007B8UL) /* Multi-packet buffer size (multiPacketBufferAllo... */
#define multi_packet_data_ptr (*(volatile uint32_t*)0x008007BAUL) /* Multi-packet data pointer 0x8007c4 (multiPacket... */
#define multi_packet_status_ptr (*(volatile uint32_t*)0x008007BEUL) /* Multi-packet status pointer 0x8007c2 (multiPack... */
#define multi_packet_status_byte (*(volatile uint8_t*)0x008007C2UL) /* Multi-packet transmission status byte (multiPac... */
#define diagnostic_request_buffer ((volatile uint8_t*)0x00800B00UL) /* Diagnostic request/response buffer - 4 x 48-byt... */
#define multi_packet_small_size (*(volatile uint16_t*)0x00800ED0UL) /* Multi-packet small buffer size (multiPacketBuff... */
#define multi_packet_small_data_ptr (*(volatile uint32_t*)0x00800ED2UL) /* Multi-packet small data pointer 0x800edc (multi... */
#define multi_packet_small_status_ptr (*(volatile uint32_t*)0x00800ED6UL) /* Multi-packet small status pointer 0x800eda (mul... */
#define debounce_state_flag (*(volatile uint8_t*)0x00800EE4UL) /* Debounce state machine flag (3 refs) */
#define j1939_multi_frame_debounce_state (*(volatile uint8_t*)0x00800EE5UL) /* J1939 multi-frame debounce state array element ... */
#define j1939_multi_frame_retry_counter (*(volatile uint16_t*)0x00800EE8UL) /* J1939 multi-frame retry counter array (sendJ193... */
#define debounce_state_array_current (*(volatile uint8_t*)0x00800EEAUL) /* Debounce state array current values (4 refs) */
#define j1939_multi_frame_sequence_number (*(volatile uint8_t*)0x00800EEBUL) /* J1939 multi-frame sequence number array (sendJ1... */
#define debounce_buffer_pointer_array (*(volatile uint32_t*)0x00800EECUL) /* Debounce buffer pointer array base (3 refs) */
#define debounce_output_pointer_array (*(volatile uint32_t*)0x00800EF0UL) /* Debounce output pointer array base (3 refs) */
#define debounce_countdown_array (*(volatile uint16_t*)0x00800EF4UL) /* Debounce countdown timer array (4 refs) */
#define j1939_multi_frame_pgn_data (*(volatile uint32_t*)0x00800EF6UL) /* J1939 multi-frame PGN data array (sendJ1939Mult... */
#define j1939_multi_frame_timeout_counter (*(volatile uint16_t*)0x00800EFAUL) /* J1939 multi-frame timeout counter array (sendJ1... */
#define j1939_multi_frame_buffer_ptr (*(volatile uint32_t*)0x00800EFCUL) /* J1939 multi-frame buffer pointer array (sendJ19... */
#define j1939_multi_frame_active_flag (*(volatile uint8_t*)0x00800F04UL) /* J1939 multi-frame transmission active flag (mes... */
#define vp44_diag_buffer_2_ptr (*(volatile uint32_t*)0x00800F1CUL) /* VP44 diagnostic buffer 2 pointer 0x800f2c (vp44... */
#define vp44_response_buffer (*(volatile uint8_t*)0x00800F5EUL) /* VP44 fuel temperature response message processi... */
#define vp44_sequence_number (*(volatile uint8_t*)0x00800F5FUL) /* VP44 message sequence number for retry logic (m... */
#define vp44_message_id (*(volatile uint16_t*)0x00800F60UL) /* VP44 message identifier stored during response ... */
#define vp44_retry_flag (*(volatile uint8_t*)0x00800F62UL) /* VP44 retry flag (set to 1 when response pending) */
#define vp44_retry_count (*(volatile uint8_t*)0x00800F63UL) /* VP44 actual retry count (limited to max 5) */
#define vp44_timeout_counter (*(volatile uint8_t*)0x00800F64UL) /* VP44 response timeout countdown (starts at 112 ... */
#define vp44_message_data (*(volatile uint32_t*)0x00800F66UL) /* VP44 stored message command/data during respons... */
#define vp44_expected_sequence (*(volatile uint8_t*)0x00800F69UL) /* Expected VP44 sequence number for response vali... */
#define serial_port_config_value (*(volatile uint16_t*)0x00800F6AUL) /* Serial port configuration value (3 refs) */
#define serial_buffer_pointer (*(volatile uint32_t*)0x00800F6CUL) /* Serial port buffer pointer (3 refs) */
#define fuel_arbitrator_prev_rpm_target (*(volatile uint16_t*)0x0080161CUL) /* Fuel arbitrator previous RPM target (5 refs) */
#define fuel_arbitrator_prev_source (*(volatile uint16_t*)0x0080161EUL) /* Fuel arbitrator previous source identifier (3 r... */
#define fuel_arbitrator_prev_limited (*(volatile uint8_t*)0x00801620UL) /* Fuel arbitrator previous limited value (2 refs) */
#define fuel_arbitrator_prev_speed_limit (*(volatile uint16_t*)0x00801622UL) /* Fuel arbitrator previous speed limit state (2 r... */
#define fuel_arbitrator_prev_state (*(volatile uint16_t*)0x00801624UL) /* Fuel arbitrator previous state (2 refs) */
#define fuel_arbitrator_prev_byte (*(volatile uint8_t*)0x00801626UL) /* Fuel arbitrator previous control byte (2 refs) */
#define fuel_arbitrator_prev_session (*(volatile uint16_t*)0x00801628UL) /* Fuel arbitrator previous session counter (2 refs) */
#define fuel_arbitrator_prev_fuel_limit (*(volatile uint16_t*)0x0080162AUL) /* Fuel arbitrator previous fuel limit state (5 refs) */
#define fuel_arbitrator_prev_throttle (*(volatile uint16_t*)0x0080162CUL) /* Fuel arbitrator previous throttle mode (5 refs) */
#define fuel_arbitrator_source_1_flag (*(volatile uint8_t*)0x0080162FUL) /* Fuel arbitrator source 1 change flag (7 refs) */
#define fuel_arbitrator_source_2_flag (*(volatile uint8_t*)0x00801630UL) /* Fuel arbitrator source 2 change flag (8 refs) */
#define io_control_entry_table_base (*(volatile uint16_t*)0x00801632UL) /* IO control entry table base address (4 refs) */
#define io_control_command_array (*(volatile uint8_t*)0x00801634UL) /* I/O control command array base (3 refs) */
#define io_control_param_array (*(volatile uint16_t*)0x00801636UL) /* I/O control parameter array base (3 refs) */
#define io_control_timeout_array (*(volatile uint16_t*)0x00801638UL) /* I/O control timeout array base (3 refs) */
#define diagnostic_queue_data_array (*(volatile uint8_t*)0x0080165AUL) /* Diagnostic queue data array base (4 refs) */
#define io_control_timeout_table_entry (*(volatile uint16_t*)0x0080165CUL) /* IO control timeout table entry array (ioControl... */
#define scheduler_cycle_counter (*(volatile uint8_t*)0x0080166EUL) /* Scheduler cycle counter */
#define scheduler_phase_flag (*(volatile uint8_t*)0x0080166FUL) /* Scheduler phase flag for timing */
#define io_control_mask_state_active (*(volatile uint8_t*)0x00801670UL) /* IO control mask state machine active flag (ioCo... */
#define diagnostic_queue_init_flag (*(volatile uint8_t*)0x00801671UL) /* Diagnostic queue initialization flag (3 refs) */
#define diagnostic_queue_active_flag (*(volatile uint8_t*)0x00801672UL) /* Diagnostic queue active processing flag (3 refs) */
#define fault_code_display_value (*(volatile uint16_t*)0x00801674UL) /* Fault code display current value */
#define io_toggle_cycle_counter (*(volatile uint16_t*)0x00801676UL) /* IO control toggle cycle counter (10 refs) */
#define lamp_1_blink_counter (*(volatile uint16_t*)0x00801678UL) /* Fault lamp 1 blink cycle counter (7 refs) */
#define lamp_2_blink_counter (*(volatile uint16_t*)0x0080167AUL) /* Lamp 2 blink state counter */
#define lamp_3_blink_counter (*(volatile uint16_t*)0x0080167CUL) /* Lamp 3 blink state counter */
#define diagnostic_queue_pending_flag_1 (*(volatile uint8_t*)0x0080167EUL) /* Diagnostic queue pending flag 1 (3 refs) */
#define diagnostic_queue_pending_flag_2 (*(volatile uint8_t*)0x0080167FUL) /* Diagnostic queue pending flag 2 (3 refs) */
#define digit_display_hundreds_digit (*(volatile uint8_t*)0x00801680UL) /* I/O control digit display hundreds digit - acce... */
#define digit_display_tens_digit (*(volatile uint8_t*)0x00801681UL) /* I/O control digit display tens digit - accessed... */
#define digit_display_ones_digit (*(volatile uint8_t*)0x00801682UL) /* I/O control digit display ones digit - accessed... */
#define fault_code_display_state (*(volatile uint8_t*)0x00801683UL) /* Fault code display controller state (10 refs) */
#define fault_code_display_mode (*(volatile uint8_t*)0x00801684UL) /* Fault code display controller mode (3 refs) */
#define diagnostic_queue_counter_1 (*(volatile uint8_t*)0x00801685UL) /* Diagnostic queue counter 1 (3 refs) */
#define fault_code_display_counter (*(volatile uint8_t*)0x00801686UL) /* Fault code display iteration counter (9 refs) */
#define diagnostic_queue_counter_2 (*(volatile uint8_t*)0x00801687UL) /* Diagnostic queue counter 2 (3 refs) */
#define digit_display_sequencer_state (*(volatile uint8_t*)0x00801688UL) /* I/O control digit display sequencer state - acc... */
#define digit_display_sequencer_reserved (*(volatile uint8_t*)0x00801689UL) /* Digit display sequencer reserved byte */
#define io_control_mask_toggle (*(volatile uint16_t*)0x0080168AUL) /* I/O control mask toggle value (2 refs) */
#define active_fault_code_iterator (*(volatile uint8_t*)0x0080168CUL) /* Active fault code iterator index - accessed via... */
#define active_fault_code_iterator_reserved (*(volatile uint8_t*)0x0080168DUL) /* Active fault code iterator reserved byte */
#define io_control_mask_state_2 (*(volatile uint16_t*)0x0080168EUL) /* I/O control mask state machine value 2 (7 refs) */
#define io_control_mask_state_1 (*(volatile uint16_t*)0x00801692UL) /* I/O control mask state machine value 1 (4 refs) */
#define fault_lamp_blink_pattern_state (*(volatile uint16_t*)0x00801694UL) /* Fault lamp blink pattern generator state (2 refs) */
#define fault_lamp_blink_counter (*(volatile uint16_t*)0x00801696UL) /* Fault lamp blink pattern counter (13 refs) */
#define lamp_flash_timer_state (*(volatile uint16_t*)0x00801698UL) /* Lamp flash controller timer state (9 refs) */
#define wait_to_start_lamp_state (*(volatile uint8_t*)0x0080169AUL) /* Wait-to-start lamp blink pattern state - access... */
#define diagnostic_pending_flag (*(volatile uint8_t*)0x0080169BUL) /* Diagnostic pending code flag (0/1) (3 refs) */
#define lamp_flash_controller_state (*(volatile uint16_t*)0x0080169CUL) /* Periodic lamp flash controller state (11 refs) */
#define lamp_flash_cycle_counter (*(volatile uint16_t*)0x0080169EUL) /* Lamp flash controller cycle counter (4 refs) */
#define io_control_state_0 (*(volatile uint16_t*)0x008016A0UL) /* IO control state machine value 0 (5 refs) */
#define io_control_delay_timer (*(volatile uint16_t*)0x008016A2UL) /* IO control state machine delay timer (6 refs) */
#define io_control_state_1 (*(volatile uint16_t*)0x008016A4UL) /* IO control state machine value 1 (5 refs) */
#define io_control_state_2 (*(volatile uint16_t*)0x008016A6UL) /* IO control state machine value 2 (5 refs) */
#define io_control_state_3 (*(volatile uint16_t*)0x008016A8UL) /* IO control state machine value 3 (5 refs) */
#define io_control_state_4 (*(volatile uint16_t*)0x008016AAUL) /* IO control state machine value 4 (5 refs) */
#define io_control_state_5 (*(volatile uint16_t*)0x008016ACUL) /* IO control state machine value 5 (5 refs) */
#define io_control_state_6 (*(volatile uint16_t*)0x008016AEUL) /* IO control state machine value 6 (5 refs) */
#define eps_diagnostic_table_ptr (*(volatile uint32_t*)0x008016B0UL) /* EPS diagnostic calibration table pointer (1 ref) */
#define eps_diagnostic_rpm_snapshot (*(volatile uint32_t*)0x008016B4UL) /* EPS diagnostic RPM snapshot value (2 refs) */
#define cam_sync_derate_previous (*(volatile uint16_t*)0x008016B8UL) /* Cam sync derate threshold previous state (2 refs) */
#define dzg_pressure_lookup_table_arg (*(volatile uint16_t*)0x008016BAUL) /* DZG pressure threshold lookup table argument (i... */
#define eps_timing_table_1_ptr (*(volatile uint32_t*)0x008016BCUL) /* EPS timing table 1 pointer 0x808796 (initLookup... */
#define eps_timing_rpm_input_1 (*(volatile uint16_t*)0x008016C0UL) /* EPS timing RPM input 1 (epsTimingCalculationSlo... */
#define eps_timing_table_2_ptr (*(volatile uint32_t*)0x008016C2UL) /* EPS timing table 2 pointer 0x8087a4 (initLookup... */
#define eps_main_lookup_table_arg (*(volatile uint16_t*)0x008016C6UL) /* EPS main lost duration lookup table argument (i... */
#define eps_timing_table_3_ptr (*(volatile uint32_t*)0x008016C8UL) /* EPS timing table 3 pointer 0x808796 (initLookup... */
#define eps_timing_rpm_input_2 (*(volatile uint16_t*)0x008016CCUL) /* EPS timing RPM input 2 (epsTimingCalculationSlo... */
#define eps_timing_table_4_ptr (*(volatile uint32_t*)0x008016CEUL) /* EPS timing table 4 pointer 0x8087b2 (initLookup... */
#define eps_governor_table_ptr_2 (*(volatile uint32_t*)0x008016D2UL) /* EPS governor calibration table pointer 2 (2 refs) */
#define governor_pid_integral_fractional (*(volatile uint32_t*)0x008016D6UL) /* Governor PID integral fractional accumulator (4... */
#define eps_governor_table_ptr_1 (*(volatile uint32_t*)0x008016DAUL) /* EPS governor calibration table pointer 1 (2 refs) */
#define governor_pid_fuel_scaled (*(volatile uint32_t*)0x008016DEUL) /* Governor PID fuel scaled value shifted (governo... */
#define governor_fuel_pid_integral (*(volatile uint32_t*)0x008016E2UL) /* Governor fuel PID controller integral term */
#define governor_fuel_blend_output (*(volatile uint16_t*)0x008016E6UL) /* Governor fuel mode blend calculation output (6 ... */
#define governor_blend_table_1_type (*(volatile uint16_t*)0x008016E8UL) /* Governor blend table 1 interpolation type (2 refs) */
#define governor_blend_table_1_x_ptr (*(volatile uint32_t*)0x008016EAUL) /* Governor blend table 1 X-axis pointer (1 ref) */
#define governor_blend_table_1_input (*(volatile uint16_t*)0x008016EEUL) /* Governor blend table 1 input value (1 ref) */
#define intake_temp_table_1_type (*(volatile uint16_t*)0x008016F0UL) /* Intake temp table 1 interpolation type (1 ref) */
#define intake_temp_table_1_x_ptr (*(volatile uint32_t*)0x008016F2UL) /* Intake temp table 1 X-axis pointer (1 ref) */
#define intake_temp_table_1_count (*(volatile uint16_t*)0x008016F6UL) /* Intake temp table 1 element count (1 ref) */
#define intake_temp_table_1_y_ptr (*(volatile uint32_t*)0x008016F8UL) /* Intake temp table 1 Y-axis pointer (1 ref) */
#define governor_blend_table_2_type (*(volatile uint16_t*)0x008016FCUL) /* Governor blend table 2 interpolation type (2 refs) */
#define governor_blend_table_2_x_ptr (*(volatile uint32_t*)0x008016FEUL) /* Governor blend table 2 X-axis pointer (1 ref) */
#define governor_blend_table_2_input (*(volatile uint16_t*)0x00801702UL) /* Governor blend table 2 input value (1 ref) */
#define intake_temp_table_2_type (*(volatile uint16_t*)0x00801704UL) /* Intake temp table 2 interpolation type (1 ref) */
#define intake_temp_table_2_x_ptr (*(volatile uint32_t*)0x00801706UL) /* Intake temp table 2 X-axis pointer (1 ref) */
#define intake_temp_table_2_count (*(volatile uint16_t*)0x0080170AUL) /* Intake temp table 2 element count (1 ref) */
#define intake_temp_table_2_y_ptr (*(volatile uint32_t*)0x0080170CUL) /* Intake temp table 2 Y-axis pointer (1 ref) */
#define eps_rpm_tracking_state (*(volatile uint16_t*)0x00801710UL) /* EPS RPM tracking state 0=inactive 1=active (4 r... */
#define eps_previous_engine_rpm (*(volatile uint16_t*)0x00801712UL) /* EPS previous engine RPM for acceleration calc (... */
#define eps_acceleration_timer_1 (*(volatile uint16_t*)0x00801714UL) /* EPS acceleration monitor timer 1 (5 refs) */
#define eps_acceleration_timer_2 (*(volatile uint16_t*)0x00801716UL) /* EPS acceleration monitor timer 2 (6 refs) */
#define eps_diagnostic_mode_counter (*(volatile uint16_t*)0x00801718UL) /* EPS diagnostic mode delay counter (5 refs) */
#define derate_bit5_status_latch (*(volatile uint8_t*)0x0080171AUL) /* Derate status byte bit 5 latch (fuelTimingOffse... */
#define derate_bit6_status_latch (*(volatile uint8_t*)0x0080171BUL) /* Derate status byte bit 6 latch (fuelTimingOffse... */
#define fuel_timing_offset_state (*(volatile uint16_t*)0x0080171CUL) /* Fuel timing offset calculation state (12 refs) */
#define fuel_arbitrator_diag_timer (*(volatile uint16_t*)0x0080171EUL) /* Fuel arbitrator diagnostic mode timer (5 refs) */
#define qadc_circular_buffer_offset (*(volatile uint16_t*)0x00801720UL) /* QADC circular buffer write position (increments... */
#define qadc_collection_state_machine (*(volatile uint16_t*)0x00801722UL) /* QADC data collection state (0 1 2) with TPU syn... */
#define qadc_circular_buffer_dest_ptr (*(volatile uint32_t*)0x00801730UL) /* QADC circular buffer destination pointer (qadcD... */
#define qadc_data_collection_ready_flag (*(volatile uint8_t*)0x00801734UL) /* QADC data collection ready flag (qadcDataCollec... */
#define rpm_lookup_table_1_arg (*(volatile uint16_t*)0x00801736UL) /* RPM lookup table 1 argument (initRpmLookupTables) */
#define rpm_lookup_table_1_ptr (*(volatile uint32_t*)0x00801738UL) /* RPM lookup table 1 pointer 0x80883a (initRpmLoo... */
#define snapshot_engine_rpm (*(volatile uint16_t*)0x0080173CUL) /* Engine RPM snapshot value (2 refs) */
#define rpm_lookup_table_2_ptr (*(volatile uint32_t*)0x0080173EUL) /* RPM lookup table 2 pointer 0x80884e (initRpmLoo... */
#define rpm_lookup_table_2_arg (*(volatile uint16_t*)0x00801742UL) /* RPM lookup table 2 argument (initRpmLookupTables) */
#define rpm_lookup_table_3_ptr (*(volatile uint32_t*)0x00801744UL) /* RPM lookup table 3 pointer 0x808862 (initRpmLoo... */
#define snapshot_throttle_position (*(volatile uint16_t*)0x00801748UL) /* Throttle position snapshot value (2 refs) */
#define rpm_lookup_table_4_ptr (*(volatile uint32_t*)0x0080174AUL) /* RPM lookup table 4 pointer 0x808876 (initRpmLoo... */
#define crank_fuel_state_previous (*(volatile uint16_t*)0x0080174EUL) /* Crank fuel calculation state previous (2 refs) */
#define crank_fuel_state_delta_base (*(volatile uint16_t*)0x00801750UL) /* Crank fuel state delta calculation base (1 ref) */
#define crank_timing_state_previous (*(volatile uint16_t*)0x00801752UL) /* Crank timing state previous value (2 refs) */
#define crank_timing_state_delta_base (*(volatile uint16_t*)0x00801754UL) /* Crank timing state delta calculation base (1 ref) */
#define crank_state_reset_trigger (*(volatile uint16_t*)0x00801756UL) /* Crank state variables reset trigger (2 refs) */
#define crank_rpm_debounce_counter (*(volatile uint16_t*)0x00801758UL) /* Crank RPM non-zero debounce counter (2 refs) */
#define crank_sensor_fault_debounce_counter (*(volatile uint16_t*)0x0080175AUL) /* Crank sensor fault debounce counter (2 refs) */
#define scheduler_slot_index (*(volatile uint16_t*)0x0080175CUL) /* Scheduler slot index for task dispatch */
#define insite_ecu_id_response_buffer (*(volatile uint8_t*)0x00801760UL) /* INSITE ECU ID response buffer start (insiteEcuI... */
#define insite_version_response_buffer (*(volatile uint8_t*)0x00801776UL) /* INSITE version response buffer start (insiteVer... */
#define insite_version_buffer_start (*(volatile uint8_t*)0x00801777UL) /* INSITE version info buffer start (insiteVersion... */
#define data_buffer_copy_dest (*(volatile uint8_t*)0x00801794UL) /* Data buffer copy destination start (dataBufferC... */
#define fuel_demand_scale_table_ptr (*(volatile uint32_t*)0x00801898UL) /* Fuel demand scale factor table pointer 0x808916... */
#define fuel_demand_proportional_calc_result (*(volatile uint32_t*)0x0080189CUL) /* Fuel demand proportional calculation result (fu... */
#define oil_pressure_fuel_calculation (*(volatile uint16_t*)0x008018A0UL) /* Oil pressure protection fuel calculation value ... */
#define oil_pressure_fuel_calc_low_word (*(volatile uint16_t*)0x008018A2UL) /* Oil pressure fuel calculation low word (4 refs) */
#define fuel_demand_scale_table_2_ptr (*(volatile uint32_t*)0x008018A6UL) /* Fuel demand scale table 2 pointer 0x808928 (fue... */
#define can_mem_table_start_ptr_1 (*(volatile uint32_t*)0x008018AEUL) /* CAN memory table start pointer 1 (2 refs) */
#define can_mem_table_end_ptr_1 (*(volatile uint32_t*)0x008018B2UL) /* CAN memory table end pointer 1 (2 refs) */
#define can_mem_table_src_ptr_1 (*(volatile uint32_t*)0x008018B6UL) /* CAN memory table source pointer 1 (1 ref) */
#define can_mem_table_start_ptr_2 (*(volatile uint32_t*)0x008018BAUL) /* CAN memory table start pointer 2 (2 refs) */
#define can_mem_table_end_ptr_2 (*(volatile uint32_t*)0x008018BEUL) /* CAN memory table end pointer 2 (1 ref) */
#define can_mem_table_src_ptr_2 (*(volatile uint32_t*)0x008018C2UL) /* CAN memory table source pointer 2 (1 ref) */
#define can_memory_sync_pointer (*(volatile uint32_t*)0x008018C6UL) /* CAN message memory sync pointer */
#define can_memory_sync_src_ptr (*(volatile uint32_t*)0x008018CAUL) /* CAN memory sync source pointer (4 refs) */
#define can_memory_sync_dest_ptr (*(volatile uint32_t*)0x008018CEUL) /* CAN memory sync destination pointer (6 refs) */
#define can_memory_sync_dirty_flag (*(volatile uint16_t*)0x008018D2UL) /* CAN memory sync data dirty flag (4 refs) */
#define can_memory_sync_chunk_size (*(volatile uint16_t*)0x008018D4UL) /* CAN memory sync chunk size per cycle (2 refs) */
#define can_memory_sync_enable_prev (*(volatile uint16_t*)0x008018D6UL) /* CAN memory sync enable previous state (3 refs) */
#define diagnostic_service_dispatch_ptr (*(volatile uint32_t*)0x008018D8UL) /* Diagnostic service dispatch table pointer (diag... */
#define diagnostic_service_state_counter (*(volatile uint8_t*)0x00801998UL) /* Diagnostic service state counter (diagnosticSer... */
#define diagnostic_security_access_mode (*(volatile uint8_t*)0x0080199AUL) /* Diagnostic security access mode byte (4 refs) */
#define torque_control_message_flags (*(volatile uint8_t*)0x008019A2UL) /* Torque control message flags byte (3 refs) */
#define torque_control_status_byte_19a6 (*(volatile uint8_t*)0x008019A6UL) /* Torque control message status byte (5 refs) */
#define torque_control_mode_byte (*(volatile uint8_t*)0x008019AAUL) /* Torque control message byte 1 - mode flags (8 r... */
#define torque_control_priority_high_byte (*(volatile uint8_t*)0x008019ABUL) /* Torque control priority high byte (4 refs) */
#define torque_control_source_address (*(volatile uint8_t*)0x008019ACUL) /* Torque control message source address byte (4 r... */
#define torque_control_message_byte_4 (*(volatile uint8_t*)0x008019ADUL) /* Torque control message byte 4 (7 refs) */
#define torque_control_comparison_byte (*(volatile uint8_t*)0x008019B2UL) /* Torque control comparison byte value (3 refs) */
#define torque_control_priority_value (*(volatile uint16_t*)0x008019B4UL) /* Torque control message priority comparison valu... */
#define torque_control_priority_byte (*(volatile uint8_t*)0x008019B6UL) /* Torque control message priority byte 4 comparis... */
#define diag_service_pgn_dispatch_ptr (*(volatile uint32_t*)0x008019B8UL) /* Diagnostic service PGN dispatch pointer (diagno... */
#define can_transmission_active_count (*(volatile uint8_t*)0x00801A36UL) /* CAN transmission active count (canTransmissionC... */
#define retarder_mode_priority_level (*(volatile RETARDER_MODE_STATE*)0x00801A38UL) /* Previous mode priority for arbitration */
#define retarder_control_priority_prev (*(volatile uint8_t*)0x00801A39UL) /* Previous retarder control priority byte (retard... */
#define retarder_mode_control_byte_mirror (*(volatile uint8_t*)0x00801A3AUL) /* Mirror of control byte (bit0-1: mode bit4-5: pr... */
#define retarder_control_priority_byte (*(volatile uint8_t*)0x00801A3DUL) /* Retarder control mode priority byte from messag... */
#define retarder_mode1_threshold_table (*(volatile uint16_t*)0x00801A42UL) /* Retarder mode 1 threshold lookup table structure */
#define retarder_mode1_data_ptr (*(volatile uint32_t*)0x00801A44UL) /* Pointer to retarder mode 1 threshold data */
#define retarder_mode1_rpm_input (*(volatile uint16_t*)0x00801A48UL) /* Retarder mode 1 threshold RPM input (retarderMo... */
#define retarder_mode1_output_ptr (*(volatile uint32_t*)0x00801A4AUL) /* Pointer to retarder mode 1 output buffer */
#define retarder_mode2_threshold_table (*(volatile uint16_t*)0x00801A4EUL) /* Retarder mode 2 threshold lookup table structure */
#define retarder_mode2_data_ptr (*(volatile uint32_t*)0x00801A50UL) /* Pointer to retarder mode 2 threshold data */
#define retarder_mode2_rpm_input (*(volatile uint16_t*)0x00801A54UL) /* Retarder mode 2 threshold RPM input (retarderMo... */
#define retarder_mode2_output_ptr (*(volatile uint32_t*)0x00801A56UL) /* Pointer to retarder mode 2 output buffer */
#define retarder_mode3_threshold_table (*(volatile uint16_t*)0x00801A5AUL) /* Retarder mode 3 threshold lookup table structure */
#define retarder_mode3_data_ptr (*(volatile uint32_t*)0x00801A5CUL) /* Pointer to retarder mode 3 threshold data */
#define retarder_mode3_rpm_input (*(volatile uint16_t*)0x00801A60UL) /* Retarder mode 3 threshold RPM input (retarderMo... */
#define retarder_mode3_output_ptr (*(volatile uint32_t*)0x00801A62UL) /* Pointer to retarder mode 3 output buffer */
#define retarder_mode_timeout_value (*(volatile uint16_t*)0x00801A66UL) /* Retarder control mode timeout value (5 refs) */
#define fuel_statistics_fault_counter (*(volatile uint16_t*)0x00801A68UL) /* Fuel statistics fault counter (4 refs) */
#define fuel_economy_sample_1 (*(volatile uint16_t*)0x00801A6AUL) /* Fuel economy sample value 1 (3 refs) */
#define fuel_economy_sample_2 (*(volatile uint16_t*)0x00801A6CUL) /* Fuel economy sample value 2 (3 refs) */
#define fuel_economy_sample_3 (*(volatile uint16_t*)0x00801A6EUL) /* Fuel economy sample value 3 (2 refs) */
#define vp44_fuel_demand_previous (*(volatile uint32_t*)0x00801A70UL) /* VP44 fuel demand previous value for delta (2 refs) */
#define non_idle_time_counter (*(volatile uint16_t*)0x00801A74UL) /* Non-idle operating time counter (4 refs) */
#define high_load_idle_cooldown_timer (*(volatile uint16_t*)0x00801A78UL) /* High load idle cooldown timer (5 refs) */
#define high_speed_idle_cooldown_timer (*(volatile uint16_t*)0x00801A7AUL) /* High speed idle cooldown timer (5 refs) */
#define high_temp_idle_cooldown_timer (*(volatile uint16_t*)0x00801A7CUL) /* High temperature idle cooldown timer (5 refs) */
#define engine_mode_previous_state_1a7e (*(volatile uint8_t*)0x00801A7EUL) /* Engine operating mode previous state (3 refs) */
#define rpm_averaging_accumulator_2 (*(volatile uint16_t*)0x00801A80UL) /* RPM averaging accumulator 2 (4 refs) */
#define rpm_averaging_accumulator_1 (*(volatile uint16_t*)0x00801A82UL) /* RPM averaging accumulator 1 (4 refs) */
#define rpm_histogram_sample_divider (*(volatile uint8_t*)0x00801A84UL) /* RPM histogram sample divider counter (3 refs) */
#define fuel_economy_sample_toggle (*(volatile uint8_t*)0x00801A85UL) /* Fuel economy sample toggle flag (3 refs) */
#define diagnostic_can_response_header (*(volatile uint32_t*)0x00801A86UL) /* Diagnostic CAN response header buffer (diagnost... */
#define diag_can_response_pgn (*(volatile uint16_t*)0x00801A88UL) /* Diagnostic CAN response PGN bytes (diagnosticCa... */
#define can_buffer_setup1_size (*(volatile uint8_t*)0x00801A8AUL) /* CAN buffer 1 message size (set to 8 bytes) */
#define can_buffer_setup1_data_ptr (*(volatile uint32_t*)0x00801A8CUL) /* CAN buffer 1 data pointer to 0x801a94 */
#define can_buffer_setup1_unused_ptr (*(volatile uint32_t*)0x00801A90UL) /* CAN buffer 1 unused/padding pointer to 0x801a9c */
#define can_buffer_setup1_data (*(volatile uint8_t*)0x00801A94UL) /* CAN buffer 1 data array (8 bytes with 0xFF padd... */
#define can_buffer_1_reserved_0 (*(volatile uint8_t*)0x00801A95UL) /* CAN buffer 1 reserved byte 0 0xff (canBufferSet... */
#define can_buffer_1_reserved_1 (*(volatile uint8_t*)0x00801A96UL) /* CAN buffer 1 reserved byte 1 0xff (canBufferSet... */
#define can_buffer_1_reserved_2 (*(volatile uint8_t*)0x00801A97UL) /* CAN buffer 1 reserved byte 2 0xff (canBufferSet... */
#define can_buffer_1_reserved_3 (*(volatile uint8_t*)0x00801A98UL) /* CAN buffer 1 reserved byte 3 0xff (canBufferSet... */
#define diag_can_response_data_0 (*(volatile uint8_t*)0x00801A99UL) /* Diagnostic CAN response data byte 0 (diagnostic... */
#define diag_can_response_data_1 (*(volatile uint8_t*)0x00801A9AUL) /* Diagnostic CAN response data byte 1 (diagnostic... */
#define diag_can_response_data_2 (*(volatile uint8_t*)0x00801A9BUL) /* Diagnostic CAN response data byte 2 (diagnostic... */
#define ambient_conditions_msg_header (*(volatile uint32_t*)0x00801A9EUL) /* J1939 ambient conditions message header (PGN 65... */
#define ambient_conditions_msg_length (*(volatile uint16_t*)0x00801AA2UL) /* J1939 ambient conditions message length (8 bytes) */
#define ambient_conditions_data_ptr (*(volatile uint32_t*)0x00801AA4UL) /* Pointer to ambient conditions data buffer */
#define ambient_conditions_unused_ptr (*(volatile uint32_t*)0x00801AA8UL) /* Unused pointer for ambient conditions message s... */
#define ambient_conditions_data_start (*(volatile uint8_t*)0x00801AACUL) /* Start of ambient conditions data buffer */
#define ambient_barometric_pressure (*(volatile uint8_t*)0x00801AADUL) /* Barometric pressure data (0xFF = not available) */
#define ambient_cab_interior_temp (*(volatile uint8_t*)0x00801AAEUL) /* Cab interior temperature (0xFF = not available) */
#define ambient_air_temp (*(volatile uint8_t*)0x00801AAFUL) /* Ambient air temperature (0xFF = not available) */
#define engine_air_inlet_temp (*(volatile uint8_t*)0x00801AB0UL) /* Engine air inlet temperature (0xFF = not availa... */
#define road_surface_temp (*(volatile uint8_t*)0x00801AB1UL) /* Road surface temperature (0xFF = not available) */
#define ambient_conditions_reserved (*(volatile uint16_t*)0x00801AB2UL) /* Reserved bytes for ambient conditions (0xFFFF) */
#define ambient_conditions_buffer_end (*(volatile uint8_t*)0x00801AB4UL) /* End marker for ambient conditions data buffer */
#define j1939_pgn_65265_header (*(volatile uint32_t*)0x00801AB6UL) /* J1939 PGN 65265 message header (engine data) */
#define j1939_pgn_65265_size (*(volatile uint8_t*)0x00801ABAUL) /* J1939 PGN 65265 message size (7 bytes) */
#define j1939_pgn_65265_data_ptr (*(volatile uint32_t*)0x00801ABCUL) /* J1939 PGN 65265 data pointer */
#define j1939_pgn_65265_unused_ptr (*(volatile uint32_t*)0x00801AC0UL) /* J1939 PGN 65265 unused pointer */
#define j1939_pgn_65265_data_byte1 (*(volatile uint8_t*)0x00801AC4UL) /* J1939 PGN 65265 first data byte (0xF3) */
#define ambient_temp_calc_low (*(volatile uint8_t*)0x00801AC5UL) /* Calculated ambient temperature low byte */
#define ambient_temp_calc_high (*(volatile uint8_t*)0x00801AC6UL) /* Calculated ambient temperature high byte */
#define ambient_sensor_status1 (*(volatile uint8_t*)0x00801AC7UL) /* Ambient sensor status flags byte 1 */
#define ambient_sensor_status2 (*(volatile uint8_t*)0x00801AC8UL) /* Ambient sensor status flags byte 2 */
#define ambient_temp_processed (*(volatile uint8_t*)0x00801AC9UL) /* Processed ambient temperature value */
#define ambient_status_final (*(volatile uint8_t*)0x00801ACAUL) /* Final ambient conditions status byte */
#define j1939_pgn65265_reserved_byte (*(volatile uint8_t*)0x00801ACBUL) /* J1939 PGN 65265 reserved byte 0xff (j1939Messag... */
#define j1939_message_buffer_pgn65259 (*(volatile uint32_t*)0x00801ACEUL) /* J1939 CAN message buffer PGN 65259/0xFEEB (4 refs) */
#define j1939_pgn65259_msg_size (*(volatile uint16_t*)0x00801AD2UL) /* J1939 PGN 65259 message size 0x1c (engineSerial... */
#define j1939_pgn65259_data_ptr (*(volatile uint32_t*)0x00801AD4UL) /* J1939 PGN 65259 data pointer (engineSerialNumbe... */
#define j1939_pgn65259_unused_ptr (*(volatile uint32_t*)0x00801AD8UL) /* J1939 PGN 65259 unused pointer 0x801af8 (engine... */
#define engine_serial_number_buffer (*(volatile uint8_t*)0x00801ADCUL) /* Engine serial number data buffer start (engineS... */
#define engine_serial_separator_1 (*(volatile uint8_t*)0x00801AE1UL) /* Engine serial number separator 0x2a (engineSeri... */
#define engine_serial_part2_start (*(volatile uint8_t*)0x00801AE2UL) /* Engine serial number part 2 start (engineSerial... */
#define engine_serial_separator_2 (*(volatile uint8_t*)0x00801AF3UL) /* Engine serial number separator 0x2a (engineSeri... */
#define engine_serial_part3_start (*(volatile uint8_t*)0x00801AF4UL) /* Engine serial number part 3 start (engineSerial... */
#define j1939_message_buffer_pgn65226 (*(volatile uint32_t*)0x00801AFAUL) /* J1939 CAN message buffer PGN 65226/0xFECA (4 refs) */
#define diagnostic_pending_response_offset (*(volatile uint16_t*)0x00801AFEUL) /* Diagnostic pending code response offset (4 refs) */
#define j1939_pgn65226_data_ptr (*(volatile uint32_t*)0x00801B00UL) /* J1939 PGN 65226 data pointer (engineCoolantPGN_... */
#define active_dtc_list_header_ptr (*(volatile uint32_t*)0x00801B04UL) /* Active DTC list header pointer (activeDtcListBu... */
#define j1939_transport_sequence_counter (*(volatile uint16_t*)0x00801B08UL) /* J1939 transport protocol sequence counter (3 refs) */
#define active_dtc_list_data_buffer (*(volatile uint32_t*)0x00801B0AUL) /* Active DTC list data buffer (activeDtcListBuilder) */
#define engine_coolant_pgn65226_status (*(volatile uint8_t*)0x00801B0DUL) /* Engine coolant PGN 65226 status byte (engineCoo... */
#define j1939_transport_protocol_header (*(volatile uint8_t*)0x008021FEUL) /* J1939 transport protocol message header (3 refs) */
#define j1939_message_buffer_pgn65227 (*(volatile uint32_t*)0x00802200UL) /* J1939 CAN message buffer PGN 65227/0xFECB (4 refs) */
#define throttle_fault_handler_state (*(volatile uint16_t*)0x00802204UL) /* Throttle fault handler state value (5 refs) */
#define dm2_pgn65227_data_ptr (*(volatile uint32_t*)0x00802206UL) /* DM2 PGN 65227 data pointer (diagnosticDM2PGN_65... */
#define dm2_pgn65227_unused_ptr (*(volatile uint32_t*)0x0080220AUL) /* DM2 PGN 65227 unused pointer (diagnosticDM2PGN_... */
#define dm2_pgn65227_data_byte (*(volatile uint8_t*)0x0080220EUL) /* DM2 PGN 65227 data byte (previousDtcListBuilder) */
#define dm2_pgn65227_reserved (*(volatile uint8_t*)0x0080220FUL) /* DM2 PGN 65227 reserved 0xff (diagnosticDM2PGN_6... */
#define dm2_pgn65227_data_buffer (*(volatile uint32_t*)0x00802210UL) /* DM2 PGN 65227 data buffer (previousDtcListBuilder) */
#define dm2_pgn65227_control_byte (*(volatile uint8_t*)0x00802213UL) /* DM2 PGN 65227 control byte (diagnosticDM2PGN_65... */
#define dm2_pgn65227_unused_byte (*(volatile uint8_t*)0x00802904UL) /* DM2 PGN 65227 unused byte (previousDtcListBuilder) */
#define j1939_message_buffer_pgn65229 (*(volatile uint32_t*)0x00802906UL) /* J1939 CAN message buffer PGN 65229/0xFECD (4 refs) */
#define diagnostic_dtc_response_length (*(volatile uint16_t*)0x0080290AUL) /* Diagnostic DTC response message length (4 refs) */
#define dm4_pgn65229_data_ptr (*(volatile uint32_t*)0x0080290CUL) /* DM4 PGN 65229 data pointer (diagnosticDM4PGN_65... */
#define dm4_pgn65229_unused_ptr (*(volatile uint32_t*)0x00802910UL) /* DM4 PGN 65229 unused pointer (diagnosticDM4PGN_... */
#define j1939_multiframe_data_buffer (*(volatile uint32_t*)0x00802914UL) /* J1939 multiframe data buffer start (4 refs) */
#define dtc_response_spn_high_byte (*(volatile uint8_t*)0x00802918UL) /* DTC response SPN high byte (buildCanMessage) */
#define dtc_response_spn_mid_byte (*(volatile uint8_t*)0x00802919UL) /* DTC response SPN mid byte 0xff (buildCanMessage) */
#define dtc_response_spn_low_byte (*(volatile uint8_t*)0x0080291AUL) /* DTC response SPN low byte 0xff (buildCanMessage) */
#define dtc_response_fmi_byte (*(volatile uint8_t*)0x0080291CUL) /* DTC response FMI byte 0xff (buildCanMessage) */
#define dm4_pgn65229_status_byte (*(volatile uint8_t*)0x00802FECUL) /* DM4 PGN 65229 status byte (buildCanMessage/diag... */
#define j1939_message_buffer_pgn65230 (*(volatile uint32_t*)0x00802FEEUL) /* J1939 CAN message buffer PGN 65230/0xFECE (4 refs) */
#define dm5_pgn65230_msg_size (*(volatile uint16_t*)0x00802FF2UL) /* DM5 PGN 65230 message size 8 (diagnosticDM5PGN_... */
#define dm5_pgn65230_data_ptr (*(volatile uint32_t*)0x00802FF4UL) /* DM5 PGN 65230 data pointer (diagnosticDM5PGN_65... */
#define dm5_pgn65230_unused_ptr (*(volatile uint32_t*)0x00802FF8UL) /* DM5 PGN 65230 unused pointer 0x803004 (diagnost... */
#define dm5_pgn65230_pending_code_count (*(volatile uint8_t*)0x00802FFCUL) /* DM5 PGN 65230 pending code count (diagnosticDM5... */
#define dm5_active_code_count (*(volatile uint8_t*)0x00802FFDUL) /* DM5 active diagnostic code count (diagnosticDM5... */
#define dm5_obd_compliance (*(volatile uint8_t*)0x00802FFEUL) /* DM5 OBD compliance byte (diagnosticDM5DataBuilder) */
#define dm5_obd_compliance_2 (*(volatile uint8_t*)0x00802FFFUL) /* DM5 OBD compliance byte 2 (diagnosticDM5DataBui... */
#define dm5_status_flags_swapped (*(volatile uint16_t*)0x00803000UL) /* DM5 status flags byte-swapped (diagnosticDM5Dat... */
#define dm5_status_flags_2_swapped (*(volatile uint16_t*)0x00803002UL) /* DM5 status flags 2 byte-swapped (diagnosticDM5D... */
#define j1939_message_buffer_pgn65232 (*(volatile uint32_t*)0x00803006UL) /* J1939 CAN message buffer PGN 65232/0xFED0 (4 refs) */
#define dm8_pgn65232_msg_size (*(volatile uint16_t*)0x0080300AUL) /* DM8 PGN 65232 message size 8 (diagnosticDM8PGN_... */
#define dm8_pgn65232_data_ptr (*(volatile uint32_t*)0x0080300CUL) /* DM8 PGN 65232 data pointer (diagnosticDM8PGN_65... */
#define dm8_pgn65232_unused_ptr (*(volatile uint32_t*)0x00803010UL) /* DM8 PGN 65232 unused pointer 0x80301c (diagnost... */
#define dm8_pgn65232_data_byte (*(volatile uint8_t*)0x00803014UL) /* DM8 PGN 65232 data byte (diagnosticByteResponse... */
#define dm8_reserved_byte (*(volatile uint8_t*)0x00803015UL) /* DM8 reserved byte 0xff (diagnosticDM8PGN_65232_... */
#define diagnostic_byte_response_word (*(volatile uint16_t*)0x00803016UL) /* Diagnostic byte response word value (diagnostic... */
#define dm8_reserved_word_1 (*(volatile uint16_t*)0x00803018UL) /* DM8 reserved word 1 0xffff (diagnosticDM8PGN_65... */
#define dm8_reserved_word_2 (*(volatile uint16_t*)0x0080301AUL) /* DM8 reserved word 2 0xffff (diagnosticDM8PGN_65... */
#define j1939_message_buffer_pgn65234 (*(volatile uint32_t*)0x0080301EUL) /* J1939 CAN message buffer PGN 65234/0xFED2 (3 refs) */
#define dm11_pgn65234_data_ptr (*(volatile uint32_t*)0x00803022UL) /* DM11 PGN 65234 data pointer (diagnosticDM11PGN_... */
#define dm11_pgn65234_unused_ptr (*(volatile uint32_t*)0x00803024UL) /* DM11 PGN 65234 unused pointer (diagnosticDM11PG... */
#define dm11_pgn65234_data_buffer_ptr (*(volatile uint32_t*)0x00803028UL) /* DM11 PGN 65234 data buffer pointer 0x803034 (di... */
#define dm11_pgn65234_unused_buffer (*(volatile uint32_t*)0x0080302CUL) /* DM11 PGN 65234 unused buffer address (diagnosti... */
#define j1939_tx_msg_buffer (*(volatile uint8_t*)0x00803036UL) /* J1939 transmission message buffer with data and... */
#define j1939_vp44_fuel_high (*(volatile uint8_t*)0x00803037UL) /* J1939/VP44 fuel amount high byte (DAT_00803037 ... */
#define j1939_vp44_fuel_low (*(volatile uint8_t*)0x00803038UL) /* J1939/VP44 fuel amount low byte (DAT_00803038 i... */
#define j1939_vp44_rpm_low (*(volatile uint8_t*)0x00803039UL) /* J1939/VP44 RPM low byte (DAT_00803039 in buildP... */
#define j1939_vp44_rpm_high (*(volatile uint8_t*)0x0080303AUL) /* J1939/VP44 RPM high byte (DAT_0080303A in build... */
#define vp44_cmd_msg_buffer (*(volatile uint8_t*)0x0080303EUL) /* VP44 0x100 command message header */
#define vp44_fuel_amount_high (*(volatile uint8_t*)0x0080303FUL) /* VP44 fuel amount high byte (param_table_aux>>8 ... */
#define vp44_fuel_amount_low (*(volatile uint8_t*)0x00803040UL) /* VP44 fuel amount low byte (param_table_main>>8 ... */
#define vp44_timing_byte3 (*(volatile uint8_t*)0x00803041UL) /* VP44 timing advance data byte 3 */
#define vp44_timing_byte4 (*(volatile uint8_t*)0x00803042UL) /* VP44 timing advance data byte 4 */
#define vp44_timing_byte5 (*(volatile uint8_t*)0x00803043UL) /* VP44 timing advance data byte 5 */
#define vp44_timing_byte6 (*(volatile uint8_t*)0x00803044UL) /* VP44 timing advance data byte 6 */
#define vp44_rpm_low (*(volatile uint8_t*)0x00803045UL) /* VP44 RPM×4 low byte (current_engine_rpm & 0xFF) */
#define vp44_rpm_high (*(volatile uint8_t*)0x00803046UL) /* VP44 RPM×4 high byte (current_engine_rpm >> 8) */
#define vp44_cmd_0x100_data_ptr (*(volatile uint32_t*)0x00803048UL) /* VP44 command 0x100 data pointer (vp44Command0x1... */
#define diagnostic_status_data (*(volatile uint8_t*)0x0080304EUL) /* Diagnostic status data buffer (0xF0/F4/F8 based... */
#define diagnostic_load_data_byte (*(volatile uint8_t*)0x0080304FUL) /* Diagnostic message load data byte - scaled from... */
#define diagnostic_param_ctrl_byte (*(volatile uint8_t*)0x00803050UL) /* Diagnostic message parameter control byte - par... */
#define can_param_msg_buf_2 (*(volatile uint8_t*)0x00803056UL) /* CAN parameter message buffer 2 (secondary params) */
#define dm983_proprietary_msg_size (*(volatile uint8_t*)0x0080305AUL) /* DM983 proprietary message size 3 (cumminsPropri... */
#define dm983_diagnostic_status_ptr (*(volatile uint32_t*)0x0080305CUL) /* DM983 diagnostic status buffer pointer (cummins... */
#define dm983_diagnostic_unused_ptr (*(volatile uint32_t*)0x00803060UL) /* DM983 diagnostic unused buffer pointer (cummins... */
#define diagnostic_buffer_unused (*(volatile uint8_t*)0x00803064UL) /* Diagnostic message unused data buffer pointer t... */
#define can_param_msg_buf_1 (*(volatile uint8_t*)0x00803066UL) /* CAN parameter message buffer 1 (config data) */
#define config_param_can_byte_0 (*(volatile uint8_t*)0x00803067UL) /* Config param CAN message byte 0 (configParamCan... */
#define config_param_can_byte_1 (*(volatile uint8_t*)0x00803068UL) /* Config param CAN message byte 1 (configParamCan... */
#define config_param_can_byte_2 (*(volatile uint8_t*)0x00803069UL) /* Config param CAN message byte 2 (configParamCan... */
#define can_param_msg_buf_3 (*(volatile uint8_t*)0x0080306EUL) /* CAN parameter message buffer 3 (config + limits) */
#define secondary_param_pgn65247_size (*(volatile uint8_t*)0x00803072UL) /* Secondary param PGN 65247 message size 4 (secon... */
#define secondary_param_pgn65247_data_ptr (*(volatile uint32_t*)0x00803074UL) /* Secondary param PGN 65247 data buffer pointer (... */
#define secondary_param_pgn65247_unused_ptr (*(volatile uint32_t*)0x00803078UL) /* Secondary param PGN 65247 unused buffer pointer... */
#define extended_diag_pgn65251_data_start (*(volatile uint8_t*)0x0080307EUL) /* Extended diagnostic PGN 65251 data buffer start... */
#define fuel_param_gov_rpm_error_high (*(volatile uint8_t*)0x0080307FUL) /* Fuel param governor RPM error high byte (fuelPa... */
#define fuel_param_calc_param_offset (*(volatile uint8_t*)0x00803080UL) /* Fuel param calculated param offset (fuelParamet... */
#define fuel_param_offset_blend_low (*(volatile uint8_t*)0x00803081UL) /* Fuel param offset blend low byte (fuelParameter... */
#define fuel_param_offset_blend_high (*(volatile uint8_t*)0x00803082UL) /* Fuel param offset blend high byte (fuelParamete... */
#define fuel_param_calculated_2_offset (*(volatile uint8_t*)0x00803083UL) /* Fuel param calculated 2 offset (fuelParameterCa... */
#define fuel_param_table_blend_1_low (*(volatile uint8_t*)0x00803084UL) /* Fuel param table blend 1 low byte (fuelParamete... */
#define fuel_param_table_blend_1_high (*(volatile uint8_t*)0x00803085UL) /* Fuel param table blend 1 high byte (fuelParamet... */
#define fuel_param_calculated_3_offset (*(volatile uint8_t*)0x00803086UL) /* Fuel param calculated 3 offset (fuelParameterCa... */
#define fuel_param_table_blend_2_low (*(volatile uint8_t*)0x00803087UL) /* Fuel param table blend 2 low byte (fuelParamete... */
#define fuel_param_table_blend_2_high (*(volatile uint8_t*)0x00803088UL) /* Fuel param table blend 2 high byte (fuelParamet... */
#define fuel_param_calculated_4_offset (*(volatile uint8_t*)0x00803089UL) /* Fuel param calculated 4 offset (fuelParameterCa... */
#define fuel_param_mode_offset_low (*(volatile uint8_t*)0x0080308AUL) /* Fuel param mode selection offset low byte (fuel... */
#define fuel_param_mode_offset_high (*(volatile uint8_t*)0x0080308BUL) /* Fuel param mode selection offset high byte (fue... */
#define fuel_param_result_buffer_offset (*(volatile uint8_t*)0x0080308CUL) /* Fuel param result buffer offset (fuelParameterC... */
#define fuel_param_limit_calc_low (*(volatile uint8_t*)0x0080308DUL) /* Fuel param limit calc low byte (fuelParameterCa... */
#define fuel_param_limit_calc_high (*(volatile uint8_t*)0x0080308EUL) /* Fuel param limit calc high byte (fuelParameterC... */
#define fuel_param_reserved_ff_0 (*(volatile uint8_t*)0x0080308FUL) /* Fuel param reserved 0xff byte 0 (extendedDiagPG... */
#define fuel_param_reserved_ff_1 (*(volatile uint8_t*)0x00803090UL) /* Fuel param reserved 0xff byte 1 (extendedDiagPG... */
#define fuel_param_arbitrator_low (*(volatile uint8_t*)0x00803091UL) /* Fuel param arbitrator output low byte (fuelPara... */
#define fuel_param_arbitrator_high (*(volatile uint8_t*)0x00803092UL) /* Fuel param arbitrator output high byte (fuelPar... */
#define fuel_param_diag_mode_low (*(volatile uint8_t*)0x00803093UL) /* Fuel param diagnostic mode low byte (fuelParame... */
#define fuel_param_diag_mode_high (*(volatile uint8_t*)0x00803094UL) /* Fuel param diagnostic mode high byte (fuelParam... */
#define fuel_param_arb_status_scaled (*(volatile uint8_t*)0x00803095UL) /* Fuel param arbitrator status scaled /10 (fuelPa... */
#define fuel_param_timing_offset_scaled (*(volatile uint8_t*)0x00803096UL) /* Fuel param timing offset min scaled /80 (fuelPa... */
#define extended_diag_torque_limit_byte (*(volatile uint8_t*)0x00803097UL) /* Extended diagnostic torque limit change byte (f... */
#define fuel_param_reserved_7d (*(volatile uint8_t*)0x00803098UL) /* Fuel param reserved 0x7d byte (extendedDiagPGN_... */
#define fuel_param_max_calc_offset (*(volatile uint8_t*)0x00803099UL) /* Fuel param max calculated offset (fuelParameter... */
#define j1939_message_buffer_pgn65251 (*(volatile uint32_t*)0x0080309AUL) /* J1939 CAN message buffer PGN 65251/0xFEE3 (4 refs) */
#define extended_diag_pgn65251_size (*(volatile uint8_t*)0x0080309EUL) /* Extended diag PGN 65251 message size 28 (extend... */
#define extended_diag_pgn65251_data_ptr (*(volatile uint32_t*)0x008030A0UL) /* Extended diag PGN 65251 data pointer 0x80307e (... */
#define extended_diag_pgn65251_unused_ptr (*(volatile uint32_t*)0x008030A4UL) /* Extended diag PGN 65251 unused pointer 0x8030a8... */
#define extended_diag_pgn65251_status (*(volatile uint8_t*)0x008030A8UL) /* Extended diagnostic PGN 65251 status byte (fuel... */
#define engine_fluid_level_msg_header (*(volatile uint32_t*)0x008030AAUL) /* J1939 engine fluid level/pressure message heade... */
#define engine_fluid_level_msg_length (*(volatile uint16_t*)0x008030AEUL) /* J1939 engine fluid level/pressure message lengt... */
#define engine_fluid_level_data_ptr (*(volatile uint32_t*)0x008030B0UL) /* Pointer to engine fluid level/pressure data buffer */
#define engine_fluid_level_unused_ptr (*(volatile uint32_t*)0x008030B4UL) /* Unused pointer for engine fluid level message s... */
#define fuel_delivery_pressure (*(volatile uint8_t*)0x008030B8UL) /* Fuel delivery pressure (0xFF = not available) */
#define engine_oil_pressure (*(volatile uint8_t*)0x008030B9UL) /* Engine oil pressure (0xFF = not available) */
#define crankcase_pressure (*(volatile uint8_t*)0x008030BAUL) /* Crankcase pressure (0xFF = not available) */
#define engine_oil_level (*(volatile uint8_t*)0x008030BBUL) /* Engine oil level (0xFF = not available) */
#define coolant_pressure (*(volatile uint16_t*)0x008030BCUL) /* Coolant pressure (0xFFFF = not available) */
#define coolant_level (*(volatile uint8_t*)0x008030BEUL) /* Coolant level (0xFF = not available) */
#define extended_crankcase_pressure (*(volatile uint8_t*)0x008030BFUL) /* Extended crankcase blow-by pressure (0xFF = not... */
#define engine_fluid_level_buffer_end (*(volatile uint8_t*)0x008030C0UL) /* End marker for engine fluid level data buffer */
#define j1939_message_buffer_pgn65262 (*(volatile uint32_t*)0x008030C2UL) /* J1939 CAN message buffer PGN 65262/0xFEEE (4 refs) */
#define engine_temp_pgn65262_size (*(volatile uint8_t*)0x008030C6UL) /* Engine temperature PGN 65262 message size 8 (en... */
#define engine_temp_pgn65262_data_ptr (*(volatile uint32_t*)0x008030C8UL) /* Engine temperature PGN 65262 data pointer (engi... */
#define engine_temp_pgn65262_unused_ptr (*(volatile uint32_t*)0x008030CCUL) /* Engine temperature PGN 65262 unused pointer 0x8... */
#define engine_temp_processed1 (*(volatile uint8_t*)0x008030D0UL) /* Processed engine temperature value 1 */
#define engine_temp_processed2 (*(volatile uint8_t*)0x008030D1UL) /* Processed engine temperature value 2 */
#define engine_fluid_calc_result (*(volatile uint16_t*)0x008030D2UL) /* Engine fluid calculation result */
#define engine_temp_reserved_ffff (*(volatile uint16_t*)0x008030D4UL) /* Engine temperature reserved 0xffff (engineTempe... */
#define engine_temp_reserved_ff_0 (*(volatile uint8_t*)0x008030D6UL) /* Engine temperature reserved 0xff byte 0 (engine... */
#define engine_temp_reserved_ff_1 (*(volatile uint8_t*)0x008030D7UL) /* Engine temperature reserved 0xff byte 1 (engine... */
#define torque_control_status_byte_30da (*(volatile uint8_t*)0x008030DAUL) /* Torque control status and mode flags for propri... */
#define torque_control_data_byte2 (*(volatile uint8_t*)0x008030DBUL) /* Second byte of torque control data for propriet... */
#define cummins_tsc_msg_header (*(volatile uint32_t*)0x008030E2UL) /* Cummins proprietary TSC message header (PGN 157... */
#define cummins_tsc_msg_length (*(volatile uint16_t*)0x008030E6UL) /* Cummins proprietary TSC message length (2 bytes) */
#define cummins_tsc_data_ptr (*(volatile uint32_t*)0x008030E8UL) /* Pointer to torque control data buffer */
#define cummins_tsc_unused_ptr (*(volatile uint32_t*)0x008030ECUL) /* Unused pointer for Cummins TSC message structure */
#define torque_control_buffer_end (*(volatile uint8_t*)0x008030F0UL) /* End marker for torque control data buffer */
#define j1939_message_buffer_pgn65257 (*(volatile uint32_t*)0x008030F2UL) /* J1939 CAN message buffer PGN 65257/0xFEE9 (4 refs) */
#define intake_exhaust_pgn65257_size (*(volatile uint8_t*)0x008030F6UL) /* Intake/exhaust conditions PGN 65257 message siz... */
#define intake_exhaust_pgn65257_data_ptr (*(volatile uint32_t*)0x008030F8UL) /* Intake/exhaust conditions PGN 65257 data pointe... */
#define intake_exhaust_pgn65257_unused_ptr (*(volatile uint32_t*)0x008030FCUL) /* Intake/exhaust conditions PGN 65257 unused poin... */
#define intake_exhaust_clutch_stat_dword (*(volatile uint32_t*)0x00803100UL) /* Intake exhaust conditions clutch stat dword (in... */
#define intake_exhaust_fuel_stat_dword (*(volatile uint32_t*)0x00803104UL) /* Intake/exhaust fuel statistics dword (intakeExh... */
#define fuel_economy_data_byte1 (*(volatile uint8_t*)0x0080310CUL) /* First byte of fuel economy calculation result */
#define fuel_economy_data_byte2 (*(volatile uint8_t*)0x0080310DUL) /* Second byte of fuel economy calculation result */
#define fuel_economy_data_byte3 (*(volatile uint8_t*)0x0080310EUL) /* Third byte of fuel economy calculation result */
#define fuel_economy_data_byte4 (*(volatile uint8_t*)0x0080310FUL) /* Fourth byte of fuel economy calculation result */
#define fuel_economy_data_byte5 (*(volatile uint8_t*)0x00803110UL) /* Fifth byte of fuel economy calculation result */
#define fuel_economy_data_byte6 (*(volatile uint8_t*)0x00803111UL) /* Sixth byte of fuel economy calculation result */
#define fuel_economy_msg_header (*(volatile uint32_t*)0x00803114UL) /* J1939 fuel economy message header (PGN 65266) */
#define fuel_economy_msg_length (*(volatile uint16_t*)0x00803118UL) /* J1939 fuel economy message length (6 bytes) */
#define fuel_economy_data_ptr (*(volatile uint32_t*)0x0080311AUL) /* Pointer to fuel economy data buffer */
#define fuel_economy_unused_ptr (*(volatile uint32_t*)0x0080311EUL) /* Unused pointer for fuel economy message structure */
#define fuel_economy_buffer_end (*(volatile uint8_t*)0x00803122UL) /* End marker for fuel economy data buffer */
#define j1939_message_buffer_pgn65244 (*(volatile uint32_t*)0x00803128UL) /* J1939 CAN message buffer PGN 65244/0xFEDC (4 refs) */
#define io_control_pgn65244_size (*(volatile uint8_t*)0x0080312CUL) /* I/O control PGN 65244 message size 8 (ioControl... */
#define io_control_pgn65244_data_ptr (*(volatile uint32_t*)0x0080312EUL) /* I/O control PGN 65244 data pointer (ioControlPG... */
#define io_control_pgn65244_unused_ptr (*(volatile uint32_t*)0x00803132UL) /* I/O control PGN 65244 unused pointer 0x80313e (... */
#define io_control_pgn_data_dword (*(volatile uint32_t*)0x00803136UL) /* IO control PGN 65244 data dword (ioControlDataB... */
#define io_control_runtime_hours_dword (*(volatile uint32_t*)0x0080313AUL) /* I/O control runtime hours dword (ioControlDataB... */
#define j1939_message_buffer_pgn65252 (*(volatile uint32_t*)0x00803140UL) /* J1939 CAN message buffer PGN 65252/0xFEE4 (3 refs) */
#define engine_hours_pgn65252_size (*(volatile uint8_t*)0x00803144UL) /* Engine hours PGN 65252 message size 8 (engineHo... */
#define engine_hours_pgn65252_data_ptr (*(volatile uint32_t*)0x00803146UL) /* Engine hours PGN 65252 data pointer (engineHour... */
#define engine_hours_pgn65252_unused_ptr (*(volatile uint32_t*)0x0080314AUL) /* Engine hours PGN 65252 unused pointer 0x803156 ... */
#define engine_hours_data_byte_0 (*(volatile uint8_t*)0x0080314EUL) /* Engine hours data byte 0 (engineHoursPGN_65252_... */
#define engine_hours_reserved_3f (*(volatile uint8_t*)0x0080314FUL) /* Engine hours reserved 0x3f byte (engineHoursPGN... */
#define engine_hours_reserved_ff_0 (*(volatile uint8_t*)0x00803150UL) /* Engine hours reserved 0xff byte 0 (engineHoursP... */
#define engine_hours_reserved_ff_1 (*(volatile uint8_t*)0x00803151UL) /* Engine hours reserved 0xff byte 1 (engineHoursP... */
#define engine_hours_reserved_ff_2 (*(volatile uint8_t*)0x00803152UL) /* Engine hours reserved 0xff byte 2 (engineHoursP... */
#define engine_hours_reserved_ff_3 (*(volatile uint8_t*)0x00803153UL) /* Engine hours reserved 0xff byte 3 (engineHoursP... */
#define engine_hours_reserved_ff_4 (*(volatile uint8_t*)0x00803154UL) /* Engine hours reserved 0xff byte 4 (engineHoursP... */
#define engine_hours_reserved_ff_5 (*(volatile uint8_t*)0x00803155UL) /* Engine hours reserved 0xff byte 5 (engineHoursP... */
#define j1939_message_buffer_pgn65270 (*(volatile uint32_t*)0x00803158UL) /* J1939 CAN message buffer PGN 65270/0xFEF6 (4 refs) */
#define intake_manifold_pgn65526_size (*(volatile uint8_t*)0x0080315CUL) /* Intake manifold PGN 65526 message size 8 (intak... */
#define intake_manifold_pgn65526_data_ptr (*(volatile uint32_t*)0x0080315EUL) /* Intake manifold PGN 65526 data pointer (intakeM... */
#define intake_manifold_pgn65526_unused_ptr (*(volatile uint32_t*)0x00803162UL) /* Intake manifold PGN 65526 unused pointer 0x8031... */
#define intake_manifold_pgn65526_data (*(volatile uint8_t*)0x00803166UL) /* Intake manifold PGN 65526 data byte (intakeMani... */
#define intake_manifold_data_byte_1 (*(volatile uint8_t*)0x00803167UL) /* Intake manifold data byte 1 (intakeManifoldData... */
#define intake_manifold_data_byte_2 (*(volatile uint8_t*)0x00803168UL) /* Intake manifold data byte 2 (intakeManifoldData... */
#define intake_manifold_reserved_ff_0 (*(volatile uint8_t*)0x00803169UL) /* Intake manifold reserved 0xff byte 0 (intakeMan... */
#define intake_manifold_reserved_ff_1 (*(volatile uint8_t*)0x0080316AUL) /* Intake manifold reserved 0xff byte 1 (intakeMan... */
#define intake_manifold_reserved_ff_2 (*(volatile uint8_t*)0x0080316BUL) /* Intake manifold reserved 0xff byte 2 (intakeMan... */
#define intake_manifold_reserved_ff_3 (*(volatile uint8_t*)0x0080316CUL) /* Intake manifold reserved 0xff byte 3 (intakeMan... */
#define intake_manifold_reserved_ff_4 (*(volatile uint8_t*)0x0080316DUL) /* Intake manifold reserved 0xff byte 4 (intakeMan... */
#define j1939_message_buffer_pgn65264 (*(volatile uint32_t*)0x00803170UL) /* J1939 CAN message buffer PGN 65264/0xFEF0 (3 refs) */
#define cruise_control_pgn65264_size (*(volatile uint8_t*)0x00803174UL) /* Cruise control PGN 65264 message size 8 (cruise... */
#define cruise_control_pgn65264_data_ptr (*(volatile uint32_t*)0x00803176UL) /* Cruise control PGN 65264 data pointer (cruiseCo... */
#define cruise_control_pgn65264_unused_ptr (*(volatile uint32_t*)0x0080317AUL) /* Cruise control PGN 65264 unused pointer 0x80318... */
#define cruise_control_pgn65264_data (*(volatile uint8_t*)0x0080317EUL) /* Cruise control PGN 65264 data byte (cruiseContr... */
#define cruise_control_reserved_ff_0 (*(volatile uint8_t*)0x0080317FUL) /* Cruise control reserved 0xff byte 0 (cruiseCont... */
#define cruise_control_reserved_ff_1 (*(volatile uint8_t*)0x00803180UL) /* Cruise control reserved 0xff byte 1 (cruiseCont... */
#define cruise_control_reserved_ff_2 (*(volatile uint8_t*)0x00803183UL) /* Cruise control reserved 0xff byte 2 (cruiseCont... */
#define cruise_control_reserved_ff_3 (*(volatile uint8_t*)0x00803184UL) /* Cruise control reserved 0xff byte 3 (cruiseCont... */
#define cruise_control_reserved_ff_4 (*(volatile uint8_t*)0x00803185UL) /* Cruise control reserved 0xff byte 4 (cruiseCont... */
#define retarder_steps_at_idle (*(volatile uint8_t*)0x00803188UL) /* Retarder steps available at idle (Point 1) */
#define retarder_percent_torque_idle (*(volatile uint8_t*)0x00803189UL) /* Retarder percent torque at idle (Point 1) */
#define retarder_speed_point2_low (*(volatile uint8_t*)0x0080318AUL) /* Retarder speed at point 2 low byte */
#define retarder_speed_point2_high (*(volatile uint8_t*)0x0080318BUL) /* Retarder speed at point 2 high byte */
#define retarder_percent_torque_point2 (*(volatile uint8_t*)0x0080318CUL) /* Retarder percent torque at point 2 */
#define retarder_speed_point3_low (*(volatile uint8_t*)0x0080318DUL) /* Retarder speed at point 3 low byte */
#define retarder_speed_point3_high (*(volatile uint8_t*)0x0080318EUL) /* Retarder speed at point 3 high byte */
#define retarder_percent_torque_point3 (*(volatile uint8_t*)0x0080318FUL) /* Retarder percent torque at point 3 */
#define retarder_speed_point4_low (*(volatile uint8_t*)0x00803190UL) /* Retarder speed at point 4 low byte */
#define retarder_speed_point4_high (*(volatile uint8_t*)0x00803191UL) /* Retarder speed at point 4 high byte */
#define retarder_percent_torque_point4 (*(volatile uint8_t*)0x00803192UL) /* Retarder percent torque at point 4 */
#define retarder_speed_point5_low (*(volatile uint8_t*)0x00803193UL) /* Retarder speed at peak torque low byte */
#define retarder_speed_point5_high (*(volatile uint8_t*)0x00803194UL) /* Retarder speed at peak torque high byte */
#define retarder_percent_torque_point5 (*(volatile uint8_t*)0x00803195UL) /* Retarder percent torque at peak torque */
#define retarder_reference_torque_low (*(volatile uint8_t*)0x00803196UL) /* Reference retarder torque low byte */
#define retarder_reference_torque_high (*(volatile uint8_t*)0x00803197UL) /* Reference retarder torque high byte */
#define retarder_config_byte17 (*(volatile uint8_t*)0x00803198UL) /* Retarder configuration byte 17 */
#define retarder_config_byte18 (*(volatile uint8_t*)0x00803199UL) /* Retarder configuration byte 18 */
#define retarder_config_msg_header (*(volatile uint32_t*)0x0080319AUL) /* J1939 retarder configuration message header (PG... */
#define retarder_config_msg_length (*(volatile uint16_t*)0x0080319EUL) /* J1939 retarder configuration message length (18... */
#define retarder_config_data_ptr (*(volatile uint32_t*)0x008031A0UL) /* Pointer to retarder configuration data buffer */
#define retarder_config_unused_ptr (*(volatile uint32_t*)0x008031A4UL) /* Unused pointer for retarder configuration messa... */
#define retarder_config_buffer_end (*(volatile uint8_t*)0x008031A8UL) /* End marker for retarder configuration data buffer */
#define j1939_message_buffer_pgn65248 (*(volatile uint32_t*)0x008031AAUL) /* J1939 CAN message buffer PGN 65248/0xFEE0 (4 refs) */
#define vehicle_distance_pgn65248_size (*(volatile uint8_t*)0x008031AEUL) /* Vehicle distance PGN 65248 message size 8 (vehi... */
#define vehicle_distance_pgn65248_data_ptr (*(volatile uint32_t*)0x008031B0UL) /* Vehicle distance PGN 65248 data pointer (vehicl... */
#define vehicle_distance_pgn65248_unused_ptr (*(volatile uint32_t*)0x008031B4UL) /* Vehicle distance PGN 65248 unused pointer 0x803... */
#define vehicle_distance_pgn_data_dword (*(volatile uint32_t*)0x008031B8UL) /* Vehicle distance PGN 65248 data dword (vehicleD... */
#define vehicle_distance_data_dword (*(volatile uint32_t*)0x008031BCUL) /* Vehicle distance data dword (vehicleDistanceDat... */
#define j1939_message_buffer_pgn65271 (*(volatile uint32_t*)0x008031C2UL) /* J1939 CAN message buffer PGN 65271/0xFEF7 (4 refs) */
#define electronic_brake_pgn65527_size (*(volatile uint8_t*)0x008031C6UL) /* Electronic brake PGN 65527 message size 8 (elec... */
#define electronic_brake_pgn65527_data_ptr (*(volatile uint32_t*)0x008031C8UL) /* Electronic brake PGN 65527 data pointer (electr... */
#define electronic_brake_pgn65527_unused_ptr (*(volatile uint32_t*)0x008031CCUL) /* Electronic brake PGN 65527 unused pointer 0x803... */
#define electronic_brake_pgn65527_data (*(volatile uint8_t*)0x008031D0UL) /* Electronic brake PGN 65527 data byte (electroni... */
#define electronic_brake_reserved_ff (*(volatile uint8_t*)0x008031D1UL) /* Electronic brake reserved 0xff byte (electronic... */
#define electronic_brake_reserved_ffff_0 (*(volatile uint16_t*)0x008031D2UL) /* Electronic brake reserved 0xffff word 0 (electr... */
#define electronic_brake_reserved_ffff_1 (*(volatile uint16_t*)0x008031D4UL) /* Electronic brake reserved 0xffff word 1 (electr... */
#define electronic_brake_data_word (*(volatile uint16_t*)0x008031D6UL) /* Electronic brake data word (electronicBrakePGN_... */
#define j1939_message_buffer_pgn65255 (*(volatile uint32_t*)0x008031DAUL) /* J1939 CAN message buffer PGN 65255/0xFEE7 (4 refs) */
#define vehicle_hours_pgn65255_size (*(volatile uint8_t*)0x008031DEUL) /* Vehicle hours PGN 65255 message size 8 (vehicle... */
#define vehicle_hours_pgn65255_data_ptr (*(volatile uint32_t*)0x008031E0UL) /* Vehicle hours PGN 65255 data pointer (vehicleHo... */
#define vehicle_hours_pgn65255_unused_ptr (*(volatile uint32_t*)0x008031E4UL) /* Vehicle hours PGN 65255 unused pointer 0x8031f0... */
#define vehicle_hours_pgn_data_dword (*(volatile uint32_t*)0x008031E8UL) /* Vehicle hours PGN 65255 data dword (vehicleHour... */
#define vehicle_hours_idle_hours_dword (*(volatile uint32_t*)0x008031ECUL) /* Vehicle hours idle hours dword (vehicleHoursDat... */
#define fuel_demand_rpm_lookup_result (*(volatile uint16_t*)0x008031F4UL) /* Fuel demand RPM-based lookup result (3 refs) */
#define engine_data_trending_state (*(volatile uint16_t*)0x008031F6UL) /* Engine data trending state (engineDataTrendingS... */
#define engine_trending_load_threshold_ptr (*(volatile uint32_t*)0x008031F8UL) /* Engine trending load threshold pointer (engineD... */
#define engine_trending_intake_temp_value (*(volatile uint16_t*)0x008031FCUL) /* Engine trending intake manifold temp value (eng... */
#define engine_trending_count_min_ptr (*(volatile uint32_t*)0x008031FEUL) /* Engine trending count minimum pointer (engineDa... */
#define diagnostic_state_transition_counter (*(volatile uint16_t*)0x00803202UL) /* Counter for diagnostic state transitions */
#define diagnostic_state_exit_counter (*(volatile uint16_t*)0x00803204UL) /* Counter for diagnostic state exit timing */
#define diagnostic_mode_previous_3206 (*(volatile uint16_t*)0x00803206UL) /* Previous diagnostic mode for comparison */
#define protection_imt_threshold_ptr (*(volatile uint32_t*)0x00803208UL) /* Protection IMT fuel limit threshold pointer (in... */
#define protection_table_init_value (*(volatile uint16_t*)0x0080320CUL) /* Protection table initialization value 0 (initPr... */
#define oil_pressure_mode_previous (*(volatile uint16_t*)0x00803210UL) /* Oil pressure mode selector previous (2 refs) */
#define protection_shutdown_time_ptr (*(volatile uint32_t*)0x00803214UL) /* Protection oil pressure shutdown time pointer (... */
#define fuel_temp_limit_snapshot (*(volatile uint16_t*)0x00803218UL) /* Snapshot of fuel_temp_calculated_limit for comp... */
#define protection_water_in_fuel_ptr (*(volatile uint32_t*)0x0080321AUL) /* Protection water in fuel threshold pointer (eng... */
#define diagnostic_fuel_baseline (*(volatile uint16_t*)0x00803222UL) /* Diagnostic fuel baseline reference (9 refs) */
#define diagnostic_oil_pressure_max_ptr (*(volatile uint32_t*)0x0080322AUL) /* Diagnostic oil pressure max threshold pointer (... */
#define diagnostic_boost_table_ptr (*(volatile uint32_t*)0x00803232UL) /* Diagnostic boost pressure table pointer 0x8070e... */
#define diagnostic_boost_start_ptr (*(volatile uint32_t*)0x00803236UL) /* Diagnostic boost pressure start duration pointe... */
#define diagnostic_fuel_output_scaled_hi (*(volatile uint16_t*)0x0080323AUL) /* Diagnostic fuel output high word (1 ref) */
#define diagnostic_fuel_output_scaled_lo (*(volatile uint16_t*)0x0080323EUL) /* Diagnostic fuel output low word (1 ref) */
#define diagnostic_water_fault_ptr (*(volatile uint32_t*)0x00803242UL) /* Diagnostic water in fuel fault pointer (diagnos... */
#define diagnostic_water_warn_ptr (*(volatile uint32_t*)0x00803246UL) /* Diagnostic water warn before shutdown pointer (... */
#define boost_feedback_scaled_hi (*(volatile uint16_t*)0x0080324AUL) /* Boost pressure feedback scaled high word (1 ref) */
#define boost_feedback_scaled_lo (*(volatile uint16_t*)0x0080324EUL) /* Boost pressure feedback scaled low word (1 ref) */
#define diagnostic_fuel_demand_limit (*(volatile uint16_t*)0x00803252UL) /* Diagnostic mode fuel demand limit */
#define diagnostic_mode_10_temp_var (*(volatile uint16_t*)0x00803254UL) /* Diagnostic mode 10 temporary variable (4 refs) */
#define diagnostic_boost_delay_ptr (*(volatile uint32_t*)0x0080325AUL) /* Diagnostic boost pressure error delay pointer (... */
#define boost_pressure_control_output (*(volatile uint16_t*)0x00803268UL) /* Boost pressure control output value */
#define diagnostic_mode_previous_326a (*(volatile uint16_t*)0x0080326AUL) /* Previous diagnostic mode for transition detecti... */
#define boost_diagnostic_cooldown (*(volatile uint16_t*)0x0080326CUL) /* Boost diagnostic cooldown timer (3 refs) */
#define diagnostic_mode_countdown (*(volatile uint16_t*)0x00803272UL) /* Diagnostic mode countdown timer (5 refs) */
#define boost_diagnostic_adjustment (*(volatile uint16_t*)0x00803274UL) /* Boost diagnostic adjustment value (6 refs) */
#define boost_diagnostic_trigger_flag (*(volatile uint16_t*)0x00803276UL) /* Boost diagnostic trigger flag (4 refs) */
#define boost_diagnostic_delta_calc (*(volatile uint16_t*)0x00803278UL) /* Boost diagnostic delta calculation (3 refs) */
#define vp44_sensor_bit2_prev_state (*(volatile uint8_t*)0x0080327AUL) /* VP44 sensor bit 2 previous state (3 refs) */
#define vp44_sensor_bit0_prev_state (*(volatile uint8_t*)0x0080327BUL) /* VP44 sensor bit 0 previous state (3 refs) */
#define vp44_operating_condition_prev (*(volatile VP44_OPERATING_CONDITION*)0x0080327CUL) /* VP44 operating condition previous value (4 refs) */
#define boost_pressure_feedback_previous (*(volatile uint16_t*)0x0080327EUL) /* Previous boost pressure feedback for rate limiting */
#define boost_pressure_protection_mode_prev (*(volatile uint16_t*)0x00803280UL) /* Boost pressure protection mode previous (4 refs) */
#define rpm_fuel_calculation_scratch (*(volatile uint32_t*)0x00803282UL) /* Scratch register for RPM-based fuel calculation */
#define rpm_fuel_calculation_remainder (*(volatile uint16_t*)0x00803284UL) /* Remainder from RPM fuel calculation division */
#define fuel_limit_interpolator_result (*(volatile uint16_t*)0x00803286UL) /* Diagnostic/engine state fuel limit interpolator... */
#define fuel_limit_timer_divisor (*(volatile uint16_t*)0x00803288UL) /* Timer divisor for fuel limit interpolation from... */
#define fuel_temp_protection_table_ptr (*(volatile uint32_t*)0x0080328AUL) /* Fuel temp protection table pointer (fuelArbitra... */
#define fuel_temp_protection_state_328e (*(volatile uint16_t*)0x0080328EUL) /* Fuel temperature protection state (9 refs) */
#define fuel_temp_protection_limit_3292 (*(volatile uint16_t*)0x00803292UL) /* Fuel temperature protection limit calculator va... */
#define fuel_temp_protection_calculator (*(volatile uint16_t*)0x00803294UL) /* Fuel temp protection limit calculator value (3 ... */
#define fuel_temp_limit_previous (*(volatile uint16_t*)0x00803296UL) /* Previous fuel temp calculated limit (2 refs) */
#define crank_protection_state_flags (*(volatile uint8_t*)0x00803298UL) /* Crank protection state flags bitmap - accessed ... */
#define crank_protection_sample_counter (*(volatile uint16_t*)0x0080329AUL) /* Crank protection sample counter (6 refs) */
#define crank_protection_sequence_flag (*(volatile uint16_t*)0x0080329CUL) /* Crank protection sequence complete flag (2 refs) */
#define crank_protection_state_index (*(volatile uint16_t*)0x0080329EUL) /* Crank protection state sequence index (5 refs) */
#define crank_derate_threshold_previous (*(volatile uint16_t*)0x008032A0UL) /* Crank derate threshold previous state (2 refs) */
#define crank_derate_status_previous (*(volatile uint16_t*)0x008032A2UL) /* Crank derate status byte previous state (3 refs) */
#define crank_operating_time_snapshot (*(volatile uint32_t*)0x008032A4UL) /* Crank operating time snapshot (2 refs) */
#define crank_operating_time_previous (*(volatile uint16_t*)0x008032A6UL) /* Crank operating time previous value (1 ref) */
#define crank_scaling_lookup_arg (*(volatile uint16_t*)0x008032A8UL) /* Crank scaling factor lookup table arg (2 refs) */
#define crank_calibration_table_ptr_1 (*(volatile uint32_t*)0x008032AAUL) /* Crank calibration lookup table pointer 1 (1 ref) */
#define crank_lookup_table_selector (*(volatile uint16_t*)0x008032AEUL) /* Crank lookup table selector value (1 ref) */
#define crank_calibration_table_ptr_2 (*(volatile uint32_t*)0x008032B0UL) /* Crank calibration lookup table pointer 2 (1 ref) */
#define engine_fault_a_timer (*(volatile uint16_t*)0x008032B4UL) /* Engine fault register A presence timer (2 refs) */
#define engine_fault_b_timer (*(volatile uint16_t*)0x008032B6UL) /* Engine fault register B presence timer (2 refs) */
#define crank_data_buffer_index (*(volatile uint16_t*)0x008032B8UL) /* Crank data buffer store index counter (11 refs) */
#define crank_data_buffer_enable_flag (*(volatile uint16_t*)0x008032BAUL) /* Crank data buffer store enable flag (5 refs) */
#define boost_pressure_table_pointer (*(volatile uint32_t*)0x008032BEUL) /* Boost pressure lookup table pointer (2 refs) */
#define boost_pressure_interp_state (*(volatile uint32_t*)0x008032C2UL) /* Boost pressure interpolation state (2 refs) */
#define high_rpm_state_4_latch_flag (*(volatile uint8_t*)0x008032C6UL) /* High RPM protection state 4 latch flag (5 refs) */
#define high_rpm_state_3_latch_flag (*(volatile uint8_t*)0x008032C7UL) /* High RPM protection state 3 latch flag (5 refs) */
#define clutch_rpm_previous_32c8 (*(volatile uint16_t*)0x008032C8UL) /* Clutch RPM previous value for delta (3 refs) */
#define derate_event_timer_32ca (*(volatile uint16_t*)0x008032CAUL) /* Derate event timer counter (3 refs) */
#define clutch_rpm_delta_32cc (*(volatile uint32_t*)0x008032CCUL) /* Clutch RPM delta calculation (6 refs) */
#define fuel_temp_protection_counter_2_32ce (*(volatile uint16_t*)0x008032CEUL) /* Fuel temp protection counter 2 (2 refs) */
#define clutch_sample_divider_32d0 (*(volatile uint16_t*)0x008032D0UL) /* Clutch statistics sample divider counter (3 refs) */
#define fault_presence_timer (*(volatile uint16_t*)0x008032D2UL) /* Fault presence timer for logging (3 refs) */
#define fuel_temp_exceedance_timer (*(volatile uint16_t*)0x008032D4UL) /* Fuel temperature exceedance timer (3 refs) */
#define fuel_limit_near_exceedance_timer (*(volatile uint16_t*)0x008032D6UL) /* Fuel limit near exceedance timer (3 refs) */
#define clutch_slip_detection_state_32d8 (*(volatile uint16_t*)0x008032D8UL) /* Clutch slip detection state flag (4 refs) */
#define derate_event_state_machine_32da (*(volatile DERATE_EVENT_STATE*)0x008032DAUL) /* Derate event state machine state (6 refs) */
#define vp44_fault_protection_init_flag (*(volatile uint8_t*)0x008032DCUL) /* VP44 fault protection init complete flag (2 refs) */
#define vp44_derate_bit8_previous (*(volatile uint8_t*)0x008032DDUL) /* VP44 derate bit 8 previous state (2 refs) */
#define vp44_derate_bit4_previous (*(volatile uint8_t*)0x008032DEUL) /* VP44 derate bit 4 previous state (2 refs) */
#define vp44_derate_exceeded_previous (*(volatile uint16_t*)0x008032E0UL) /* VP44 derate exceeded previous state (2 refs) */
#define vp44_fuel_temp_previous (*(volatile uint16_t*)0x008032E2UL) /* VP44 fuel temp previous value for delta (6 refs) */
#define vp44_clutch_rpm_snapshot (*(volatile uint16_t*)0x008032E4UL) /* VP44 clutch RPM snapshot for fault detect (3 refs) */
#define vp44_fuel_table_lookup_1 (*(volatile uint16_t*)0x008032E6UL) /* VP44 fuel table lookup result 1 (2 refs) */
#define vp44_fuel_table_lookup_2 (*(volatile uint16_t*)0x008032E8UL) /* VP44 fuel table lookup result 2 (2 refs) */
#define vp44_timing_table_lookup_1 (*(volatile uint16_t*)0x008032EAUL) /* VP44 timing table lookup result 1 (2 refs) */
#define vp44_timing_table_lookup_2 (*(volatile uint16_t*)0x008032ECUL) /* VP44 timing table lookup result 2 (2 refs) */
#define oil_pressure_fault_table_ptr (*(volatile uint32_t*)0x008032EEUL) /* Oil pressure fault table pointer (oilPressureTa... */
#define oil_pressure_table_1_offset (*(volatile uint16_t*)0x008032F2UL) /* Oil pressure table 1 offset (1 ref) */
#define oil_pressure_table_1_pointer (*(volatile uint32_t*)0x008032F6UL) /* Oil pressure table 1 pointer (3 refs) */
#define oil_pressure_table_2_offset (*(volatile uint16_t*)0x008032FAUL) /* Oil pressure table 2 offset (1 ref) */
#define oil_pressure_table_3_pointer (*(volatile uint32_t*)0x008032FEUL) /* Oil pressure table 3 pointer (3 refs) */
#define oil_pressure_table_3_offset (*(volatile uint16_t*)0x00803302UL) /* Oil pressure table 3 offset (1 ref) */
#define oil_pressure_table_4_pointer (*(volatile uint32_t*)0x00803306UL) /* Oil pressure table 4 pointer (3 refs) */
#define oil_pressure_table_4_offset (*(volatile uint16_t*)0x0080330AUL) /* Oil pressure table 4 offset (1 ref) */
#define vp44_timing_limit_upper (*(volatile uint16_t*)0x0080330EUL) /* VP44 timing limit upper bound (2 refs) */
#define vp44_timing_limit_lower (*(volatile uint16_t*)0x00803310UL) /* VP44 timing limit lower bound (2 refs) */
#define vp44_fuel_limit_upper (*(volatile uint16_t*)0x00803312UL) /* VP44 fuel temp limit upper bound (2 refs) */
#define vp44_fuel_limit_lower (*(volatile uint16_t*)0x00803314UL) /* VP44 fuel temp limit lower bound (2 refs) */
#define interpolation_wscltatb_size (*(volatile uint16_t*)0x00803316UL) /* Interpolation WSCLTATB table size (interpolatio... */
#define interpolation_table_1_ptr (*(volatile uint32_t*)0x00803318UL) /* Interpolation table 1 pointer 0x80720a (interpo... */
#define diagnostic_rpm_setpoint_saved (*(volatile uint16_t*)0x0080331CUL) /* Diagnostic RPM setpoint saved value (2 refs) */
#define interpolation_wscltatb_ptr (*(volatile uint32_t*)0x0080331EUL) /* Interpolation WSCLTATB table pointer (interpola... */
#define interpolation_table_2_size (*(volatile uint16_t*)0x00803322UL) /* Interpolation table 2 size (interpolationTableS... */
#define interpolation_table_2_ptr (*(volatile uint32_t*)0x00803324UL) /* Interpolation table 2 pointer 0x807232 (interpo... */
#define diagnostic_throttle_saved (*(volatile uint16_t*)0x00803328UL) /* Diagnostic throttle position saved (2 refs) */
#define interpolation_table_3_ptr (*(volatile uint32_t*)0x0080332AUL) /* Interpolation table 3 pointer 0x807246 (interpo... */
#define vp44_state_processing_timeout_counter (*(volatile uint16_t*)0x0080332EUL) /* VP44 state machine timeout countdown (loaded fr... */
#define vp44_state_input_current (*(volatile VP44_STATE*)0x00803330UL) /* VP44 current state input value (7 refs) */
#define output_timing_base_value (*(volatile uint16_t*)0x00803332UL) /* Output timing generator base value (5 refs) */
#define vp44_state_debounce_countdown (*(volatile uint16_t*)0x00803334UL) /* VP44 state debounce countdown timer (8 refs) */
#define vp44_state_current_debounced (*(volatile VP44_STATE*)0x00803336UL) /* VP44 debounced state from vp44StateDebounceFilt... */
#define vp44_state_previous (*(volatile VP44_STATE*)0x00803338UL) /* VP44 previous state for transition detection (7... */
#define vp44_state_operating_condition_cached (*(volatile VP44_OPERATING_CONDITION*)0x0080333AUL) /* VP44 cached operating condition for state compa... */
#define vp44_state_output_timing_base (*(volatile uint16_t*)0x0080333CUL) /* VP44 state machine output timing base value (7 ... */
#define vp44_state_debounce_value_333e (*(volatile VP44_STATE*)0x0080333EUL) /* VP44 state debounce filter value (7 refs) */
#define output_control_can_state (*(volatile uint8_t*)0x00803340UL) /* Output control CAN interface state (9 refs) */
#define vp44_timing_override_state (*(volatile uint16_t*)0x00803342UL) /* VP44 timing override state (3 refs) */
#define vp44_timing_override_counter (*(volatile uint16_t*)0x00803344UL) /* VP44 timing override counter (4 refs) */
#define output_control_intake_temp_value (*(volatile uint16_t*)0x00803346UL) /* Output control intake temperature sensor value ... */
#define vp44_timing_coordinator_value (*(volatile uint16_t*)0x00803348UL) /* VP44 timing coordinator read value (vp44Injecti... */
#define output_control_state_4_value (*(volatile uint16_t*)0x0080334AUL) /* Output control state 4 handler value used by ou... */
#define output_control_state_selector (*(volatile uint8_t*)0x0080334CUL) /* Output control state machine selector value (11... */
#define output_timing_config_word_1 (*(volatile uint16_t*)0x0080334EUL) /* Output timing generator config word 1 (5 refs) */
#define output_timing_state_previous (*(volatile uint16_t*)0x00803350UL) /* Previous output_control_timer_value for continuity */
#define output_timing_config_word_2 (*(volatile uint16_t*)0x00803352UL) /* Output timing generator config word 2 (5 refs) */
#define output_timing_cycle_counter (*(volatile uint16_t*)0x00803354UL) /* Counts cycles when fuel demand exceeds threshol... */
#define output_timing_config_word_3 (*(volatile uint16_t*)0x00803356UL) /* Output timing generator config word 3 (5 refs) */
#define output_control_state_sequencer (*(volatile uint16_t*)0x00803358UL) /* Output control state sequencer counter (7 refs) */
#define output_control_timing_reset_counter (*(volatile uint16_t*)0x0080335AUL) /* Countdown counter loaded from 0x00807266 */
#define output_timing_duration_countdown (*(volatile uint16_t*)0x0080335CUL) /* Countdown timer loaded from interpolation resul... */
#define output_timing_cycle_divider (*(volatile uint16_t*)0x0080335EUL) /* Output timing generator cycle divider (5 refs) */
#define output_timing_duty_cycle_counter (*(volatile uint16_t*)0x00803360UL) /* Output control timing generator duty cycle coun... */
#define output_control_idle_counter (*(volatile uint16_t*)0x00803362UL) /* Output control idle state incrementing counter ... */
#define output_timing_state_selector (*(volatile uint16_t*)0x00803364UL) /* Output timing generator state selector (5 refs) */
#define output_control_lookup_failure_flag (*(volatile uint8_t*)0x00803366UL) /* 0=success 1=failure for io_control_flags */
#define output_control_table_2_size (*(volatile uint16_t*)0x00803368UL) /* Output control table 2 size (engineModeOutputCo... */
#define output_control_table_1_ptr (*(volatile uint32_t*)0x0080336AUL) /* Output control table 1 pointer 0x807278 (engine... */
#define output_control_rpm_workspace_2 (*(volatile uint16_t*)0x0080336EUL) /* Output control RPM workspace 2 (outputControlSt... */
#define output_control_table_2_ptr (*(volatile uint32_t*)0x00803370UL) /* Output control table 2 pointer 0x807292 (engine... */
#define output_control_table_4_size (*(volatile uint16_t*)0x00803374UL) /* Output control table 4 size (engineModeOutputCo... */
#define output_control_table_3_ptr (*(volatile uint32_t*)0x00803376UL) /* Output control table 3 pointer 0x8072fe (engine... */
#define output_control_sensor_input_cached (*(volatile uint16_t*)0x0080337AUL) /* Output control cached sensor input value (4 refs) */
#define output_control_table_4_ptr (*(volatile uint32_t*)0x0080337CUL) /* Output control table 4 pointer 0x807318 (engine... */
#define output_control_table_6_size (*(volatile uint16_t*)0x00803380UL) /* Output control table 6 size (engineModeOutputCo... */
#define output_control_table_5_ptr (*(volatile uint32_t*)0x00803382UL) /* Output control table 5 pointer 0x807332 (engine... */
#define output_control_sequence_state (*(volatile uint16_t*)0x00803386UL) /* Output control sequence state (outputControlTim... */
#define output_control_table_6_ptr (*(volatile uint32_t*)0x00803388UL) /* Output control table 6 pointer 0x80733e (engine... */
#define output_control_table_7_size (*(volatile uint16_t*)0x0080338CUL) /* Output control table 7 size (engineModeOutputCo... */
#define output_control_table_7_ptr (*(volatile uint32_t*)0x0080338EUL) /* Output control table 7 pointer 0x8072ac (engine... */
#define output_control_timing_workspace (*(volatile uint16_t*)0x00803392UL) /* Output control timing workspace (outputControlS... */
#define output_control_table_8_size (*(volatile uint16_t*)0x00803394UL) /* Output control table 8 size 2 (engineModeOutput... */
#define output_control_table_8_ptr (*(volatile uint32_t*)0x00803396UL) /* Output control table 8 pointer 0x8072bc (engine... */
#define output_control_index_workspace (*(volatile uint16_t*)0x0080339AUL) /* Output control index workspace (outputControlSt... */
#define output_control_table_9_ptr (*(volatile uint32_t*)0x0080339CUL) /* Output control table 9 pointer 0x8072c6 (engine... */
#define output_sequence_state (*(volatile uint16_t*)0x008033A0UL) /* Output sequence state machine */
#define output_state_timing_delay_base (*(volatile uint16_t*)0x008033A2UL) /* Base delay value for output control state seque... */
#define output_state_1_timing_offset (*(volatile uint16_t*)0x008033A4UL) /* State 1 timing offset from interpolation table ... */
#define output_state_2_timing_offset (*(volatile uint16_t*)0x008033A6UL) /* State 2 timing offset from interpolation table ... */
#define output_state_3_timing_offset (*(volatile uint16_t*)0x008033A8UL) /* State 3 timing offset from interpolation table ... */
#define output_control_interpolation_result (*(volatile uint16_t*)0x008033ACUL) /* Output control table interpolation result (4 refs) */
#define output_timing_duty_lookup_result (*(volatile uint16_t*)0x008033AEUL) /* Output timing duty cycle lookup result (3 refs) */
#define output_control_timing_state_33b0 (*(volatile uint8_t*)0x008033B0UL) /* Output control timing generator state (outputCo... */
#define output_timing_interpolation_result (*(volatile uint16_t*)0x008033B2UL) /* Output control timing generator interpolation r... */
#define output_control_rpm_workspace (*(volatile uint16_t*)0x008033B4UL) /* RPM workspace for output control threshold comp... */
#define output_control_idle_timeout_threshold (*(volatile uint16_t*)0x008033B6UL) /* Output control idle timeout threshold (initiali... */
#define output_control_active_flag (*(volatile uint16_t*)0x008033B8UL) /* Output control active state flag (0=idle 1=acti... */
#define output_control_flags_state (*(volatile uint8_t*)0x008033BAUL) /* Output control flags initialization state (11 r... */
#define output_control_mode_state_variable (*(volatile uint16_t*)0x008033BCUL) /* Output control mode state (values 1 2 3) for en... */
#define output_control_state_transition_flag (*(volatile uint8_t*)0x008033BEUL) /* State transition flag for engine mode I/O contr... */
#define engine_mode_io_control_flags (*(volatile uint8_t*)0x008033BFUL) /* Engine mode based I/O controller flags (11 refs) */
#define engine_mode_io_control_counter (*(volatile uint16_t*)0x008033C0UL) /* Engine mode IO control counter in engineModeBas... */
#define fuel_demand_table_3_size (*(volatile uint16_t*)0x008033C2UL) /* Fuel demand table 3 size (fuelDemandTablePointe... */
#define fuel_demand_table_1_ptr_33c4 (*(volatile uint32_t*)0x008033C4UL) /* Fuel demand table 1 pointer 0x807352 (fuelDeman... */
#define rpm_load_lookup_input (*(volatile uint16_t*)0x008033C8UL) /* RPM load parameter lookup input (rpmLoadParamet... */
#define fuel_demand_table_2_size (*(volatile uint16_t*)0x008033CAUL) /* Fuel demand table 2 size 2 (fuelDemandTablePoin... */
#define fuel_demand_table_2_ptr_33cc (*(volatile uint32_t*)0x008033CCUL) /* Fuel demand table 2 pointer 0x80735c (fuelDeman... */
#define rpm_load_lookup_result_ptr (*(volatile uint32_t*)0x008033D0UL) /* RPM load lookup result pointer (rpmLoadParamete... */
#define fuel_demand_table_3_ptr_33d2 (*(volatile uint32_t*)0x008033D2UL) /* Fuel demand table 3 pointer 0x807366 (fuelDeman... */
#define vp44_diagnostic_sensor_threshold (*(volatile uint16_t*)0x008033D6UL) /* VP44 diagnostic sensor threshold monitor value ... */
#define fuel_pressure_sync_counter (*(volatile uint16_t*)0x008033D8UL) /* Fuel pressure sync countdown counter */
#define fuel_pressure_rpm_flag (*(volatile uint16_t*)0x008033DAUL) /* Fuel pressure RPM condition flag */
#define fuel_pressure_injection_flag (*(volatile uint16_t*)0x008033DCUL) /* Fuel pressure injection condition flag */
#define fuel_pressure_sync_state_machine (*(volatile FUEL_SYNC_STATE*)0x008033DEUL) /* Fuel pressure sync state machine state */
#define fuel_temp_protection_state_33e2 (*(volatile uint16_t*)0x008033E2UL) /* Fuel temp protection state */
#define fuel_temp_protection_active_flag (*(volatile uint16_t*)0x008033E4UL) /* Fuel temp protection active flag (4 refs) */
#define fuel_temp_vp44_state_flag (*(volatile uint16_t*)0x008033E6UL) /* Fuel temp VP44 state flag (4 refs) */
#define fuel_temp_vp44_state_previous (*(volatile uint16_t*)0x008033E8UL) /* Fuel temp VP44 state previous value (2 refs) */
#define fuel_temp_limit_primary_prev (*(volatile uint16_t*)0x008033EAUL) /* Fuel temp limit primary previous value (5 refs) */
#define fuel_temp_limit_secondary_prev (*(volatile uint16_t*)0x008033ECUL) /* Fuel temp limit secondary previous value (3 refs) */
#define fuel_temp_primary_counter_flag (*(volatile uint16_t*)0x008033EEUL) /* Fuel temp primary counter enable flag (7 refs) */
#define fuel_temp_secondary_counter_flag (*(volatile uint16_t*)0x008033F0UL) /* Fuel temp secondary counter enable flag (3 refs) */
#define vp44_sensor_debounce_counter (*(volatile uint16_t*)0x008033F2UL) /* VP44 sensor status debounce counter (3 refs) */
#define vp44_sensor_prev_debounce (*(volatile VP44_STATE*)0x008033F4UL) /* VP44 sensor previous debounce value (3 refs) */
#define vp44_sensor_status_monitor_state (*(volatile VP44_STATE*)0x008033F6UL) /* VP44 sensor status monitor state (11 refs) */
#define vp44_sensor_state_counter (*(volatile uint16_t*)0x008033F8UL) /* VP44 sensor state transition counter (6 refs) */
#define vp44_control_flags_state (*(volatile uint16_t*)0x008033FAUL) /* VP44 control flags init state value (5 refs) */
#define vp44_control_flags_init_state (*(volatile uint16_t*)0x008033FCUL) /* VP44 control flags init state (vp44ControlFlags... */
#define vp44_control_flag_1 (*(volatile uint8_t*)0x008033FEUL) /* VP44 control flag 1 init=1 (vp44ControlFlagsInit) */
#define vp44_control_flag_2 (*(volatile uint8_t*)0x00803400UL) /* VP44 control flag 2 init=1 (vp44ControlFlagsInit) */
#define vp44_control_flag_3 (*(volatile uint8_t*)0x00803402UL) /* VP44 control flag 3 init=1 (vp44ControlFlagsInit) */
#define vp44_control_flag_4 (*(volatile uint8_t*)0x00803404UL) /* VP44 control flag 4 init=0 (vp44ControlFlagsInit) */
#define vp44_control_flag_5 (*(volatile uint8_t*)0x00803406UL) /* VP44 control flag 5 init=1 (vp44ControlFlagsInit) */
#define vp44_control_flag_6 (*(volatile uint8_t*)0x00803408UL) /* VP44 control flag 6 init=0 (vp44ControlFlagsInit) */
#define vp44_control_flag_7 (*(volatile uint8_t*)0x0080340AUL) /* VP44 control flag 7 init=0 (vp44ControlFlagsInit) */
#define vp44_sensor_diag_timer_1 (*(volatile uint16_t*)0x0080340CUL) /* VP44 sensor diagnostic control timer 1 (5 refs) */
#define vp44_sensor_diagnostic_countdown (*(volatile uint16_t*)0x0080340EUL) /* VP44 sensor diagnostic state countdown timer (4... */
#define dzg_pressure_state_saved (*(volatile uint16_t*)0x00803410UL) /* DZG pressure control state saved (2 refs) */
#define vp44_sensor_diag_state_prev (*(volatile uint8_t*)0x00803412UL) /* VP44 sensor diagnostic previous state (vp44Sens... */
#define vp44_sensor_diag_index (*(volatile uint8_t*)0x00803413UL) /* VP44 sensor diagnostic index (vp44SensorDiagnos... */
#define vp44_sensor_diag_timer_2 (*(volatile uint16_t*)0x00803414UL) /* VP44 sensor diagnostic control timer 2 (5 refs) */
#define dzg_timing_accumulator_value (*(volatile uint16_t*)0x00803416UL) /* DZG timing accumulator calculation value (23 refs) */
#define dzg_timing_state_variable (*(volatile uint16_t*)0x00803418UL) /* DZG timing and pressure control state variable ... */
#define dzg_timing_state_machine_value (*(volatile uint16_t*)0x0080341AUL) /* DZG timing state machine control value (8 refs) */
#define dzg_timing_state_index (*(volatile DZG_TIMING_STATE*)0x0080341CUL) /* DZG timing state machine index 0-2 (8 refs) */
#define dzg_state_transition_counter (*(volatile uint16_t*)0x0080341EUL) /* DZG state machine transition counter */
#define dzg_pressure_ramp_rate (*(volatile uint16_t*)0x00803420UL) /* DZG pressure control ramp rate value (9 refs) */
#define dzg_pressure_target_value (*(volatile uint16_t*)0x00803422UL) /* DZG pressure control target value (6 refs) */
#define dzg_pressure_state_index (*(volatile uint16_t*)0x00803424UL) /* DZG pressure state machine index 0-2 (6 refs) */
#define sensor_history_table_ptr (*(volatile uint32_t*)0x00803426UL) /* Sensor history table pointer 0x80784c (sensorHi... */
#define sensor_history_init_value (*(volatile uint32_t*)0x0080342AUL) /* Sensor history init value 0x80000000 (sensorHis... */
#define clutch_rpm_accumulator_previous (*(volatile uint16_t*)0x0080342EUL) /* Clutch RPM accumulator previous value (2 refs) */
#define sensor_status_history_bits (*(volatile uint32_t*)0x00803430UL) /* Sensor status history bits - shifting record */
#define oil_pressure_rpm_ramp_complete (*(volatile uint16_t*)0x00803434UL) /* Flag indicating oil pressure RPM ramp complete */
#define oil_pressure_rpm_limit_current (*(volatile uint16_t*)0x00803436UL) /* Current RPM limit from oil pressure protection */
#define oil_pressure_rpm_limit_target (*(volatile uint16_t*)0x00803438UL) /* Target RPM limit for oil pressure protection */
#define oil_pressure_rpm_limit_previous (*(volatile uint16_t*)0x0080343AUL) /* Previous RPM limit for oil pressure tracking */
#define oil_pressure_state_index (*(volatile uint16_t*)0x0080343CUL) /* State index for oil pressure protection */
#define oil_pressure_validation_timer (*(volatile uint16_t*)0x0080343EUL) /* Timer for oil pressure validation */
#define sensor_status_validation_counter (*(volatile uint16_t*)0x00803440UL) /* Sensor status validation timing counter */
#define oil_pressure_protection_table_ptr (*(volatile uint32_t*)0x00803442UL) /* Oil pressure protection lookup table pointer (i... */
#define oil_pressure_table_1_ptr (*(volatile uint32_t*)0x00803446UL) /* Oil pressure protection table 1 pointer 0x8036a... */
#define oil_pressure_table_2_ptr (*(volatile uint32_t*)0x0080344AUL) /* Oil pressure protection table 2 pointer 0x8037f... */
#define oil_pressure_table_3_ptr (*(volatile uint32_t*)0x0080344EUL) /* Oil pressure protection table 3 pointer 0x80380... */
#define oil_pressure_table_4_ptr (*(volatile uint32_t*)0x00803452UL) /* Oil pressure protection table 4 pointer 0x80380... */
#define oil_pressure_table_5_ptr (*(volatile uint32_t*)0x00803456UL) /* Oil pressure protection table 5 pointer 0x80380... */
#define base_timing_table_lookup_arg_345a (*(volatile uint16_t*)0x0080345AUL) /* Base timing table lookup argument (vp44FaultPro... */
#define vp44_timing_idle_cmd_ptr (*(volatile uint32_t*)0x0080345CUL) /* VP44 timing idle command pointer (vp44FaultProt... */
#define base_timing_rpm_input (*(volatile uint16_t*)0x00803460UL) /* Base timing lookup RPM input (1 ref) */
#define vp44_timing_table_size (*(volatile uint16_t*)0x00803462UL) /* VP44 timing table size 2 (vp44FaultProtectionSy... */
#define vp44_timing_fault_limit_ptr (*(volatile uint32_t*)0x00803464UL) /* VP44 timing fault fuel limit pointer (vp44Fault... */
#define base_timing_fuel_value_input (*(volatile uint16_t*)0x00803468UL) /* Base timing lookup fuel value input (1 ref) */
#define vp44_stuck_pump_threshold_ptr (*(volatile uint32_t*)0x0080346AUL) /* VP44 stuck pump max messages threshold pointer ... */
#define base_timing_table_lookup_arg_346e (*(volatile uint16_t*)0x0080346EUL) /* Base timing table lookup arg (2 refs) */
#define lift_pump_table_lookup_arg_3472 (*(volatile uint16_t*)0x00803472UL) /* Lift pump table lookup argument (vp44FaultProte... */
#define vp44_lift_pump_table_ptr (*(volatile uint32_t*)0x00803474UL) /* VP44 lift pump table pointer 0x807656 (vp44Faul... */
#define lift_pump_fuel_demand_input (*(volatile uint16_t*)0x00803478UL) /* Lift pump controller fuel demand input (1 ref) */
#define vp44_lift_pump_table_2_size (*(volatile uint16_t*)0x0080347AUL) /* VP44 lift pump table 2 size 2 (vp44FaultProtect... */
#define vp44_lift_pump_table_2_ptr (*(volatile uint32_t*)0x0080347CUL) /* VP44 lift pump table 2 pointer 0x807670 (vp44Fa... */
#define lift_pump_fuel_value_input (*(volatile uint16_t*)0x00803480UL) /* Lift pump controller fuel value input (1 ref) */
#define vp44_lift_pump_table_3_ptr (*(volatile uint32_t*)0x00803482UL) /* VP44 lift pump table 3 pointer 0x80768a (vp44Fa... */
#define lift_pump_table_lookup_arg_3486 (*(volatile uint16_t*)0x00803486UL) /* Lift pump table interpolation lookup arg (2 refs) */
#define vp44_can_msg_100_received_flag (*(volatile uint8_t*)0x0080348AUL) /* VP44 CAN msg 100 received flag (3 refs) */
#define vp44_can_msg_100_retry_counter (*(volatile uint8_t*)0x0080348BUL) /* VP44 CAN msg 100 retry counter (3 refs) */
#define vp44_can_msg_timeout_counter (*(volatile uint16_t*)0x0080348CUL) /* VP44 CAN msg timeout counter (5 refs) */
#define lift_pump_diagnostic_mode_flag (*(volatile uint8_t*)0x0080348EUL) /* Lift pump diagnostic mode enable flag (3 refs) */
#define vp44_fso_circuit_fault_flag (*(volatile uint8_t*)0x0080348FUL) /* VP44 FSO circuit fault detected flag */
#define vp44_timing_expected_table_ptr (*(volatile uint32_t*)0x00803490UL) /* VP44 timing expected table pointer 0x807404 (vp... */
#define vp44_timing_expected_init (*(volatile uint32_t*)0x00803494UL) /* VP44 timing expected init value 0x28f0000 (vp44... */
#define vp44_timing_actual_table_ptr (*(volatile uint32_t*)0x00803498UL) /* VP44 timing actual table pointer 0x807404 (vp44... */
#define vp44_diagnostic_threshold_state (*(volatile uint16_t*)0x0080349AUL) /* VP44 diagnostic threshold monitor state (9 refs) */
#define vp44_timing_actual_init (*(volatile uint32_t*)0x0080349CUL) /* VP44 timing actual init value 0x28f0000 (vp44Fa... */
#define vp44_fso_fault_active_flag (*(volatile uint8_t*)0x008034A0UL) /* VP44 FSO fault active status flag */
#define vp44_fso_fault_detection_enable (*(volatile uint8_t*)0x008034A1UL) /* VP44 FSO circuit fault detection enable flag */
#define vp44_fso_warmup_counter (*(volatile uint16_t*)0x008034A2UL) /* VP44 FSO warmup counter (2 refs) */
#define derate_threshold_change_counter (*(volatile uint16_t*)0x008034A4UL) /* Derate threshold change detection counter (4 refs) */
#define vp44_timing_negative_fault_counter (*(volatile uint8_t*)0x008034A5UL) /* VP44 timing negative value fault counter (4 refs) */
#define vp44_timing_max_fault_counter (*(volatile uint8_t*)0x008034A6UL) /* VP44 timing max exceeded fault counter (4 refs) */
#define vp44_fuel_demand_range_fault_counter (*(volatile uint8_t*)0x008034A7UL) /* VP44 fuel demand out of range fault counter (4 ... */
#define vp44_timing_min_fault_counter (*(volatile uint8_t*)0x008034A8UL) /* VP44 timing min exceeded fault counter (4 refs) */
#define vp44_timing_decrease_fault_counter (*(volatile uint8_t*)0x008034A9UL) /* VP44 timing decrease fault counter (4 refs) */
#define vp44_feedback_pulse_low_fault_counter (*(volatile uint8_t*)0x008034AAUL) /* VP44 feedback pulse low fault counter (4 refs) */
#define vp44_feedback_pulse_high_fault_counter (*(volatile uint8_t*)0x008034ABUL) /* VP44 feedback pulse high fault counter (4 refs) */
#define lift_pump_timing_smoothed (*(volatile uint16_t*)0x008034ACUL) /* Lift pump timing smoothed output (6 refs) */
#define derate_threshold_previous (*(volatile uint16_t*)0x008034AEUL) /* Derate threshold previous value (2 refs) */
#define fso_fault_previous_value (*(volatile uint16_t*)0x008034B0UL) /* FSO fault detection previous value */
#define fso_fault_latched_value (*(volatile uint16_t*)0x008034B2UL) /* FSO fault latched value when detected */
#define fso_bit5_fault_set_counter (*(volatile uint8_t*)0x008034B4UL) /* VP44 FSO bit 5 fault set debounce counter (5 refs) */
#define fso_bit5_fault_clear_counter (*(volatile uint8_t*)0x008034B5UL) /* VP44 FSO bit 5 fault clear debounce counter (5 ... */
#define fso_fault_debounce_counter (*(volatile uint8_t*)0x008034B6UL) /* FSO fault detection debounce counter */
#define fso_bit6_fault_clear_counter (*(volatile uint8_t*)0x008034B7UL) /* VP44 FSO bit 6 fault clear debounce counter (5 ... */
#define fso_high_cmd_fault_debounce_counter (*(volatile uint8_t*)0x008034B8UL) /* VP44 FSO high command fault debounce counter (5... */
#define fso_low_cmd_fault_clear_counter (*(volatile uint8_t*)0x008034B9UL) /* VP44 FSO low command fault clear counter (5 refs) */
#define fso_stuck_fault_debounce_counter (*(volatile uint8_t*)0x008034BAUL) /* VP44 FSO stuck fault debounce counter (5 refs) */
#define vp44_fso_range1_fault_counter (*(volatile uint8_t*)0x008034BBUL) /* VP44 FSO range 1 fault detection counter */
#define vp44_fso_range2_fault_counter (*(volatile uint8_t*)0x008034BCUL) /* VP44 FSO range 2 fault detection counter */
#define vp44_fso_recovery_counter (*(volatile uint8_t*)0x008034BDUL) /* VP44 FSO fault recovery counter */
#define vp44_fso_bit1_range1_fault_counter (*(volatile uint8_t*)0x008034BEUL) /* VP44 FSO bit1 range 1 fault detection counter */
#define vp44_fso_bit1_range2_fault_counter (*(volatile uint8_t*)0x008034BFUL) /* VP44 FSO bit1 range 2 fault detection counter */
#define vp44_fso_bit1_recovery_counter (*(volatile uint8_t*)0x008034C0UL) /* VP44 FSO bit1 fault recovery counter */
#define fso_range_fault_low_counter (*(volatile uint8_t*)0x008034C1UL) /* VP44 FSO range fault low debounce counter (6 refs) */
#define fso_range_fault_high_counter (*(volatile uint8_t*)0x008034C2UL) /* VP44 FSO range fault high debounce counter (6 r... */
#define fso_range_fault_clear_counter (*(volatile uint8_t*)0x008034C3UL) /* VP44 FSO range fault clear debounce counter (5 ... */
#define vp44_timing_status_fault_counter (*(volatile uint8_t*)0x008034C4UL) /* VP44 timing status fault debounce counter (4 refs) */
#define vp44_timing_mode_3_high_counter (*(volatile uint8_t*)0x008034C5UL) /* VP44 timing mode 3 high fault counter (6 refs) */
#define vp44_timing_mode_267_high_counter (*(volatile uint8_t*)0x008034C6UL) /* VP44 timing mode 2/6/7 high fault counter (6 refs) */
#define vp44_timing_mode_3_low_counter (*(volatile uint8_t*)0x008034C7UL) /* VP44 timing mode 3 low fault counter (6 refs) */
#define vp44_timing_mode_267_low_counter (*(volatile uint8_t*)0x008034C8UL) /* VP44 timing mode 2/6/7 low fault counter (6 refs) */
#define vp44_fso_fault_latch_flag (*(volatile uint8_t*)0x008034C9UL) /* VP44 FSO fault latch flag (2 refs) */
#define vp44_fso_condition_counter (*(volatile uint16_t*)0x008034CAUL) /* VP44 FSO condition counter (4 refs) */
#define vp44_fso_duration_counter (*(volatile uint16_t*)0x008034CCUL) /* VP44 FSO duration counter (3 refs) */
#define vp44_fso_timing_fault_counter (*(volatile uint8_t*)0x008034CEUL) /* VP44 FSO timing fault debounce counter (4 refs) */
#define vp44_fso_bit0_fault_counter (*(volatile uint16_t*)0x008034D0UL) /* VP44 FSO bit 0 fault debounce counter (5 refs) */
#define vp44_fso_bit0_recovery_counter (*(volatile uint16_t*)0x008034D2UL) /* VP44 FSO bit 0 recovery counter (4 refs) */
#define vp44_fso_bit15_fault_counter (*(volatile uint16_t*)0x008034D4UL) /* VP44 FSO bit 15 fault debounce counter (5 refs) */
#define vp44_fso_bit15_limit_counter (*(volatile uint16_t*)0x008034D6UL) /* VP44 FSO bit 15 limit counter (4 refs) */
#define vp44_fso_bit15_recovery_counter (*(volatile uint8_t*)0x008034D8UL) /* VP44 FSO bit 15 recovery counter (4 refs) */
#define vp44_fso_multibit_fault_debounce_counter (*(volatile uint16_t*)0x008034DAUL) /* VP44 FSO multibit fault debounce counter (7 refs) */
#define vp44_fso_multibit_clear_flag (*(volatile uint16_t*)0x008034DCUL) /* VP44 FSO multibit fault clear flag (vp44FsoMult... */
#define vp44_fso_multibit_fault_accumulator (*(volatile uint16_t*)0x008034DEUL) /* VP44 FSO multi-bit fault accumulator in vp44Fso... */
#define vp44_fso_multibit_fault_state (*(volatile uint16_t*)0x008034E0UL) /* VP44 FSO multi-bit fault monitor state (10 refs) */
#define vp44_fso_stuck_high_state (*(volatile uint16_t*)0x008034E2UL) /* VP44 FSO stuck high fault detector state (4 refs) */
#define vp44_fso_stuck_high_recovery_counter (*(volatile uint8_t*)0x008034E4UL) /* VP44 FSO stuck high recovery counter (4 refs) */
#define vp44_fso_zero_timing_fault_counter (*(volatile uint8_t*)0x008034E6UL) /* VP44 FSO zero timing fault counter (4 refs) */
#define vp44_fso_demand_delta_fault_counter (*(volatile uint8_t*)0x008034E7UL) /* VP44 FSO demand delta fault counter (4 refs) */
#define vp44_fso_rpm_fault_counter (*(volatile uint16_t*)0x008034E8UL) /* VP44 FSO RPM-based fault counter (7 refs) */
#define can_message_buffer_start (*(volatile uint8_t*)0x008034F8UL) /* Start of CAN message buffer array for logging (... */
#define calibration_validation_buffer (*(volatile uint8_t*)0x008034FAUL) /* Calibration validation buffer base (calibration... */
#define calibration_checksum_expected_1 (*(volatile uint16_t*)0x00803500UL) /* Calibration checksum expected value 1 (2 refs) */
#define calibration_checksum_expected_2 (*(volatile uint16_t*)0x00803502UL) /* Calibration checksum expected value 2 (2 refs) */
#define loop_counter_reference (*(volatile uint16_t*)0x0080352CUL) /* Loop counter comparison reference value (3 refs) */
#define security_bypass_flag (*(volatile uint16_t*)0x00803586UL) /* Security bypass magic value - 0xB522 enables by... */
#define vp44_status_flags_1 (*(volatile uint16_t*)0x008035D4UL) /* VP44 status flags 1 - bit 6 (0x40) affects pin ... */
#define fuel_demand_control_flags (*(volatile uint16_t*)0x008035D6UL) /* Fuel demand mode control flags */
#define protection_system_flags (*(volatile uint16_t*)0x008035D8UL) /* Protection system status flags */
#define engine_operating_state_flags (*(volatile uint16_t*)0x008035DAUL) /* Engine operating state flags */
#define diagnostic_status_flags (*(volatile uint16_t*)0x008035DCUL) /* Diagnostic status bit flags (2 refs) */
#define fuel_temp_control_flags (*(volatile uint16_t*)0x008035E0UL) /* Fuel temperature control bit flags */
#define protection_state_enable_flags (*(volatile uint16_t*)0x008035E2UL) /* Protection state enable/disable flags register ... */
#define diagnostic_service_enable_flags (*(volatile uint8_t*)0x008035EAUL) /* Diagnostic service enable flags (DIAG_ENABLE_FL... */
#define vp44_status_flags_2 (*(volatile uint16_t*)0x008035ECUL) /* VP44 status flags 2 - bit 1 (0x02) affects pin ... */
#define derate_percentage_active (*(volatile uint16_t*)0x00803614UL) /* Active derate percentage */
#define engine_operating_mode_flags (*(volatile uint16_t*)0x00803618UL) /* Engine operating mode flags (2 refs) */
#define vp44_comm_bit0_counter (*(volatile uint16_t*)0x00803678UL) /* VP44 comm bit0 transition counter (vp44_status_... */
#define eeprom_calibration_write_state (*(volatile uint8_t*)0x0080367AUL) /* EEPROM calibration write state and validation (... */
#define eeprom_calibration_check_value_1 (*(volatile uint16_t*)0x0080367CUL) /* EEPROM calibration check value 1 (2 refs) */
#define loop_termination_flag (*(volatile uint16_t*)0x0080367EUL) /* Loop exit comparison flag (3 refs) */
#define protection_flag_source_1 (*(volatile uint16_t*)0x00803680UL) /* Protection flag accumulator source 1 (protectio... */
#define eeprom_calibration_check_value_2 (*(volatile uint16_t*)0x00803682UL) /* EEPROM calibration check value 2 (4 refs) */
#define eeprom_calibration_check_value_3 (*(volatile uint16_t*)0x00803684UL) /* EEPROM calibration check value 3 (2 refs) */
#define vp44_comm_test_flag (*(volatile uint16_t*)0x00803686UL) /* VP44 communication test flag */
#define vp44_comm_test_sensor_value (*(volatile uint16_t*)0x00803688UL) /* VP44 communication test redundant sensor value ... */
#define redundant_sensor_param_1 (*(volatile uint16_t*)0x0080368AUL) /* Redundant sensor parameter 1 (4 refs) */
#define redundant_sensor_param_2 (*(volatile uint16_t*)0x0080368CUL) /* Redundant sensor parameter 2 (3 refs) */
#define redundant_sensor_param_3 (*(volatile uint16_t*)0x0080368EUL) /* Redundant sensor parameter 3 (3 refs) */
#define protection_flag_source_2 (*(volatile uint16_t*)0x00803692UL) /* Protection flag accumulator source 2 (protectio... */
#define governor_rpm_error_init_value (*(volatile uint16_t*)0x00803698UL) /* Initial value for governor_rpm_error_value in e... */
#define fuel_demand_rate_limit_init (*(volatile uint16_t*)0x0080369AUL) /* Fuel demand rate limit init value (1 ref) */
#define oil_pressure_rpm_limit_max (*(volatile uint16_t*)0x008036A2UL) /* Oil pressure RPM limit maximum value (4 refs) */
#define vp44_comm_fault_monitor_state (*(volatile uint16_t*)0x008036BAUL) /* VP44 communication fault monitor state (9 refs) */
#define diagnostic_mode_7_enable_flag (*(volatile uint16_t*)0x008036EAUL) /* Diagnostic status 7 enable flag (1 ref) */
#define high_rpm_protection_initial_timer (*(volatile uint16_t*)0x008036FCUL) /* High RPM protection initial timer value */
#define oil_pressure_rpm_target_low (*(volatile uint16_t*)0x00803706UL) /* Oil pressure RPM target low value (2 refs) */
#define oil_pressure_rpm_target_high (*(volatile uint16_t*)0x0080370AUL) /* Oil pressure RPM target high value (2 refs) */
#define crank_fuel_timing_buffer_value (*(volatile uint16_t*)0x00803734UL) /* Crank fuel and timing buffer stored value (11 r... */
#define crank_mode_1_calibration_factor (*(volatile uint16_t*)0x00803736UL) /* Crank mode 1 calibration factor (3 refs) */
#define param_scaling_lookup_value (*(volatile uint16_t*)0x00803738UL) /* Parameter scaling system lookup value (3 refs) */
#define crank_fuel_threshold_divisor (*(volatile uint16_t*)0x0080373AUL) /* Crank fuel threshold divisor (1 ref) */
#define eps_signal_quality_threshold (*(volatile uint16_t*)0x0080373CUL) /* EPS signal quality validator threshold (epsSign... */
#define crank_fuel_timing_state (*(volatile uint16_t*)0x00803740UL) /* Crank fuel timing state machine value (9 refs) */
#define fuel_timing_transition_state_3744 (*(volatile uint16_t*)0x00803744UL) /* Fuel timing transition state value (9 refs) */
#define fuel_timing_transition_limit (*(volatile uint16_t*)0x00803746UL) /* Fuel timing transition state machine limit valu... */
#define boost_pressure_target_pointer (*(volatile uint16_t*)0x00803748UL) /* Boost pressure target calculation pointer (7 refs) */
#define vp44_fault_calc_factor_2 (*(volatile uint16_t*)0x0080374AUL) /* VP44 fault calculation factor 2 (3 refs) */
#define vp44_sensor_type_selector (*(volatile uint16_t*)0x0080374CUL) /* VP44 sensor type selector 1=primary 2=secondary... */
#define sensor_fault_debounce_limit (*(volatile uint16_t*)0x00803750UL) /* Sensor fault debounce monitor limit (sensorFaul... */
#define fuel_timing_mode_arb_value (*(volatile uint16_t*)0x00803782UL) /* Fuel timing mode arbitration value (fuelTimingM... */
#define vp44_timing_condition_value (*(volatile uint16_t*)0x00803784UL) /* VP44 timing condition checker value (vp44Timing... */
#define insite_diagnostic_lower_bound (*(volatile uint16_t*)0x00803786UL) /* INSITE diagnostic reading lower bound (2 refs) */
#define throttle_validator_enable_flag (*(volatile uint16_t*)0x00803788UL) /* Throttle position validator enable flag (1 ref) */
#define vp44_forced_status_7 (*(volatile uint8_t*)0x00803790UL) /* VP44 forced status 7 (vp44_status_data_collector) */
#define vp44_forced_status_8 (*(volatile uint8_t*)0x00803791UL) /* VP44 forced status 8 (vp44_status_data_collector) */
#define vp44_forced_status_9 (*(volatile uint8_t*)0x00803792UL) /* VP44 forced status 9 (vp44_status_data_collector) */
#define oil_pressure_override_mode (*(volatile uint16_t*)0x0080379AUL) /* Oil pressure mode override selector (0=normal 1... */
#define oil_pressure_mode_active_flag (*(volatile uint16_t*)0x0080379CUL) /* Flag indicating oil pressure control mode is ac... */
#define fuel_demand_mode_selector_value (*(volatile uint16_t*)0x0080379EUL) /* Fuel demand mode selector value (fuelDemandMode... */
#define fuel_demand_mode_override (*(volatile uint16_t*)0x008037A0UL) /* Fuel demand mode override value (fuelDemandMode... */
#define fuel_timing_base_offset (*(volatile uint16_t*)0x008037AEUL) /* Fuel timing base offset value */
#define fuel_demand_blend_param_1 (*(volatile uint16_t*)0x008037B0UL) /* Fuel demand table blend parameter 1 (fuelDemand... */
#define fuel_demand_blend_param_2 (*(volatile uint16_t*)0x008037B2UL) /* Fuel demand table blend parameter 2 (fuelDemand... */
#define shutdown_protection_timer (*(volatile uint16_t*)0x008037B4UL) /* Shutdown protection countdown timer */
#define can_priority_table_start (*(volatile uint8_t*)0x008037B6UL) /* CAN message priority lookup table start (J1939 ... */
#define j1939_priority_pgn65269 (*(volatile uint8_t*)0x008037B8UL) /* J1939 priority byte for PGN 65269 ambient condi... */
#define j1939_priority_pgn65265 (*(volatile uint8_t*)0x008037BAUL) /* J1939 priority byte for PGN 65265 cruise contro... */
#define j1939_priority_pgn65259 (*(volatile uint8_t*)0x008037BCUL) /* J1939 priority byte for PGN 65259 engine serial... */
#define j1939_priority_pgn65226 (*(volatile uint8_t*)0x008037BEUL) /* J1939 priority byte for PGN 65226 engine coolan... */
#define j1939_priority_pgn65227 (*(volatile uint8_t*)0x008037C0UL) /* J1939 priority byte for PGN 65227 DM2 (diagnost... */
#define j1939_priority_pgn65229 (*(volatile uint8_t*)0x008037C2UL) /* J1939 priority byte for PGN 65229 DM4 (diagnost... */
#define j1939_priority_pgn65230 (*(volatile uint8_t*)0x008037C4UL) /* J1939 priority byte for PGN 65230 DM5 (diagnost... */
#define j1939_priority_pgn65232 (*(volatile uint8_t*)0x008037C6UL) /* J1939 priority byte for PGN 65232 DM8 (diagnost... */
#define j1939_priority_pgn65234 (*(volatile uint8_t*)0x008037C8UL) /* J1939 priority byte for PGN 65234 DM11 (diagnos... */
#define j1939_priority_vp44_cmd_256 (*(volatile uint8_t*)0x008037CAUL) /* J1939 priority byte for VP44 command 0x100 (vp4... */
#define can_priority_dm983 (*(volatile uint8_t*)0x008037CCUL) /* CAN priority for Cummins DM-983 diagnostic message */
#define j1939_priority_pgn65247 (*(volatile uint8_t*)0x008037CEUL) /* J1939 priority byte for PGN 65247 electronic en... */
#define j1939_priority_pgn65251 (*(volatile uint8_t*)0x008037D0UL) /* J1939 priority byte for PGN 65251 extended diag... */
#define j1939_priority_pgn65263 (*(volatile uint8_t*)0x008037D2UL) /* J1939 priority byte for PGN 65263 fluid level (... */
#define retarder_mode_threshold_value_37d4 (*(volatile uint16_t*)0x008037D4UL) /* Retarder mode threshold calculation value (12 r... */
#define j1939_priority_pgn15728640 (*(volatile uint8_t*)0x008037D6UL) /* J1939 priority byte for PGN 15728640 Cummins TS... */
#define j1939_priority_pgn65262 (*(volatile uint8_t*)0x008037D8UL) /* J1939 priority byte for PGN 65262 engine temp (... */
#define j1939_priority_pgn65257 (*(volatile uint8_t*)0x008037DAUL) /* J1939 priority byte for PGN 65257 intake exhaus... */
#define j1939_priority_pgn65266 (*(volatile uint8_t*)0x008037DCUL) /* J1939 priority byte for PGN 65266 fuel economy ... */
#define j1939_priority_pgn65244 (*(volatile uint8_t*)0x008037DEUL) /* J1939 priority byte for PGN 65244 I/O control (... */
#define j1939_priority_pgn65252 (*(volatile uint8_t*)0x008037E0UL) /* J1939 priority byte for PGN 65252 engine hours ... */
#define j1939_priority_pgn65526 (*(volatile uint8_t*)0x008037E2UL) /* J1939 priority byte for PGN 65526 intake manifo... */
#define j1939_priority_pgn65264 (*(volatile uint8_t*)0x008037E6UL) /* J1939 priority byte for PGN 65264 cruise contro... */
#define j1939_priority_pgn65249 (*(volatile uint8_t*)0x008037E8UL) /* J1939 priority byte for PGN 65249 retarder conf... */
#define j1939_priority_pgn65248 (*(volatile uint8_t*)0x008037EAUL) /* J1939 priority byte for PGN 65248 vehicle dista... */
#define j1939_priority_pgn65527 (*(volatile uint8_t*)0x008037ECUL) /* J1939 priority byte for PGN 65527 electronic br... */
#define j1939_priority_pgn65255 (*(volatile uint8_t*)0x008037EEUL) /* J1939 priority byte for PGN 65255 vehicle hours... */
#define diagnostic_command_state_init (*(volatile uint16_t*)0x008037F0UL) /* Diagnostic command state initial value (initDia... */
#define rpm_source_selector_flag (*(volatile uint16_t*)0x008037F2UL) /* RPM source selector flag 1=use init (rpmSourceS... */
#define oil_pressure_rpm_increment (*(volatile uint16_t*)0x008037F6UL) /* Oil pressure RPM limit increment (2 refs) */
#define sensor_status_history_pointer_37f8 (*(volatile uint16_t*)0x008037F8UL) /* Sensor status history tracker data pointer (6 r... */
#define oil_pressure_rpm_limit_min (*(volatile uint16_t*)0x008037FAUL) /* Oil pressure RPM limit minimum value (4 refs) */
#define oil_pressure_state_index_limit (*(volatile uint16_t*)0x008037FCUL) /* Oil pressure state index limit (sensorStatusHis... */
#define oil_pressure_rpm_target_special (*(volatile uint16_t*)0x00803806UL) /* Oil pressure RPM target special value (oilPress... */
#define oil_pressure_rpm_limit_reference (*(volatile uint16_t*)0x0080380AUL) /* Oil pressure RPM limit reference (oil_pressure_... */
#define fuel_demand_scale_multiplier (*(volatile uint16_t*)0x0080380EUL) /* Fuel demand scale factor multiplier (fuelDemand... */
#define fuel_statistics_base_offset_3814 (*(volatile uint32_t*)0x00803814UL) /* Fuel statistics base offset for calculation (2 ... */
#define rpm_histogram_base_rpm (*(volatile uint16_t*)0x00803818UL) /* RPM histogram base RPM for binning (2 refs) */
#define diagnostic_mode_fuel_limit_value (*(volatile uint16_t*)0x0080381AUL) /* Diagnostic mode fuel limit value (diagnosticMod... */
#define diagnostic_source_5_param_value (*(volatile uint16_t*)0x0080381CUL) /* Diagnostic source 5 parameter value (setDiagnos... */
#define protection_threshold_offset (*(volatile uint16_t*)0x00803820UL) /* Protection threshold offset value */
#define fuel_timing_transition_offset (*(volatile uint16_t*)0x00803822UL) /* Fuel timing transition offset value (2 refs) */
#define protection_init_mode_param (*(volatile uint16_t*)0x00803824UL) /* Protection init mode parameter (engine_protecti... */
#define protection_init_timing_param_2 (*(volatile uint16_t*)0x00803826UL) /* Protection init timing parameter 2 (engine_prot... */
#define vp44_boost_pressure_reference (*(volatile uint16_t*)0x00803828UL) /* VP44 fault boost pressure reference value (6 refs) */
#define fuel_gain_multiplier (*(volatile uint16_t*)0x0080382CUL) /* Fuel gain multiplier for diagnostic calc (2 refs) */
#define boost_pressure_scale_divisor_3830 (*(volatile uint16_t*)0x00803830UL) /* Boost pressure scale divisor (1 ref) */
#define boost_pressure_override_enable (*(volatile uint16_t*)0x00803832UL) /* Boost pressure override enable flag (1 ref) */
#define fuel_demand_limit_special_value (*(volatile uint16_t*)0x00803836UL) /* Fuel demand limit special value (fuelDemandLimi... */
#define fuel_temp_vp44_diagnostic_enable (*(volatile uint16_t*)0x00803838UL) /* Fuel temp VP44 diagnostic enable flag (5 refs) */
#define fuel_temp_protection_threshold_383c (*(volatile uint16_t*)0x0080383CUL) /* Fuel temp protection timer threshold (5 refs) */
#define fuel_temp_throttle_low_threshold (*(volatile uint16_t*)0x00803840UL) /* Fuel temp throttle low threshold (2 refs) */
#define fuel_temp_throttle_high_threshold (*(volatile uint16_t*)0x00803842UL) /* Fuel temp throttle high threshold (1 ref) */
#define fuel_temp_calc_multiplier (*(volatile uint16_t*)0x00803846UL) /* Fuel temp calculation multiplier (1 ref) */
#define crank_fuel_mode_3_divisor (*(volatile uint16_t*)0x0080384AUL) /* Crank fuel timing mode 3 divisor value (3 refs) */
#define timer_capture_low_threshold (*(volatile uint16_t*)0x0080384EUL) /* Timer capture low threshold for clutch calc (1 ... */
#define timer_capture_high_threshold (*(volatile uint16_t*)0x00803852UL) /* Timer capture high threshold for clutch calc (1... */
#define derate_table_pointer_init (*(volatile uint16_t*)0x00803856UL) /* Derate table pointer init value (derateTablePoi... */
#define qsm_newqp_multiplier (*(volatile uint16_t*)0x0080385AUL) /* QSM NEWQP shift multiplier (2 refs) */
#define vp44_fault_calc_factor_1 (*(volatile uint16_t*)0x0080385CUL) /* VP44 fault calculation factor 1 (2 refs) */
#define vp44_fault_detection_enable (*(volatile uint16_t*)0x0080385EUL) /* VP44 fault detection enable flag (3 refs) */
#define boost_pressure_low_limit (*(volatile uint16_t*)0x00803864UL) /* Boost pressure low limit */
#define boost_pressure_high_limit (*(volatile uint16_t*)0x00803866UL) /* Boost pressure high limit */
#define boost_pressure_low_offset (*(volatile uint16_t*)0x00803868UL) /* Boost pressure low limit offset (1 ref) */
#define boost_pressure_high_offset (*(volatile uint16_t*)0x0080386AUL) /* Boost pressure high limit offset (1 ref) */
#define vp44_timing_base_value (*(volatile uint16_t*)0x0080386CUL) /* VP44 timing base value for limit calc (2 refs) */
#define vehicle_distance_base_value (*(volatile uint32_t*)0x00803870UL) /* Vehicle distance data base value (1 ref) */
#define oil_pressure_mode_flag_1 (*(volatile uint16_t*)0x00803874UL) /* Oil pressure mode flag 1 for table select (1 ref) */
#define oil_pressure_mode_flag_2 (*(volatile uint16_t*)0x00803876UL) /* Oil pressure mode flag 2 for table select (1 ref) */
#define vp44_fault_protection_threshold (*(volatile uint16_t*)0x0080387EUL) /* VP44 fault protection controller threshold (10 ... */
#define rpm_derate_calculation_table_ptr (*(volatile uint16_t*)0x00803880UL) /* RPM derate calculation table pointer (13 refs) */
#define can_message_buffer_end (*(volatile uint8_t*)0x00803882UL) /* End marker for CAN message buffer logging range */
#define ecu_identity_header ((volatile uint8_t*)0x00803B00UL) /* ECU identity block header - VERIFIED via RAM dump */
#define ecu_identity_marker_1 (*(volatile uint16_t*)0x00803B0AUL) /* ECU identity marker 0x600D - VERIFIED via RAM dump */
#define ecu_identity_test_pattern ((volatile uint8_t*)0x00803B0CUL) /* ECU identity test pattern ABCDEF - VERIFIED via... */
#define ecu_serial_number ((volatile uint8_t*)0x00803B15UL) /* ECU serial number (e.g. T03942860) - VERIFIED v... */
#define ecu_unit_marker ((volatile uint8_t*)0x00803B44UL) /* ECU unit marker ENUU - VERIFIED via RAM dump */
#define ecu_build_date ((volatile uint8_t*)0x00803B88UL) /* ECU build date string MMDDYY format (e.g. 06049... */
#define calibration_id_string ((volatile uint8_t*)0x00803E1DUL) /* Calibration ID (e.g. J90350.00 100898231658) - ... */
#define oem_name_string ((volatile uint8_t*)0x00803E60UL) /* OEM name string (e.g. GENERIC) - VERIFIED via R... */
#define part_number_list ((volatile uint8_t*)0x00803EC2UL) /* Concatenated part number strings - VERIFIED via... */
#define flash_program_block_1_buffer (*(volatile uint32_t*)0x00804882UL) /* Flash program block 1 RAM buffer start (4 refs) */
#define flash_program_block_2_buffer (*(volatile uint16_t*)0x0080488EUL) /* Flash program block 2 RAM buffer start (4 refs) */
#define calibration_validator_ptr (*(volatile uint32_t*)0x008049ECUL) /* Calibration validator data pointer (calibration... */
#define output_control_countdown_timer (*(volatile uint16_t*)0x00804A0AUL) /* Output control status countdown timer (3 refs) */
#define engine_run_counter_snapshot_1 (*(volatile uint32_t*)0x00804A0CUL) /* Engine run counter snapshot 1 (engineRunTimeHis... */
#define engine_run_counter_snapshot_2 (*(volatile uint32_t*)0x00804A10UL) /* Engine run counter snapshot 2 (engineRunTimeHis... */
#define engine_run_counter_snapshot_0 (*(volatile uint32_t*)0x00804A14UL) /* Engine run counter snapshot 0 (engineRunTimeHis... */
#define hour_meter_stored_ticks (*(volatile uint16_t*)0x00804A18UL) /* Hour meter stored tick count (4 refs) */
#define histogram_stored_ticks (*(volatile uint16_t*)0x00804A1AUL) /* Histogram stored tick count (4 refs) */
#define engine_runtime_total_counter (*(volatile uint32_t*)0x00804A1CUL) /* Total engine runtime counter (max 3600000000) (... */
#define runtime_histogram_array_1 (*(volatile uint16_t*)0x00804A20UL) /* Runtime histogram array 1 base (3 refs) */
#define runtime_histogram_array_2 (*(volatile uint16_t*)0x00804A86UL) /* Runtime histogram array 2 base (3 refs) */
#define derate_threshold_setpoint (*(volatile uint16_t*)0x00804BB6UL) /* Derate threshold setpoint value */
#define insite_fuel_statistics_output (*(volatile uint32_t*)0x00804BB8UL) /* INSITE fuel statistics output (1 ref) */
#define clutch_operating_stats_output (*(volatile uint32_t*)0x00804BBCUL) /* Clutch operating statistics output value (4 refs) */
#define vehicle_distance_statistics_value (*(volatile uint32_t*)0x00804BC0UL) /* Vehicle distance data builder statistics value ... */
#define vehicle_distance_clutch_value (*(volatile uint32_t*)0x00804BC4UL) /* Vehicle distance clutch transition value (3 refs) */
#define fuel_economy_statistics_output (*(volatile uint16_t*)0x00804BC8UL) /* Fuel economy data builder statistics output (6 ... */
#define clutch_transitions_per_distance (*(volatile uint16_t*)0x00804BCAUL) /* Clutch transitions per distance output (4 refs) */
#define insite_runtime_hours_accumulator (*(volatile uint32_t*)0x00804BCCUL) /* INSITE runtime hours accumulator (1 ref) */
#define insite_command_base_value (*(volatile uint32_t*)0x00804BD0UL) /* INSITE command dispatcher base value (1 ref) */
#define insite_idle_hours_accumulator (*(volatile uint32_t*)0x00804BD4UL) /* INSITE idle hours accumulator (1 ref) */
#define vehicle_hours_statistics_value (*(volatile uint32_t*)0x00804BD8UL) /* Vehicle hours data builder statistics value (4 ... */
#define derate_vp44_status_flag (*(volatile uint8_t*)0x00804BDCUL) /* Derate VP44 communication status flag (1 ref) */
#define overspeed_event_active_flag (*(volatile uint16_t*)0x00804D80UL) /* Overspeed event recording active flag */
#define overspeed_event_buffer_index (*(volatile uint16_t*)0x00804D82UL) /* Overspeed event circular buffer index */
#define engine_startup_inhibit_flag (*(volatile uint16_t*)0x00804D84UL) /* Engine startup inhibit flag */
#define engine_mode_transition_timer_array (*(volatile uint16_t*)0x00804D86UL) /* Engine mode transition timer array base (4 refs) */
#define protection_state2_output_value (*(volatile uint16_t*)0x00804DE0UL) /* Protection state 2 threshold output value (1 ref) */
#define diagnostic_protection_state (*(volatile uint16_t*)0x00804E76UL) /* Diagnostic protection evaluator state (12 refs) */
#define protection_state_4_emergency_counter (*(volatile uint16_t*)0x00804E78UL) /* Protection state 4 emergency handler counter (6... */
#define retry_counter_byte (*(volatile uint8_t*)0x00804E7AUL) /* Retry counter incremented to max 0xff (3 refs) */
#define diagnostic_pending_code_count (*(volatile uint8_t*)0x00804E7CUL) /* Diagnostic pending code count - accessed via su... */
#define diagnostic_pending_code_array (*(volatile uint8_t*)0x00804E7DUL) /* Diagnostic pending code array[31] - codes waiti... */
#define diagnostic_active_code_count (*(volatile uint8_t*)0x00804E9CUL) /* Diagnostic active code count - accessed via sub... */
#define diagnostic_active_code_array (*(volatile uint8_t*)0x00804E9DUL) /* Diagnostic active code array[31] - currently ac... */
#define diagnostic_pending_list_count (*(volatile uint16_t*)0x00804EBCUL) /* Diagnostic pending code list counter (7 refs) */
#define diagnostic_code_status_count (*(volatile uint16_t*)0x00804EFCUL) /* Diagnostic code status active count - accessed ... */
#define diagnostic_code_status_reserved (*(volatile uint16_t*)0x00804EFEUL) /* Diagnostic code status reserved */
#define diagnostic_state_machine_counter (*(volatile uint16_t*)0x00804F38UL) /* Diagnostic state machine iteration counter (9 r... */
#define diagnostic_state_machine_index (*(volatile uint16_t*)0x00804F3CUL) /* Diagnostic state machine processor index (10 refs) */
#define diagnostic_queue_iterator_index (*(volatile uint16_t*)0x00804F3EUL) /* Diagnostic queue iterator index (18 refs) */
#define insite_fault_detail_state (*(volatile uint16_t*)0x00804F40UL) /* INSITE fault detail builder state (12 refs) */
#define insite_fault_detail_index (*(volatile uint16_t*)0x00804F42UL) /* INSITE fault detail builder index (10 refs) */
#define diagnostic_active_fault_counter (*(volatile uint16_t*)0x00804F44UL) /* Active diagnostic fault count tracker (7 refs) */
#define accumulated_amount_of_fuel_used_during_vehicle_operatio_0_0_10000000 (*(volatile uint32_t*)0x00804FB8UL) /* ACCUMULATED AMOUNT OF FUEL USED DURING VEHICLE ... */
#define ivs_switch_status_when_throttle_validation_process_error_true_false (*(volatile uint16_t*)0x00804FC8UL) /* IVS SWITCH STATUS WHEN THROTTLE_VALIDATION_PROC... */
#define diagnostic_pid_dtc_index (*(volatile uint8_t*)0x00804FCDUL) /* Diagnostic PID/DTC index for Insite */
#define duty_cycle_mon_approxiamte_short_term_map_1_start_0_0_50000_0 (*(volatile uint32_t*)0x00805388UL) /* DUTY CYCLE MON APPROXIAMTE SHORT TERM MAP 1 START */
#define duty_cycle_mon_approxiamte_short_term_map_2_start_0_0_50000_0 (*(volatile uint32_t*)0x0080538CUL) /* DUTY CYCLE MON APPROXIAMTE SHORT TERM MAP 2 START */
#define duty_cycle_mon_approximate_long_term_map_start_0_0_50000_0 (*(volatile uint32_t*)0x00805390UL) /* DUTY CYCLE MON APPROXIMATE LONG TERM MAP START */
#define duty_cycle_monitor_short_term_map_1_total_time_0_0_500_0 (*(volatile uint16_t*)0x00805394UL) /* DUTY CYCLE MONITOR SHORT TERM MAP 1 TOTAL TIME */
#define duty_cycle_monitor_short_term_map_2_total_time_0_0_500_0 (*(volatile uint16_t*)0x00805396UL) /* DUTY CYCLE MONITOR SHORT TERM MAP 2 TOTAL TIME */
#define duty_cycle_monitor_long_term_map_total_time_0_0_100000_0 (*(volatile uint32_t*)0x00805398UL) /* DUTY CYCLE MONITOR LONG TERM MAP TOTAL TIME */
#define DCMNMP01 (*(volatile uint16_t*)0x0080539CUL) /* CalTerm DCMNMP01: DUTY CYCLE MON. STORED SHORT ... */
#define DCMNMP02 (*(volatile uint16_t*)0x00805404UL) /* CalTerm DCMNMP02: DUTY CYCLE MONITOR SHORT TERM... */
#define DCMNLGMP (*(volatile uint32_t*)0x0080546CUL) /* CalTerm DCMNLGMP: DUTY CYCLE MONITOR LONG TERM ... */
#define j1939_message_type_total_counter (*(volatile uint16_t*)0x008054A6UL) /* J1939 message type classifier counter (7 refs) */
#define vp44_sensor_diag_counter (*(volatile uint16_t*)0x008054A8UL) /* VP44 sensor diagnostic control counter (5 refs) */
#define rpm_histogram_bin_1_counter (*(volatile uint16_t*)0x008054ACUL) /* RPM histogram bin 1 counter (3 refs) */
#define loop_counter_snapshot_0 (*(volatile uint16_t*)0x008054AEUL) /* Loop counter snapshot 0 (2 refs) */
#define rpm_histogram_bin_2_counter (*(volatile uint16_t*)0x008054B2UL) /* RPM histogram bin 2 counter (3 refs) */
#define loop_counter_snapshot_1 (*(volatile uint16_t*)0x008054B4UL) /* Loop counter snapshot 1 (2 refs) */
#define rpm_histogram_overflow_counter (*(volatile uint16_t*)0x008054B8UL) /* RPM histogram overflow bin counter (3 refs) */
#define loop_counter_snapshot_2 (*(volatile uint16_t*)0x008054BAUL) /* Loop counter snapshot 2 (2 refs) */
#define DGRPOSLF ((volatile uint8_t*)0x0080553AUL) /* [40] CalTerm DGRPOSLF: FAULT LOG FOR ENGINE SPEED OV... */
#define diagnostic_snapshot_limited_byte (*(volatile uint8_t*)0x0080553BUL) /* Diagnostic snapshot limited value byte (diagnos... */
#define diagnostic_snapshot_fuel_mode_0 (*(volatile uint16_t*)0x0080553CUL) /* Diagnostic snapshot fuel mode 0 (diagnosticGrou... */
#define vp44_sensor_diag_state_1 (*(volatile uint16_t*)0x0080553EUL) /* VP44 sensor diagnostic control state 1 (5 refs) */
#define fuel_arbitrator_rpm_target_history (*(volatile uint16_t*)0x00805540UL) /* Fuel arbitrator RPM target history array (3 refs) */
#define diagnostic_snapshot_zero_0 (*(volatile uint16_t*)0x00805542UL) /* Diagnostic snapshot zero value 0 (diagnosticGro... */
#define diagnostic_snapshot_zero_1 (*(volatile uint16_t*)0x00805544UL) /* Diagnostic snapshot zero value 1 (diagnosticGro... */
#define diagnostic_snapshot_zero_2 (*(volatile uint16_t*)0x00805546UL) /* Diagnostic snapshot zero value 2 (diagnosticGro... */
#define fuel_arbitrator_rpm_history_index (*(volatile uint16_t*)0x00805548UL) /* Fuel arbitrator RPM history array index (3 refs) */
#define loop_counter_capture_start_2 (*(volatile uint32_t*)0x0080554AUL) /* Loop counter capture start for timing measureme... */
#define loop_counter_elapsed_time_2 (*(volatile uint32_t*)0x0080554EUL) /* Loop counter elapsed time measurement 2 (3 refs) */
#define diagnostic_snapshot_position_flag (*(volatile uint8_t*)0x00805554UL) /* Diagnostic group snapshot position flag (diagno... */
#define diagnostic_snapshot_byte_1 (*(volatile uint8_t*)0x00805555UL) /* Diagnostic snapshot byte 1 from DAT_0080cfad (d... */
#define diagnostic_snapshot_fuel_mode_1 (*(volatile uint16_t*)0x00805556UL) /* Diagnostic snapshot fuel mode 1 (diagnosticGrou... */
#define vp44_sensor_diag_state_2 (*(volatile uint16_t*)0x00805558UL) /* VP44 sensor diagnostic control state 2 (5 refs) */
#define fuel_arbitrator_state_history (*(volatile uint16_t*)0x0080555AUL) /* Fuel arbitrator state history array (3 refs) */
#define diagnostic_snapshot_zero_3 (*(volatile uint16_t*)0x0080555CUL) /* Diagnostic snapshot zero value 3 (diagnosticGro... */
#define diagnostic_snapshot_zero_4 (*(volatile uint16_t*)0x0080555EUL) /* Diagnostic snapshot zero value 4 (diagnosticGro... */
#define diagnostic_snapshot_zero_5 (*(volatile uint16_t*)0x00805560UL) /* Diagnostic snapshot zero value 5 (diagnosticGro... */
#define DGCLLVLF ((volatile uint8_t*)0x00805562UL) /* [40] CalTerm DGCLLVLF: KEEPS HISTORY OF COOLANT_LEVE... */
#define loop_counter_capture_start_1 (*(volatile uint32_t*)0x00805564UL) /* Loop counter capture start for timing measureme... */
#define loop_counter_elapsed_time_1 (*(volatile uint32_t*)0x00805568UL) /* Loop counter elapsed time measurement 1 (3 refs) */
#define diagnostic_capture_active_flag (*(volatile uint16_t*)0x0080556CUL) /* Diagnostic data capture active flag (4 refs) */
#define timing_measurement_active_flag_1 (*(volatile uint16_t*)0x0080556EUL) /* Timing measurement 1 active flag (0/1) (3 refs) */
#define diagnostic_snapshot_fuel_mode_capture (*(volatile uint16_t*)0x00805570UL) /* Diagnostic snapshot fuel mode capture (diagnost... */
#define diagnostic_snapshot_retarder_mode (*(volatile uint16_t*)0x00805572UL) /* Diagnostic snapshot retarder mode (diagnosticGr... */
#define diagnostic_buffer_write_index (*(volatile uint16_t*)0x00805574UL) /* Diagnostic buffer circular write index (0-4) (4... */
#define serial_transmit_ready_flag (*(volatile uint8_t*)0x00805576UL) /* Serial transmit handler ready flag (serialTrans... */
#define fuel_arbitrator_overflow_counter_1 (*(volatile uint16_t*)0x00805578UL) /* Fuel arbitrator overflow counter 1 (4 refs) */
#define fuel_arbitrator_overflow_counter_2 (*(volatile uint16_t*)0x0080557AUL) /* Fuel arbitrator overflow counter 2 (3 refs) */
#define fuel_timing_offset_state_backup (*(volatile uint16_t*)0x0080557CUL) /* Fuel timing offset state backup (vp44 status) (... */
#define crank_fuel_delta_accumulator (*(volatile uint16_t*)0x0080557EUL) /* Crank fuel delta accumulator (5 refs) */
#define crank_fuel_over_limit_snapshot (*(volatile uint32_t*)0x00805582UL) /* Crank fuel over-limit snapshot value (4 refs) */
#define crank_timing_delta_accumulator (*(volatile uint16_t*)0x00805586UL) /* Crank timing delta accumulator (5 refs) */
#define DGCLTPLF ((volatile uint8_t*)0x0080558AUL) /* [40] CalTerm DGCLTPLF: KEEPS HISTORY OF COOLANT_TEMP... */
#define crank_fuel_status_flags (*(volatile uint16_t*)0x0080558EUL) /* Crank fuel calculation status bit flags */
#define crank_fuel_buffer_index (*(volatile uint16_t*)0x00805590UL) /* Crank fuel and timing buffer index (9 refs) */
#define DGLOPRLF ((volatile uint8_t*)0x008055DAUL) /* [40] CalTerm DGLOPRLF: KEEPS HISTORY OF LOW_OIL_PRES... */
#define DGVYPRLF ((volatile uint8_t*)0x00805602UL) /* [40] CalTerm DGVYPRLF: KEEPS HISTORY OF VERY_LOW_OIL... */
#define fault_code_active_list_count (*(volatile uint16_t*)0x0080561EUL) /* Count of active faults in list (7 refs) */
#define hour_meter_event_log_array ((volatile uint8_t*)0x00805620UL) /* [2] Hour meter event log array start (hourMeterEven... */
#define hour_meter_event_log_array_1 (*(volatile uint8_t*)0x00805621UL) /* Hour meter event log array element 1 (hourMeter... */
#define dtc_active_fault_count (*(volatile uint16_t*)0x00805670UL) /* Active DTC fault count */
#define dtc_timestamp_array (*(volatile uint32_t*)0x00805676UL) /* DTC timestamp array base */
#define engine_startup_inhibit_true_false (*(volatile uint16_t*)0x008057BEUL) /* ENGINE STARTUP INHIBIT [CalTerm: CKEGSRIH] */
#define coolant_level_fueling_severity_index_0_0_1_0 (*(volatile uint16_t*)0x008057C0UL) /* COOLANT LEVEL FUELING SEVERITY INDEX */
#define severity_index_for_epf_coolant_level_fault_0_0_1_0 (*(volatile uint16_t*)0x008057C2UL) /* SEVERITY INDEX FOR EPF COOLANT LEVEL FAULT. */
#define coolant_level_fueling_restart_severity_index_0_0_1_0 (*(volatile uint16_t*)0x008057C4UL) /* COOLANT LEVEL FUELING RESTART SEVERITY INDEX */
#define coolant_level_rpm_restart_severity_index_0_0_1_0 (*(volatile uint16_t*)0x008057C6UL) /* COOLANT LEVEL RPM RESTART SEVERITY INDEX */
#define coolant_level_extremity_time_0_2_32 (*(volatile uint32_t*)0x008057CAUL) /* COOLANT LEVEL EXTREMITY TIME */
#define total_time_coolant_level_fuel_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x008057CEUL) /* TOTAL TIME COOLANT LEVEL FUEL FAULT HAS BEEN AC... */
#define total_time_coolant_level_rpm_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x008057D2UL) /* TOTAL TIME COOLANT LEVEL RPM FAULT HAS BEEN ACTIVE */
#define fault_log_recording_flag_for_coolant_level_fueling_0_1 (*(volatile uint16_t*)0x008057D6UL) /* FAULT LOG RECORDING FLAG FOR COOLANT LEVEL FUELING */
#define index_into_epf_fault_log_for_coolant_level_fueling_0_4 (*(volatile uint16_t*)0x008057D8UL) /* INDEX INTO EPF FAULT LOG FOR COOLANT LEVEL FUELING */
#define fault_log_recording_flag_for_coolant_level_rpm_0_1 (*(volatile uint16_t*)0x008057DAUL) /* FAULT LOG RECORDING FLAG FOR COOLANT LEVEL RPM */
#define index_into_epf_fault_log_for_coolant_level_rpm_0_4 (*(volatile uint16_t*)0x008057DCUL) /* INDEX INTO EPF FAULT LOG FOR COOLANT LEVEL RPM */
#define coolant_temp_fueling_severity_index_0_0_1_0 (*(volatile uint16_t*)0x008057DEUL) /* COOLANT TEMP. FUELING SEVERITY INDEX. */
#define severity_index_for_epf_coolant_temperature_fault_0_0_1_0 (*(volatile uint16_t*)0x008057E0UL) /* SEVERITY INDEX FOR EPF COOLANT TEMPERATURE FAULT. */
#define coolant_temp_fueling_restart_severity_index_0_0_1_0 (*(volatile uint16_t*)0x008057E2UL) /* COOLANT TEMP. FUELING RESTART SEVERITY INDEX. */
#define coolant_temp_rpm_restart_severity_index_0_0_1_0 (*(volatile uint16_t*)0x008057E4UL) /* COOLANT TEMP. RPM RESTART SEVERITY INDEX. */
#define coolant_temperature_extremity_time_0_2_32 (*(volatile uint32_t*)0x008057E8UL) /* COOLANT TEMPERATURE EXTREMITY TIME */
#define total_time_coolant_temp_fuel_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x008057ECUL) /* TOTAL TIME COOLANT TEMP FUEL FAULT HAS BEEN ACTIVE */
#define total_time_coolant_temp_rpm_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x008057F0UL) /* TOTAL TIME COOLANT TEMP RPM FAULT HAS BEEN ACTIVE */
#define fault_log_recording_flag_for_coolant_temp_fueling_0_1 (*(volatile uint16_t*)0x008057F4UL) /* FAULT LOG RECORDING FLAG FOR COOLANT TEMP FUELING */
#define index_into_epf_fault_log_for_coolant_temp_fueling_0_4 (*(volatile uint16_t*)0x008057F6UL) /* INDEX INTO EPF FAULT LOG FOR COOLANT TEMP FUELING */
#define fault_log_recording_flag_for_coolant_temp_rpm_0_1 (*(volatile uint16_t*)0x008057F8UL) /* FAULT LOG RECORDING FLAG FOR COOLANT TEMP RPM */
#define index_into_epf_fault_log_for_coolant_temp_rpm_0_4 (*(volatile uint16_t*)0x008057FAUL) /* INDEX INTO EPF FAULT LOG FOR COOLANT TEMP RPM */
#define intake_man_temp_fueling_severity_index_0_0_1_0 (*(volatile uint16_t*)0x008057FCUL) /* INTAKE MAN. TEMP. FUELING SEVERITY INDEX. */
#define intake_man_temp_rpm_severity_index_0_0_1_0 (*(volatile uint16_t*)0x008057FEUL) /* INTAKE MAN. TEMP. RPM SEVERITY INDEX. */
#define intake_man_temp_fueling_restart_severity_index_0_0_1_0 (*(volatile uint16_t*)0x00805800UL) /* INTAKE MAN. TEMP. FUELING RESTART SEVERITY INDEX. */
#define intake_man_temp_rpm_restart_severity_index_0_0_1_0 (*(volatile uint16_t*)0x00805802UL) /* INTAKE MAN. TEMP. RPM RESTART SEVERITY INDEX. */
#define intake_manifold_temperature_extremity_time_0_2_32 (*(volatile uint32_t*)0x00805806UL) /* INTAKE MANIFOLD TEMPERATURE EXTREMITY TIME */
#define total_time_intake_temp_fuel_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x0080580AUL) /* TOTAL TIME INTAKE TEMP FUEL FAULT HAS BEEN ACTIVE */
#define total_time_intake_temp_rpm_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x0080580EUL) /* TOTAL TIME INTAKE TEMP RPM FAULT HAS BEEN ACTIVE */
#define fault_log_recording_flag_for_intake_temp_fueling_0_1 (*(volatile uint16_t*)0x00805812UL) /* FAULT LOG RECORDING FLAG FOR INTAKE TEMP FUELING */
#define index_into_epf_fault_log_for_intake_temp_fueling_0_4 (*(volatile uint16_t*)0x00805814UL) /* INDEX INTO EPF FAULT LOG FOR INTAKE TEMP FUELING */
#define fault_log_recording_flag_for_intake_temp_rpm_0_1 (*(volatile uint16_t*)0x00805816UL) /* FAULT LOG RECORDING FLAG FOR INTAKE TEMP RPM */
#define index_into_epf_fault_log_for_intake_temp_rpm_0_4 (*(volatile uint16_t*)0x00805818UL) /* INDEX INTO EPF FAULT LOG FOR INTAKE TEMP RPM */
#define oil_pressure_fueling_severity_index_0_0_1_0 (*(volatile uint16_t*)0x0080581AUL) /* OIL PRESSURE FUELING SEVERITY INDEX. */
#define severity_index_for_epf_oil_pressure_fault_0_0_1_0 (*(volatile uint16_t*)0x0080581CUL) /* SEVERITY INDEX FOR EPF OIL PRESSURE FAULT. */
#define oil_pressure_fueling_restart_severity_index_0_0_1_0 (*(volatile uint16_t*)0x0080581EUL) /* OIL PRESSURE FUELING RESTART SEVERITY INDEX. */
#define oil_pressure_rpm_restart_severity_index_0_0_1_0 (*(volatile uint16_t*)0x00805820UL) /* OIL PRESSURE RPM RESTART SEVERITY INDEX. */
#define oil_pressure_extremity_time_0_2_32 (*(volatile uint32_t*)0x00805824UL) /* OIL PRESSURE EXTREMITY TIME */
#define total_time_oil_pres_fuel_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x00805828UL) /* TOTAL TIME OIL PRES. FUEL FAULT HAS BEEN ACTIVE */
#define total_time_oil_pres_rpm_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x0080582CUL) /* TOTAL TIME OIL PRES. RPM FAULT HAS BEEN ACTIVE */
#define fault_log_recording_flag_for_oil_pressure_fueling_0_1 (*(volatile uint16_t*)0x00805830UL) /* FAULT LOG RECORDING FLAG FOR OIL PRESSURE FUELING */
#define index_into_epf_fault_log_for_oil_pressure_fueling_0_4 (*(volatile uint16_t*)0x00805832UL) /* INDEX INTO EPF FAULT LOG FOR OIL PRESSURE FUELING */
#define fault_log_recording_flag_for_oil_pressure_rpm_0_1 (*(volatile uint16_t*)0x00805834UL) /* FAULT LOG RECORDING FLAG FOR OIL PRESSURE RPM */
#define index_into_epf_fault_log_for_oil_pressure_rpm_0_4 (*(volatile uint16_t*)0x00805836UL) /* INDEX INTO EPF FAULT LOG FOR OIL PRESSURE RPM */
#define water_in_fuel_fueling_severity_index_0_0_0_1 (*(volatile uint16_t*)0x00805838UL) /* WATER IN FUEL FUELING SEVERITY INDEX */
#define severity_index_for_epf_water_in_fuel_fault_0_0_0_1 (*(volatile uint16_t*)0x0080583AUL) /* SEVERITY INDEX FOR EPF WATER IN FUEL FAULT */
#define water_in_fuel_restart_severity_index_0_0_0_1 (*(volatile uint16_t*)0x0080583CUL) /* WATER IN FUEL RESTART SEVERITY INDEX */
#define water_in_fuel_rpm_restart_severity_index_0_0_0_1 (*(volatile uint16_t*)0x0080583EUL) /* WATER IN FUEL RPM RESTART SEVERITY INDEX */
#define water_in_fuel_extremity_time_0_2_32 (*(volatile uint32_t*)0x00805842UL) /* WATER IN FUEL EXTREMITY TIME */
#define total_time_water_in_fuel_fuel_fault_has_been_active_0_2_32 (*(volatile uint32_t*)0x00805846UL) /* TOTAL TIME WATER IN FUEL FUEL FAULT HAS BEEN AC... */
#define total_time_water_in_fuel_rpm_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x0080584AUL) /* TOTAL TIME WATER IN FUEL RPM FAULT HAS BEEN ACTIVE */
#define fault_log_recording_flag_for_water_in_fuel_fueling_0_1 (*(volatile uint16_t*)0x0080584EUL) /* FAULT LOG RECORDING FLAG FOR WATER IN FUEL FUELING */
#define index_into_epf_fault_log_for_water_in_fuel_fueling_0_4 (*(volatile uint16_t*)0x00805850UL) /* INDEX INTO EPF FAULT LOG FOR WATER IN FUEL FUELING */
#define fault_log_recording_flag_for_water_in_fuel_rpm_0_1 (*(volatile uint16_t*)0x00805852UL) /* FAULT LOG RECORDING FLAG FOR WATER IN FUEL RPM */
#define index_into_epf_fault_log_for_water_in_fuel_0_4 (*(volatile uint16_t*)0x00805854UL) /* INDEX INTO EPF FAULT LOG FOR WATER IN FUEL */
#define boost_pressure_fueling_severity_index_0_0_0_1 (*(volatile uint16_t*)0x00805856UL) /* BOOST PRESSURE FUELING SEVERITY INDEX */
#define severity_index_for_epf_boost_pressure_fault_0_0_0_1 (*(volatile uint16_t*)0x00805858UL) /* SEVERITY INDEX FOR EPF BOOST PRESSURE FAULT */
#define boost_pressure_restart_severity_index_0_0_0_1 (*(volatile uint16_t*)0x0080585AUL) /* BOOST PRESSURE RESTART SEVERITY INDEX */
#define boost_pressure_rpm_restart_severity_index_0_0_0_1 (*(volatile uint16_t*)0x0080585CUL) /* BOOST PRESSURE RPM RESTART SEVERITY INDEX */
#define boost_pressure_extremity_time_0_2_32 (*(volatile uint32_t*)0x00805860UL) /* BOOST PRESSURE EXTREMITY TIME */
#define total_time_boost_pressure_fuel_fault_has_been_active_0_2_32 (*(volatile uint32_t*)0x00805864UL) /* TOTAL TIME BOOST PRESSURE FUEL FAULT HAS BEEN A... */
#define total_time_boost_pressure_rpm_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x00805868UL) /* TOTAL TIME BOOST PRESSURE RPM FAULT HAS BEEN AC... */
#define fault_log_recording_flag_for_boost_pressure_fueling_0_1 (*(volatile uint16_t*)0x0080586CUL) /* FAULT LOG RECORDING FLAG FOR BOOST PRESSURE FUE... */
#define index_into_epf_fault_log_for_boost_pressure_fueling_0_4 (*(volatile uint16_t*)0x0080586EUL) /* INDEX INTO EPF FAULT LOG FOR BOOST PRESSURE FUE... */
#define fault_log_recording_flag_for_boost_pressure_rpm_0_1 (*(volatile uint16_t*)0x00805870UL) /* FAULT LOG RECORDING FLAG FOR BOOST PRESSURE RPM */
#define index_into_epf_fault_log_for_boost_pressure_0_4 (*(volatile uint16_t*)0x00805872UL) /* INDEX INTO EPF FAULT LOG FOR BOOST PRESSURE */
#define engine_sync_fuel_pressure_fueling_severity_index_0_0_0_1 (*(volatile uint16_t*)0x00805874UL) /* ENGINE SYNC FUEL PRESSURE FUELING SEVERITY INDEX */
#define severity_index_for_epf_engine_sync_fuel_pressure_fault_0_0_0_1 (*(volatile uint16_t*)0x00805876UL) /* SEVERITY INDEX FOR EPF ENGINE SYNC FUEL PRESSUR... */
#define eng_sync_fuel_pressure_restart_severity_index_0_0_0_1 (*(volatile uint16_t*)0x00805878UL) /* ENG SYNC FUEL PRESSURE RESTART SEVERITY INDEX */
#define eng_sync_fuel_pressure_rpm_restart_severity_index_0_0_0_1 (*(volatile uint16_t*)0x0080587AUL) /* ENG SYNC FUEL PRESSURE RPM RESTART SEVERITY INDEX */
#define engine_sync_fuel_pressure_extremity_time_0_2_32 (*(volatile uint32_t*)0x0080587EUL) /* ENGINE SYNC FUEL PRESSURE EXTREMITY TIME */
#define total_time_engine_sync_fuel_pressure_fuel_fault_has_been_active_0_2_32 (*(volatile uint32_t*)0x00805882UL) /* TOTAL TIME ENGINE SYNC FUEL PRESSURE FUEL FAULT... */
#define total_time_engine_sync_fuel_pressure_rpm_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x00805886UL) /* TOTAL TIME ENGINE SYNC FUEL PRESSURE RPM FAULT ... */
#define fault_log_recording_flag_for_engine_sync_fuel_pressure_fueling_0_1 (*(volatile uint16_t*)0x0080588AUL) /* FAULT LOG RECORDING FLAG FOR ENGINE SYNC FUEL P... */
#define index_into_epf_fault_log_for_engine_sync_fuel_pressure_fueling_0_4 (*(volatile uint16_t*)0x0080588CUL) /* INDEX INTO EPF FAULT LOG FOR ENGINE SYNC FUEL P... */
#define fault_log_recording_flag_for_engine_sync_fuel_pressure_rpm_0_1 (*(volatile uint16_t*)0x0080588EUL) /* FAULT LOG RECORDING FLAG FOR ENGINE SYNC FUEL P... */
#define index_into_epf_fault_log_for_engine_sync_fuel_pressure_0_4 (*(volatile uint16_t*)0x00805890UL) /* INDEX INTO EPF FAULT LOG FOR ENGINE SYNC FUEL P... */
#define severity_index_for_fuel_temperature_error_0_0_1_0 (*(volatile uint16_t*)0x00805892UL) /* SEVERITY INDEX FOR FUEL TEMPERATURE ERROR */
#define severity_index_for_fuel_temperature_rpm_error_0_0_1_0 (*(volatile uint16_t*)0x00805894UL) /* SEVERITY INDEX FOR FUEL TEMPERATURE RPM ERROR */
#define severity_index_for_fuel_temperature_fuel_limiting_after_rest_0_0_1_0 (*(volatile uint16_t*)0x00805896UL) /* SEVERITY INDEX FOR FUEL TEMPERATURE FUEL LIMITI... */
#define severity_index_for_fuel_temperature_rpm_limiting_after_resta_0_0_1_0 (*(volatile uint16_t*)0x00805898UL) /* SEVERITY INDEX FOR FUEL TEMPERATURE RPM LIMITIN... */
#define fuel_temperature_extremity_time_0_2_29 (*(volatile uint32_t*)0x0080589CUL) /* FUEL TEMPERATURE EXTREMITY TIME */
#define total_time_duration_for_fuel_temperature_fuel_error_0_2_29 (*(volatile uint32_t*)0x008058A0UL) /* TOTAL TIME DURATION FOR FUEL TEMPERATURE FUEL E... */
#define total_time_duration_for_fuel_temperature_rpm_error_0_2_29 (*(volatile uint32_t*)0x008058A4UL) /* TOTAL TIME DURATION FOR FUEL TEMPERATURE RPM ERROR */
#define EPFTFLFG (*(volatile uint16_t*)0x008058A8UL) /* CalTerm EPFTFLFG: FAULT LOG RECORDING FLAG FOR ... */
#define index_into_epf_fault_log_for_fuel_temperature_fueling_0_4 (*(volatile uint16_t*)0x008058AAUL) /* INDEX INTO EPF FAULT LOG FOR FUEL TEMPERATURE F... */
#define EPFTRPFG (*(volatile uint16_t*)0x008058ACUL) /* CalTerm EPFTRPFG: FAULT LOG RECORDING FLAG FOR ... */
#define index_into_epf_fault_log_for_fuel_temperature_rpm_errors_0_4 (*(volatile uint16_t*)0x008058AEUL) /* INDEX INTO EPF FAULT LOG FOR FUEL TEMPERATURE R... */
#define ambient_air_pressure_fueling_severity_index_0_0_0_1 (*(volatile uint16_t*)0x008058B0UL) /* AMBIENT AIR PRESSURE FUELING SEVERITY INDEX */
#define severity_index_for_epf_ambient_air_pressure_fault_0_0_0_1 (*(volatile uint16_t*)0x008058B2UL) /* SEVERITY INDEX FOR EPF AMBIENT AIR PRESSURE FAULT */
#define ambient_air_pressure_restart_severity_index_0_0_0_1 (*(volatile uint16_t*)0x008058B4UL) /* AMBIENT AIR PRESSURE RESTART SEVERITY INDEX */
#define ambient_air_pressure_rpm_restart_severity_index_0_0_0_1 (*(volatile uint16_t*)0x008058B6UL) /* AMBIENT AIR PRESSURE RPM RESTART SEVERITY INDEX */
#define ambient_air_pressure_extremity_time_0_2_32 (*(volatile uint32_t*)0x008058BAUL) /* AMBIENT AIR PRESSURE EXTREMITY TIME */
#define total_time_ambient_air_pressure_fuel_fault_has_been_active_0_2_32 (*(volatile uint32_t*)0x008058BEUL) /* TOTAL TIME AMBIENT AIR PRESSURE FUEL FAULT HAS ... */
#define total_time_ambient_air_pressure_rpm_fault_has_been_active_0_2_29 (*(volatile uint32_t*)0x008058C2UL) /* TOTAL TIME AMBIENT AIR PRESSURE RPM FAULT HAS B... */
#define fault_log_recording_flag_for_ambient_air_pressure_fueling_0_1 (*(volatile uint16_t*)0x008058C6UL) /* FAULT LOG RECORDING FLAG FOR AMBIENT AIR PRESSU... */
#define index_into_epf_fault_log_for_ambient_air_pressure_fueling_0_4 (*(volatile uint16_t*)0x008058C8UL) /* INDEX INTO EPF FAULT LOG FOR AMBIENT AIR PRESSU... */
#define fault_log_recording_flag_for_ambient_air_pressure_rpm_0_1 (*(volatile uint16_t*)0x008058CAUL) /* FAULT LOG RECORDING FLAG FOR AMBIENT AIR PRESSU... */
#define index_into_epf_fault_log_for_ambient_air_pressure_0_4 (*(volatile uint16_t*)0x008058CCUL) /* INDEX INTO EPF FAULT LOG FOR AMBIENT AIR PRESSURE */
#define DGAEFUBF ((volatile uint8_t*)0x008058D4UL) /* [32] CalTerm DGAEFUBF: STORAGE FOR 31 ACTIVE FAULTS */
#define DGIEFUBF ((volatile uint8_t*)0x008058F4UL) /* [32] CalTerm DGIEFUBF: STORAGE FOR 31 INACTIVE FAULTS */
#define DGAEFOBF ((volatile uint8_t*)0x00805914UL) /* [64] CalTerm DGAEFOBF: STORAGE FOR THREE DIGIT SERVI... */
#define DGIEFOBF ((volatile uint8_t*)0x00805954UL) /* [64] CalTerm DGIEFOBF: STORAGE OF 3 DIGIT FAULT SERV... */
#define DGFUCUBF ((volatile uint8_t*)0x00805A1CUL) /* [1250] CalTerm DGFUCUBF: FAULT_COUNT_TABLE.H */
#define diagnostic_fault_status_array (*(volatile uint16_t*)0x00805A36UL) /* Diagnostic fault status array base (4 refs) */
#define diagnostic_snapshot_throttle_value (*(volatile uint16_t*)0x00805A38UL) /* Diagnostic snapshot throttle position value (di... */
#define diagnostic_snapshot_fuel_value (*(volatile uint16_t*)0x00805A3EUL) /* Diagnostic snapshot fuel calc input value (diag... */
#define diagnostic_snapshot_sensor_reading (*(volatile uint16_t*)0x00805A42UL) /* Diagnostic snapshot sensor reading (diagnosticT... */
#define diagnostic_snapshot_throttle_raw (*(volatile uint16_t*)0x00805A44UL) /* Diagnostic snapshot throttle position raw (diag... */
#define fault_flags_active_base (*(volatile uint16_t*)0x00805DF2UL) /* Active fault flags array base - indexed by (fau... */
#define fault_status_flags_2 (*(volatile uint16_t*)0x00805DF4UL) /* Fault status flags register 2 */
#define engine_fault_status_reg (*(volatile uint16_t*)0x00805DF6UL) /* Engine fault status register */
#define io_fault_status_reg_1 (*(volatile uint16_t*)0x00805DFAUL) /* IO fault status register 1 - active faults */
#define io_fault_status_reg_2 (*(volatile uint16_t*)0x00805DFCUL) /* IO fault status register 2 - active faults */
#define io_fault_status_reg_3 (*(volatile uint16_t*)0x00805DFEUL) /* IO fault status register 3 - active faults */
#define io_fault_status_reg_4 (*(volatile uint16_t*)0x00805E00UL) /* IO fault status register 4 - active faults */
#define vp44_status_register_5e12 (*(volatile uint16_t*)0x00805E12UL) /* VP44 status register value */
#define vp44_fault_status_reg (*(volatile uint16_t*)0x00805E14UL) /* VP44 fault status register */
#define vp44_fso_fault_flags_active (*(volatile uint16_t*)0x00805E16UL) /* VP44 FSO fault active flags - bit 0x20=FSO circ... */
#define fault_flags_history_base (*(volatile uint16_t*)0x00805E32UL) /* Fault history flags array base - set when fault... */
#define fault_status_flags_8_previous (*(volatile uint16_t*)0x00805E34UL) /* Previous state of fault_status_flags_8 for edge... */
#define engine_fault_latch_reg (*(volatile uint16_t*)0x00805E36UL) /* Engine fault latch register */
#define io_fault_latch_reg_1 (*(volatile uint16_t*)0x00805E3AUL) /* IO fault latch register 1 - latched faults */
#define io_fault_latch_reg_2 (*(volatile uint16_t*)0x00805E3CUL) /* IO fault latch register 2 - latched faults */
#define io_fault_latch_reg_3 (*(volatile uint16_t*)0x00805E3EUL) /* IO fault latch register 3 - latched faults */
#define io_fault_latch_reg_4 (*(volatile uint16_t*)0x00805E40UL) /* IO fault latch register 4 - latched faults */
#define vp44_fso_fault_flags (*(volatile uint16_t*)0x00805E52UL) /* VP44 FSO fault flag processor flags (10 refs) */
#define vp44_fso_fault_accumulator (*(volatile uint16_t*)0x00805E54UL) /* VP44 FSO fault accumulator value (9 refs) */
#define vp44_fso_fault_flags_history (*(volatile uint16_t*)0x00805E56UL) /* VP44 FSO fault history flags - mirrors active f... */
#define diagnostic_fault_group_bitmask_array (*(volatile uint16_t*)0x00805E72UL) /* Diagnostic fault group bitmask array base (4 refs) */
#define rpm_histogram_buffer_start (*(volatile uint32_t*)0x00805EB4UL) /* RPM histogram buffer start address (2 refs) */
#define rpm_added_to_lsg_reference_300_300 (*(volatile uint16_t*)0x00805F0AUL) /* RPM ADDED TO LSG REFERENCE */
#define fuel_total_when_the_weighted_fuel_value_reaches_the_fu_0_0_1000000_0 (*(volatile uint32_t*)0x00805F18UL) /* FUEL TOTAL WHEN THE WEIGHTED FUEL VALUE REACHES... */
#define pointer_to_the_most_current_entry_of_the_ocm_reset_log_circula_0_2 (*(volatile uint16_t*)0x00805F1EUL) /* POINTER TO THE MOST CURRENT ENTRY OF THE OCM RE... */
#define fuel_statistics_accumulator_1 (*(volatile uint32_t*)0x00805F20UL) /* Fuel statistics accumulator 1 (2 refs) */
#define runtime_counter_update_arg_1 (*(volatile uint32_t*)0x00805F24UL) /* Runtime counter update arg 1 (2 refs) */
#define OCHRRSHS (*(volatile uint32_t*)0x00805F28UL) /* CalTerm OCHRRSHS: TOTAL HOURS AND THE WEIGHTED ... */
#define crank_fuel_calculation_state (*(volatile uint16_t*)0x00805F2CUL) /* Crank fuel calculation and protection state (12... */
#define fuel_statistics_accumulator_2 (*(volatile uint32_t*)0x00805F30UL) /* Fuel statistics accumulator 2 (2 refs) */
#define clutch_operating_stats_value (*(volatile uint32_t*)0x00805F34UL) /* Clutch operating statistics tracker value (6 refs) */
#define runtime_counter_update_arg_2 (*(volatile uint32_t*)0x00805F38UL) /* Runtime counter update arg 2 (2 refs) */
#define runtime_counter_update_alt_arg (*(volatile uint32_t*)0x00805F3CUL) /* Runtime counter update alt arg (2 refs) */
#define crank_rpm_condition_flag (*(volatile uint16_t*)0x00805F40UL) /* Crank RPM condition met flag */
#define runtime_hours_accumulator (*(volatile uint32_t*)0x00805F44UL) /* Runtime hours accumulator (2 refs) */
#define runtime_counter_accumulator_1 (*(volatile uint32_t*)0x00805F48UL) /* Runtime counter accumulator 1 (2 refs) */
#define runtime_counter_accumulator_2 (*(volatile uint32_t*)0x00805F4CUL) /* Runtime counter accumulator 2 (2 refs) */
#define fuel_demand_fault_counter (*(volatile uint32_t*)0x00805F50UL) /* Fuel demand fault counter increment value (2 refs) */
#define fuel_statistics_counter (*(volatile uint32_t*)0x00805F54UL) /* Fuel statistics tracker counter (3 refs) */
#define idle_hours_accumulator (*(volatile uint32_t*)0x00805F64UL) /* Idle hours accumulator (2 refs) */
#define general_increment_counter (*(volatile uint16_t*)0x00805F68UL) /* General incrementing counter (2 refs) */
#define crank_timing_state_current (*(volatile uint32_t*)0x00805F6CUL) /* Current crank timing state for delta calculatio... */
#define fuel_timing_control_counter_1 (*(volatile uint32_t*)0x00805F70UL) /* Fuel timing control counter 1 (2 refs) */
#define fuel_timing_control_counter_2 (*(volatile uint32_t*)0x00805F74UL) /* Fuel timing control counter 2 (1 ref) */
#define rpm_histogram_filtered_value (*(volatile uint16_t*)0x00805F78UL) /* RPM histogram filtered output value (2 refs) */
#define rpm_histogram_average_value (*(volatile uint16_t*)0x00805F7AUL) /* RPM histogram averaging statistics value (3 refs) */
#define rpm_histogram_sample_counter_2 (*(volatile uint32_t*)0x00805F7CUL) /* RPM histogram sample counter 2 (3 refs) */
#define rpm_histogram_accumulator (*(volatile uint32_t*)0x00805F80UL) /* RPM histogram accumulator (4 refs) */
#define rpm_histogram_count (*(volatile uint32_t*)0x00805F84UL) /* RPM histogram sample count (2 refs) */
#define rpm_histogram_sum (*(volatile uint32_t*)0x00805F88UL) /* RPM histogram sum value (2 refs) */
#define rpm_histogram_max_rpm (*(volatile uint16_t*)0x00805F8AUL) /* RPM histogram maximum RPM recorded (3 refs) */
#define vp44_fuel_demand_accumulator (*(volatile uint32_t*)0x00805F8CUL) /* VP44 fuel demand accumulator for statistics (5 ... */
#define fuel_limit_engine_state_capture (*(volatile uint16_t*)0x00805F90UL) /* Fuel limit engine state capture/restore value (... */
#define fuel_temp_low_throttle_accum (*(volatile uint32_t*)0x00805F92UL) /* Fuel temp low throttle time accumulator (2 refs) */
#define fuel_temp_secondary_time_accum (*(volatile uint32_t*)0x00805F96UL) /* Fuel temp secondary limit time accumulator (2 r... */
#define fuel_temp_protection_time_accum (*(volatile uint32_t*)0x00805F9AUL) /* Fuel temp protection time accumulator (2 refs) */
#define fuel_temp_high_throttle_accum (*(volatile uint32_t*)0x00805F9EUL) /* Fuel temp high throttle time accumulator (2 refs) */
#define fuel_temp_protection_counter_1_5fa2 (*(volatile uint32_t*)0x00805FA2UL) /* Fuel temperature protection slow cycle counter ... */
#define fuel_temp_protection_counter_2_5fa6 (*(volatile uint32_t*)0x00805FA6UL) /* Fuel temperature protection slow cycle counter ... */
#define crank_protection_accumulator (*(volatile uint32_t*)0x00805FAAUL) /* Crank protection weighted accumulator (5 refs) */
#define crank_protection_threshold_time (*(volatile uint32_t*)0x00805FAEUL) /* Crank protection threshold time value (4 refs) */
#define vp44_fault_source_code (*(volatile uint16_t*)0x00805FE4UL) /* VP44 fault source code identifier (4 refs) */
#define vp44_fault_accumulator_1 (*(volatile uint16_t*)0x00805FE6UL) /* VP44 fault accumulator 1 (2 refs) */
#define vp44_fault_accumulator_2 (*(volatile uint16_t*)0x00805FE8UL) /* VP44 fault accumulator 2 (2 refs) */
#define vp44_fault_protection_counter_5fec (*(volatile uint16_t*)0x00805FECUL) /* VP44 fault protection controller counter (10 refs) */
#define vp44_protection_threshold_value (*(volatile uint16_t*)0x00805FEEUL) /* VP44 fault protection threshold value (9 refs) */
#define vp44_fault_protection_timer (*(volatile uint16_t*)0x00805FF0UL) /* VP44 fault protection controller timer (6 refs) */
#define vp44_fault_protection_counter_5ff2 (*(volatile uint16_t*)0x00805FF2UL) /* VP44 fault protection controller counter (4 refs) */
#define vp44_derate_exceeded_counter (*(volatile uint16_t*)0x00805FF4UL) /* VP44 derate exceeded event counter (2 refs) */
#define vp44_derate_bit8_counter (*(volatile uint16_t*)0x00805FF6UL) /* VP44 derate bit 8 event counter (2 refs) */
#define vp44_derate_bit4_counter (*(volatile uint16_t*)0x00805FF8UL) /* VP44 derate bit 4 event counter (2 refs) */
#define rpm_protection_statistics_buffer (*(volatile uint32_t*)0x00805FFCUL) /* RPM protection histogram statistics buffer (3 r... */
#define commanded_enable_for_pwm5_enable_disable (*(volatile uint16_t*)0x00805FFEUL) /* COMMANDED ENABLE FOR PWM5. */
#define status_32_word_bit_mapped_system_error_status_word_0_0_1 (*(volatile uint16_t*)0x00806000UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_1_0_1 (*(volatile uint16_t*)0x00806002UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_2_0_1 (*(volatile uint16_t*)0x00806004UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_3_0_1 (*(volatile uint16_t*)0x00806006UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_4_0_1 (*(volatile uint16_t*)0x00806008UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_5_0_1 (*(volatile uint16_t*)0x0080600AUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_6_0_1 (*(volatile uint16_t*)0x0080600CUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_7_0_1 (*(volatile uint16_t*)0x0080600EUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_8_0_1 (*(volatile uint16_t*)0x00806010UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_9_0_1 (*(volatile uint16_t*)0x00806012UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_10_0_1 (*(volatile uint16_t*)0x00806014UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_11_0_1 (*(volatile uint16_t*)0x00806016UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_12_0_1 (*(volatile uint16_t*)0x00806018UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_13_0_1 (*(volatile uint16_t*)0x0080601AUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_14_0_1 (*(volatile uint16_t*)0x0080601CUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_15_0_1 (*(volatile uint16_t*)0x0080601EUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_16_0_1 (*(volatile uint16_t*)0x00806020UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_17_0_1 (*(volatile uint16_t*)0x00806022UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_18_0_1 (*(volatile uint16_t*)0x00806024UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_19_0_1 (*(volatile uint16_t*)0x00806026UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_20_0_1 (*(volatile uint16_t*)0x00806028UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_21_0_1 (*(volatile uint16_t*)0x0080602AUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_22_0_1 (*(volatile uint16_t*)0x0080602CUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_23_0_1 (*(volatile uint16_t*)0x0080602EUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_24_0_1 (*(volatile uint16_t*)0x00806030UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_25_0_1 (*(volatile uint16_t*)0x00806032UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_26_0_1 (*(volatile uint16_t*)0x00806034UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_27_0_1 (*(volatile uint16_t*)0x00806036UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_28_0_1 (*(volatile uint16_t*)0x00806038UL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_29_0_1 (*(volatile uint16_t*)0x0080603AUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_30_0_1 (*(volatile uint16_t*)0x0080603CUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define status_32_word_bit_mapped_system_error_status_word_31_0_1 (*(volatile uint16_t*)0x0080603EUL) /* 32 WORD BIT MAPPED SYSTEM ERROR STATUS */
#define count_of_samples_used_in_the_determination_of_engine_ave_0_2000000000 (*(volatile uint32_t*)0x0080618AUL) /* COUNT OF SAMPLES USED IN THE DETERMINATION OF E... */
#define accumulated_fan_on_time_when_fan_on_due_to_engine_system_comman_0_2_29 (*(volatile uint32_t*)0x008061B0UL) /* ACCUMULATED FAN ON TIME WHEN FAN ON DUE TO ENGI... */
#define accumulated_fan_on_time_when_fan_on_due_to_manual_switch_select_0_2_29 (*(volatile uint32_t*)0x008061B4UL) /* ACCUMULATED FAN ON TIME WHEN FAN ON DUE TO MANU... */
#define fan_clutch_on_without_mph_time_0_2_29 (*(volatile uint32_t*)0x008061B8UL) /* FAN_CLUTCH_ON_WITHOUT_MPH_TIME */
#define time_engine_operated_under_severity_level_1_for_blowbyp_0_320000000 (*(volatile uint32_t*)0x008061BCUL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 1  FO... */
#define time_engine_operated_under_severity_level_2_for_blowbypr_0_320000000 (*(volatile uint32_t*)0x008061C0UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 2 FOR... */
#define time_engine_operated_under_severity_level_3_for_blowbypr_0_320000000 (*(volatile uint32_t*)0x008061C4UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 3 FOR... */
#define time_engine_operated_under_severity_level_3_for_coolantl_0_320000000 (*(volatile uint32_t*)0x008061C8UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 3 FOR... */
#define time_engine_operated_under_severity_level_1_for_coolantp_0_320000000 (*(volatile uint32_t*)0x008061CCUL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 1 FOR... */
#define time_engine_operated_under_severity_level_2_for_coolantp_0_320000000 (*(volatile uint32_t*)0x008061D0UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 2 FOR... */
#define time_engine_operated_under_severity_level_3_for_coolantp_0_320000000 (*(volatile uint32_t*)0x008061D4UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 3 FOR... */
#define time_engine_operated_under_severity_level_1_for_coolantt_0_320000000 (*(volatile uint32_t*)0x008061D8UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 1 FOR... */
#define time_engine_operated_under_severity_level_2_for_coolantt_0_320000000 (*(volatile uint32_t*)0x008061DCUL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 2 FOR... */
#define time_engine_operated_under_severity_level_3_for_coolantt_0_320000000 (*(volatile uint32_t*)0x008061E0UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 3 FOR... */
#define time_engine_operated_under_severity_level_1_for_this_eng_0_320000000 (*(volatile uint32_t*)0x008061E4UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 1 FOR... */
#define time_engine_operated_under_severity_level_2_for_this_eng_0_320000000 (*(volatile uint32_t*)0x008061E8UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 2 FOR... */
#define time_engine_operated_under_severity_level_3_for_this_eng_0_320000000 (*(volatile uint32_t*)0x008061ECUL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 3 FOR... */
#define total_number_of_engine_starts_over_life_of_engine_0_500000 (*(volatile uint32_t*)0x008061F0UL) /* TOTAL NUMBER OF ENGINE STARTS OVER LIFE OF ENGINE */
#define time_engine_operated_under_severity_level_1_for_imt_abus_0_320000000 (*(volatile uint32_t*)0x008061F4UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 1 FOR... */
#define time_engine_operated_under_severity_level_2_for_imt_abus_0_320000000 (*(volatile uint32_t*)0x008061F8UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 2 FOR... */
#define time_engine_operated_under_severity_level_3_for_imt_abus_0_320000000 (*(volatile uint32_t*)0x008061FCUL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 3 FOR... */
#define time_engine_operated_under_severity_level_1_for_oilpres_0_320000000 (*(volatile uint32_t*)0x00806200UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 1 FOR... */
#define time_engine_operated_under_severity_level_2_for_oilpres_0_320000000 (*(volatile uint32_t*)0x00806204UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 2 FOR... */
#define time_engine_operated_under_severity_level_3_for_oilpres_0_320000000 (*(volatile uint32_t*)0x00806208UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 3 FOR... */
#define time_engine_operated_under_severity_level_1_for_oiltemp_0_320000000 (*(volatile uint32_t*)0x0080620CUL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 1 FOR... */
#define time_engine_operated_under_severity_level_2_for_oiltemp_0_320000000 (*(volatile uint32_t*)0x00806210UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 2 FOR... */
#define time_engine_operated_under_severity_level_3_for_oiltemp_0_320000000 (*(volatile uint32_t*)0x00806214UL) /* TIME ENGINE OPERATED UNDER SEVERITY LEVEL 3 FOR... */
#define total_cummulative_number_of_engine_revs_upto_32yrs_at_1400r_0_2_35 (*(volatile uint32_t*)0x00806218UL) /* TOTAL CUMMULATIVE NUMBER OF ENGINE REVS.  UPTO ... */
#define fuel_demand_exceeded_accumulator_6228 (*(volatile uint32_t*)0x00806228UL) /* Fuel demand exceeded time accumulator (2 refs) */
#define OCMIRSHS (*(volatile uint32_t*)0x0080622AUL) /* CalTerm OCMIRSHS: TOTAL MILES AND THE WEIGHTED ... */
#define fuel_demand_exceeded_counter_622c (*(volatile uint32_t*)0x0080622CUL) /* Fuel demand exceeded event counter (2 refs) */
#define fuel_demand_exceeded_arg_6230 (*(volatile uint32_t*)0x00806230UL) /* Fuel demand exceeded accumulator overflow arg (... */
#define fuel_source_10_time_accumulator_6234 (*(volatile uint32_t*)0x00806234UL) /* Fuel source 10 idle time accumulator (2 refs) */
#define fuel_source_10_time_arg_6238 (*(volatile uint32_t*)0x00806238UL) /* Fuel source 10 time accumulator overflow arg (2... */
#define boost_pressure_stats_arg_623c (*(volatile uint32_t*)0x0080623CUL) /* Boost pressure stats accumulator overflow arg (... */
#define rpm_protection_stats_index_6250 (*(volatile uint32_t*)0x00806250UL) /* RPM protection max throttle index tracking (3 r... */
#define rpm_protection_overflow_counter (*(volatile uint32_t*)0x00806254UL) /* RPM protection histogram overflow counter (1 ref) */
#define clutch_time_accumulator_1_6258 (*(volatile uint32_t*)0x00806258UL) /* Clutch time percent load accumulator 1 (2 refs) */
#define derate_time_accumulator_625a (*(volatile uint32_t*)0x0080625AUL) /* Derate event time accumulator (2 refs) */
#define boost_pressure_stats_accumulator_625c (*(volatile uint32_t*)0x0080625CUL) /* Boost pressure statistics accumulator (2 refs) */
#define derate_time_accumulator_arg_625e (*(volatile uint32_t*)0x0080625EUL) /* Derate time accumulator overflow arg (2 refs) */
#define clutch_time_accumulator_2_6260 (*(volatile uint32_t*)0x00806260UL) /* Clutch time accumulator 2 (2 refs) */
#define clutch_time_accumulator_3_6264 (*(volatile uint32_t*)0x00806264UL) /* Clutch time accumulator 3 (2 refs) */
#define counts_time_percent_load_is_low_for_const_freq_alg_0_100 (*(volatile uint16_t*)0x00806268UL) /* COUNTS TIME PERCENT LOAD IS LOW FOR CONST FREQ.... */
#define counter_for_constant_freq_detection_alg_0_10000 (*(volatile uint16_t*)0x0080626AUL) /* COUNTER FOR CONSTANT FREQ. DETECTION ALG. */
#define clutch_operating_time_total (*(volatile uint32_t*)0x0080626CUL) /* Clutch operating time total (7 refs) */
#define clutch_transitions_counter_0_100 (*(volatile uint16_t*)0x00806270UL) /* CLUTCH TRANSITIONS COUNTER */
#define clutch_transition_accumulator_6274 (*(volatile uint32_t*)0x00806274UL) /* Clutch transition accumulator (6 refs) */
#define clutch_statistics_status_flags_6278 (*(volatile uint16_t*)0x00806278UL) /* Clutch operating statistics status flags (7 refs) */
#define derate_event_counter_627a (*(volatile uint16_t*)0x0080627AUL) /* Derate event counter (2 refs) */
#define clutch_slip_event_counter_627c (*(volatile uint16_t*)0x0080627CUL) /* Clutch slip event counter (2 refs) */
#define fuel_demand_statistics_flags (*(volatile uint16_t*)0x0080627EUL) /* Fuel demand statistics accumulator flags (2 refs) */
#define fuel_limit_exceedance_counter_1_6282 (*(volatile uint32_t*)0x00806282UL) /* Fuel limit exceedance statistics counter 1 (2 r... */
#define fuel_source_10_statistics_counter_628a (*(volatile uint32_t*)0x0080628AUL) /* Fuel source 10 (idle) statistics counter (2 refs) */
#define fuel_temp_exceedance_counter_628e (*(volatile uint32_t*)0x0080628EUL) /* Fuel temperature exceedance statistics counter ... */
#define boost_pressure_stats_arg_6292 (*(volatile uint32_t*)0x00806292UL) /* Boost pressure statistics accumulator arg (2 refs) */
#define derate_time_accumulator_6296 (*(volatile uint32_t*)0x00806296UL) /* Derate event time accumulator (2 refs) */
#define derate_time_accumulator_arg_629a (*(volatile uint32_t*)0x0080629AUL) /* Derate event time accumulator arg (2 refs) */
#define fuel_demand_exceeded_accumulator_629e (*(volatile uint32_t*)0x0080629EUL) /* Fuel demand exceeded statistics accumulator (2 ... */
#define fuel_source_10_time_accumulator_62a2 (*(volatile uint32_t*)0x008062A2UL) /* Fuel source 10 time accumulator (2 refs) */
#define fuel_demand_exceeded_counter_62a6 (*(volatile uint32_t*)0x008062A6UL) /* Fuel demand exceeded event counter (2 refs) */
#define fuel_demand_exceeded_arg_62aa (*(volatile uint32_t*)0x008062AAUL) /* Fuel demand exceeded accumulator arg (2 refs) */
#define fuel_source_10_time_arg_62ae (*(volatile uint32_t*)0x008062AEUL) /* Fuel source 10 time accumulator arg (2 refs) */
#define fuel_limit_near_exceedance_accum_62b2 (*(volatile uint32_t*)0x008062B2UL) /* Fuel limit near exceedance accumulator (2 refs) */
#define fuel_temp_exceedance_accumulator_62b6 (*(volatile uint32_t*)0x008062B6UL) /* Fuel temp exceedance time accumulator (2 refs) */
#define fuel_limit_near_exceedance_arg_62ba (*(volatile uint32_t*)0x008062BAUL) /* Fuel limit near exceedance accumulator arg (2 r... */
#define fuel_temp_exceedance_arg_62be (*(volatile uint32_t*)0x008062BEUL) /* Fuel temp exceedance accumulator arg (2 refs) */
#define rpm_protection_stats_counter (*(volatile uint32_t*)0x008062C2UL) /* RPM protection histogram statistics counter (2 ... */
#define rpm_protection_stats_accumulator (*(volatile uint32_t*)0x008062C6UL) /* RPM protection histogram statistics accumulator... */
#define rpm_protection_stats_index_62ca (*(volatile uint32_t*)0x008062CAUL) /* RPM protection histogram statistics index (3 refs) */
#define system_protected_range_start (*(volatile uint8_t*)0x008062CBUL) /* Start of 4-byte protected system area */
#define can_memory_vp44_comm_ptr (*(volatile uint16_t*)0x008062CCUL) /* CAN memory VP44 communication pointer (vp44Comm... */
#define system_protected_range_end (*(volatile uint8_t*)0x008062CFUL) /* End of 4-byte protected system area */
#define calibration_data_copy_status (*(volatile uint16_t*)0x008062D0UL) /* Calibration data copy status flag (1 ref) */
#define can_memory_table_start (*(volatile uint32_t*)0x008062D2UL) /* CAN memory synchronization table start (3 refs) */
#define rpm_timer_reload_value_2 (*(volatile uint16_t*)0x008062D4UL) /* Timer reload value 2 for RPM control */
#define rpm_state_controller_param (*(volatile uint16_t*)0x008062D6UL) /* RPM state controller parameter (rpm_system_stat... */
#define rpm_threshold_lower (*(volatile uint16_t*)0x008062D8UL) /* Lower RPM threshold for system control */
#define rpm_secondary_threshold (*(volatile uint16_t*)0x008062DAUL) /* Secondary RPM threshold for control logic */
#define rpm_threshold_upper (*(volatile uint16_t*)0x008062DCUL) /* Upper RPM threshold for system control */
#define rpm_timer_reload_value_1 (*(volatile uint16_t*)0x008062FEUL) /* Timer reload value 1 for RPM control */
#define dma_desc_source_addr2 (*(volatile uint32_t*)0x00806304UL) /* DMA descriptor 2 source address pointer */
#define dma_desc_dest_addr2 (*(volatile uint32_t*)0x00806318UL) /* DMA descriptor 2 destination address pointer */
#define dma_desc_source_addr3 (*(volatile uint32_t*)0x0080632CUL) /* DMA descriptor 3 source address pointer */
#define dma_desc_dest_addr3 (*(volatile uint32_t*)0x00806340UL) /* DMA descriptor 3 destination address pointer */
#define insite_dtc_search_code_1 (*(volatile uint8_t*)0x00806375UL) /* INSITE DTC search code 1 (insiteCommandByteDisp... */
#define insite_dtc_search_code_2 (*(volatile uint8_t*)0x008063A7UL) /* INSITE DTC search code 2 (insiteCommandByteDisp... */
#define insite_dtc_search_code_3 (*(volatile uint8_t*)0x008063B9UL) /* INSITE DTC search code 3 (insiteCommandByteDisp... */
#define insite_dtc_search_code_4 (*(volatile uint8_t*)0x008063D3UL) /* INSITE DTC search code 4 (insiteCommandByteDisp... */
#define insite_dtc_search_code_5 (*(volatile uint8_t*)0x008063DBUL) /* INSITE DTC search code 5 (insiteCommandByteDisp... */
#define insite_dtc_search_code_6 (*(volatile uint8_t*)0x008063E1UL) /* INSITE DTC search code 6 (insiteCommandByteDisp... */
#define insite_dtc_search_code_7 (*(volatile uint8_t*)0x008063FBUL) /* INSITE DTC search code 7 (insiteCommandByteDisp... */
#define insite_dtc_search_code_8 (*(volatile uint8_t*)0x008063FDUL) /* INSITE DTC search code 8 (insiteCommandByteDisp... */
#define insite_dtc_search_code_9 (*(volatile uint8_t*)0x008063FFUL) /* INSITE DTC search code 9 (insiteCommandByteDisp... */
#define diagnostic_fault_parameter_array (*(volatile uint16_t*)0x008065CCUL) /* Diagnostic fault parameter lookup array (4 refs) */
#define dtc_fault_table_base (*(volatile uint32_t*)0x008065CEUL) /* DTC fault table base address pointer */
#define diagnostic_sensor_data_ptr (*(volatile uint32_t*)0x008065D0UL) /* Diagnostic sensor data pointer */
#define fault_flags_enabled_base (*(volatile uint16_t*)0x008068C4UL) /* Fault enable/confirm flags array base - mirrors... */
#define accelerator_pedal_position (*(volatile uint16_t*)0x008068C6UL) /* Accelerator pedal position value */
#define fault_mask_flags_7 (*(volatile uint16_t*)0x008068C8UL) /* Fault mask flags paired with fault_status_flags_7 */
#define fault_enable_mask_1 (*(volatile uint16_t*)0x008068CCUL) /* Fault enable mask register 1 */
#define engine_mode_output_control_state_68ce (*(volatile uint8_t*)0x008068CEUL) /* Engine mode output control state machine state ... */
#define vp44_timing_param_1 (*(volatile uint16_t*)0x008068D0UL) /* VP44 injection timing parameter 1 (vp44Injectio... */
#define fault_mask_flags_1 (*(volatile uint16_t*)0x008068D2UL) /* Fault mask flags paired with fault_status_flags_1 */
#define vp44_fso_fault_enable_mask_2 (*(volatile uint16_t*)0x008068E4UL) /* VP44 FSO fault enable mask 2 (2 refs) */
#define fso_fault_enable_mask_1 (*(volatile uint16_t*)0x008068E6UL) /* FSO fault enable mask 1 */
#define vp44_fso_fault_enable_mask (*(volatile uint16_t*)0x008068E8UL) /* VP44 FSO fault enable mask */
#define vp44_injection_timing_state_copy (*(volatile uint16_t*)0x008068ECUL) /* VP44 injection timing state copy (vp44Injection... */
#define a_d_digital_filter_constant_for_intake_manifold_temperature_0_1 (*(volatile uint16_t*)0x00806AE2UL) /* A/D DIGITAL FILTER CONSTANT FOR INTAKE MANIFOLD... */
#define global_default_value_for_intake_manifold_temperature_50_to_293 (*(volatile uint16_t*)0x00806AE4UL) /* GLOBAL DEFAULT VALUE FOR INTAKE MANIFOLD TEMPER... */
#define a_d_fault_clear_counts_for_intake_manifold_temperature_0_32767 (*(volatile uint16_t*)0x00806AE6UL) /* A/D FAULT CLEAR COUNTS FOR INTAKE MANIFOLD TEMP... */
#define a_d_fault_decrement_for_intake_manifold_temperature_0_32767 (*(volatile uint16_t*)0x00806AE8UL) /* A/D FAULT DECREMENT FOR INTAKE MANIFOLD TEMPERA... */
#define a_d_fault_increment_for_intake_manifold_temperature_0_32767 (*(volatile uint16_t*)0x00806AEAUL) /* A/D FAULT INCREMENT FOR INTAKE MANIFOLD TEMPERA... */
#define a_d_fault_set_for_intake_manifold_temperature_0_32767 (*(volatile uint16_t*)0x00806AECUL) /* A/D FAULT SET FOR INTAKE MANIFOLD TEMPERATURE [... */
#define a_d_high_error_limit_for_intake_manifold_temperature_0_1023 (*(volatile uint16_t*)0x00806AEEUL) /* A/D HIGH ERROR LIMIT FOR INTAKE MANIFOLD TEMPER... */
#define a_d_low_error_limit_for_intake_manifold_temperature_0_1023 (*(volatile uint16_t*)0x00806AF0UL) /* A/D LOW ERROR LIMIT FOR INTAKE MANIFOLD TEMPERA... */
#define intake_manifold_temperature_channel_address_none (*(volatile uint16_t*)0x00806AF2UL) /* INTAKE_MANIFOLD_TEMPERATURE_CHANNEL_ADDRESS [Ca... */
#define adimtpmu_param (*(volatile uint8_t*)0x00806AF4UL) /* CHANNEL MUX SETTING [CalTerm: ADIMTPMU] */
#define tri_state_flag_intake_manifold_temperature_enable_disable (*(volatile uint8_t*)0x00806AF5UL) /* TRI STATE FLAG [CalTerm: ADIMTPTS] */
#define error_number_storage_for_intake_manifold_temperature_high_erro_0_255 (*(volatile uint8_t*)0x00806AF6UL) /* ERROR NUMBER STORAGE FOR INTAKE_MANIFOLD_TEMPER... */
#define error_number_storage_for_intake_manifold_temperature_low_error_0_255 (*(volatile uint8_t*)0x00806AF7UL) /* ERROR NUMBER STORAGE FOR INTAKE_MANIFOLD_TEMPER... */
#define error_number_storage_for_in_range_error_intake_manifold_tempera_none (*(volatile uint8_t*)0x00806AF8UL) /* ERROR NUMBER STORAGE FOR IN_RANGE_ERROR [CalTer... */
#define ADIMTPSA (*(volatile uint8_t*)0x00806AF9UL) /* A/D SAMPLE PERIOD FOR INTAKE MANIFOLD TEMPERATURE */
#define a_d_digital_filter_constant_for_fuel_temperature_0_1 (*(volatile uint16_t*)0x00806AFAUL) /* A/D DIGITAL FILTER CONSTANT FOR FUEL TEMPERATUR... */
#define global_default_value_for_fuel_temperature_50_to_293 (*(volatile uint16_t*)0x00806AFCUL) /* GLOBAL DEFAULT VALUE FOR FUEL TEMPERATURE [CalT... */
#define a_d_fault_clear_counts_for_fuel_temperature_0_32767 (*(volatile uint16_t*)0x00806AFEUL) /* A/D FAULT CLEAR COUNTS FOR FUEL TEMPERATURE [Ca... */
#define a_d_fault_decrement_for_fuel_temperature_0_32767 (*(volatile uint16_t*)0x00806B00UL) /* A/D FAULT DECREMENT FOR FUEL TEMPERATURE [CalTe... */
#define a_d_fault_increment_for_fuel_temperature_0_32767 (*(volatile uint16_t*)0x00806B02UL) /* A/D FAULT INCREMENT FOR FUEL TEMPERATURE [CalTe... */
#define a_d_fault_set_for_fuel_temperature_0_32767 (*(volatile uint16_t*)0x00806B04UL) /* A/D FAULT SET FOR FUEL TEMPERATURE [CalTerm: AD... */
#define a_d_high_error_limit_for_fuel_temperature_0_1023 (*(volatile uint16_t*)0x00806B06UL) /* A/D HIGH ERROR LIMIT FOR FUEL TEMPERATURE [CalT... */
#define a_d_low_error_limit_for_fuel_temperature_0_1023 (*(volatile uint16_t*)0x00806B08UL) /* A/D LOW ERROR LIMIT FOR FUEL TEMPERATURE [CalTe... */
#define fuel_temperature_channel_address_none (*(volatile uint16_t*)0x00806B0AUL) /* FUEL_TEMPERATURE_CHANNEL_ADDRESS [CalTerm: ADFL... */
#define adfltpmu_param (*(volatile uint8_t*)0x00806B0CUL) /* CHANNEL MUX SETTING [CalTerm: ADFLTPMU] */
#define tri_state_flag_fuel_temperature_enable_disable (*(volatile uint8_t*)0x00806B0DUL) /* TRI STATE FLAG [CalTerm: ADFLTPTS] */
#define error_number_storage_for_fuel_temperature_high_error_0_255 (*(volatile uint8_t*)0x00806B0EUL) /* ERROR NUMBER STORAGE FOR FUEL_TEMPERATURE_HIGH_... */
#define error_number_storage_for_fuel_temperature_low_error_0_255 (*(volatile uint8_t*)0x00806B0FUL) /* ERROR NUMBER STORAGE FOR FUEL_TEMPERATURE_LOW_E... */
#define error_number_storage_for_in_range_error_fuel_temperature_none (*(volatile uint8_t*)0x00806B10UL) /* ERROR NUMBER STORAGE FOR IN_RANGE_ERROR [CalTer... */
#define ADFLTPSA (*(volatile uint8_t*)0x00806B11UL) /* A/D SAMPLE PERIOD FOR FUEL TEMPERATURE */
#define coolant_level_a_d_digital_filter_constant_0_1 (*(volatile uint16_t*)0x00806B12UL) /* COOLANT LEVEL A/D DIGITAL FILTER CONSTANT [CalT... */
#define coolant_level_global_default_value_0_2 (*(volatile uint16_t*)0x00806B14UL) /* COOLANT LEVEL GLOBAL DEFAULT VALUE [CalTerm: AD... */
#define coolant_level_channel_address_0_32767 (*(volatile uint16_t*)0x00806B16UL) /* COOLANT LEVEL CHANNEL ADDRESS [CalTerm: ADCVCC] */
#define coolant_level_a_d_fault_decrement_0_32767 (*(volatile uint16_t*)0x00806B18UL) /* COOLANT LEVEL A/D FAULT DECREMENT [CalTerm: ADC... */
#define coolant_level_a_d_fault_increment_0_32767 (*(volatile uint16_t*)0x00806B1AUL) /* COOLANT LEVEL A/D FAULT INCREMENT [CalTerm: ADC... */
#define coolant_level_a_d_fault_set_0_32767 (*(volatile uint16_t*)0x00806B1CUL) /* COOLANT LEVEL A/D FAULT SET [CalTerm: ADCVSE] */
#define coolant_level_a_d_high_error_limit_0_1023 (*(volatile uint16_t*)0x00806B1EUL) /* COOLANT LEVEL A/D HIGH ERROR LIMIT [CalTerm: AD... */
#define coolant_level_a_d_low_error_limit_0_1023 (*(volatile uint16_t*)0x00806B20UL) /* COOLANT LEVEL A/D LOW ERROR LIMIT [CalTerm: ADC... */
#define coolant_level_channel_address_none (*(volatile uint16_t*)0x00806B22UL) /* COOLANT LEVEL CHANNEL ADDRESS [CalTerm: ADCVCA] */
#define coolant_level_channel_mux_setting_0_255 (*(volatile uint8_t*)0x00806B24UL) /* COOLANT LEVEL CHANNEL MUX SETTING [CalTerm: ADC... */
#define coolant_level_tri_state_flag_enable_disable (*(volatile uint8_t*)0x00806B25UL) /* COOLANT LEVEL TRI STATE FLAG [CalTerm: ADCVTS] */
#define error_number_storage_for_coolant_level_high_error_0_255 (*(volatile uint8_t*)0x00806B26UL) /* ERROR NUMBER STORAGE FOR COOLANT_LEVEL_HIGH_ERR... */
#define error_number_storage_for_coolant_level_low_error_0_255 (*(volatile uint8_t*)0x00806B27UL) /* ERROR NUMBER STORAGE FOR COOLANT_LEVEL_LOW_ERRO... */
#define coolant_level_error_number_storage_for_in_range_error_none (*(volatile uint8_t*)0x00806B28UL) /* COOLANT LEVEL ERROR NUMBER STORAGE FOR IN_RANGE... */
#define ADCVSA (*(volatile uint8_t*)0x00806B29UL) /* COOLANT LEVEL A/D SAMPLE PERIOD */
#define adsyfpcs_param (*(volatile uint16_t*)0x00806B2AUL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADSYFPCS] */
#define adsyfpgd_param (*(volatile uint16_t*)0x00806B2CUL) /* GLOBAL DEFAULT VALUE [CalTerm: ADSYFPGD] */
#define adsyfpfc_param (*(volatile uint16_t*)0x00806B2EUL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADSYFPFC] */
#define adsyfpfd_param (*(volatile uint16_t*)0x00806B30UL) /* A/D FAULT DECREMENT [CalTerm: ADSYFPFD] */
#define adsyfpfi_param (*(volatile uint16_t*)0x00806B32UL) /* A/D FAULT INCREMENT [CalTerm: ADSYFPFI] */
#define adsyfpfs_param (*(volatile uint16_t*)0x00806B34UL) /* A/D FAULT SET [CalTerm: ADSYFPFS] */
#define adsyfphl_param (*(volatile uint16_t*)0x00806B36UL) /* A/D HIGH ERROR LIMIT [CalTerm: ADSYFPHL] */
#define adsyfpll_param (*(volatile uint16_t*)0x00806B38UL) /* A/D LOW ERROR LIMIT [CalTerm: ADSYFPLL] */
#define adsyfpmu_param (*(volatile uint8_t*)0x00806B3CUL) /* CHANNEL MUX SETTING [CalTerm: ADSYFPMU] */
#define adsyfpts_param (*(volatile uint8_t*)0x00806B3DUL) /* TRI STATE ERROR [CalTerm: ADSYFPTS] */
#define error_number_storage_for_fuel_pressure_high_limit_error_0_255 (*(volatile uint8_t*)0x00806B3EUL) /* ERROR NUMBER STORAGE FOR FUEL_PRESSURE_HIGH_LIM... */
#define error_number_storage_for_fuel_pressure_low_error_0_255 (*(volatile uint8_t*)0x00806B3FUL) /* ERROR NUMBER STORAGE FOR FUEL_PRESSURE_LOW_ERRO... */
#define adsyfpte_param (*(volatile uint8_t*)0x00806B40UL) /* TRI STATE ERROR [CalTerm: ADSYFPTE] */
#define ADSYFPSR (*(volatile uint8_t*)0x00806B41UL) /* A/D SAMPLE PERIOD */
#define a_d_digital_filter_constant_for_oil_pressure_0_1 (*(volatile uint16_t*)0x00806B42UL) /* A/D DIGITAL FILTER CONSTANT FOR OIL PRESSURE [C... */
#define global_default_value_for_oil_pressure_0_100 (*(volatile uint16_t*)0x00806B44UL) /* GLOBAL DEFAULT VALUE FOR OIL PRESSURE [CalTerm:... */
#define a_d_fault_clear_counts_for_oil_pressure_0_32767 (*(volatile uint16_t*)0x00806B46UL) /* A/D FAULT CLEAR COUNTS FOR OIL PRESSURE [CalTer... */
#define a_d_fault_decrement_for_oil_pressure_0_32767 (*(volatile uint16_t*)0x00806B48UL) /* A/D FAULT DECREMENT FOR OIL PRESSURE [CalTerm: ... */
#define a_d_fault_increment_for_oil_pressure_0_32767 (*(volatile uint16_t*)0x00806B4AUL) /* A/D FAULT INCREMENT FOR OIL PRESSURE [CalTerm: ... */
#define a_d_fault_set_for_oil_pressure_0_32767 (*(volatile uint16_t*)0x00806B4CUL) /* A/D FAULT SET FOR OIL PRESSURE [CalTerm: ADOLPRSE] */
#define a_d_high_error_limit_for_oil_pressure_0_1023 (*(volatile uint16_t*)0x00806B4EUL) /* A/D HIGH ERROR LIMIT FOR OIL PRESSURE [CalTerm:... */
#define a_d_low_error_limit_for_oil_pressure_0_1023 (*(volatile uint16_t*)0x00806B50UL) /* A/D LOW ERROR LIMIT FOR OIL PRESSURE [CalTerm: ... */
#define oil_pressure_channel_address_none (*(volatile uint16_t*)0x00806B52UL) /* OIL_PRESSURE_CHANNEL_ADDRESS [CalTerm: ADOLPRCA] */
#define adolprmu_param (*(volatile uint8_t*)0x00806B54UL) /* CHANNEL MUX SETTING [CalTerm: ADOLPRMU] */
#define tri_state_flag_oil_pressure_enable_disable (*(volatile uint8_t*)0x00806B55UL) /* TRI STATE FLAG [CalTerm: ADOLPRTS] */
#define error_number_storage_for_oil_pressure_high_limit_0_255 (*(volatile uint8_t*)0x00806B56UL) /* ERROR NUMBER STORAGE FOR OIL_PRESSURE_HIGH_LIMI... */
#define error_number_storage_for_oil_pressure_low_error_0_255 (*(volatile uint8_t*)0x00806B57UL) /* ERROR NUMBER STORAGE FOR OIL_PRESSURE_LOW_ERROR... */
#define error_number_storage_for_in_range_error_oil_pressure_none (*(volatile uint8_t*)0x00806B58UL) /* ERROR NUMBER STORAGE FOR IN_RANGE_ERROR [CalTer... */
#define ADOLPRSA (*(volatile uint8_t*)0x00806B59UL) /* A/D SAMPLE PERIOD FOR OIL PRESSURE */
#define a_d_digital_filter_constant_for_boost_pressure_0_1 (*(volatile uint16_t*)0x00806B5AUL) /* A/D DIGITAL FILTER CONSTANT FOR BOOST PRESSURE ... */
#define ADDFBSPR (*(volatile uint16_t*)0x00806B5CUL) /* GLOBAL DEFAULT VALUE FOR BOOST PRESSURE */
#define a_d_fault_clear_counts_for_boost_pressure_0_32767 (*(volatile uint16_t*)0x00806B5EUL) /* A/D FAULT CLEAR COUNTS FOR BOOST PRESSURE [CalT... */
#define a_d_fault_decrement_for_boost_pressure_0_32767 (*(volatile uint16_t*)0x00806B60UL) /* A/D FAULT DECREMENT FOR BOOST PRESSURE [CalTerm... */
#define a_d_fault_increment_for_boost_pressure_0_32767 (*(volatile uint16_t*)0x00806B62UL) /* A/D FAULT INCREMENT FOR BOOST PRESSURE [CalTerm... */
#define a_d_fault_set_for_boost_pressure_0_32767 (*(volatile uint16_t*)0x00806B64UL) /* A/D FAULT SET FOR BOOST PRESSURE [CalTerm: ADBS... */
#define a_d_high_error_limit_for_boost_pressure_0_1023 (*(volatile uint16_t*)0x00806B66UL) /* A/D HIGH ERROR LIMIT FOR BOOST PRESSURE [CalTer... */
#define a_d_low_error_limit_for_boost_pressure_0_1023 (*(volatile uint16_t*)0x00806B68UL) /* A/D LOW ERROR LIMIT FOR BOOST PRESSURE [CalTerm... */
#define boost_pressure_channel_address_none (*(volatile uint16_t*)0x00806B6AUL) /* BOOST_PRESSURE_CHANNEL_ADDRESS [CalTerm: ADBSPRCA] */
#define adbsprmu_param (*(volatile uint8_t*)0x00806B6CUL) /* CHANNEL MUX SETTING [CalTerm: ADBSPRMU] */
#define tri_state_flag_boost_pressure_enable_disable (*(volatile uint8_t*)0x00806B6DUL) /* TRI STATE FLAG [CalTerm: ADBSPRTS] */
#define error_number_storage_for_boost_pressure_high_error_0_255 (*(volatile uint8_t*)0x00806B6EUL) /* ERROR NUMBER STORAGE FOR BOOST_PRESSURE_HIGH_ER... */
#define error_number_storage_for_boost_pressure_low_error_0_255 (*(volatile uint8_t*)0x00806B6FUL) /* ERROR NUMBER STORAGE FOR BOOST_PRESSURE_LOW_ERR... */
#define error_number_storage_for_tri_state_error_boost_pressure_none (*(volatile uint8_t*)0x00806B70UL) /* ERROR NUMBER STORAGE FOR TRI STATE ERROR [CalTe... */
#define ADBSPRSA (*(volatile uint8_t*)0x00806B71UL) /* A/D SAMPLE PERIOD FOR BOOST PRESSURE */
#define a_d_digital_filter_constant_for_coolant_temperature_0_1 (*(volatile uint16_t*)0x00806B72UL) /* A/D DIGITAL FILTER CONSTANT FOR COOLANT TEMPERA... */
#define global_default_value_to_coolant_temperature_50_to_293 (*(volatile uint16_t*)0x00806B74UL) /* GLOBAL DEFAULT VALUE TO COOLANT TEMPERATURE [Ca... */
#define a_d_fault_clear_counts_for_coolant_temperature_0_32767 (*(volatile uint16_t*)0x00806B76UL) /* A/D FAULT CLEAR COUNTS FOR COOLANT TEMPERATURE ... */
#define a_d_fault_decrement_for_coolant_temperature_0_32767 (*(volatile uint16_t*)0x00806B78UL) /* A/D FAULT DECREMENT FOR COOLANT TEMPERATURE [Ca... */
#define a_d_fault_increment_for_coolant_temperature_0_32767 (*(volatile uint16_t*)0x00806B7AUL) /* A/D FAULT INCREMENT FOR COOLANT TEMPERATURE [Ca... */
#define a_d_fault_set_for_coolant_temperature_0_32767 (*(volatile uint16_t*)0x00806B7CUL) /* A/D FAULT SET FOR COOLANT TEMPERATURE [CalTerm:... */
#define a_d_high_error_limit_for_coolant_temperature_0_1023 (*(volatile uint16_t*)0x00806B7EUL) /* A/D HIGH ERROR LIMIT FOR COOLANT TEMPERATURE [C... */
#define a_d_low_error_limit_for_coolant_temperature_0_1023 (*(volatile uint16_t*)0x00806B80UL) /* A/D LOW ERROR LIMIT FOR COOLANT TEMPERATURE [Ca... */
#define coolant_temperature_channel_address_none (*(volatile uint16_t*)0x00806B82UL) /* COOLANT_TEMPERATURE_CHANNEL_ADDRESS [CalTerm: A... */
#define adcltpmu_param (*(volatile uint8_t*)0x00806B84UL) /* CHANNEL MUX SETTING [CalTerm: ADCLTPMU] */
#define tri_state_flag_coolant_temperature_enable_disable (*(volatile uint8_t*)0x00806B85UL) /* TRI STATE FLAG [CalTerm: ADCLTPTS] */
#define error_number_storage_for_coolant_temperature_high_error_0_255 (*(volatile uint8_t*)0x00806B86UL) /* ERROR NUMBER STORAGE FOR COOLANT_TEMPERATURE_HI... */
#define error_number_storage_for_coolant_temperature_low_error_0_255 (*(volatile uint8_t*)0x00806B87UL) /* ERROR NUMBER STORAGE FOR COOLANT_TEMPERATURE_LO... */
#define error_number_storage_for_tri_state_error_coolant_temperature_none (*(volatile uint8_t*)0x00806B88UL) /* ERROR NUMBER STORAGE FOR TRI STATE ERROR [CalTe... */
#define ADCLTPSA (*(volatile uint8_t*)0x00806B89UL) /* A/D SAMPLE PERIOD FOR COOLANT TEMPERATURE */
#define a_d_digital_filter_constant_for_ambient_air_temperature_0_1 (*(volatile uint16_t*)0x00806B8AUL) /* A/D DIGITAL FILTER CONSTANT FOR AMBIENT AIR TEM... */
#define global_default_value_for_ambient_air_temperature_100_255 (*(volatile uint16_t*)0x00806B8CUL) /* GLOBAL DEFAULT VALUE FOR AMBIENT AIR TEMPERATUR... */
#define a_d_fault_clear_counts_for_ambient_air_temperature_0_10000 (*(volatile uint16_t*)0x00806B8EUL) /* A/D FAULT CLEAR COUNTS FOR AMBIENT AIR TEMPERAT... */
#define a_d_fault_decrement_for_ambient_air_temperature_1_100 (*(volatile uint16_t*)0x00806B90UL) /* A/D FAULT DECREMENT FOR AMBIENT AIR TEMPERATURE... */
#define a_d_fault_increment_for_ambient_air_temperature_2_1000 (*(volatile uint16_t*)0x00806B92UL) /* A/D FAULT INCREMENT FOR AMBIENT AIR TEMPERATURE... */
#define a_d_fault_set_for_ambient_air_temperature_400_40000 (*(volatile uint16_t*)0x00806B94UL) /* A/D FAULT SET FOR AMBIENT AIR TEMPERATURE */
#define a_d_high_error_limit_for_raw_ambient_air_temperature_0_1023 (*(volatile uint16_t*)0x00806B96UL) /* A/D HIGH ERROR LIMIT FOR RAW AMBIENT AIR TEMPER... */
#define ad_low_error_limit_for_ambient_air_temperature_0_1023 (*(volatile uint16_t*)0x00806B98UL) /* AD LOW ERROR LIMIT FOR AMBIENT AIR TEMPERATURE ... */
#define ambient_air_temperature_channel_address_none (*(volatile uint16_t*)0x00806B9AUL) /* AMBIENT AIR TEMPERATURE CHANNEL ADDRESS [CalTer... */
#define adttmu_param (*(volatile uint8_t*)0x00806B9CUL) /* CHANNEL MUX SETTING [CalTerm: ADTTMU] */
#define tri_state_flag_ambient_air_temperature_enable_disable (*(volatile uint8_t*)0x00806B9DUL) /* TRI STATE FLAG */
#define error_number_storage_for_ambient_air_temperature_high_error_id_0_255 (*(volatile uint8_t*)0x00806B9EUL) /* ERROR NUMBER STORAGE FOR AMBIENT_AIR_TEMPERATUR... */
#define error_storage_number_for_ambient_air_temperature_low_error_0_255 (*(volatile uint8_t*)0x00806B9FUL) /* ERROR STORAGE NUMBER FOR AMBIENT AIR TEMPERATUR... */
#define error_number_storage_for_tri_state_error_id_none (*(volatile uint8_t*)0x00806BA0UL) /* ERROR NUMBER STORAGE FOR TRI STATE ERROR ID [Ca... */
#define a_d_sample_period_for_ambient_air_temperature_0_4000 (*(volatile uint8_t*)0x00806BA1UL) /* A/D SAMPLE PERIOD FOR AMBIENT AIR TEMPERATURE */
#define adpotpcs_param (*(volatile uint16_t*)0x00806BA2UL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADPOTPCS] */
#define global_default_value_50_to_293 (*(volatile uint16_t*)0x00806BA4UL) /* GLOBAL DEFAULT VALUE [CalTerm: ADPOTPGD] */
#define adpotpcc_param (*(volatile uint16_t*)0x00806BA6UL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADPOTPCC] */
#define adpotpdt_param (*(volatile uint16_t*)0x00806BA8UL) /* A/D FAULT DECREMENT [CalTerm: ADPOTPDT] */
#define adpotpic_param (*(volatile uint16_t*)0x00806BAAUL) /* A/D FAULT INCREMENT [CalTerm: ADPOTPIC] */
#define adpotpse_param (*(volatile uint16_t*)0x00806BACUL) /* A/D FAULT SET [CalTerm: ADPOTPSE] */
#define adpotphl_param (*(volatile uint16_t*)0x00806BAEUL) /* A/D HIGH ERROR LIMIT [CalTerm: ADPOTPHL] */
#define adpotpll_param (*(volatile uint16_t*)0x00806BB0UL) /* A/D LOW ERROR LIMIT [CalTerm: ADPOTPLL] */
#define power_steering_temperature_channel_address_none (*(volatile uint16_t*)0x00806BB2UL) /* POWER_STEERING_TEMPERATURE_CHANNEL_ADDRESS [Cal... */
#define adpotpmu_param (*(volatile uint8_t*)0x00806BB4UL) /* CHANNEL MUX SETTING [CalTerm: ADPOTPMU] */
#define tri_state_flag_enable_disable (*(volatile uint8_t*)0x00806BB5UL) /* TRI STATE FLAG [CalTerm: ADPOTPTS] */
#define error_number_storage_for_power_steering_temperature_high_error_0_255 (*(volatile uint8_t*)0x00806BB6UL) /* ERROR NUMBER STORAGE FOR POWER_STEERING_TEMPERA... */
#define error_number_storage_for_power_steering_temperature_low_error_0_255 (*(volatile uint8_t*)0x00806BB7UL) /* ERROR NUMBER STORAGE FOR POWER_STEERING_TEMPERA... */
#define error_number_storage_for_in_range_error_none (*(volatile uint8_t*)0x00806BB8UL) /* ERROR NUMBER STORAGE FOR IN_RANGE_ERROR [CalTer... */
#define ADPOTPSA (*(volatile uint8_t*)0x00806BB9UL) /* A/D SAMPLE PERIOD */
#define adsyepcs_param (*(volatile uint16_t*)0x00806BBAUL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADSYEPCS] */
#define adsyepgd_param (*(volatile uint16_t*)0x00806BBCUL) /* GLOBAL DEFAULT VALUE [CalTerm: ADSYEPGD] */
#define adsyepfc_param (*(volatile uint16_t*)0x00806BBEUL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADSYEPFC] */
#define adsyepfd_param (*(volatile uint16_t*)0x00806BC0UL) /* A/D FAULT DECREMENT [CalTerm: ADSYEPFD] */
#define adsyepfi_param (*(volatile uint16_t*)0x00806BC2UL) /* A/D FAULT INCREMENT [CalTerm: ADSYEPFI] */
#define a_d_fault_set_0_32757 (*(volatile uint16_t*)0x00806BC4UL) /* A/D FAULT SET [CalTerm: ADSYEPFS] */
#define adsyephl_param (*(volatile uint16_t*)0x00806BC6UL) /* A/D HIGH ERROR LIMIT [CalTerm: ADSYEPHL] */
#define adsyepll_param (*(volatile uint16_t*)0x00806BC8UL) /* A/D LOW ERROR LIMIT [CalTerm: ADSYEPLL] */
#define engine_sync_exhaust_pressure_channel_address_none (*(volatile uint16_t*)0x00806BCAUL) /* ENGINE_SYNC_EXHAUST_PRESSURE_CHANNEL_ADDRESS [C... */
#define adsyepmu_param (*(volatile uint8_t*)0x00806BCCUL) /* CHANNEL MUX SETTING [CalTerm: ADSYEPMU] */
#define adsyepts_param (*(volatile uint8_t*)0x00806BCDUL) /* TRI STATE ERROR [CalTerm: ADSYEPTS] */
#define error_number_storage_for_engine_sync_exhaust_pressure_high_err_0_255 (*(volatile uint8_t*)0x00806BCEUL) /* ERROR NUMBER STORAGE FOR ENGINE_SYNC_EXHAUST_PR... */
#define error_number_storage_for_engine_sync_exhaust_pressure_low_erro_0_255 (*(volatile uint8_t*)0x00806BCFUL) /* ERROR NUMBER STORAGE FOR ENGINE_SYNC_EXHAUST_PR... */
#define adsyepte_param (*(volatile uint8_t*)0x00806BD0UL) /* TRI STATE ERROR [CalTerm: ADSYEPTE] */
#define ADSYEPSR (*(volatile uint8_t*)0x00806BD1UL) /* A/D SAMPLE PERIOD */
#define a_d_digital_filter_constant_for_throttle_0_1 (*(volatile uint16_t*)0x00806BD2UL) /* A/D DIGITAL FILTER CONSTANT FOR THROTTLE [CalTe... */
#define global_default_value_for_throttle_0_100 (*(volatile uint16_t*)0x00806BD4UL) /* GLOBAL DEFAULT VALUE FOR THROTTLE [CalTerm: ADD... */
#define a_d_fault_clear_counts_for_sampled_throttle_0_32767 (*(volatile uint16_t*)0x00806BD6UL) /* A/D FAULT CLEAR COUNTS FOR SAMPLED THROTTLE [Ca... */
#define a_d_fault_decrement_for_throttle_0_32767 (*(volatile uint16_t*)0x00806BD8UL) /* A/D FAULT DECREMENT FOR THROTTLE [CalTerm: ADSA... */
#define a_d_fault_increment_for_throttle_0_32767 (*(volatile uint16_t*)0x00806BDAUL) /* A/D FAULT INCREMENT FOR THROTTLE [CalTerm: ADSA... */
#define a_d_fault_set_for_throttle_0_32767 (*(volatile uint16_t*)0x00806BDCUL) /* A/D FAULT SET FOR THROTTLE [CalTerm: ADSATHSE] */
#define a_d_high_error_limit_for_throttle_0_1023 (*(volatile uint16_t*)0x00806BDEUL) /* A/D HIGH ERROR LIMIT FOR THROTTLE [CalTerm: ADS... */
#define a_d_low_error_limit_for_throttle_0_1023 (*(volatile uint16_t*)0x00806BE0UL) /* A/D LOW ERROR LIMIT FOR THROTTLE [CalTerm: ADSA... */
#define sampled_throttle_channel_address_none (*(volatile uint16_t*)0x00806BE2UL) /* SAMPLED_THROTTLE_CHANNEL_ADDRESS [CalTerm: ADSA... */
#define adsathmu_param (*(volatile uint8_t*)0x00806BE4UL) /* CHANNEL MUX SETTING [CalTerm: ADSATHMU] */
#define tri_state_flag_throttle_enable_disable (*(volatile uint8_t*)0x00806BE5UL) /* TRI STATE FLAG [CalTerm: ADSATHTS] */
#define error_number_storage_for_sampled_throttle_high_error_0_255 (*(volatile uint8_t*)0x00806BE6UL) /* ERROR NUMBER STORAGE FOR SAMPLED_THROTTLE_HIGH_... */
#define error_number_storage_for_sampled_throttle_low_error_0_255 (*(volatile uint8_t*)0x00806BE7UL) /* ERROR NUMBER STORAGE FOR SAMPLED_THROTTLE_LOW_E... */
#define error_number_storage_for_in_range_error_throttle_none (*(volatile uint8_t*)0x00806BE8UL) /* ERROR NUMBER STORAGE FOR IN_RANGE_ERROR [CalTer... */
#define ADSATHSA (*(volatile uint8_t*)0x00806BE9UL) /* A/D SAMPLE PERIOD FOR THROTTLE */
#define a_d_digital_filter_constant_for_remote_throttle_0_1 (*(volatile uint16_t*)0x00806BEAUL) /* A/D DIGITAL FILTER CONSTANT FOR REMOTE THROTTLE... */
#define global_default_value_for_remote_throttle_0_100 (*(volatile uint16_t*)0x00806BECUL) /* GLOBAL DEFAULT VALUE FOR REMOTE THROTTLE [CalTe... */
#define a_d_fault_clear_counts_for_remote_throttle_0_32767 (*(volatile uint16_t*)0x00806BEEUL) /* A/D FAULT CLEAR COUNTS FOR REMOTE THROTTLE [Cal... */
#define a_d_fault_decrement_for_remote_throttle_0_32767 (*(volatile uint16_t*)0x00806BF0UL) /* A/D FAULT DECREMENT FOR REMOTE THROTTLE [CalTer... */
#define a_d_fault_increment_for_remote_throttle_0_32767 (*(volatile uint16_t*)0x00806BF2UL) /* A/D FAULT INCREMENT FOR REMOTE THROTTLE [CalTer... */
#define a_d_fault_set_for_remote_throttle_0_32767 (*(volatile uint16_t*)0x00806BF4UL) /* A/D FAULT SET FOR REMOTE THROTTLE [CalTerm: ADR... */
#define a_d_high_error_limit_for_remote_throttle_0_1023 (*(volatile uint16_t*)0x00806BF6UL) /* A/D HIGH ERROR LIMIT FOR REMOTE THROTTLE [CalTe... */
#define a_d_low_error_limit_for_remote_throttle_0_1023 (*(volatile uint16_t*)0x00806BF8UL) /* A/D LOW ERROR LIMIT FOR REMOTE THROTTLE [CalTer... */
#define remote_throttle_channel_address_none (*(volatile uint16_t*)0x00806BFAUL) /* REMOTE_THROTTLE_CHANNEL_ADDRESS [CalTerm: ADROT... */
#define adrothmu_param (*(volatile uint8_t*)0x00806BFCUL) /* CHANNEL MUX SETTING [CalTerm: ADROTHMU] */
#define tri_state_flag_remote_throttle_enable_disable (*(volatile uint8_t*)0x00806BFDUL) /* TRI STATE FLAG [CalTerm: ADROTHTS] */
#define error_number_storage_for_remote_throttle_high_error_0_255 (*(volatile uint8_t*)0x00806BFEUL) /* ERROR NUMBER STORAGE FOR REMOTE_THROTTLE_HIGH_E... */
#define error_number_storage_for_remote_throttle_low_error_0_255 (*(volatile uint8_t*)0x00806BFFUL) /* ERROR NUMBER STORAGE FOR REMOTE_THROTTLE_LOW_ER... */
#define error_number_storage_for_in_range_error_remote_throttle_none (*(volatile uint8_t*)0x00806C00UL) /* ERROR NUMBER STORAGE FOR IN_RANGE_ERROR [CalTer... */
#define ADROTHSA (*(volatile uint8_t*)0x00806C01UL) /* A/D SAMPLE PERIOD FOR REMOTE THROTTLE */
#define a_d_digital_filter_constant_for_ambient_air_pressure_0_1 (*(volatile uint16_t*)0x00806C02UL) /* A/D DIGITAL FILTER CONSTANT FOR AMBIENT AIR PRE... */
#define ADDFAAPR (*(volatile uint16_t*)0x00806C04UL) /* GLOBAL DEFAULT VALUE FOR AMBIENT AIR PRESSURE */
#define a_d_fault_clear_counts_for_ambient_air_pressure_0_32767 (*(volatile uint16_t*)0x00806C06UL) /* A/D FAULT CLEAR COUNTS FOR AMBIENT AIR PRESSURE... */
#define a_d_fault_decrement_for_ambient_air_pressure_0_32767 (*(volatile uint16_t*)0x00806C08UL) /* A/D FAULT DECREMENT FOR AMBIENT AIR PRESSURE [C... */
#define a_d_fault_increment_for_ambient_air_pressure_0_32767 (*(volatile uint16_t*)0x00806C0AUL) /* A/D FAULT INCREMENT FOR AMBIENT AIR PRESSURE [C... */
#define a_d_fault_set_for_ambient_air_pressure_0_32767 (*(volatile uint16_t*)0x00806C0CUL) /* A/D FAULT SET FOR AMBIENT AIR PRESSURE [CalTerm... */
#define a_d_high_error_limit_for_ambient_air_pressure_0_1023 (*(volatile uint16_t*)0x00806C0EUL) /* A/D HIGH ERROR LIMIT FOR AMBIENT AIR PRESSURE [... */
#define a_d_low_error_limit_for_ambient_air_pressure_0_1023 (*(volatile uint16_t*)0x00806C10UL) /* A/D LOW ERROR LIMIT FOR AMBIENT AIR PRESSURE [C... */
#define ambient_air_pressure_channel_address_none (*(volatile uint16_t*)0x00806C12UL) /* AMBIENT_AIR_PRESSURE_CHANNEL_ADDRESS [CalTerm: ... */
#define adaaprmu_param (*(volatile uint8_t*)0x00806C14UL) /* CHANNEL MUX SETTING [CalTerm: ADAAPRMU] */
#define tri_state_flag_ambient_air_pressure_enable_disable (*(volatile uint8_t*)0x00806C15UL) /* TRI STATE FLAG [CalTerm: ADAAPRTS] */
#define error_number_storage_for_ambient_air_pressure_high_error_0_255 (*(volatile uint8_t*)0x00806C16UL) /* ERROR NUMBER STORAGE FOR AMBIENT_AIR_PRESSURE_H... */
#define error_number_storage_for_ambient_air_pressure_low_error_0_255 (*(volatile uint8_t*)0x00806C17UL) /* ERROR NUMBER STORAGE FOR AMBIENT_AIR_PRESSURE_L... */
#define error_number_storage_for_tri_state_error_ambient_air_pressure_none (*(volatile uint8_t*)0x00806C18UL) /* ERROR NUMBER STORAGE FOR TRI STATE ERROR [CalTe... */
#define ADAAPRSA (*(volatile uint8_t*)0x00806C19UL) /* A/D SAMPLE PERIOD FOR AMBIENT AIR PRESSURE */
#define a_d_digital_filter_constant_for_battery_voltage_0_1 (*(volatile uint16_t*)0x00806C1AUL) /* A/D DIGITAL FILTER CONSTANT FOR BATTERY VOLTAGE... */
#define global_default_value_for_battery_voltage_0_40 (*(volatile uint16_t*)0x00806C1CUL) /* GLOBAL DEFAULT VALUE FOR BATTERY VOLTAGE [CalTe... */
#define a_d_fault_clear_counts_for_battery_voltage_0_32767 (*(volatile uint16_t*)0x00806C1EUL) /* A/D FAULT CLEAR COUNTS FOR BATTERY VOLTAGE [Cal... */
#define a_d_fault_decrement_for_battery_voltage_0_32767 (*(volatile uint16_t*)0x00806C20UL) /* A/D FAULT DECREMENT FOR BATTERY VOLTAGE [CalTer... */
#define a_d_fault_increment_for_battery_voltage_0_32767 (*(volatile uint16_t*)0x00806C22UL) /* A/D FAULT INCREMENT FOR BATTERY VOLTAGE [CalTer... */
#define a_d_fault_set_for_battery_voltage_0_32767 (*(volatile uint16_t*)0x00806C24UL) /* A/D FAULT SET FOR BATTERY VOLTAGE [CalTerm: ADB... */
#define a_d_high_error_limit_for_battery_voltage_0_1023 (*(volatile uint16_t*)0x00806C26UL) /* A/D HIGH ERROR LIMIT FOR BATTERY VOLTAGE [CalTe... */
#define a_d_low_error_limit_for_battery_voltage_0_1023 (*(volatile uint16_t*)0x00806C28UL) /* A/D LOW ERROR LIMIT FOR BATTERY VOLTAGE [CalTer... */
#define battery_voltage_channel_address_none (*(volatile uint16_t*)0x00806C2AUL) /* BATTERY_VOLTAGE_CHANNEL_ADDRESS [CalTerm: ADBTV... */
#define adbtvtmu_param (*(volatile uint8_t*)0x00806C2CUL) /* CHANNEL MUX SETTING [CalTerm: ADBTVTMU] */
#define tri_state_flag_battery_voltage_enable_disable (*(volatile uint8_t*)0x00806C2DUL) /* TRI STATE FLAG [CalTerm: ADBTVTTS] */
#define error_number_storage_for_battery_voltage_high_error_0_255 (*(volatile uint8_t*)0x00806C2EUL) /* ERROR NUMBER STORAGE FOR BATTERY_VOLTAGE_HIGH_E... */
#define error_number_storage_for_battery_voltage_low_error_0_255 (*(volatile uint8_t*)0x00806C2FUL) /* ERROR NUMBER STORAGE FOR BATTERY_VOLTAGE_LOW_ER... */
#define error_number_storage_for_in_range_error_battery_voltage_none (*(volatile uint8_t*)0x00806C30UL) /* ERROR NUMBER STORAGE FOR IN_RANGE_ERROR [CalTer... */
#define ADBTVTSA (*(volatile uint8_t*)0x00806C31UL) /* A/D SAMPLE PERIOD FOR BATTERY VOLTAGE */
#define adessvcs_param (*(volatile uint16_t*)0x00806C32UL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADESSVCS] */
#define adessvgd_param (*(volatile uint16_t*)0x00806C34UL) /* GLOBAL DEFAULT VALUE [CalTerm: ADESSVGD] */
#define adessvfc_param (*(volatile uint16_t*)0x00806C36UL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADESSVFC] */
#define adessvfd_param (*(volatile uint16_t*)0x00806C38UL) /* A/D FAULT DECREMENT [CalTerm: ADESSVFD] */
#define adessvfi_param (*(volatile uint16_t*)0x00806C3AUL) /* A/D FAULT INCREMENT [CalTerm: ADESSVFI] */
#define adessvfs_param (*(volatile uint16_t*)0x00806C3CUL) /* A/D FAULT SET [CalTerm: ADESSVFS] */
#define adessvhl_param (*(volatile uint16_t*)0x00806C3EUL) /* A/D HIGH ERROR LIMIT [CalTerm: ADESSVHL] */
#define adessvll_param (*(volatile uint16_t*)0x00806C40UL) /* A/D LOW ERROR LIMIT [CalTerm: ADESSVLL] */
#define engine_speed_sensor_sv_channel_address_none (*(volatile uint16_t*)0x00806C42UL) /* ENGINE_SPEED_SENSOR_SV_CHANNEL_ADDRESS [CalTerm... */
#define adessvmu_param (*(volatile uint8_t*)0x00806C44UL) /* CHANNEL MUX SETTING [CalTerm: ADESSVMU] */
#define adessvts_param (*(volatile uint8_t*)0x00806C45UL) /* TRI STATE ERROR [CalTerm: ADESSVTS] */
#define error_number_storage_for_engine_speed_sv_high_error_0_255 (*(volatile uint8_t*)0x00806C46UL) /* ERROR NUMBER STORAGE FOR ENGINE_SPEED_SV_HIGH_E... */
#define error_number_storage_for_engine_speed_sv_low_error_0_255 (*(volatile uint8_t*)0x00806C47UL) /* ERROR NUMBER STORAGE FOR ENGINE_SPEED_SV_LOW_ER... */
#define adessvte_param (*(volatile uint8_t*)0x00806C48UL) /* TRI STATE ERROR [CalTerm: ADESSVTE] */
#define ADESSVSR (*(volatile uint8_t*)0x00806C49UL) /* A/D SAMPLE PERIOD */
#define ADBSPRXA ((volatile uint16_t*)0x00806C4AUL) /* [5] BOOST PRESSURE LINEARIZATION X-AXIS (5 entries)... */
#define ADBSPRXA_entry_1 (*(volatile uint16_t*)0x00806C4CUL) /* BOOST PRESSURE X-AXIS ENTRY 1 (part of ADBSPRXA... */
#define ADBSPRXA_entry_2 (*(volatile uint16_t*)0x00806C4EUL) /* BOOST PRESSURE X-AXIS ENTRY 2 (part of ADBSPRXA... */
#define ADBSPRXA_entry_3 (*(volatile uint16_t*)0x00806C50UL) /* BOOST PRESSURE X-AXIS ENTRY 3 (part of ADBSPRXA... */
#define ADBSPRXA_entry_4 (*(volatile uint16_t*)0x00806C52UL) /* BOOST PRESSURE X-AXIS ENTRY 4 (part of ADBSPRXA... */
#define ADBSPRYA ((volatile uint16_t*)0x00806C54UL) /* [5] BOOST PRESSURE LINEARIZATION Y-AXIS (5 entries)... */
#define ADBSPRYA_entry_1 (*(volatile uint16_t*)0x00806C56UL) /* BOOST PRESSURE Y-AXIS ENTRY 1 (part of ADBSPRYA... */
#define ADBSPRYA_entry_2 (*(volatile uint16_t*)0x00806C58UL) /* BOOST PRESSURE Y-AXIS ENTRY 2 (part of ADBSPRYA... */
#define ADBSPRYA_entry_3 (*(volatile uint16_t*)0x00806C5AUL) /* BOOST PRESSURE Y-AXIS ENTRY 3 (part of ADBSPRYA... */
#define ADBSPRYA_entry_4 (*(volatile uint16_t*)0x00806C5CUL) /* BOOST PRESSURE Y-AXIS ENTRY 4 (part of ADBSPRYA... */
#define error_number_storage_for_throttle_position_sv_high_error_0_255 (*(volatile uint8_t*)0x00806C5EUL) /* ERROR NUMBER STORAGE FOR THROTTLE_POSITION_SV_H... */
#define error_number_storage_for_throttle_position_sv_low_error_0_255 (*(volatile uint8_t*)0x00806C5FUL) /* ERROR NUMBER STORAGE FOR THROTTLE_POSITION_SV_L... */
#define adthsvte_param (*(volatile uint8_t*)0x00806C60UL) /* TRI STATE ERROR [CalTerm: ADTHSVTE] */
#define ADTHSVSR (*(volatile uint8_t*)0x00806C61UL) /* A/D SAMPLE PERIOD */
#define advhsvcs_param (*(volatile uint16_t*)0x00806C62UL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADVHSVCS] */
#define advhsvgd_param (*(volatile uint16_t*)0x00806C64UL) /* GLOBAL DEFAULT VALUE [CalTerm: ADVHSVGD] */
#define advhsvfc_param (*(volatile uint16_t*)0x00806C66UL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADVHSVFC] */
#define advhsvfd_param (*(volatile uint16_t*)0x00806C68UL) /* A/D FAULT DECREMENT [CalTerm: ADVHSVFD] */
#define advhsvfi_param (*(volatile uint16_t*)0x00806C6AUL) /* A/D FAULT INCREMENT [CalTerm: ADVHSVFI] */
#define advhsvfs_param (*(volatile uint16_t*)0x00806C6CUL) /* A/D FAULT SET [CalTerm: ADVHSVFS] */
#define advhsvhl_param (*(volatile uint16_t*)0x00806C6EUL) /* A/D HIGH ERROR LIMIT [CalTerm: ADVHSVHL] */
#define advhsvll_param (*(volatile uint16_t*)0x00806C70UL) /* A/D LOW ERROR LIMIT [CalTerm: ADVHSVLL] */
#define vehicle_connector_sensors_sv_channel_address_none (*(volatile uint16_t*)0x00806C72UL) /* VEHICLE_CONNECTOR_SENSORS_SV_CHANNEL_ADDRESS [C... */
#define advhsvmu_param (*(volatile uint8_t*)0x00806C74UL) /* CHANNEL MUX SETTING [CalTerm: ADVHSVMU] */
#define advhsvts_param (*(volatile uint8_t*)0x00806C75UL) /* TRI STATE ERROR [CalTerm: ADVHSVTS] */
#define error_number_storage_for_vehicle_connector_sensors_sv_high_err_0_255 (*(volatile uint8_t*)0x00806C76UL) /* ERROR NUMBER STORAGE FOR VEHICLE_CONNECTOR_SENS... */
#define error_number_storage_for_vehicle_connector_sensors_sv_low_erro_0_255 (*(volatile uint8_t*)0x00806C77UL) /* ERROR NUMBER STORAGE FOR VEHICLE_CONNECTOR_SENS... */
#define advhsvte_param (*(volatile uint8_t*)0x00806C78UL) /* TRI STATE ERROR [CalTerm: ADVHSVTE] */
#define ADVHSVSR (*(volatile uint8_t*)0x00806C79UL) /* A/D SAMPLE PERIOD */
#define engine_sensor_supply_voltage_a_d_digital_filter_constant_0_1 (*(volatile uint16_t*)0x00806C7AUL) /* ENGINE SENSOR SUPPLY VOLTAGE A/D DIGITAL FILTER... */
#define engine_sensor_supply_voltage_global_default_value_0_6 (*(volatile uint16_t*)0x00806C7CUL) /* ENGINE SENSOR SUPPLY VOLTAGE GLOBAL DEFAULT VAL... */
#define engine_sensor_supply_voltage_a_d_fault_clear_counts_0_32767 (*(volatile uint16_t*)0x00806C7EUL) /* ENGINE SENSOR SUPPLY VOLTAGE A/D FAULT CLEAR CO... */
#define engine_sensor_supply_voltage_a_d_fault_decrement_1_32767 (*(volatile uint16_t*)0x00806C80UL) /* ENGINE SENSOR SUPPLY VOLTAGE A/D FAULT DECREMEN... */
#define engine_sensor_supply_voltage_a_d_fault_increment_0_32767 (*(volatile uint16_t*)0x00806C82UL) /* ENGINE SENSOR SUPPLY VOLTAGE A/D FAULT INCREMEN... */
#define engine_sensor_supply_voltage_a_d_fault_set_0_32767 (*(volatile uint16_t*)0x00806C84UL) /* ENGINE SENSOR SUPPLY VOLTAGE A/D FAULT SET [Cal... */
#define engine_sensor_supply_voltage_a_d_high_error_limit_0_1023 (*(volatile uint16_t*)0x00806C86UL) /* ENGINE SENSOR SUPPLY VOLTAGE A/D HIGH ERROR LIM... */
#define engine_sensor_supply_voltage_a_d_low_error_limit_0_1023 (*(volatile uint16_t*)0x00806C88UL) /* ENGINE SENSOR SUPPLY VOLTAGE A/D LOW ERROR LIMI... */
#define engine_conn_sensors_sv_channel_address_none (*(volatile uint16_t*)0x00806C8AUL) /* ENGINE_CONN_SENSORS_SV_CHANNEL_ADDRESS [CalTerm... */
#define engine_sensor_supply_voltage_channel_mux_setting_0_255 (*(volatile uint8_t*)0x00806C8CUL) /* ENGINE SENSOR SUPPLY VOLTAGE CHANNEL MUX SETTIN... */
#define engine_sensor_supply_voltage_tri_state_error_flag_enable_disable (*(volatile uint8_t*)0x00806C8DUL) /* ENGINE SENSOR SUPPLY VOLTAGE TRI STATE ERROR FL... */
#define error_number_storage_for_engine_conn_sensors_sv_high_error_0_255 (*(volatile uint8_t*)0x00806C8EUL) /* ERROR NUMBER STORAGE FOR ENGINE_CONN_SENSORS_SV... */
#define error_number_storage_for_engine_conn_sensors_sv_low_error_0_255 (*(volatile uint8_t*)0x00806C8FUL) /* ERROR NUMBER STORAGE FOR ENGINE_CONN_SENSORS_SV... */
#define engine_sensor_supply_voltage_tri_state_error_id_none (*(volatile uint8_t*)0x00806C90UL) /* ENGINE SENSOR SUPPLY VOLTAGE TRI STATE ERROR ID... */
#define ADECSVSR (*(volatile uint8_t*)0x00806C91UL) /* ENGINE SENSOR SUPPLY VOLTAGE A/D SAMPLE PERIOD */
#define adftsvcs_param (*(volatile uint16_t*)0x00806C92UL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADFTSVCS] */
#define adftsvgd_param (*(volatile uint16_t*)0x00806C94UL) /* GLOBAL DEFAULT VALUE [CalTerm: ADFTSVGD] */
#define adftsvfc_param (*(volatile uint16_t*)0x00806C96UL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADFTSVFC] */
#define adftsvfd_param (*(volatile uint16_t*)0x00806C98UL) /* A/D FAULT DECREMENT [CalTerm: ADFTSVFD] */
#define adftsvfi_param (*(volatile uint16_t*)0x00806C9AUL) /* A/D FAULT INCREMENT [CalTerm: ADFTSVFI] */
#define adftsvfs_param (*(volatile uint16_t*)0x00806C9CUL) /* A/D FAULT SET [CalTerm: ADFTSVFS] */
#define adftsvhl_param (*(volatile uint16_t*)0x00806C9EUL) /* A/D HIGH ERROR LIMIT [CalTerm: ADFTSVHL] */
#define adftsvll_param (*(volatile uint16_t*)0x00806CA0UL) /* A/D LOW ERROR LIMIT [CalTerm: ADFTSVLL] */
#define frequency_throttle_input_sensor_sv_channel_address_none (*(volatile uint16_t*)0x00806CA2UL) /* FREQUENCY_THROTTLE_INPUT_SENSOR_SV_CHANNEL_ADDR... */
#define adftsvmu_param (*(volatile uint8_t*)0x00806CA4UL) /* CHANNEL MUX SETTING [CalTerm: ADFTSVMU] */
#define adftsvts_param (*(volatile uint8_t*)0x00806CA5UL) /* TRI STATE ERROR [CalTerm: ADFTSVTS] */
#define error_number_storage_for_frequency_throttle_input_sv_high_erro_0_255 (*(volatile uint8_t*)0x00806CA6UL) /* ERROR NUMBER STORAGE FOR FREQUENCY_THROTTLE_INP... */
#define error_number_storage_for_frequency_throttle_input_sv_low_error_0_255 (*(volatile uint8_t*)0x00806CA7UL) /* ERROR NUMBER STORAGE FOR FREQUENCY_THROTTLE_INP... */
#define adftsvte_param (*(volatile uint8_t*)0x00806CA8UL) /* TRI STATE ERROR [CalTerm: ADFTSVTE] */
#define ADFTSVSR (*(volatile uint8_t*)0x00806CA9UL) /* A/D SAMPLE PERIOD */
#define a_d_digital_filter_constant_for_cc_switch_mux_0_1 (*(volatile uint16_t*)0x00806CAAUL) /* A/D DIGITAL FILTER CONSTANT FOR CC SWITCH MUX [... */
#define global_default_value_for_cc_switch_mux_0_5 (*(volatile uint16_t*)0x00806CACUL) /* GLOBAL DEFAULT VALUE FOR CC SWITCH MUX [CalTerm... */
#define a_d_fault_clear_counts_for_cc_switch_mux_0_32767 (*(volatile uint16_t*)0x00806CAEUL) /* A/D FAULT CLEAR COUNTS FOR CC SWITCH MUX [CalTe... */
#define a_d_fault_decrement_for_cc_switch_mux_0_32767 (*(volatile uint16_t*)0x00806CB0UL) /* A/D FAULT DECREMENT FOR CC SWITCH MUX [CalTerm:... */
#define a_d_fault_increment_for_cc_switch_mux_0_32767 (*(volatile uint16_t*)0x00806CB2UL) /* A/D FAULT INCREMENT FOR CC SWITCH MUX [CalTerm:... */
#define a_d_fault_set_for_cc_switch_mux_0_32767 (*(volatile uint16_t*)0x00806CB4UL) /* A/D FAULT SET FOR CC SWITCH MUX [CalTerm: ADCRFS] */
#define a_d_high_error_limit_for_cc_switch_mux_0_1023 (*(volatile uint16_t*)0x00806CB6UL) /* A/D HIGH ERROR LIMIT FOR CC SWITCH MUX [CalTerm... */
#define a_d_low_error_limit_for_cc_switch_mux_0_1023 (*(volatile uint16_t*)0x00806CB8UL) /* A/D LOW ERROR LIMIT FOR CC SWITCH MUX [CalTerm:... */
#define cruise_control_switch_mux_channel_address_none (*(volatile uint16_t*)0x00806CBAUL) /* CRUISE_CONTROL_SWITCH_MUX_CHANNEL_ADDRESS [CalT... */
#define cc_switch_mux_channel_mux_setting_0_255 (*(volatile uint8_t*)0x00806CBCUL) /* CC SWITCH MUX CHANNEL MUX SETTING [CalTerm: ADC... */
#define tri_state_error_for_cc_switch_mux_enable_disable (*(volatile uint8_t*)0x00806CBDUL) /* TRI STATE ERROR FOR CC SWITCH MUX [CalTerm: ADC... */
#define error_number_storage_for_cruise_control_switch_mux_high_error_0_255 (*(volatile uint8_t*)0x00806CBEUL) /* ERROR NUMBER STORAGE FOR CRUISE_CONTROL_SWITCH_... */
#define error_number_storage_for_cruise_control_switch_mux_low_error_0_255 (*(volatile uint8_t*)0x00806CBFUL) /* ERROR NUMBER STORAGE FOR CRUISE_CONTROL_SWITCH_... */
#define tri_state_error_none_6cc0 (*(volatile uint8_t*)0x00806CC0UL) /* TRI STATE ERROR */
#define ADCRSR (*(volatile uint8_t*)0x00806CC1UL) /* A/D SAMPLE PERIOD FOR CC SWITCH MUX */
#define water_in_fuel_a_d_digital_filter_constant_0_1 (*(volatile uint16_t*)0x00806CC2UL) /* WATER IN FUEL A/D DIGITAL FILTER CONSTANT [CalT... */
#define water_in_fuel_global_default_value_0_3 (*(volatile uint16_t*)0x00806CC4UL) /* WATER IN FUEL GLOBAL DEFAULT VALUE [CalTerm: AD... */
#define water_in_fuel_a_d_fault_clear_counts_0_32767 (*(volatile uint16_t*)0x00806CC6UL) /* WATER IN FUEL A/D FAULT CLEAR COUNTS [CalTerm: ... */
#define water_in_fuel_a_d_fault_decrement_0_32767 (*(volatile uint16_t*)0x00806CC8UL) /* WATER IN FUEL A/D FAULT DECREMENT [CalTerm: ADW... */
#define water_in_fuel_a_d_fault_increment_0_32767 (*(volatile uint16_t*)0x00806CCAUL) /* WATER IN FUEL A/D FAULT INCREMENT [CalTerm: ADW... */
#define water_in_fuel_a_d_fault_set_0_32767 (*(volatile uint16_t*)0x00806CCCUL) /* WATER IN FUEL A/D FAULT SET [CalTerm: ADWFFS] */
#define water_in_fuel_a_d_high_error_limit_0_1023 (*(volatile uint16_t*)0x00806CCEUL) /* WATER IN FUEL A/D HIGH ERROR LIMIT [CalTerm: AD... */
#define water_in_fuel_a_d_low_error_limit_0_1023 (*(volatile uint16_t*)0x00806CD0UL) /* WATER IN FUEL A/D LOW ERROR LIMIT [CalTerm: ADW... */
#define water_in_fuel_channel_address_none (*(volatile uint16_t*)0x00806CD2UL) /* WATER_IN_FUEL_CHANNEL_ADDRESS [CalTerm: ADWFCA] */
#define water_in_fuel_channel_mux_setting_0_255 (*(volatile uint8_t*)0x00806CD4UL) /* WATER IN FUEL CHANNEL MUX SETTING [CalTerm: ADW... */
#define water_in_fuel_tri_state_error_enable_disable (*(volatile uint8_t*)0x00806CD5UL) /* WATER IN FUEL TRI STATE ERROR [CalTerm: ADWFTS] */
#define error_number_storage_for_water_in_fuel_high_error_0_255 (*(volatile uint8_t*)0x00806CD6UL) /* ERROR NUMBER STORAGE FOR WATER_IN_FUEL_HIGH_ERR... */
#define error_number_storage_for_water_in_fuel_low_error_0_255 (*(volatile uint8_t*)0x00806CD7UL) /* ERROR NUMBER STORAGE FOR WATER_IN_FUEL_LOW_ERRO... */
#define water_in_fuel_tri_state_error_none (*(volatile uint8_t*)0x00806CD8UL) /* WATER IN FUEL TRI STATE ERROR [CalTerm: ADWFTE] */
#define ADWFSR (*(volatile uint8_t*)0x00806CD9UL) /* WATER IN FUEL A/D SAMPLE PERIOD */
#define adegcfcs_param (*(volatile uint16_t*)0x00806CDAUL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADEGCFCS] */
#define adegcfgd_param (*(volatile uint16_t*)0x00806CDCUL) /* GLOBAL DEFAULT VALUE [CalTerm: ADEGCFGD] */
#define adegcfcc_param (*(volatile uint16_t*)0x00806CDEUL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADEGCFCC] */
#define adegcffd_param (*(volatile uint16_t*)0x00806CE0UL) /* A/D FAULT DECREMENT [CalTerm: ADEGCFFD] */
#define adegcffi_param (*(volatile uint16_t*)0x00806CE2UL) /* A/D FAULT INCREMENT [CalTerm: ADEGCFFI] */
#define adegcffs_param (*(volatile uint16_t*)0x00806CE4UL) /* A/D FAULT SET [CalTerm: ADEGCFFS] */
#define adegcfhl_param (*(volatile uint16_t*)0x00806CE6UL) /* A/D HIGH ERROR LIMIT [CalTerm: ADEGCFHL] */
#define adegcfll_param (*(volatile uint16_t*)0x00806CE8UL) /* A/D LOW ERROR LIMIT [CalTerm: ADEGCFLL] */
#define egr_current_feedback_channel_address_none (*(volatile uint16_t*)0x00806CEAUL) /* EGR_CURRENT_FEEDBACK_CHANNEL_ADDRESS [CalTerm: ... */
#define adegcfmu_param (*(volatile uint8_t*)0x00806CECUL) /* CHANNEL MUX SETTING [CalTerm: ADEGCFMU] */
#define adegcfts_param (*(volatile uint8_t*)0x00806CEDUL) /* TRI STATE ERROR [CalTerm: ADEGCFTS] */
#define error_number_storage_for_egr_current_feedback_high_error_0_255 (*(volatile uint8_t*)0x00806CEEUL) /* ERROR NUMBER STORAGE FOR EGR_CURRENT_FEEDBACK_H... */
#define error_number_storage_for_egr_current_feedback_low_error_0_255 (*(volatile uint8_t*)0x00806CEFUL) /* ERROR NUMBER STORAGE FOR EGR_CURRENT_FEEDBACK_L... */
#define adegcfte_param (*(volatile uint8_t*)0x00806CF0UL) /* TRI STATE ERROR [CalTerm: ADEGCFTE] */
#define ADEGCFSR (*(volatile uint8_t*)0x00806CF1UL) /* A/D SAMPLE PERIOD */
#define adpssvcs_param (*(volatile uint16_t*)0x00806CF2UL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADPSSVCS] */
#define adpssvgd_param (*(volatile uint16_t*)0x00806CF4UL) /* GLOBAL DEFAULT VALUE [CalTerm: ADPSSVGD] */
#define adpssvfc_param (*(volatile uint16_t*)0x00806CF6UL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADPSSVFC] */
#define adpssvfd_param (*(volatile uint16_t*)0x00806CF8UL) /* A/D FAULT DECREMENT [CalTerm: ADPSSVFD] */
#define adpssvfi_param (*(volatile uint16_t*)0x00806CFAUL) /* A/D FAULT INCREMENT [CalTerm: ADPSSVFI] */
#define adpssvfs_param (*(volatile uint16_t*)0x00806CFCUL) /* A/D FAULT SET [CalTerm: ADPSSVFS] */
#define adpssvhl_param (*(volatile uint16_t*)0x00806CFEUL) /* A/D HIGH ERROR LIMIT [CalTerm: ADPSSVHL] */
#define adpssvll_param (*(volatile uint16_t*)0x00806D00UL) /* A/D LOW ERROR LIMIT [CalTerm: ADPSSVLL] */
#define programming_pulse_sv_channel_address_none (*(volatile uint16_t*)0x00806D02UL) /* PROGRAMMING_PULSE_SV_CHANNEL_ADDRESS [CalTerm: ... */
#define adpssvmu_param (*(volatile uint8_t*)0x00806D04UL) /* CHANNEL MUX SETTING [CalTerm: ADPSSVMU] */
#define adpssvts_param (*(volatile uint8_t*)0x00806D05UL) /* TRI STATE ERROR [CalTerm: ADPSSVTS] */
#define error_number_storage_for_programming_pulse_sv_high_error_0_255 (*(volatile uint8_t*)0x00806D06UL) /* ERROR NUMBER STORAGE FOR PROGRAMMING_PULSE_SV_H... */
#define error_number_storage_for_programming_pulse_sv_low_error_0_255 (*(volatile uint8_t*)0x00806D07UL) /* ERROR NUMBER STORAGE FOR PROGRAMMING_PULSE_SV_L... */
#define adpssvte_param (*(volatile uint8_t*)0x00806D08UL) /* TRI STATE ERROR [CalTerm: ADPSSVTE] */
#define ADPSSVSR (*(volatile uint8_t*)0x00806D09UL) /* A/D SAMPLE PERIOD */
#define ADHBSVCS (*(volatile uint16_t*)0x00806D0AUL) /* A/D DIGITAL FILTER CONSTANT */
#define ADHBSVGD (*(volatile uint16_t*)0x00806D0CUL) /* GLOBAL DEFAULT VALUE */
#define ADHBSVFC (*(volatile uint16_t*)0x00806D0EUL) /* A/D FAULT CLEAR COUNTS */
#define ADHBSVFD (*(volatile uint16_t*)0x00806D10UL) /* A/D FAULT DECREMENT */
#define ADHBSVFI (*(volatile uint16_t*)0x00806D12UL) /* A/D FAULT INCREMENT */
#define ADHBSVFS (*(volatile uint16_t*)0x00806D14UL) /* A/D FAULT SET */
#define adhbsvhl_param (*(volatile uint16_t*)0x00806D16UL) /* A/D HIGH ERROR LIMIT [CalTerm: ADHBSVHL] */
#define adhbsvll_param (*(volatile uint16_t*)0x00806D18UL) /* A/D LOW ERROR LIMIT [CalTerm: ADHBSVLL] */
#define ADHBSVCA (*(volatile uint16_t*)0x00806D1AUL) /* HIGH_SIDE_GATE_BIAS_SV_CHANNEL_ADDRESS */
#define ADHBSVMU (*(volatile uint8_t*)0x00806D1CUL) /* CHANNEL MUX SETTING */
#define ADHBSVTS (*(volatile uint8_t*)0x00806D1DUL) /* TRI STATE ERROR */
#define ADHBSVHE (*(volatile uint8_t*)0x00806D1EUL) /* ERROR NUMBER STORAGE FOR HIGH_SIDE_GATE_BIAS_SV... */
#define ADHBSVLE (*(volatile uint8_t*)0x00806D1FUL) /* ERROR NUMBER STORAGE FOR HIGH_SIDE_GATE_BIAS_SV... */
#define ADHBSVTE (*(volatile uint8_t*)0x00806D20UL) /* TRI STATE ERROR */
#define ADHBSVSR (*(volatile uint8_t*)0x00806D21UL) /* A/D SAMPLE PERIOD */
#define adocsvcs_param (*(volatile uint16_t*)0x00806D22UL) /* A/D DIGITAL FILTER CONSTANT [CalTerm: ADOCSVCS] */
#define adocsvgd_param (*(volatile uint16_t*)0x00806D24UL) /* GLOBAL DEFAULT VALUE [CalTerm: ADOCSVGD] */
#define adocsvfc_param (*(volatile uint16_t*)0x00806D26UL) /* A/D FAULT CLEAR COUNTS [CalTerm: ADOCSVFC] */
#define adocsvfd_param (*(volatile uint16_t*)0x00806D28UL) /* A/D FAULT DECREMENT [CalTerm: ADOCSVFD] */
#define adocsvfi_param (*(volatile uint16_t*)0x00806D2AUL) /* A/D FAULT INCREMENT [CalTerm: ADOCSVFI] */
#define adocsvfs_param (*(volatile uint16_t*)0x00806D2CUL) /* A/D FAULT SET [CalTerm: ADOCSVFS] */
#define adocsvhl_param (*(volatile uint16_t*)0x00806D2EUL) /* A/D HIGH ERROR LIMIT [CalTerm: ADOCSVHL] */
#define adocsvll_param (*(volatile uint16_t*)0x00806D30UL) /* A/D LOW ERROR LIMIT [CalTerm: ADOCSVLL] */
#define op_amps_and_comparators_sv_channel_address_none (*(volatile uint16_t*)0x00806D32UL) /* OP_AMPS_AND_COMPARATORS_SV_CHANNEL_ADDRESS [Cal... */
#define adocsvmu_param (*(volatile uint8_t*)0x00806D34UL) /* CHANNEL MUX SETTING [CalTerm: ADOCSVMU] */
#define adocsvts_param (*(volatile uint8_t*)0x00806D35UL) /* TRI STATE ERROR [CalTerm: ADOCSVTS] */
#define error_number_storage_for_op_amps_and_comparators_sv_high_error_0_255 (*(volatile uint8_t*)0x00806D36UL) /* ERROR NUMBER STORAGE FOR OP_AMPS_AND_COMPARATOR... */
#define error_number_storage_for_op_amps_and_comparators_sv_low_error_0_255 (*(volatile uint8_t*)0x00806D37UL) /* ERROR NUMBER STORAGE FOR OP_AMPS_AND_COMPARATOR... */
#define adocsvte_param (*(volatile uint8_t*)0x00806D38UL) /* TRI STATE ERROR [CalTerm: ADOCSVTE] */
#define ADOCSVSR (*(volatile uint8_t*)0x00806D39UL) /* A/D SAMPLE PERIOD */
#define linearization_table_ch15_x_axis ((volatile uint16_t*)0x00806D3AUL) /* [3] ADC Channel 15 linearization X-axis (3 entries)... */
#define linearization_table_ch15_y_axis ((volatile uint16_t*)0x00806D40UL) /* [3] ADC Channel 15 linearization Y-axis (3 entries) */
#define linearization_table_ch16_x_axis ((volatile uint16_t*)0x00806D46UL) /* [3] ADC Channel 16 linearization X-axis (3 entries)... */
#define linearization_table_ch16_y_axis ((volatile uint16_t*)0x00806D4CUL) /* [3] ADC Channel 16 linearization Y-axis (3 entries) */
#define linearization_table_ch17_x_axis ((volatile uint16_t*)0x00806D52UL) /* [3] ADC Channel 17 linearization X-axis (3 entries)... */
#define linearization_table_ch17_y_axis ((volatile uint16_t*)0x00806D58UL) /* [3] ADC Channel 17 linearization Y-axis (3 entries) */
#define linearization_table_ch18_x_axis ((volatile uint16_t*)0x00806D5EUL) /* [3] ADC Channel 18 linearization X-axis (3 entries)... */
#define linearization_table_ch18_y_axis ((volatile uint16_t*)0x00806D64UL) /* [3] ADC Channel 18 linearization Y-axis (3 entries) */
#define linearization_table_ch19_x_axis ((volatile uint16_t*)0x00806D6AUL) /* [3] ADC Channel 19 linearization X-axis (3 entries)... */
#define linearization_table_ch19_y_axis ((volatile uint16_t*)0x00806D70UL) /* [3] ADC Channel 19 linearization Y-axis (3 entries) */
#define linearization_table_ch20_x_axis ((volatile uint16_t*)0x00806D76UL) /* [19] ADC Channel 20 linearization X-axis (19 entries... */
#define linearization_table_ch20_y_axis ((volatile uint16_t*)0x00806D9CUL) /* [19] ADC Channel 20 linearization Y-axis (19 entries) */
#define linearization_table_ch21_x_axis ((volatile uint16_t*)0x00806DC2UL) /* [9] ADC Channel 21 linearization X-axis (9 entries)... */
#define linearization_table_ch21_y_axis ((volatile uint16_t*)0x00806DD4UL) /* [9] ADC Channel 21 linearization Y-axis (9 entries)... */
#define linearization_table_ch22_x_axis ((volatile uint16_t*)0x00806DE6UL) /* [4] ADC Channel 22 linearization X-axis (4 entries)... */
#define linearization_table_ch22_y_axis ((volatile uint16_t*)0x00806DEEUL) /* [4] ADC Channel 22 linearization Y-axis (4 entries) */
#define linearization_table_ch23_x_axis ((volatile uint16_t*)0x00806DF6UL) /* [3] ADC Channel 23 linearization X-axis (3 entries)... */
#define linearization_table_ch23_y_axis ((volatile uint16_t*)0x00806DFCUL) /* [3] ADC Channel 23 linearization Y-axis (3 entries) */
#define linearization_table_ch24_x_axis ((volatile uint16_t*)0x00806E02UL) /* [3] ADC Channel 24 linearization X-axis (3 entries)... */
#define linearization_table_ch24_y_axis ((volatile uint16_t*)0x00806E08UL) /* [3] ADC Channel 24 linearization Y-axis (3 entries) */
#define linearization_table_ch25_x_axis ((volatile uint16_t*)0x00806E0EUL) /* [3] ADC Channel 25 linearization X-axis (3 entries)... */
#define linearization_table_ch25_y_axis ((volatile uint16_t*)0x00806E14UL) /* [3] ADC Channel 25 linearization Y-axis (3 entries) */
#define fuel_limit_rpm_error_offset (*(volatile uint16_t*)0x00806E1AUL) /* Fuel limit offset added to governor RPM error (... */
#define diagnostic_exit_limit (*(volatile uint16_t*)0x00806E1CUL) /* Diagnostic state exit counter limit (2 refs) */
#define diagnostic_transition_limit (*(volatile uint16_t*)0x00806E1EUL) /* Diagnostic state transition counter limit (2 refs) */
#define unnamed_data_6e24 (*(volatile uint16_t*)0x00806E24UL)
#define unnamed_data_6e36 (*(volatile uint16_t*)0x00806E36UL)
#define unnamed_data_6e4c (*(volatile uint16_t*)0x00806E4CUL)
#define unnamed_data_6e8a (*(volatile uint16_t*)0x00806E8AUL)
#define ADAATXA ((volatile uint8_t*)0x00806ED0UL) /* [8] CalTerm ADAATXA: X-AXIS */
#define ADPOTPXA (*(volatile uint16_t*)0x00806EE8UL) /* X-AXIS */
#define unnamed_data_6ef4 (*(volatile uint16_t*)0x00806EF4UL)
#define unnamed_data_6f08 (*(volatile uint16_t*)0x00806F08UL)
#define unnamed_data_6f24 (*(volatile uint16_t*)0x00806F24UL)
#define unnamed_data_6f3c (*(volatile uint16_t*)0x00806F3CUL)
#define unnamed_data_6f4c (*(volatile uint16_t*)0x00806F4CUL)
#define unnamed_data_6f58 (*(volatile uint16_t*)0x00806F58UL)
#define unnamed_data_6f64 (*(volatile uint16_t*)0x00806F64UL)
#define unnamed_data_6f70 (*(volatile uint16_t*)0x00806F70UL)
#define unnamed_data_6f7c (*(volatile uint16_t*)0x00806F7CUL)
#define unnamed_data_6f88 (*(volatile uint16_t*)0x00806F88UL)
#define timing_protection_flags_param (*(volatile uint16_t*)0x00806FA0UL) /* Timing protection flags parameter (timingProtec... */
#define timing_protection_blend_base (*(volatile uint16_t*)0x00806FA2UL) /* Timing protection blend base value (4 refs) */
#define timing_protection_blend_increment (*(volatile uint16_t*)0x00806FA4UL) /* Timing protection blend ramp increment value (3... */
#define fuel_mode_transition_timeout_value (*(volatile uint16_t*)0x00806FA6UL) /* Timeout countdown init for fuel mode transition... */
#define fuel_timing_mode_arbitration_1 (*(volatile uint16_t*)0x00806FA8UL) /* Fuel timing mode arbitration param 1 (fuelTimin... */
#define fuel_timing_mode_arbitration_2 (*(volatile uint16_t*)0x00806FACUL) /* Fuel timing mode arbitration param 2 (fuelTimin... */
#define fuel_source_mode_11_timeout_value (*(volatile uint16_t*)0x00806FAEUL) /* Timeout countdown init for fuel source mode 11 ... */
#define timing_blend_threshold (*(volatile uint16_t*)0x00806FB2UL) /* Timing blend state threshold for fuelTableBlend... */
#define unnamed_data_6fb4 (*(volatile uint16_t*)0x00806FB4UL)
#define shutdown_protection_param_1 (*(volatile uint16_t*)0x00806FB6UL) /* Shutdown protection parameter 1 (shutdownProtec... */
#define shutdown_protection_param_2 (*(volatile uint16_t*)0x00806FB8UL) /* Shutdown protection parameter 2 (shutdownProtec... */
#define unnamed_data_6fec (*(volatile uint16_t*)0x00806FECUL)
#define unnamed_data_7006 (*(volatile uint16_t*)0x00807006UL)
#define unnamed_data_7014 (*(volatile uint16_t*)0x00807014UL)
#define unnamed_data_7020 (*(volatile uint16_t*)0x00807020UL)
#define unnamed_data_702c (*(volatile uint16_t*)0x0080702CUL)
#define time_from_overlimit_reached_to_starting_fuel_derate_0_65535_7034 (*(volatile uint16_t*)0x00807034UL) /* TIME FROM OVERLIMIT REACHED TO STARTING FUEL DE... */
#define time_from_coolant_level_thresh_reached_to_starting_rpm_dera_0_65535 (*(volatile uint16_t*)0x00807036UL) /* TIME FROM COOLANT LEVEL THRESH. REACHED TO STAR... */
#define time_to_reach_full_derate_during_coolant_level_engine_pro_0_0039_256_7038 (*(volatile uint16_t*)0x00807038UL) /* TIME TO REACH FULL DERATE DURING COOLANT LEVEL ... */
#define time_to_reach_full_derate_during_coolant_level_engine_pro_0_0039_256_703a (*(volatile uint16_t*)0x0080703AUL) /* TIME TO REACH FULL DERATE DURING COOLANT LEVEL ... */
#define minimum_threshold_for_coolant_level_fuel_limiting_0 (*(volatile uint16_t*)0x0080703CUL) /* MINIMUM THRESHOLD FOR COOLANT LEVEL FUEL LIMITING. */
#define maximum_threshold_for_coolant_level_fueling_limiting_0 (*(volatile uint16_t*)0x0080703EUL) /* MAXIMUM THRESHOLD FOR COOLANT LEVEL FUELING LIM... */
#define minimum_threshold_for_coolant_level_rpm_limiting_0_65535 (*(volatile uint16_t*)0x00807040UL) /* MINIMUM THRESHOLD FOR COOLANT LEVEL RPM LIMITING */
#define shutdown_threshold_for_coolant_level_fueling_0_65535 (*(volatile uint16_t*)0x00807042UL) /* SHUTDOWN THRESHOLD FOR COOLANT LEVEL FUELING */
#define shutdown_threshold_for_coolant_level_rpm_0_65535 (*(volatile uint16_t*)0x00807044UL) /* SHUTDOWN THRESHOLD FOR COOLANT LEVEL RPM */
#define shutdown_delay_for_coolant_level_shutdown_0_255 (*(volatile uint16_t*)0x00807046UL) /* SHUTDOWN DELAY FOR COOLANT LEVEL SHUTDOWN */
#define rpm_to_reach_before_coolant_level_errors_0_8000 (*(volatile uint16_t*)0x00807048UL) /* RPM TO REACH BEFORE COOLANT LEVEL ERRORS. */
#define delay_after_rpm_reached_before_coolant_level_errors_0_255 (*(volatile uint16_t*)0x0080704AUL) /* DELAY AFTER RPM REACHED BEFORE COOLANT LEVEL ER... */
#define fault_index_indicating_epf_coolant_level_fuel_error_found_0_ffff (*(volatile uint16_t*)0x0080704CUL) /* FAULT INDEX INDICATING EPF COOLANT LEVEL FUEL E... */
#define fault_index_indicating_epf_coolant_level_rpm_error_found_0_ffff (*(volatile uint16_t*)0x0080704EUL) /* FAULT INDEX INDICATING EPF COOLANT LEVEL RPM ER... */
#define time_duration_to_warn_driver_before_shutdown_due_to_coolant_0_65535_7050 (*(volatile uint16_t*)0x00807050UL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define shutdown_threshold_for_coolant_level_fueling_0_1 (*(volatile uint16_t*)0x00807052UL) /* SHUTDOWN THRESHOLD FOR COOLANT LEVEL FUELING */
#define shutdown_threshold_for_coolant_level_rpm_0_1 (*(volatile uint16_t*)0x00807054UL) /* SHUTDOWN THRESHOLD FOR COOLANT LEVEL RPM */
#define time_from_coolant_temp_thresh_reached_to_starting_fuel_dera_0_65535 (*(volatile uint16_t*)0x00807058UL) /* TIME FROM COOLANT TEMP THRESH. REACHED TO START... */
#define time_from_coolant_temp_thresh_reached_to_starting_rpm_derat_0_65535 (*(volatile uint16_t*)0x0080705AUL) /* TIME FROM COOLANT TEMP THRESH. REACHED TO START... */
#define time_to_reach_full_derate_w_coolant_temperature_engine_p_0_0039_256 (*(volatile uint16_t*)0x0080705CUL) /* TIME TO REACH FULL DERATE W/ COOLANT TEMPERATUR... */
#define time_to_reach_full_derate_during_coolant_temperature_engi_0_0039_256 (*(volatile uint16_t*)0x0080705EUL) /* TIME TO REACH FULL DERATE DURING COOLANT TEMPER... */
#define minimum_temperature_threshold_for_coolant_temperature_fuel_50_to_293 (*(volatile uint16_t*)0x00807060UL) /* MINIMUM TEMPERATURE THRESHOLD FOR COOLANT TEMPE... */
#define maximum_temperature_threshold_for_coolant_temperature_fuel_50_to_293 (*(volatile uint16_t*)0x00807062UL) /* MAXIMUM TEMPERATURE THRESHOLD FOR COOLANT TEMPE... */
#define minimum_threshold_for_coolant_temperature_rpm_limiting_0_4500 (*(volatile uint16_t*)0x00807064UL) /* MINIMUM THRESHOLD FOR COOLANT TEMPERATURE RPM L... */
#define shutdown_threshold_duration_time_0_65535 (*(volatile uint16_t*)0x00807066UL) /* SHUTDOWN THRESHOLD DURATION TIME [CalTerm: ADCL... */
#define shutdown_threshold_for_coolant_temp_rpm_0_65535 (*(volatile uint16_t*)0x00807068UL) /* SHUTDOWN THRESHOLD FOR COOLANT TEMP RPM */
#define shutdown_delay_for_coolant_temperature_shutdown_0_255 (*(volatile uint16_t*)0x0080706AUL) /* SHUTDOWN DELAY FOR COOLANT TEMPERATURE SHUTDOWN */
#define rpm_to_reach_before_coolant_temp_errors_0_8000 (*(volatile uint16_t*)0x0080706CUL) /* RPM TO REACH BEFORE COOLANT TEMP ERRORS. */
#define delay_after_rpm_reached_before_coolant_temp_errors_0_255 (*(volatile uint16_t*)0x0080706EUL) /* DELAY AFTER RPM REACHED BEFORE COOLANT TEMP ERR... */
#define fault_index_indicating_epf_coolant_temp_fuel_error_found_0_ffff (*(volatile uint16_t*)0x00807070UL) /* FAULT INDEX INDICATING EPF COOLANT TEMP FUEL ER... */
#define fault_index_indicating_epf_coolant_temp_rpm_error_found_0_ffff (*(volatile uint16_t*)0x00807072UL) /* FAULT INDEX INDICATING EPF COOLANT TEMP RPM ERR... */
#define time_duration_to_warn_driver_before_shutdown_due_to_coolant_0_65535_7074 (*(volatile uint16_t*)0x00807074UL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define shutdown_threshold_for_coolant_temperature_20_255 (*(volatile uint16_t*)0x00807076UL) /* SHUTDOWN THRESHOLD FOR COOLANT TEMPERATURE */
#define shutdown_threshold_for_coolant_temp_rpm_20_255 (*(volatile uint16_t*)0x00807078UL) /* SHUTDOWN THRESHOLD FOR COOLANT TEMP RPM */
#define crank_sync_threshold (*(volatile uint16_t*)0x0080707AUL) /* Crank sync comparison threshold (2 refs) */
#define time_from_overlimit_reached_to_starting_tvo_derate_0_65535 (*(volatile uint16_t*)0x0080707CUL) /* TIME FROM OVERLIMIT REACHED TO STARTING TVO DER... */
#define time_duration_from_overlimit_reached_to_starting_rpm_derate_0_65535_707e (*(volatile uint16_t*)0x0080707EUL) /* TIME DURATION FROM OVERLIMIT REACHED TO STARTIN... */
#define time_to_reach_full_derate_during_intake_temp_engine_prote_0_0039_256_7080 (*(volatile uint16_t*)0x00807080UL) /* TIME TO REACH FULL DERATE DURING INTAKE TEMP EN... */
#define time_to_reach_full_derate_during_intake_temp_engine_prote_0_0039_256_7082 (*(volatile uint16_t*)0x00807082UL) /* TIME TO REACH FULL DERATE DURING INTAKE TEMP EN... */
#define minimum_temperature_threshold_for_imt_fuel_limiting_50_to_293 (*(volatile uint16_t*)0x00807084UL) /* MINIMUM TEMPERATURE THRESHOLD FOR IMT FUEL LIMI... */
#define maximum_temperature_threshold_for_imt_tvo_limiting_50_to_293 (*(volatile uint16_t*)0x00807086UL) /* MAXIMUM TEMPERATURE THRESHOLD FOR IMT TVO LIMIT... */
#define minimum_threshold_for_intake_temperature_rpm_limiting_50_293 (*(volatile uint16_t*)0x00807088UL) /* MINIMUM THRESHOLD FOR INTAKE TEMPERATURE RPM LI... */
#define shutdown_threshold_for_intake_temp_fuel_0_65535 (*(volatile uint16_t*)0x0080708AUL) /* SHUTDOWN THRESHOLD FOR INTAKE TEMP FUEL */
#define shutdown_threshold_for_intake_temp_rpm_0_65535 (*(volatile uint16_t*)0x0080708CUL) /* SHUTDOWN THRESHOLD FOR INTAKE TEMP RPM */
#define shutdown_delay_for_intake_temperature_shutdown_0_255 (*(volatile uint16_t*)0x0080708EUL) /* SHUTDOWN DELAY FOR INTAKE TEMPERATURE SHUTDOWN */
#define rpm_to_reach_before_imt_errors_0_8000 (*(volatile uint16_t*)0x00807090UL) /* RPM TO REACH BEFORE IMT ERRORS. */
#define delay_after_rpm_reached_before_intake_temp_errors_0_255 (*(volatile uint16_t*)0x00807092UL) /* DELAY AFTER RPM REACHED BEFORE INTAKE TEMP ERRORS. */
#define fault_index_indicating_epf_imt_fuel_error_found_0_ffff (*(volatile uint16_t*)0x00807094UL) /* FAULT INDEX INDICATING EPF IMT FUEL ERROR FOUND */
#define fault_index_indicating_epf_imt_rpm_error_found_0_ffff (*(volatile uint16_t*)0x00807096UL) /* FAULT INDEX INDICATING EPF IMT RPM ERROR FOUND */
#define time_duration_to_warn_driver_before_shutdown_due_to_intake_t_0_65535 (*(volatile uint16_t*)0x00807098UL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define shutdown_threshold_for_intake_temp_fuel_50_293 (*(volatile uint16_t*)0x0080709AUL) /* SHUTDOWN THRESHOLD FOR INTAKE TEMP FUEL */
#define shutdown_threshold_for_intake_temp_rpm_20_255 (*(volatile uint16_t*)0x0080709CUL) /* SHUTDOWN THRESHOLD FOR INTAKE TEMP RPM */
#define time_from_overlimit_reached_to_starting_fuel_derate_0_65535_70a0 (*(volatile uint16_t*)0x008070A0UL) /* TIME FROM OVERLIMIT REACHED TO STARTING FUEL DE... */
#define time_duration_from_overlimit_reached_to_starting_rpm_derate_0_65535_70a2 (*(volatile uint16_t*)0x008070A2UL) /* TIME DURATION FROM OVERLIMIT REACHED TO STARTIN... */
#define time_to_reach_full_derate_during_oil_pressure_engine_prot_0_0039_256_70a4 (*(volatile uint16_t*)0x008070A4UL) /* TIME TO REACH FULL DERATE DURING OIL PRESSURE E... */
#define time_to_reach_full_derate_during_oil_pressure_engine_prot_0_0039_256_70a6 (*(volatile uint16_t*)0x008070A6UL) /* TIME TO REACH FULL DERATE DURING OIL PRESSURE E... */
#define minimum_threshold_for_oil_pressure_fuel_limiting_0_100 (*(volatile uint16_t*)0x008070A8UL) /* MINIMUM THRESHOLD FOR OIL PRESSURE FUEL LIMITING. */
#define maximum_threshold_for_oil_pressure_fueling_limiting_0_100 (*(volatile uint16_t*)0x008070AAUL) /* MAXIMUM THRESHOLD FOR OIL PRESSURE FUELING LIMI... */
#define minimum_threshold_for_oil_pressure_rpm_limiting_0_65535 (*(volatile uint16_t*)0x008070ACUL) /* MINIMUM THRESHOLD FOR OIL PRESSURE RPM LIMITING */
#define time_to_shutdown_after_low_oil_pressure_error_declared_0_65535 (*(volatile uint16_t*)0x008070AEUL) /* TIME TO SHUTDOWN AFTER LOW OIL PRESSURE ERROR D... */
#define time_to_shutdown_after_very_low_pressure_error_declared_0_65535 (*(volatile uint16_t*)0x008070B0UL) /* TIME TO SHUTDOWN AFTER VERY LOW PRESSURE ERROR ... */
#define shutdown_delay_for_oil_pressure_shutdown_0_255 (*(volatile uint16_t*)0x008070B2UL) /* SHUTDOWN DELAY FOR OIL PRESSURE SHUTDOWN */
#define EPO2SRRP (*(volatile uint16_t*)0x008070B4UL) /* CalTerm EPO2SRRP: DONT LOG OIL PRESSURE FAULTS ... */
#define dont_log_oil_pressure_faults_until_running_and_time_expired_0_255 (*(volatile uint16_t*)0x008070B6UL) /* DONT LOG OIL PRESSURE FAULTS UNTIL RUNNING AND ... */
#define fault_index_indicating_epf_oil_pressure_fuel_error_found_0_ffff (*(volatile uint16_t*)0x008070B8UL) /* FAULT INDEX INDICATING EPF OIL PRESSURE FUEL ER... */
#define fault_index_indicating_epf_oil_pressure_rpm_error_found_0_ffff (*(volatile uint16_t*)0x008070BAUL) /* FAULT INDEX INDICATING EPF OIL PRESSURE RPM ERR... */
#define time_duration_to_warn_driver_before_shutdown_due_to_oil_pres_0_65535 (*(volatile uint16_t*)0x008070BCUL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define time_to_shutdown_after_low_oil_pressure_error_declared_0_100 (*(volatile uint16_t*)0x008070BEUL) /* TIME TO SHUTDOWN AFTER LOW OIL PRESSURE ERROR D... */
#define time_to_shutdown_after_very_low_pressure_error_declared_0_100 (*(volatile uint16_t*)0x008070C0UL) /* TIME TO SHUTDOWN AFTER VERY LOW PRESSURE ERROR ... */
#define start_duration_for_water_in_fuel_fueling_derate_0_65535 (*(volatile uint16_t*)0x008070C4UL) /* START DURATION FOR WATER IN FUEL FUELING DERATE */
#define start_duration_for_water_in_fuel_rpm_derate_0_65535 (*(volatile uint16_t*)0x008070C6UL) /* START DURATION FOR WATER IN FUEL RPM DERATE */
#define time_to_reach_full_derate_during_water_in_fuel_eng_pro_1_256_65535_256_70c8 (*(volatile uint16_t*)0x008070C8UL) /* TIME TO REACH FULL DERATE DURING WATER IN FUEL ... */
#define time_to_reach_full_derate_during_water_in_fuel_eng_pro_1_256_65535_256_70ca (*(volatile uint16_t*)0x008070CAUL) /* TIME TO REACH FULL DERATE DURING WATER IN FUEL ... */
#define min_threshold_for_water_in_fuel_fuel_limiting_0_3 (*(volatile uint16_t*)0x008070CCUL) /* MIN THRESHOLD FOR WATER IN FUEL FUEL LIMITING */
#define max_threshold_for_water_in_fuel_fuel_limiting_0_3 (*(volatile uint16_t*)0x008070CEUL) /* MAX THRESHOLD FOR WATER IN FUEL FUEL LIMITING */
#define min_threshold_for_water_in_fuel_rpm_limiting_0_65535 (*(volatile uint16_t*)0x008070D0UL) /* MIN THRESHOLD FOR WATER IN FUEL RPM LIMITING */
#define shutdown_duration_threshold_for_water_in_fuel_fuel_0_65535 (*(volatile uint16_t*)0x008070D2UL) /* SHUTDOWN DURATION THRESHOLD FOR WATER_IN_FUEL FUEL */
#define shutdown_duration_threshold_for_water_in_fuel_rpm_0_65535 (*(volatile uint16_t*)0x008070D4UL) /* SHUTDOWN DURATION THRESHOLD FOR WATER_IN_FUEL RPM */
#define shutdown_delay_for_water_in_fuel_shutdown_0_255 (*(volatile uint16_t*)0x008070D6UL) /* SHUTDOWN DELAY FOR WATER IN FUEL SHUTDOWN */
#define rpm_to_reach_before_for_water_in_fuel_errors_0_8000 (*(volatile uint16_t*)0x008070D8UL) /* RPM TO REACH BEFORE FOR WATER IN FUEL ERRORS */
#define delay_after_rpm_is_reached_before_water_in_fuel_errors_0_8000 (*(volatile uint16_t*)0x008070DAUL) /* DELAY AFTER RPM IS REACHED BEFORE WATER IN FUEL... */
#define fault_when_epf_water_in_fuel_fuel_error_found_0_65535 (*(volatile uint16_t*)0x008070DCUL) /* FAULT WHEN EPF WATER IN FUEL FUEL ERROR FOUND */
#define fault_when_epf_water_in_fuel_rpm_error_found_0_65535 (*(volatile uint16_t*)0x008070DEUL) /* FAULT WHEN EPF WATER IN FUEL RPM ERROR FOUND */
#define time_duration_to_warn_driver_before_shutdown_due_to_water_in_f_0_65535 (*(volatile uint16_t*)0x008070E0UL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define shutdown_severity_threshold_for_water_in_fuel_fueling_0_3 (*(volatile uint16_t*)0x008070E2UL) /* SHUTDOWN SEVERITY THRESHOLD FOR WATER IN FUEL F... */
#define shutdown_severity_threshold_for_water_in_fuel_rpm_0_3 (*(volatile uint16_t*)0x008070E4UL) /* SHUTDOWN SEVERITY THRESHOLD FOR WATER IN FUEL RPM */
#define start_duration_for_boost_pressure_fueling_derate_0_65535 (*(volatile uint16_t*)0x008070E8UL) /* START DURATION FOR BOOST PRESSURE FUELING DERATE */
#define start_duration_for_boost_pressure_rpm_derate_0_65535 (*(volatile uint16_t*)0x008070EAUL) /* START DURATION FOR BOOST PRESSURE RPM DERATE */
#define time_to_reach_full_derate_during_boost_press_eng_prote_1_256_65535_256_70ec (*(volatile uint16_t*)0x008070ECUL) /* TIME TO REACH FULL DERATE DURING BOOST PRESS EN... */
#define time_to_reach_full_derate_during_boost_press_eng_prote_1_256_65535_256_70ee (*(volatile uint16_t*)0x008070EEUL) /* TIME TO REACH FULL DERATE DURING BOOST PRESS EN... */
#define min_threshold_for_boost_pressure_fuel_limiting_0_100 (*(volatile uint16_t*)0x008070F0UL) /* MIN THRESHOLD FOR BOOST PRESSURE FUEL LIMITING */
#define max_threshold_for_boost_pressure_fuel_limiting_0_100 (*(volatile uint16_t*)0x008070F2UL) /* MAX THRESHOLD FOR BOOST PRESSURE FUEL LIMITING */
#define min_threshold_for_boost_fuel_pressure_rpm_limiting_0_65535 (*(volatile uint16_t*)0x008070F4UL) /* MIN THRESHOLD FOR BOOST FUEL PRESSURE RPM LIMITING */
#define shutdown_duration_threshold_for_boost_pressure_fuel_0_65535 (*(volatile uint16_t*)0x008070F6UL) /* SHUTDOWN DURATION THRESHOLD FOR BOOST_PRESSURE ... */
#define shutdown_duration_threshold_for_boost_pressure_rpm_0_65535 (*(volatile uint16_t*)0x008070F8UL) /* SHUTDOWN DURATION THRESHOLD FOR BOOST_PRESSURE RPM */
#define shutdown_delay_for_boost_pressure_shutdown_0_255 (*(volatile uint16_t*)0x008070FAUL) /* SHUTDOWN DELAY FOR BOOST PRESSURE SHUTDOWN */
#define rpm_to_reach_before_for_boost_pressure_errors_0_8000 (*(volatile uint16_t*)0x008070FCUL) /* RPM TO REACH BEFORE FOR BOOST PRESSURE ERRORS */
#define delay_after_rpm_is_reached_before_boost_pressure_errors_0_8000 (*(volatile uint16_t*)0x008070FEUL) /* DELAY AFTER RPM IS REACHED BEFORE BOOST PRESSUR... */
#define fault_when_epf_boost_pressure_fuel_error_found_0_65535 (*(volatile uint16_t*)0x00807100UL) /* FAULT WHEN EPF BOOST PRESSURE FUEL ERROR FOUND */
#define fault_when_epf_engine_boost_pressure_rpm_error_found_0_65535 (*(volatile uint16_t*)0x00807102UL) /* FAULT WHEN EPF ENGINE BOOST PRESSURE RPM ERROR ... */
#define time_duration_to_warn_driver_before_shutdown_due_to_boost_pres_0_65535 (*(volatile uint16_t*)0x00807104UL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define shutdown_severity_threshold_for_boost_pressure_fueling_0_100 (*(volatile uint16_t*)0x00807106UL) /* SHUTDOWN SEVERITY THRESHOLD FOR BOOST PRESSURE ... */
#define shutdown_severity_threshold_for_boost_pressure_rpm_0_100 (*(volatile uint16_t*)0x00807108UL) /* SHUTDOWN SEVERITY THRESHOLD FOR BOOST PRESSURE RPM */
#define boost_diagnostic_threshold (*(volatile uint16_t*)0x0080710AUL) /* Boost diagnostic threshold comparison value (1 ... */
#define start_duration_for_engine_sync_fuel_pressure_fueling_derate_0_65535 (*(volatile uint16_t*)0x0080710CUL) /* START DURATION FOR ENGINE SYNC FUEL PRESSURE FU... */
#define start_duration_for_engine_sync_fuel_pressure_rpm_derate_0_65535 (*(volatile uint16_t*)0x0080710EUL) /* START DURATION FOR ENGINE SYNC FUEL PRESSURE RP... */
#define time_to_reach_full_derate_during_fuel_press_eng_protec_1_256_65535_256_7110 (*(volatile uint16_t*)0x00807110UL) /* TIME TO REACH FULL DERATE DURING FUEL PRESS ENG... */
#define time_to_reach_full_derate_during_fuel_press_eng_protec_1_256_65535_256_7112 (*(volatile uint16_t*)0x00807112UL) /* TIME TO REACH FULL DERATE DURING FUEL PRESS ENG... */
#define EPFPMNTD (*(volatile uint16_t*)0x00807114UL) /* CalTerm EPFPMNTD: MIN THRESHOLD FOR ENG SYNC FU... */
#define EPFPMXTD (*(volatile uint16_t*)0x00807116UL) /* CalTerm EPFPMXTD: MAX THRESHOLD FOR ENG SYNC FU... */
#define min_threshold_for_engine_sync_fuel_pressure_rpm_limiting_0_65535 (*(volatile uint16_t*)0x00807118UL) /* MIN THRESHOLD FOR ENGINE SYNC FUEL PRESSURE RPM... */
#define shutdown_duration_threshold_for_fuel_pressure_fuel_0_65535 (*(volatile uint16_t*)0x0080711AUL) /* SHUTDOWN DURATION THRESHOLD FOR FUEL_PRESSURE FUEL */
#define shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535 (*(volatile uint16_t*)0x0080711CUL) /* SHUTDOWN DURATION THRESHOLD FOR FUEL_PRESSURE RPM */
#define shutdown_delay_for_engine_sync_fuel_pressure_shutdown_0_255 (*(volatile uint16_t*)0x0080711EUL) /* SHUTDOWN DELAY FOR ENGINE SYNC FUEL PRESSURE SH... */
#define rpm_to_reach_before_for_engine_sync_fuel_pressure_errors_0_8000 (*(volatile uint16_t*)0x00807120UL) /* RPM TO REACH BEFORE FOR ENGINE SYNC FUEL PRESSU... */
#define delay_after_rpm_is_reached_before_eng_sync_fuel_pressure_errors_0_8000 (*(volatile uint16_t*)0x00807122UL) /* DELAY AFTER RPM IS REACHED BEFORE ENG SYNC FUEL... */
#define fault_when_epf_engine_sync_fuel_pressure_fuel_error_found_0_65535 (*(volatile uint16_t*)0x00807124UL) /* FAULT WHEN EPF ENGINE SYNC FUEL PRESSURE FUEL E... */
#define fault_when_epf_engine_sync_fuel_pressure_rpm_error_found_0_65535 (*(volatile uint16_t*)0x00807126UL) /* FAULT WHEN EPF ENGINE SYNC FUEL PRESSURE RPM ER... */
#define time_duration_to_warn_driver_before_shutdown_due_to_eng_sync_f_0_65535 (*(volatile uint16_t*)0x00807128UL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define EPFPFLSS (*(volatile uint16_t*)0x0080712AUL) /* CalTerm EPFPFLSS: SHUTDOWN SEVERITY THRESHOLD F... */
#define EPFPRPSS (*(volatile uint16_t*)0x0080712CUL) /* CalTerm EPFPRPSS: SHUTDOWN SEVERITY THRESHOLD F... */
#define fuel_pressure_sync_param (*(volatile uint16_t*)0x0080712EUL) /* Fuel pressure sync state machine param (fuelPre... */
#define time_from_fuel_temperature_overlimit_reached_to_start_of_fue_0_65535 (*(volatile uint16_t*)0x00807130UL) /* TIME FROM FUEL TEMPERATURE OVERLIMIT REACHED TO... */
#define time_from_fuel_temperature_overlimit_reached_to_start_of_rpm_0_65535 (*(volatile uint16_t*)0x00807132UL) /* TIME FROM FUEL TEMPERATURE OVERLIMIT REACHED TO... */
#define time_to_reach_full_derate_w_fuel_temperature_engine_prot_0_0039_256_7134 (*(volatile uint16_t*)0x00807134UL) /* TIME TO REACH FULL DERATE W/ FUEL TEMPERATURE E... */
#define time_to_reach_full_derate_w_fuel_temperature_engine_prot_0_0039_256_7136 (*(volatile uint16_t*)0x00807136UL) /* TIME TO REACH FULL DERATE W/ FUEL TEMPERATURE E... */
#define minimum_temperature_threshold_for_fuel_temperature_fuel_limi_0_65535 (*(volatile uint16_t*)0x00807138UL) /* MINIMUM TEMPERATURE THRESHOLD FOR FUEL TEMPERAT... */
#define maximum_threshold_for_fuel_temperature_fuel_limiting_0_65535 (*(volatile uint16_t*)0x0080713AUL) /* MAXIMUM THRESHOLD FOR FUEL TEMPERATURE FUEL LIM... */
#define minimum_threshold_for_fuel_temperature_rpm_limiting_0_65535 (*(volatile uint16_t*)0x0080713CUL) /* MINIMUM THRESHOLD FOR FUEL TEMPERATURE RPM LIMI... */
#define threshold_for_fuel_temperature_fuel_limiting_to_initiate_shu_0_65535 (*(volatile uint16_t*)0x0080713EUL) /* THRESHOLD FOR FUEL TEMPERATURE FUEL LIMITING TO... */
#define threshold_for_fuel_temperature_rpm_limiting_to_initiate_shut_0_65535 (*(volatile uint16_t*)0x00807140UL) /* THRESHOLD FOR FUEL TEMPERATURE RPM LIMITING TO ... */
#define shutdown_delay_for_fuel_temperature_shutdown_0_65535 (*(volatile uint16_t*)0x00807142UL) /* SHUTDOWN DELAY FOR FUEL TEMPERATURE SHUTDOWN */
#define rpm_threshold_that_must_be_crossed_in_order_to_log_fuel_temp_0_4500 (*(volatile uint16_t*)0x00807144UL) /* RPM THRESHOLD THAT MUST BE CROSSED IN ORDER TO ... */
#define time_threshold_that_must_be_crossed_in_order_to_log_fuel_tempe_0_255 (*(volatile uint16_t*)0x00807146UL) /* TIME THRESHOLD THAT MUST BE CROSSED IN ORDER TO... */
#define fault_index_indicating_temperature_fueling_error_detected_0_ffff (*(volatile uint16_t*)0x00807148UL) /* FAULT INDEX INDICATING TEMPERATURE FUELING ERRO... */
#define fault_index_indicating_fuel_temperature_rpm_error_detected_0_ffff (*(volatile uint16_t*)0x0080714AUL) /* FAULT INDEX INDICATING FUEL TEMPERATURE RPM ERR... */
#define time_duration_to_warn_driver_before_shutdown_due_to_fuel_tem_0_65535 (*(volatile uint16_t*)0x0080714CUL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define threshold_for_fuel_temperature_fuel_limiting_to_initiate_shutd_0_255 (*(volatile uint16_t*)0x0080714EUL) /* THRESHOLD FOR FUEL TEMPERATURE FUEL LIMITING TO... */
#define threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255 (*(volatile uint16_t*)0x00807150UL) /* THRESHOLD FOR FUEL TEMPERATURE RPM LIMITING TO ... */
#define fuel_temp_timer_init (*(volatile uint16_t*)0x00807152UL) /* Fuel temp protection timer init value (1 ref) */
#define start_duration_for_ambient_air_pressure_fueling_derate_0_65535 (*(volatile uint16_t*)0x00807154UL) /* START DURATION FOR AMBIENT AIR PRESSURE FUELING... */
#define start_duration_for_ambient_air_pressure_rpm_derate_0_65535 (*(volatile uint16_t*)0x00807156UL) /* START DURATION FOR AMBIENT AIR PRESSURE RPM DERATE */
#define time_to_reach_full_derate_during_ambient_air_eng_protc_1_256_65535_256 (*(volatile uint16_t*)0x00807158UL) /* TIME TO REACH FULL DERATE DURING AMBIENT AIR EN... */
#define time_to_reach_full_derate_during_ambient_air_eng_prote_1_256_65535_256 (*(volatile uint16_t*)0x0080715AUL) /* TIME TO REACH FULL DERATE DURING AMBIENT AIR EN... */
#define min_threshold_for_ambient_air_pressure_fuel_limiting_0_15 (*(volatile uint16_t*)0x0080715CUL) /* MIN THRESHOLD FOR AMBIENT AIR PRESSURE FUEL LIM... */
#define max_threshold_for_ambient_air_pressure_fuel_limiting_0_15 (*(volatile uint16_t*)0x0080715EUL) /* MAX THRESHOLD FOR AMBIENT AIR PRESSURE FUEL LIM... */
#define min_threshold_for_ambient_air_pressure_rpm_limiting_0_65535 (*(volatile uint16_t*)0x00807160UL) /* MIN THRESHOLD FOR AMBIENT AIR PRESSURE RPM LIMI... */
#define shutdown_duration_threshold_for_ambient_air_pressure_fuel_0_65535 (*(volatile uint16_t*)0x00807162UL) /* SHUTDOWN DURATION THRESHOLD FOR AMBIENT_AIR_PRE... */
#define shutdown_duration_threshold_for_ambient_air_pressure_rpm_0_65535 (*(volatile uint16_t*)0x00807164UL) /* SHUTDOWN DURATION THRESHOLD FOR AMBIENT_AIR_PRE... */
#define shutdown_delay_for_ambient_air_pressure_shutdown_0_255 (*(volatile uint16_t*)0x00807166UL) /* SHUTDOWN DELAY FOR AMBIENT AIR PRESSURE SHUTDOWN */
#define rpm_to_reach_before_for_ambient_air_pressure_errors_0_8000 (*(volatile uint16_t*)0x00807168UL) /* RPM TO REACH BEFORE FOR AMBIENT AIR PRESSURE ER... */
#define delay_after_rpm_is_reached_before_ambient_air_pressure_errors_0_8000 (*(volatile uint16_t*)0x0080716AUL) /* DELAY AFTER RPM IS REACHED BEFORE AMBIENT AIR P... */
#define fault_when_epf_ambient_air_pressure_fuel_error_found_0_65535 (*(volatile uint16_t*)0x0080716CUL) /* FAULT WHEN EPF AMBIENT AIR PRESSURE FUEL ERROR ... */
#define fault_when_epf_ambient_air_pressure_rpm_error_found_0_65535 (*(volatile uint16_t*)0x0080716EUL) /* FAULT WHEN EPF AMBIENT AIR PRESSURE RPM ERROR F... */
#define time_duration_to_warn_driver_before_shutdown_due_to_ambient_ai_0_65535 (*(volatile uint16_t*)0x00807170UL) /* TIME DURATION TO WARN DRIVER BEFORE SHUTDOWN DU... */
#define shutdown_severity_threshold_for_ambient_air_pressure_fueling_0_15 (*(volatile uint16_t*)0x00807172UL) /* SHUTDOWN SEVERITY THRESHOLD FOR AMBIENT AIR PRE... */
#define shutdown_severity_threshold_for_ambient_air_pressure_rpm_0_15 (*(volatile uint16_t*)0x00807174UL) /* SHUTDOWN SEVERITY THRESHOLD FOR AMBIENT AIR PRE... */
#define load_breakpoint_table ((volatile uint16_t*)0x00807176UL) /* Load breakpoint table 0-14800 - VERIFIED via RA... */
#define shutdown_limit_selector_param (*(volatile uint16_t*)0x008071A6UL) /* Shutdown limit selector parameter (shutdownLimi... */
#define timer_capture_init_value (*(volatile uint16_t*)0x008071AAUL) /* Timer capture init value for countdown (1 ref) */
#define clutch_rpm_low_value (*(volatile uint16_t*)0x008071ACUL) /* Clutch RPM low output value (1 ref) */
#define fuel_temp_throttle_threshold (*(volatile uint16_t*)0x008071AEUL) /* Fuel temp protection throttle threshold (3 refs) */
#define boost_pressure_offset_factor (*(volatile uint16_t*)0x008071B0UL) /* Boost pressure offset factor for calc (1 ref) */
#define boost_pressure_interp_threshold (*(volatile uint16_t*)0x008071B2UL) /* Boost pressure interpolation threshold (1 ref) */
#define boost_pressure_decrement_rate (*(volatile uint16_t*)0x008071B4UL) /* Boost pressure decrement rate (1 ref) */
#define boost_pressure_stats_threshold_71b6 (*(volatile uint16_t*)0x008071B6UL) /* Boost pressure statistics threshold for accumul... */
#define boost_pressure_smoke_threshold (*(volatile uint16_t*)0x008071B8UL) /* Boost pressure smoke limiter threshold (1 ref) */
#define boost_pressure_state_6_threshold (*(volatile uint16_t*)0x008071BAUL) /* Boost pressure state 6 transition threshold (1 ... */
#define boost_pressure_state_3_threshold (*(volatile uint16_t*)0x008071BCUL) /* Boost pressure state 3 transition threshold (2 ... */
#define derate_event_threshold_time (*(volatile uint16_t*)0x008071C6UL) /* Derate event threshold time (1 ref) */
#define clutch_slip_threshold (*(volatile uint16_t*)0x008071CAUL) /* Clutch slip detection threshold (2 refs) */
#define fuel_temp_exceedance_threshold (*(volatile uint16_t*)0x008071CEUL) /* Fuel temp exceedance threshold time (1 ref) */
#define fuel_limit_near_threshold (*(volatile uint16_t*)0x008071D0UL) /* Fuel limit near exceedance threshold (1 ref) */
#define boost_pressure_stats_threshold_71d4 (*(volatile uint16_t*)0x008071D4UL) /* Boost pressure statistics threshold (1 ref) */
#define vp44_derate_bit8_limit (*(volatile uint16_t*)0x008071D6UL) /* VP44 derate bit 8 counter limit (1 ref) */
#define vp44_derate_bit4_limit (*(volatile uint16_t*)0x008071D8UL) /* VP44 derate bit 4 counter limit (1 ref) */
#define blank_spot_for_esdn_backwards_compatibility_0_0_1 (*(volatile uint16_t*)0x008071DAUL) /* BLANK SPOT FOR ESDN BACKWARDS COMPATIBILITY */
#define fueling_value_above_which_wet_stack_timing_is_set_to_zero_0_100 (*(volatile uint16_t*)0x008071DCUL) /* FUELING VALUE ABOVE WHICH WET STACK TIMING IS S... */
#define vp44_fault_counter_threshold_2 (*(volatile uint16_t*)0x008071DEUL) /* VP44 fault counter threshold 2 (1 ref) */
#define vp44_fault_timer_threshold (*(volatile uint16_t*)0x008071E0UL) /* VP44 fault timer threshold (1 ref) */
#define vp44_smoke_limiter_threshold (*(volatile uint16_t*)0x008071E2UL) /* VP44 smoke limiter comparison threshold (1 ref) */
#define vp44_fault_counter_threshold_1 (*(volatile uint16_t*)0x008071E4UL) /* VP44 fault counter threshold 1 (1 ref) */
#define vp44_fuel_temp_delta_threshold (*(volatile uint16_t*)0x008071E6UL) /* VP44 fuel temp delta threshold (1 ref) */
#define vp44_fault_tolerance_factor (*(volatile uint16_t*)0x008071E8UL) /* VP44 fault tolerance factor (2 refs) */
#define vp44_throttle_threshold (*(volatile uint16_t*)0x008071EAUL) /* VP44 throttle threshold for fault detect (1 ref) */
#define vp44_fault_counter_limit_1 (*(volatile uint16_t*)0x008071EEUL) /* VP44 fault counter limit 1 (1 ref) */
#define vp44_table_compare_threshold (*(volatile uint16_t*)0x008071F0UL) /* VP44 table compare threshold (2 refs) */
#define vp44_protection_recovery_threshold (*(volatile uint16_t*)0x008071F2UL) /* VP44 protection recovery threshold (1 ref) */
#define vp44_clutch_rpm_delta_threshold (*(volatile uint16_t*)0x008071F4UL) /* VP44 clutch RPM delta threshold (1 ref) */
#define vp44_fault_counter_limit_2 (*(volatile uint16_t*)0x008071F8UL) /* VP44 fault counter limit 2 (1 ref) */
#define oil_pressure_throttle_threshold (*(volatile uint16_t*)0x00807204UL) /* Oil pressure protection throttle position thres... */
#define oil_pressure_debounce_threshold (*(volatile uint16_t*)0x00807206UL) /* Oil pressure protection debounce counter thresh... */
#define WSCLTATB (*(volatile uint16_t*)0x0080721EUL) /* CalTerm WSCLTATB: 2 DIM. TABLE OF 8 BREAKPOINTS... */
#define output_control_decrement_step (*(volatile uint16_t*)0x0080725AUL) /* Output control CAN decrement step (2 refs) */
#define diagnostic_fuel_override_param (*(volatile uint16_t*)0x0080725CUL) /* Diagnostic fuel override parameter (diagnosticF... */
#define vp44_injection_timing_limit (*(volatile uint16_t*)0x0080725EUL) /* VP44 injection timing counter limit (2 refs) */
#define output_timing_interpolation_base_ptr (*(volatile uint16_t*)0x00807260UL) /* Base pointer for timing table lookups */
#define output_control_fuel_threshold (*(volatile uint16_t*)0x00807262UL) /* Output control fuel threshold (outputControlSta... */
#define output_control_cycle_limit (*(volatile uint16_t*)0x00807264UL) /* Output control timing cycle limit (outputContro... */
#define output_control_timing_reset_countdown (*(volatile uint16_t*)0x00807266UL) /* Countdown timer for output control reset */
#define retarder_input_threshold_for_state (*(volatile uint16_t*)0x00807268UL) /* Threshold for output control state transition */
#define output_sequence_rpm_threshold (*(volatile uint16_t*)0x0080726CUL) /* RPM threshold for output sequence state transit... */
#define output_sequence_rpm_hysteresis (*(volatile uint16_t*)0x0080726EUL) /* Output sequence RPM threshold hysteresis value ... */
#define output_control_rpm_offset (*(volatile uint16_t*)0x00807270UL) /* Output control RPM offset (outputControlState4H... */
#define throttle_position_threshold_for_output (*(volatile uint16_t*)0x00807272UL) /* Throttle threshold for engine_mode_output_contr... */
#define output_control_throttle_limit (*(volatile uint16_t*)0x00807274UL) /* Output control throttle limit (outputControlSta... */
#define output_control_rpm_limit (*(volatile uint16_t*)0x00807276UL) /* Output control RPM limit (outputControlState4Ha... */
#define battery_voltage_low_threshold_during_crank_in_count_0_1023 (*(volatile uint16_t*)0x0080727CUL) /* BATTERY VOLTAGE LOW THRESHOLD DURING CRANK(IN C... */
#define battery_low_at_cranking_error_set_0_32767 (*(volatile uint16_t*)0x0080727EUL) /* BATTERY LOW AT CRANKING ERROR SET */
#define battery_low_at_cranking_error_clear_0_32767 (*(volatile uint16_t*)0x00807280UL) /* BATTERY LOW AT CRANKING ERROR CLEAR */
#define engine_state_tranistion_delay_used_in_battery_low_at_crankin_0_32767 (*(volatile uint16_t*)0x00807282UL) /* ENGINE STATE TRANISTION DELAY USED IN BATTERY L... */
#define CRCOACTM (*(volatile uint16_t*)0x00807286UL) /* AMOUNT OF TIME BUMP MUST BE HELD BEFORE TRANSIT... */
#define delay_time_to_ensure_that_coolant_level_switches_error_has_cha_0_65535 (*(volatile uint16_t*)0x0080728AUL) /* DELAY TIME TO ENSURE THAT COOLANT LEVEL SWITCHE... */
#define rpm_breakpoint_table ((volatile uint16_t*)0x008072F4UL) /* RPM breakpoint table 32-14400 RPM - VERIFIED vi... */
#define sensor_fault_rpm_selector_param (*(volatile uint16_t*)0x0080734AUL) /* Sensor fault RPM source selector param (sensorF... */
#define vp44_state_debounce_threshold (*(volatile uint16_t*)0x0080734CUL) /* VP44 state debounce threshold value (4 refs) */
#define vp44_state_processing_timeout_reload (*(volatile uint16_t*)0x0080734EUL) /* VP44 state processing timeout reload value (4 r... */
#define vp44_state2_transition_param (*(volatile uint16_t*)0x00807350UL) /* VP44 state 2 transition parameter (vp44State2Tr... */
#define rpm_derate_scale_factor (*(volatile uint16_t*)0x00807386UL) /* RPM derate scale factor (rpmDerateCalculationCo... */
#define rpm_derate_base_offset (*(volatile uint16_t*)0x00807388UL) /* RPM derate base offset (rpmDerateCalculationCon... */
#define derate_rpm_adjustment_max (*(volatile uint16_t*)0x0080738AUL) /* Derate RPM adjustment upper clamp (2 refs) */
#define derate_rpm_adjustment_min (*(volatile uint16_t*)0x0080738CUL) /* Derate RPM adjustment lower clamp (2 refs) */
#define rpm_derate_percent_upper (*(volatile uint16_t*)0x0080738EUL) /* RPM derate percent upper threshold (2 refs) */
#define rpm_derate_percent_lower (*(volatile uint16_t*)0x00807390UL) /* RPM derate percent lower threshold (2 refs) */
#define rpm_derate_lower_threshold (*(volatile uint16_t*)0x00807392UL) /* RPM derate lower threshold (rpmDerateCalculatio... */
#define rpm_derate_upper_threshold (*(volatile uint16_t*)0x00807394UL) /* RPM derate upper threshold (rpmDerateCalculatio... */
#define rpm_derate_calc_offset_1 (*(volatile uint16_t*)0x00807396UL) /* RPM derate calculation offset 1 (rpmDerateCalcu... */
#define rpm_derate_calc_offset_2 (*(volatile uint16_t*)0x00807398UL) /* RPM derate calculation offset 2 (rpmDerateCalcu... */
#define rpm_derate_calc_multiplier (*(volatile uint16_t*)0x0080739AUL) /* RPM derate calculation multiplier (rpmDerateCal... */
#define vp44_fso_fault_debounce_threshold (*(volatile uint8_t*)0x0080739CUL) /* VP44 FSO fault debounce threshold (2 refs) */
#define vp44_feedback_pulse_value (*(volatile uint16_t*)0x0080739EUL) /* VP44 feedback pulse intermediate value (3 refs) */
#define vp44_can_200_response_byte_0 (*(volatile uint8_t*)0x008073A0UL) /* VP44 CAN message 200 response byte 0 (vp44CanMe... */
#define vp44_can_200_response_byte_1 (*(volatile uint8_t*)0x008073A1UL) /* VP44 CAN message 200 response byte 1 (vp44CanMe... */
#define derate_output_value (*(volatile uint16_t*)0x008073A2UL) /* Derate output value for message (2 refs) */
#define lift_pump_fuel_scale_factor (*(volatile uint16_t*)0x008073A8UL) /* Lift pump fuel scale factor (1 ref) */
#define lift_pump_fuel_base_offset (*(volatile uint16_t*)0x008073AAUL) /* Lift pump fuel base offset value (1 ref) */
#define lift_pump_timing_increase_limit (*(volatile uint16_t*)0x008073ACUL) /* Lift pump timing increase rate limit (3 refs) */
#define lift_pump_timing_decrease_limit (*(volatile uint16_t*)0x008073AEUL) /* Lift pump timing decrease rate limit (3 refs) */
#define vp44_can_msg_upper_threshold (*(volatile uint16_t*)0x008073B0UL) /* VP44 CAN message enable upper threshold (1 ref) */
#define vp44_can_msg_lower_threshold (*(volatile uint16_t*)0x008073B2UL) /* VP44 CAN message enable lower threshold (1 ref) */
#define vp44_fso_bit0_debounce_threshold (*(volatile uint8_t*)0x008073B4UL) /* VP44 FSO bit 0 debounce threshold (2 refs) */
#define fso_fault_debounce_threshold (*(volatile uint8_t*)0x008073B5UL) /* VP44 FSO fault detection debounce threshold (6 ... */
#define vp44_fso_bit0_fuel_threshold (*(volatile uint16_t*)0x008073B6UL) /* VP44 FSO bit 0 fuel demand threshold (1 ref) */
#define fso_fault_detection_threshold (*(volatile uint16_t*)0x008073B8UL) /* FSO fault detection threshold (vp44FsoFaultDete... */
#define vp44_fso_stuck_debounce_threshold (*(volatile uint16_t*)0x008073BAUL) /* VP44 FSO stuck fault debounce threshold (2 refs) */
#define fso_fault_delta_threshold (*(volatile uint16_t*)0x008073C2UL) /* FSO fault delta threshold (vp44FsoFaultDetectio... */
#define fso_fault_low_threshold (*(volatile uint16_t*)0x008073C4UL) /* FSO fault low threshold (vp44FsoFaultDetectionM... */
#define fso_fault_delta_calc_threshold (*(volatile uint16_t*)0x008073C6UL) /* FSO fault delta calculation threshold (vp44FsoF... */
#define fso_fault_counter_limit (*(volatile uint16_t*)0x008073C8UL) /* FSO fault counter limit (vp44FsoFaultDetectionM... */
#define vp44_fso_value_upper_threshold (*(volatile uint16_t*)0x008073CAUL) /* VP44 FSO value upper threshold (2 refs) */
#define vp44_fso_value_lower_threshold (*(volatile uint16_t*)0x008073CEUL) /* VP44 FSO value lower threshold (2 refs) */
#define lift_pump_diagnostic_override_value (*(volatile uint16_t*)0x008073D2UL) /* Lift pump diagnostic override value (1 ref) */
#define vp44_fso_duration_threshold (*(volatile uint16_t*)0x008073D4UL) /* VP44 FSO duration threshold count (1 ref) */
#define vp44_fso_condition_threshold (*(volatile uint16_t*)0x008073D6UL) /* VP44 FSO condition threshold count (1 ref) */
#define vp44_fso_fuel_value_threshold (*(volatile uint16_t*)0x008073D8UL) /* VP44 FSO fuel value threshold (1 ref) */
#define vp44_fso_fuel_demand_upper_threshold (*(volatile uint16_t*)0x008073DAUL) /* VP44 FSO fuel demand upper threshold (1 ref) */
#define vp44_fso_fuel_demand_lower_threshold (*(volatile uint16_t*)0x008073DCUL) /* VP44 FSO fuel demand lower threshold (1 ref) */
#define fso_multibit_fault_threshold (*(volatile uint16_t*)0x008073DEUL) /* VP44 FSO multi-bit fault monitor threshold (5 r... */
#define vp44_can_msg_200_parse_mode (*(volatile uint8_t*)0x008073DFUL) /* VP44 CAN msg 200 parse mode selector (3 refs) */
#define vp44_msg_300_fault_2_fuel_limit (*(volatile uint16_t*)0x008073E0UL) /* VP44 msg 300 fault 2 fuel limit value (1 ref) */
#define vp44_msg_300_fault_1_fuel_limit (*(volatile uint16_t*)0x008073E2UL) /* VP44 msg 300 fault 1 fuel limit value (1 ref) */
#define vp44_can_msg_100_cmd_word_0 (*(volatile uint16_t*)0x008073E4UL) /* VP44 CAN msg 100 command word 0 (bytes 7-8) */
#define vp44_can_msg_100_cmd_word_1 (*(volatile uint16_t*)0x008073E6UL) /* VP44 CAN msg 100 command word 1 (bytes 5-6) */
#define vp44_can_msg_100_cmd_word_2 (*(volatile uint16_t*)0x008073E8UL) /* VP44 CAN msg 100 command word 2 (bytes 3-4) */
#define vp44_can_msg_100_cmd_word_3 (*(volatile uint16_t*)0x008073EAUL) /* VP44 CAN msg 100 command word 3 (bytes 1-2) */
#define vp44_can_200_message_byte_4 (*(volatile uint8_t*)0x008073ECUL) /* VP44 CAN message 200 data byte 4 (vp44CanMessag... */
#define vp44_can_200_message_byte_5 (*(volatile uint8_t*)0x008073EDUL) /* VP44 CAN message 200 data byte 5 (vp44CanMessag... */
#define vp44_can_200_message_byte_6 (*(volatile uint8_t*)0x008073EEUL) /* VP44 CAN message 200 data byte 6 (vp44CanMessag... */
#define vp44_fso_detection_enable_flag (*(volatile uint8_t*)0x008073EFUL) /* VP44 FSO detection enable flag (1 ref) */
#define vp44_fso_bit15_fault_fuel_limit (*(volatile uint16_t*)0x008073F0UL) /* VP44 FSO bit 15 fault fuel limit value (1 ref) */
#define vp44_fso_fault_fuel_limit (*(volatile uint16_t*)0x008073F2UL) /* VP44 FSO fault fuel limit value (1 ref) */
#define vp44_can_msg_200_init_value (*(volatile uint32_t*)0x008073F4UL) /* VP44 CAN msg 200 init value (2 refs) */
#define vp44_can_msg_timeout_threshold (*(volatile uint16_t*)0x008073F8UL) /* VP44 CAN msg timeout threshold (2 refs) */
#define vp44_fso_bit0_fault_fuel_limit (*(volatile uint16_t*)0x008073FAUL) /* VP44 FSO bit 0 fault fuel limit value (1 ref) */
#define fso_fuel_command_limit (*(volatile uint16_t*)0x008073FEUL) /* FSO fuel command limit (vp44FsoFaultDetectionMo... */
#define lift_pump_diagnostic_fuel_value (*(volatile uint16_t*)0x00807400UL) /* Lift pump diagnostic fuel arbitration value (1 ... */
#define vp44_timing_fault_threshold (*(volatile uint8_t*)0x00807402UL) /* VP44 timing fault debounce threshold (4 refs) */
#define vp44_timing_status_fault_threshold (*(volatile uint8_t*)0x00807403UL) /* VP44 timing status fault threshold (1 ref) */
#define fso_protection_fuel_level_1 (*(volatile uint16_t*)0x0080740AUL) /* FSO protection fuel limit level 1 (2 refs) */
#define fso_protection_fuel_level_2 (*(volatile uint16_t*)0x0080740CUL) /* FSO protection fuel limit level 2 (2 refs) */
#define fso_protection_fuel_level_3 (*(volatile uint16_t*)0x0080740EUL) /* FSO protection fuel limit level 3 (2 refs) */
#define time_period_to_disable_imt_epf_due_to_exh_brake_0_65535 (*(volatile uint16_t*)0x00807410UL) /* TIME PERIOD TO DISABLE IMT EPF DUE TO EXH. BRAKE */
#define lift_pump_run_time_after_key_on_0_to_120 (*(volatile uint16_t*)0x00807412UL) /* LIFT PUMP RUN-TIME AFTER KEY-ON */
#define lift_pump_off_time_duration_during_cranking_0_to_120 (*(volatile uint16_t*)0x00807414UL) /* LIFT PUMP OFF-TIME DURATION DURING CRANKING */
#define lift_pump_on_time_duration_during_cranking_0_to_120 (*(volatile uint16_t*)0x00807416UL) /* LIFT PUMP ON-TIME DURATION DURING CRANKING */
#define lift_pump_run_time_when_stopping_after_cranking_0_to_120 (*(volatile uint16_t*)0x00807418UL) /* LIFT PUMP RUN TIME WHEN STOPPING AFTER CRANKING */
#define lift_pump_run_time_when_stopping_after_running_0_to_120 (*(volatile uint16_t*)0x0080741AUL) /* LIFT PUMP RUN TIME WHEN STOPPING AFTER RUNNING */
#define flag_to_override_prime_pump_control_0_to_ff (*(volatile uint8_t*)0x0080741CUL) /* FLAG TO OVERRIDE PRIME PUMP CONTROL */
#define desired_state_on_off_of_prime_pump_when_override_flag_is_set_0_to_ff (*(volatile uint8_t*)0x0080741DUL) /* DESIRED STATE (ON/OFF) OF PRIME PUMP WHEN OVERR... */
#define debounce_counts_for_vp44_micro_error_0_to_255 (*(volatile uint8_t*)0x0080741EUL) /* DEBOUNCE COUNTS FOR VP44_MICRO_ERROR */
#define number_of_cylinders_the_engine_has_0_to_16 (*(volatile uint8_t*)0x0080741FUL) /* NUMBER OF CYLINDERS THE ENGINE HAS */
#define requested_location_on_pump_cam_for_soi_100_to_100 (*(volatile uint16_t*)0x00807420UL) /* REQUESTED LOCATION ON PUMP CAM FOR SOI */
#define reserved_location_for_future_pump_setup_information_0_to_ff_7422 (*(volatile uint8_t*)0x00807422UL) /* RESERVED LOCATION FOR FUTURE PUMP SETUP INFORMA... */
#define reserved_location_for_future_pump_setup_information_0_to_ff_7423 (*(volatile uint8_t*)0x00807423UL) /* RESERVED LOCATION FOR FUTURE PUMP SETUP INFORMA... */
#define FLSYPSII (*(volatile uint16_t*)0x00807424UL) /* CalTerm FLSYPSII: ANGULAR POSITION OF VP44_ENGI... */
#define target_angular_position_of_sync_pulse_after_tdc_0_to_60 (*(volatile uint16_t*)0x00807426UL) /* TARGET ANGULAR POSITION OF SYNC PULSE AFTER TDC */
#define target_angle_during_which_sync_pulse_is_held_low_0_to_120 (*(volatile uint16_t*)0x00807428UL) /* TARGET ANGLE DURING WHICH SYNC PULSE IS HELD LOW */
#define slope_used_to_convert_final_timing_to_vp44_units_50_to_50 (*(volatile uint16_t*)0x0080742AUL) /* SLOPE USED TO CONVERT FINAL_TIMING TO VP44 UNITS */
#define intercept_used_to_convert_final_timing_to_vp44_units_360_to_360 (*(volatile uint16_t*)0x0080742CUL) /* INTERCEPT USED TO CONVERT FINAL_TIMING TO VP44 ... */
#define maximum_increase_in_timing_command_allowed_per_loop_0_to_60 (*(volatile uint16_t*)0x0080742EUL) /* MAXIMUM INCREASE IN TIMING COMMAND ALLOWED PER ... */
#define maximum_decrease_in_timing_command_allowed_per_loop_0_to_60 (*(volatile uint16_t*)0x00807430UL) /* MAXIMUM DECREASE IN TIMING COMMAND ALLOWED PER ... */
#define pump_ram_address_contents_requested_below_this_speed_0_to_5000 (*(volatile uint16_t*)0x00807432UL) /* PUMP RAM ADDRESS CONTENTS REQUESTED BELOW THIS ... */
#define pump_ram_address_contents_requested_above_this_speed_0_to_5000 (*(volatile uint16_t*)0x00807434UL) /* PUMP RAM ADDRESS CONTENTS REQUESTED ABOVE THIS ... */
#define debounce_for_fuel_quantity_feedback_pulse_fault_detection_0_to_255 (*(volatile uint8_t*)0x00807436UL) /* DEBOUNCE FOR FUEL QUANTITY FEEDBACK PULSE FAULT... */
#define debounce_for_abnormally_high_fuel_temp_fault_detection_0_to_255 (*(volatile uint8_t*)0x00807437UL) /* DEBOUNCE FOR ABNORMALLY HIGH FUEL TEMP FAULT DE... */
#define feedback_pulse_fault_disabled_when_fueling_is_below_this_para_0_to_300 (*(volatile uint16_t*)0x00807438UL) /* FEEDBACK PULSE FAULT DISABLED WHEN FUELING IS B... */
#define in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255 (*(volatile uint16_t*)0x0080743AUL) /* IN-RANGE FUEL TEMP FAULT ENABLED WHEN COOLANT T... */
#define debounce_for_vp44_fso_circuit_fault_detection_0_to_255 (*(volatile uint8_t*)0x0080743CUL) /* DEBOUNCE FOR VP44_FSO CIRCUIT FAULT DETECTION */
#define configuration_info_sent_to_pump_at_power_up_0_to_ff (*(volatile uint8_t*)0x0080743DUL) /* CONFIGURATION INFO SENT TO PUMP AT POWER-UP */
#define vp44_fso_stuck_low_detection_disabled_above_this_fueling_0_to_300 (*(volatile uint16_t*)0x0080743EUL) /* VP44_FSO STUCK-LOW DETECTION DISABLED ABOVE THI... */
#define vp44_fso_stuck_low_detection_enabled_above_this_speed_0_to_5000 (*(volatile uint16_t*)0x00807440UL) /* VP44_FSO STUCK-LOW DETECTION ENABLED ABOVE THIS... */
#define fuel_is_limited_to_this_when_fuel_temp_sensor_faults_are_acti_0_to_300 (*(volatile uint16_t*)0x00807442UL) /* FUEL IS LIMITED TO THIS WHEN FUEL TEMP SENSOR F... */
#define upper_limit_for_abnormally_high_fuel_temp_fault_40_to_300 (*(volatile uint16_t*)0x00807444UL) /* UPPER LIMIT FOR ABNORMALLY HIGH FUEL TEMP FAULT */
#define fuel_temp_in_range_fault_detection_enabled_below_this_value_40_to_400 (*(volatile uint16_t*)0x00807446UL) /* FUEL TEMP IN-RANGE FAULT DETECTION ENABLED BELO... */
#define max_time_allowed_for_constant_fuel_temp_before_setting_in_ra_0_to_3000 (*(volatile uint16_t*)0x00807448UL) /* MAX TIME ALLOWED FOR CONSTANT FUEL TEMP BEFORE ... */
#define required_change_to_clear_in_range_fuel_temp_fault_0_to_300 (*(volatile uint16_t*)0x0080744AUL) /* REQUIRED CHANGE TO CLEAR IN-RANGE FUEL TEMP FAULT */
#define max_retarded_timing_allowed_to_detect_static_timing_erro_0_to_ffffffff (*(volatile uint32_t*)0x0080744CUL) /* MAX RETARDED TIMING ALLOWED TO DETECT STATIC TI... */
#define min_retarded_timing_allowed_to_detect_static_timing_erro_0_to_ffffffff (*(volatile uint32_t*)0x00807450UL) /* MIN RETARDED TIMING ALLOWED TO DETECT STATIC TI... */
#define temporary_timing_command_at_idle_for_static_timing_check_0_100 (*(volatile uint16_t*)0x00807454UL) /* TEMPORARY TIMING COMMAND AT IDLE FOR STATIC TIM... */
#define duration_full_retard_is_commanded_for_static_timing_check_0_to_120 (*(volatile uint16_t*)0x00807456UL) /* DURATION FULL-RETARD IS COMMANDED FOR STATIC TI... */
#define static_timing_test_ran_after_this_time_has_elapsed_at_idle_0_to_120 (*(volatile uint16_t*)0x00807458UL) /* STATIC TIMING TEST RAN AFTER THIS TIME HAS ELAP... */
#define static_timing_check_disabled_when_fueling_is_above_this_0_to_300 (*(volatile uint16_t*)0x0080745AUL) /* STATIC TIMING CHECK DISABLED WHEN FUELING IS AB... */
#define static_timing_check_disabled_when_speed_is_above_this_0_to_5000 (*(volatile uint16_t*)0x0080745CUL) /* STATIC TIMING CHECK DISABLED WHEN SPEED IS ABOV... */
#define static_timing_check_disabled_when_speed_is_below_this_0_to_5000 (*(volatile uint16_t*)0x0080745EUL) /* STATIC TIMING CHECK DISABLED WHEN SPEED IS BELO... */
#define debounce_for_idle_select_circuit_fault_detection_0_to_255 (*(volatile uint8_t*)0x00807460UL) /* DEBOUNCE FOR IDLE SELECT CIRCUIT FAULT DETECTION */
#define number_of_bytes_used_by_pump_to_store_timing_feedback_0_to_4 (*(volatile uint8_t*)0x00807461UL) /* NUMBER OF BYTES USED BY PUMP TO STORE TIMING FE... */
#define fuel_limit_when_pump_analog_fault_occurs_at_power_up_0_to_300 (*(volatile uint16_t*)0x00807462UL) /* FUEL LIMIT WHEN PUMP ANALOG FAULT OCCURS AT POW... */
#define fuel_limit_when_pump_eeprom_fault_occurs_at_power_up_0_to_300 (*(volatile uint16_t*)0x00807464UL) /* FUEL LIMIT WHEN PUMP EEPROM FAULT OCCURS AT POW... */
#define ecm_requests_data_at_this_pump_address_at_low_idle_0_to_ffff_7466 (*(volatile uint16_t*)0x00807466UL) /* ECM REQUESTS DATA AT THIS PUMP ADDRESS AT LOW IDLE */
#define ecm_requests_data_at_this_pump_address_at_low_idle_0_to_ffff_7468 (*(volatile uint16_t*)0x00807468UL) /* ECM REQUESTS DATA AT THIS PUMP ADDRESS AT LOW IDLE */
#define ecm_requests_data_at_this_pump_address_at_low_idle_0_to_ffff_746a (*(volatile uint16_t*)0x0080746AUL) /* ECM REQUESTS DATA AT THIS PUMP ADDRESS AT LOW IDLE */
#define ecm_requests_data_at_this_pump_address_at_low_idle_0_to_ffff_746c (*(volatile uint16_t*)0x0080746CUL) /* ECM REQUESTS DATA AT THIS PUMP ADDRESS AT LOW IDLE */
#define reserved_location_for_future_pump_setup_information_0_to_ff_746e (*(volatile uint8_t*)0x0080746EUL) /* RESERVED LOCATION FOR FUTURE PUMP SETUP INFORMA... */
#define reserved_location_for_future_pump_setup_information_0_to_ff_746f (*(volatile uint8_t*)0x0080746FUL) /* RESERVED LOCATION FOR FUTURE PUMP SETUP INFORMA... */
#define reserved_location_for_future_pump_setup_information_0_to_ff_7470 (*(volatile uint8_t*)0x00807470UL) /* RESERVED LOCATION FOR FUTURE PUMP SETUP INFORMA... */
#define flag_to_enable_or_disable_automatic_timing_test_at_idle_0_to_ff (*(volatile uint8_t*)0x00807471UL) /* FLAG TO ENABLE OR DISABLE AUTOMATIC TIMING TEST... */
#define fuel_limit_when_vp44_engine_sync_signal_is_lost_0_to_300 (*(volatile uint16_t*)0x00807472UL) /* FUEL LIMIT WHEN VP44_ENGINE_SYNC SIGNAL IS LOST */
#define fuel_limit_when_timing_fault_is_active_0_to_300 (*(volatile uint16_t*)0x00807474UL) /* FUEL LIMIT WHEN TIMING FAULT IS ACTIVE */
#define initial_value_for_min_and_max_observed_timing_feedback_0_to_ffffffff (*(volatile uint32_t*)0x00807476UL) /* INITIAL VALUE FOR MIN AND MAX OBSERVED TIMING F... */
#define max_time_between_pump_messages_allowed_for_can_lost_fault_0_to_120 (*(volatile uint16_t*)0x0080747AUL) /* MAX TIME BETWEEN PUMP MESSAGES ALLOWED FOR CAN ... */
#define fuel_limited_to_this_when_feedback_pulse_fault_is_active_0_to_300 (*(volatile uint16_t*)0x0080747CUL) /* FUEL LIMITED TO THIS WHEN FEEDBACK PULSE FAULT ... */
#define max_ecm_voltage_under_which_pump_low_voltage_fault_is_enabled_0_to_36 (*(volatile uint16_t*)0x0080747EUL) /* MAX ECM VOLTAGE UNDER WHICH PUMP LOW VOLTAGE FA... */
#define high_fuel_temp_error_clears_when_temp_drops_below_this_40_to_300 (*(volatile uint16_t*)0x00807480UL) /* HIGH FUEL TEMP ERROR CLEARS WHEN TEMP DROPS BEL... */
#define timing_command_override_when_stuck_fuel_valve_fault_is_active_0_100 (*(volatile uint16_t*)0x00807482UL) /* TIMING COMMAND OVERRIDE WHEN STUCK FUEL VALVE F... */
#define pump_low_voltage_fault_debounce_counts_0_to_255 (*(volatile uint8_t*)0x00807484UL) /* PUMP LOW VOLTAGE FAULT DEBOUNCE COUNTS */
#define debounce_counts_for_pump_voltage_oor_fault_0_to_255 (*(volatile uint8_t*)0x00807485UL) /* DEBOUNCE COUNTS FOR PUMP VOLTAGE OOR FAULT */
#define measured_pump_voltage_filter_coefficient_0_to_1 (*(volatile uint16_t*)0x00807486UL) /* MEASURED PUMP VOLTAGE FILTER COEFFICIENT */
#define minimum_pump_voltage_to_clear_low_voltage_fault_0_to_40 (*(volatile uint16_t*)0x00807488UL) /* MINIMUM PUMP VOLTAGE TO CLEAR LOW VOLTAGE FAULT */
#define minimum_acceptable_pump_voltage_0_to_40 (*(volatile uint16_t*)0x0080748AUL) /* MINIMUM ACCEPTABLE PUMP VOLTAGE */
#define fuel_derate_in_effect_when_fuel_temp_oor_fault_is_active_0_to_300 (*(volatile uint16_t*)0x0080748CUL) /* FUEL DERATE IN EFFECT WHEN FUEL TEMP OOR FAULT ... */
#define fuel_derate_in_effect_when_high_temp_fuel_limit_is_active_0_to_300 (*(volatile uint16_t*)0x0080748EUL) /* FUEL DERATE IN EFFECT WHEN HIGH TEMP FUEL LIMIT... */
#define fuel_derate_in_effect_when_in_range_temp_fault_active_0_to_300 (*(volatile uint16_t*)0x00807490UL) /* FUEL DERATE IN EFFECT WHEN IN-RANGE TEMP FAULT ... */
#define minimum_pump_voltage_to_enable_bip_fault_0_to_40 (*(volatile uint16_t*)0x00807492UL) /* MINIMUM PUMP VOLTAGE TO ENABLE BIP FAULT */
#define max_112_messages_received_after_pump_should_be_off_for_stuck_0_to_255 (*(volatile uint8_t*)0x00807494UL) /* MAX 112 MESSAGES RECEIVED AFTER PUMP SHOULD BE ... */
#define debounce_counts_for_stuck_timing_error_0_to_255 (*(volatile uint8_t*)0x00807495UL) /* DEBOUNCE COUNTS FOR STUCK TIMING ERROR */
#define max_timing_achievable_at_high_speeds_90_to_90 (*(volatile uint16_t*)0x00807498UL) /* MAX TIMING ACHIEVABLE AT HIGH SPEEDS */
#define max_timing_achievable_at_low_speeds_90_to_90 (*(volatile uint16_t*)0x0080749AUL) /* MAX TIMING ACHIEVABLE AT LOW SPEEDS */
#define speed_at_which_high_speed_max_timing_is_available_0_to_5000 (*(volatile uint16_t*)0x0080749CUL) /* SPEED AT WHICH HIGH SPEED MAX TIMING IS AVAILABLE */
#define speed_at_which_low_speed_max_timing_is_available_0_to_5000 (*(volatile uint16_t*)0x0080749EUL) /* SPEED AT WHICH LOW SPEED MAX TIMING IS AVAILABLE */
#define pump_solenoid_errors_enabled_above_this_speed_0_to_5000 (*(volatile uint16_t*)0x008074A0UL) /* PUMP SOLENOID ERRORS ENABLED ABOVE THIS SPEED */
#define max_allowable_sol_duration_when_fuel_command_is_zero_0_to_60 (*(volatile uint16_t*)0x008074A2UL) /* MAX ALLOWABLE SOL DURATION WHEN FUEL COMMAND IS... */
#define iat_error_is_disabled_below_this_speed_threshold_0_to_5000 (*(volatile uint16_t*)0x008074A4UL) /* IAT ERROR IS DISABLED BELOW THIS SPEED THRESHOLD */
#define debounce_counts_for_iat_error_0_to_255 (*(volatile uint8_t*)0x008074A6UL) /* DEBOUNCE COUNTS FOR IAT ERROR */
#define debounce_counts_for_pump_solenoid_errors_0_to_255 (*(volatile uint8_t*)0x008074A7UL) /* DEBOUNCE COUNTS FOR PUMP SOLENOID ERRORS */
#define max_allowed_diff_betw_rpm_measured_in_ecm_and_pcm_0_to_5000 (*(volatile uint16_t*)0x008074A8UL) /* MAX ALLOWED DIFF BETW RPM MEASURED IN ECM AND PCM */
#define fuel_limited_to_this_value_upon_vp44_fuel_valve_open_error_0_to_300 (*(volatile uint16_t*)0x008074AAUL) /* FUEL LIMITED TO THIS VALUE UPON VP44_FUEL_VALVE... */
#define minumum_coolant_temperature_threshold_for_vp44_static_timin_50_to_255 (*(volatile uint16_t*)0x008074ACUL) /* MINUMUM COOLANT TEMPERATURE THRESHOLD FOR VP44_... */
#define max_allowed_fuel_for_calibration_error_sanity_check_0_to_300 (*(volatile uint16_t*)0x008074AEUL) /* MAX ALLOWED FUEL FOR CALIBRATION ERROR SANITY C... */
#define max_allowed_rpm_for_calibration_error_sanity_check_0_to_5000 (*(volatile uint16_t*)0x008074B0UL) /* MAX ALLOWED RPM FOR CALIBRATION ERROR SANITY CHECK */
#define max_allowed_timing_for_calibration_error_sanity_check_100_to_100_74b2 (*(volatile uint16_t*)0x008074B2UL) /* MAX ALLOWED TIMING FOR CALIBRATION ERROR SANITY... */
#define min_allowed_timing_for_calibration_error_sanity_check_100_to_100_74b4 (*(volatile uint16_t*)0x008074B4UL) /* MIN ALLOWED TIMING FOR CALIBRATION ERROR SANITY... */
#define engine_rpm_at_which_to_start_counting_112_messages_for_stuck_0_5000 (*(volatile uint16_t*)0x008074B6UL) /* ENGINE RPM AT WHICH TO START COUNTING 112 MESSA... */
#define max_allowed_timing_for_calibration_error_sanity_check_100_to_100_74b8 (*(volatile uint16_t*)0x008074B8UL) /* MAX ALLOWED TIMING FOR CALIBRATION ERROR SANITY... */
#define min_allowed_timing_for_calibration_error_sanity_check_100_to_100_74ba (*(volatile uint16_t*)0x008074BAUL) /* MIN ALLOWED TIMING FOR CALIBRATION ERROR SANITY... */
#define debounce_for_missing_timing_sync_pulse_fault_detection_0_to_ff (*(volatile uint8_t*)0x008074BCUL) /* DEBOUNCE FOR MISSING TIMING SYNC PULSE FAULT DE... */
#define debounce_for_ecm_calibration_out_of_range_0_to_ff (*(volatile uint8_t*)0x008074BDUL) /* DEBOUNCE FOR ECM CALIBRATION OUT OF RANGE */
#define speed_threshold_for_high_speed_solenoid_error_debounce_0_to_5000 (*(volatile uint16_t*)0x008074BEUL) /* SPEED THRESHOLD FOR HIGH SPEED SOLENOID ERROR D... */
#define high_speed_debounce_counts_for_solenoid_error_0_to_255 (*(volatile uint8_t*)0x008074C0UL) /* HIGH SPEED DEBOUNCE COUNTS FOR SOLENOID ERROR. */
#define high_speed_debounce_counts_for_iat_error_0_to_255 (*(volatile uint8_t*)0x008074C1UL) /* HIGH SPEED DEBOUNCE COUNTS FOR IAT ERROR. */
#define speed_threshold_for_high_speed_iat_error_debounce_0_to_5000 (*(volatile uint16_t*)0x008074C2UL) /* SPEED THRESHOLD FOR HIGH SPEED IAT ERROR DEBOUNCE. */
#define micro_fuel_error_disabled_below_this_threshold_0_to_5000 (*(volatile uint16_t*)0x008074C4UL) /* MICRO FUEL ERROR DISABLED BELOW THIS THRESHOLD. */
#define micro_speed_error_disabled_below_this_threshold_0_to_5000 (*(volatile uint16_t*)0x008074C6UL) /* MICRO SPEED ERROR DISABLED BELOW THIS THRESHOLD. */
#define time_after_key_on_that_start_inhibit_is_enabled_0_to_30 (*(volatile uint16_t*)0x008074C8UL) /* TIME AFTER KEY-ON THAT START INHIBIT IS ENABLED. */
#define flag_to_enable_or_disable_start_inhibit_1_enable_inhibit_0_to_1 (*(volatile uint16_t*)0x008074CAUL) /* FLAG TO ENABLE OR DISABLE START INHIBIT 1 = ENA... */
#define idle_select_error_disabled_below_this_rpm_0_to_5000 (*(volatile uint16_t*)0x008074CCUL) /* IDLE SELECT ERROR DISABLED BELOW THIS RPM */
#define low_pump_voltage_threshold_while_running_0_to_40 (*(volatile uint16_t*)0x008074CEUL) /* LOW PUMP VOLTAGE THRESHOLD WHILE RUNNING */
#define low_pump_voltage_threshold_while_cranking_0_to_40 (*(volatile uint16_t*)0x008074D0UL) /* LOW PUMP VOLTAGE THRESHOLD WHILE CRANKING */
#define pump_voltage_clear_threshold_while_running_0_to_40 (*(volatile uint16_t*)0x008074D2UL) /* PUMP VOLTAGE CLEAR THRESHOLD WHILE RUNNING */
#define pump_voltage_clear_threshold_while_cranking_0_to_40 (*(volatile uint16_t*)0x008074D4UL) /* PUMP VOLTAGE CLEAR THRESHOLD WHILE CRANKING */
#define FLTATBZA (*(volatile uint16_t*)0x0080770CUL) /* CalTerm FLTATBZA: LINE DELAY TIMING OFFSET TABLE */
#define vp44_fault_protection_table_base (*(volatile uint16_t*)0x008077AAUL) /* VP44 fault protection table base address (vp44F... */
#define vp44_rpm_fault_counter_limit (*(volatile uint16_t*)0x008077B6UL) /* VP44 RPM-based fault counter limit (vp44RpmBase... */
#define vp44_rpm_fault_state_threshold (*(volatile uint16_t*)0x008077B8UL) /* VP44 RPM fault state threshold (vp44RpmBasedFau... */
#define vp44_rpm_fault_fuel_demand_threshold (*(volatile uint16_t*)0x008077BAUL) /* VP44 RPM fault fuel demand threshold (vp44RpmBa... */
#define engine_mode_io_control_timeout_initial (*(volatile uint16_t*)0x008077BCUL) /* Initial timeout value loaded into engine_mode_i... */
#define output_control_state_transition_countdown (*(volatile uint16_t*)0x008077BEUL) /* Common countdown for state 2 and fallback trans... */
#define output_control_state_2_transition_threshold (*(volatile uint16_t*)0x008077C0UL) /* State 2 transition counter threshold (5 refs) */
#define output_control_state_1_transition_delay_alt (*(volatile uint16_t*)0x008077C2UL) /* State 1 transition delay (alternate path when f... */
#define output_control_state_1_transition_delay_primary (*(volatile uint16_t*)0x008077C4UL) /* State 1 transition delay (primary path when fla... */
#define output_control_io_override_enable_flag (*(volatile uint8_t*)0x008077C6UL) /* Engine mode I/O override enable flag (5 refs) */
#define output_control_io_override_condition_flag (*(volatile uint8_t*)0x008077C7UL) /* Engine mode I/O override condition flag (5 refs) */
#define fault_flag_bitmap_table_1_base (*(volatile uint16_t*)0x008077C8UL) /* Fault flag scanner bitmap table 1 base (faultFl... */
#define fault_flag_bitmap_table_2_base (*(volatile uint16_t*)0x008077E8UL) /* Fault flag scanner bitmap table 2 base (faultFl... */
#define fault_flag_bitmap_table_3_base (*(volatile uint16_t*)0x00807808UL) /* Fault flag scanner bitmap table 3 base (faultFl... */
#define diagnostic_sensor_rpm_threshold (*(volatile uint16_t*)0x00807828UL) /* Diagnostic sensor RPM threshold (vp44Diagnostic... */
#define diagnostic_sensor_reading_threshold (*(volatile uint16_t*)0x0080782AUL) /* Diagnostic sensor reading threshold (vp44Diagno... */
#define added_to_final_fuel_command_for_cylinder_1_300_to_300 (*(volatile uint16_t*)0x0080782CUL) /* ADDED TO FINAL FUEL COMMAND FOR CYLINDER #1 */
#define added_to_final_fuel_command_for_cylinder_2_300_to_300 (*(volatile uint16_t*)0x0080782EUL) /* ADDED TO FINAL FUEL COMMAND FOR CYLINDER #2 */
#define added_to_final_fuel_command_for_cylinder_3_300_to_300 (*(volatile uint16_t*)0x00807830UL) /* ADDED TO FINAL FUEL COMMAND FOR CYLINDER #3 */
#define added_to_final_fuel_command_for_cylinder_4_300_to_300 (*(volatile uint16_t*)0x00807832UL) /* ADDED TO FINAL FUEL COMMAND FOR CYLINDER #4 */
#define added_to_final_fuel_command_for_cylinder_5_300_to_300 (*(volatile uint16_t*)0x00807834UL) /* ADDED TO FINAL FUEL COMMAND FOR CYLINDER #5 */
#define added_to_final_fuel_command_for_cylinder_6_300_to_300 (*(volatile uint16_t*)0x00807836UL) /* ADDED TO FINAL FUEL COMMAND FOR CYLINDER #6 */
#define index_of_first_tdc_after_missed_pulse_1_6 (*(volatile uint8_t*)0x00807838UL) /* INDEX OF FIRST TDC AFTER MISSED PULSE */
#define current_cylinder_counter_resets_to_this_when_eps_ref_pulse_occu_0_16 (*(volatile uint8_t*)0x00807839UL) /* CURRENT CYLINDER COUNTER RESETS TO THIS WHEN EP... */
#define dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60 (*(volatile uint32_t*)0x0080783AUL) /* DZG_ANGLE_AFTER_CYL_TDC:ANGLE AFTER CYL TDC TO ... */
#define dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60 (*(volatile uint32_t*)0x0080783EUL) /* DZG_ANGULAR_DURATION:ANGULAR HIGH DURATION OF D... */
#define dzg_timing_control_params (*(volatile uint16_t*)0x00807840UL) /* DZG timing and pressure control parameters */
#define watchdog_fueling_debounce_counts_0_to_255 (*(volatile uint16_t*)0x00807842UL) /* WATCHDOG FUELING DEBOUNCE COUNTS */
#define max_allowed_fueling_at_high_rpm_and_min_throttle_0_to_200 (*(volatile uint16_t*)0x00807844UL) /* MAX ALLOWED FUELING AT HIGH RPM AND MIN THROTTLE */
#define watchdog_fueling_enforced_above_this_speed_0_to_5000 (*(volatile uint16_t*)0x00807846UL) /* WATCHDOG FUELING ENFORCED ABOVE THIS SPEED */
#define default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300 (*(volatile uint16_t*)0x00807848UL) /* DEFAULT VALUE FOR VP44 FUEL TEMPERATURE WHEN SE... */
#define dzg_pressure_max_limit (*(volatile uint16_t*)0x0080784AUL) /* DZG pressure control maximum limit (7 refs) */
#define engine_rpm_histogram_upper_threshold (*(volatile uint16_t*)0x00807852UL) /* Upper RPM threshold for histogram binning (4 refs) */
#define engine_rpm_histogram_lower_threshold (*(volatile uint16_t*)0x00807854UL) /* Lower RPM threshold for histogram binning (4 refs) */
#define hour_meter_multiplier (*(volatile uint16_t*)0x00807856UL) /* Hour meter conversion multiplier (2 refs) */
#define in_postheat_schedule_2_or_3_stages_1_3_trans_to_from_2_whe_0_4500 (*(volatile uint16_t*)0x00807858UL) /* IN POSTHEAT SCHEDULE 2 OR 3:  STAGES 1/3 TRANS.... */
#define hysteresis_added_to_postheat_stage_rpm_transitions_0_4500 (*(volatile uint16_t*)0x0080785AUL) /* HYSTERESIS ADDED TO POSTHEAT STAGE RPM TRANSITIONS */
#define IHPHTPDL (*(volatile uint16_t*)0x0080785CUL) /* CalTerm IHPHTPDL: IF (TEMP1-THIS CAL)<TEMP0, US... */
#define disable_postheat_if_coolant_temp_cal_and_postheat_temp_i_50_293 (*(volatile uint16_t*)0x00807860UL) /* DISABLE POSTHEAT IF COOLANT TEMP > CAL AND POST... */
#define disable_postheat_if_postheat_temp_cal_and_coolant_temp_i_50_293 (*(volatile uint16_t*)0x00807862UL) /* DISABLE POSTHEAT IF POSTHEAT TEMP > CAL AND COO... */
#define runtime_histogram_base_value (*(volatile uint16_t*)0x0080786EUL) /* Runtime histogram base value (engineRunTimeHist... */
#define runtime_histogram_offset_value (*(volatile uint16_t*)0x0080787AUL) /* Runtime histogram offset value (engineRunTimeHi... */
#define governor_derivative_deadband (*(volatile uint16_t*)0x0080787CUL) /* Governor PID derivative deadband threshold (4 r... */
#define governor_derivative_filter_coeff (*(volatile uint16_t*)0x0080787EUL) /* Governor derivative filter coefficient (1 ref) */
#define IHPHSDXA ((volatile uint8_t*)0x00807880UL) /* [12] CalTerm IHPHSDXA: IAH POSTHEAT SCHEDULE (POSTHE... */
#define derate_base_calibration_value (*(volatile uint16_t*)0x00807882UL) /* Derate base calibration value used by derate_ap... */
#define target_rpm_rate_limit (*(volatile uint16_t*)0x00807884UL) /* Target RPM rate limiter limit value (3 refs) */
#define diag_mode_7_output_upper_limit (*(volatile uint16_t*)0x008078A0UL) /* Diagnostic mode 7 output upper limit (1 ref) */
#define diag_mode_7_output_lower_limit (*(volatile uint16_t*)0x008078A2UL) /* Diagnostic mode 7 output lower limit (1 ref) */
#define diag_blend_factor_base (*(volatile uint16_t*)0x008078A8UL) /* Diagnostic blend factor base value (1 ref) */
#define diag_blend_factor_offset (*(volatile uint16_t*)0x008078AAUL) /* Diagnostic blend factor offset value (1 ref) */
#define governor_fuel_blend_limit_upper (*(volatile uint16_t*)0x008078B0UL) /* Governor fuel blend calculation upper limit (3 ... */
#define governor_fuel_blend_limit_lower (*(volatile uint16_t*)0x008078B2UL) /* Governor fuel blend calculation lower limit (3 ... */
#define IHPHTMZA (*(volatile uint16_t*)0x008078B4UL) /* CalTerm IHPHTMZA: IAH POSTHEAT TIME - Z MATRIX,... */
#define diag_mode_2_output_upper_limit (*(volatile uint16_t*)0x008078F8UL) /* Diagnostic mode 2 output upper limit (1 ref) */
#define diag_mode_2_output_lower_limit (*(volatile uint16_t*)0x008078FAUL) /* Diagnostic mode 2 output lower limit (1 ref) */
#define IHPSDCXA ((volatile uint8_t*)0x0080792CUL) /* [5] CalTerm IHPSDCXA: IAH POSTHEAT STAGE TO DUTY CY... */
#define insite_fuel_timing_display (*(volatile uint16_t*)0x00807944UL) /* INSITE fuel timing display value (1 ref) */
#define fault_persistence_threshold (*(volatile uint16_t*)0x00807946UL) /* Fault persistence counter threshold for debounc... */
#define accel_throttle_fault_delay_threshold (*(volatile uint16_t*)0x00807948UL) /* Accelerator throttle fault delay threshold (2 r... */
#define accel_throttle_fault_count_threshold (*(volatile uint16_t*)0x0080794AUL) /* Accelerator throttle fault count threshold (2 r... */
#define accel_throttle_fault_upper_threshold (*(volatile uint16_t*)0x0080794CUL) /* Accelerator throttle fault upper threshold (1 ref) */
#define BSTATBZA (*(volatile uint16_t*)0x0080794EUL) /* TABLE FOR DETERMINING MINIMUM ADVANCE FOR MISFIRE */
#define accel_throttle_diag_reading_threshold (*(volatile uint16_t*)0x00807950UL) /* Accelerator throttle diagnostic reading thresho... */
#define delay_time_before_setting_oil_pressure_high_postprocessed_error_0_600 (*(volatile uint16_t*)0x0080796EUL) /* DELAY TIME BEFORE SETTING OIL PRESSURE HIGH POS... */
#define ADO2TPAI (*(volatile uint16_t*)0x00807970UL) /* CalTerm ADO2TPAI: COOLANT TEMPERATURE AXIS FOR ... */
#define ADO2ESTB (*(volatile uint16_t*)0x00807978UL) /* CalTerm ADO2ESTB: TABLE OF SPEEDS ABOVE WHICH E... */
#define retarder_mode_threshold_value_7996 (*(volatile uint16_t*)0x00807996UL) /* Retarder mode threshold value (retarderModeThre... */
#define throttle_position_low_threshold (*(volatile uint16_t*)0x008079B6UL) /* Throttle position low threshold (1 ref) */
#define throttle_buffer_threshold_low (*(volatile uint16_t*)0x008079B8UL) /* Throttle buffer low threshold (bufferThresholdV... */
#define throttle_buffer_offset_adjust (*(volatile uint16_t*)0x008079BAUL) /* Throttle buffer offset adjustment (bufferDecrea... */
#define throttle_buffer_min_delta (*(volatile uint16_t*)0x008079BCUL) /* Throttle buffer minimum delta (bufferDecreasing... */
#define throttle_position_high_threshold (*(volatile uint16_t*)0x008079BEUL) /* Throttle position high threshold (1 ref) */
#define throttle_scaling_factor (*(volatile uint16_t*)0x008079C6UL) /* Throttle position scaling factor (3 refs) */
#define throttle_buffer_scale_factor (*(volatile uint16_t*)0x008079C8UL) /* Throttle buffer scale factor (bufferThresholdVa... */
#define throttle_buffer_low_threshold (*(volatile uint16_t*)0x008079CAUL) /* Throttle buffer low threshold value (bufferThre... */
#define throttle_buffer_high_threshold (*(volatile uint16_t*)0x008079CEUL) /* Throttle buffer high threshold value (bufferThr... */
#define derate_upper_offset (*(volatile uint16_t*)0x008079D2UL) /* Derate upper threshold offset (1 ref) */
#define derate_lower_offset (*(volatile uint16_t*)0x008079D4UL) /* Derate lower threshold offset (1 ref) */
#define derate_threshold_calibration (*(volatile uint16_t*)0x008079D8UL) /* Derate threshold calibration base value (4 refs) */
#define derate_monitor_timer_init (*(volatile uint16_t*)0x008079DAUL) /* Derate monitor timer init value (2 refs) */
#define derate_hysteresis_offset (*(volatile uint16_t*)0x008079DCUL) /* Derate hysteresis offset for comparison (1 ref) */
#define derate_fault_counter_threshold_alt (*(volatile uint16_t*)0x008079DEUL) /* Derate fault counter threshold alternate (1 ref) */
#define derate_mode_selector (*(volatile uint16_t*)0x008079E0UL) /* Derate mode selector 0=normal 1=override (2 refs) */
#define the_transmission_pwm_scaling_from_load_to_duty_cycle_2_2 (*(volatile uint16_t*)0x008079E2UL) /* THE TRANSMISSION PWM SCALING FROM LOAD TO DUTY ... */
#define the_transmission_pwm_bias_from_load_to_duty_cycle_100_100 (*(volatile uint16_t*)0x008079E4UL) /* THE TRANSMISSION PWM BIAS FROM LOAD TO DUTY CYCLE */
#define the_transmission_pwm_signal_dutycycle_maximum_value_high_time_0_100 (*(volatile uint16_t*)0x008079E6UL) /* THE TRANSMISSION PWM SIGNAL DUTYCYCLE MAXIMUM V... */
#define the_transmission_pwm_signal_dutycycle_minimum_value_high_time_0_100 (*(volatile uint16_t*)0x008079E8UL) /* THE TRANSMISSION PWM SIGNAL DUTYCYCLE MINIMUM V... */
#define the_load_point_at_which_the_kick_down_signal_activates_0_127 (*(volatile uint16_t*)0x008079EAUL) /* THE LOAD POINT AT WHICH THE KICK DOWN SIGNAL AC... */
#define the_load_point_at_which_the_kick_down_signal_de_activates_0_127 (*(volatile uint16_t*)0x008079ECUL) /* THE LOAD POINT AT WHICH THE KICK DOWN SIGNAL DE... */
#define engine_speed_at_0_fuel_which_activates_kick_down_signal_0_8000 (*(volatile uint16_t*)0x008079EEUL) /* ENGINE SPEED AT 0 %FUEL WHICH ACTIVATES KICK DO... */
#define engine_speed_at_0_fuel_which_de_activates_kick_down_signal_0_8000 (*(volatile uint16_t*)0x008079F0UL) /* ENGINE SPEED AT 0 %FUEL WHICH DE-ACTIVATES KICK... */
#define droop_added_to_trans_speed_kick_down_which_activates_kick_d_400_400 (*(volatile uint16_t*)0x008079F2UL) /* DROOP ADDED TO TRANS_SPEED_KICK_DOWN WHICH ACTI... */
#define droop_added_to_trans_speed_kick_up_which_de_activates_kick_400_400 (*(volatile uint16_t*)0x008079F4UL) /* DROOP ADDED TO TRANS_SPEED_KICK_UP WHICH DE-ACT... */
#define DRTXESLD (*(volatile uint16_t*)0x008079F6UL) /* CalTerm DRTXESLD: BELOW THIS ENGINE SPEED, LOAD... */
#define minimum_boost_pressure_for_which_the_high_boost_error_can_be_log_0_100 (*(volatile uint16_t*)0x008079FAUL) /* MINIMUM BOOST PRESSURE FOR WHICH THE HIGH BOOST... */
#define minimum_time_at_a_high_boost_condition_before_setting_the_error_0_60 (*(volatile uint16_t*)0x008079FCUL) /* MINIMUM TIME AT A HIGH BOOST CONDITION BEFORE S... */
#define hysteresis_duration_on_ac_compressor_clutch_0_3600 (*(volatile uint16_t*)0x008079FEUL) /* HYSTERESIS DURATION ON AC COMPRESSOR CLUTCH [Ca... */
#define accel_threshold_to_disable_a_c_1200_1200 (*(volatile uint16_t*)0x00807A00UL) /* ACCEL THRESHOLD TO DISABLE A/C [CalTerm: ACVSACCO] */
#define alg_executions_to_suspend_ac_after_shutoff_from_accel_0_3600 (*(volatile uint16_t*)0x00807A02UL) /* ALG EXECUTIONS TO SUSPEND AC AFTER SHUTOFF FROM... */
#define threshold_on_sw_err_counter_for_fault_0_3600 (*(volatile uint16_t*)0x00807A04UL) /* THRESHOLD ON SW ERR COUNTER FOR FAULT [CalTerm:... */
#define speed_below_which_ac_clutch_is_disabled_0_4500 (*(volatile uint16_t*)0x00807A06UL) /* SPEED BELOW WHICH AC CLUTCH IS DISABLED [CalTer... */
#define temperature_boundary_between_cold_and_normal_cool_temp_gauge_50_293 (*(volatile uint16_t*)0x00807A0CUL) /* TEMPERATURE BOUNDARY BETWEEN COLD AND NORMAL CO... */
#define duty_cycle_conversion_factor_for_cool_temp_gauge_cold_state_0_9 (*(volatile uint16_t*)0x00807A0EUL) /* DUTY CYCLE CONVERSION FACTOR FOR COOL TEMP GAUG... */
#define duty_cycle_conversion_factor_for_cool_temp_gauge_hot_state_0_9 (*(volatile uint16_t*)0x00807A12UL) /* DUTY CYCLE CONVERSION FACTOR FOR COOL TEMP GAUG... */
#define duty_cycle_conversion_factor_for_cool_temp_gauge_very_hot_state_0_9 (*(volatile uint16_t*)0x00807A14UL) /* DUTY CYCLE CONVERSION FACTOR FOR COOL TEMP GAUG... */
#define duty_cycle_conversion_factor_for_oil_press_gauge_very_low_state_0_9 (*(volatile uint16_t*)0x00807A16UL) /* DUTY CYCLE CONVERSION FACTOR FOR OIL PRESS GAUG... */
#define duty_cycle_conversion_factor_for_oil_press_gauge_low_state_0_9 (*(volatile uint16_t*)0x00807A18UL) /* DUTY CYCLE CONVERSION FACTOR FOR OIL PRESS GAUG... */
#define first_order_filter_coeff_for_limited_veh_accel_0_1 (*(volatile uint16_t*)0x00807A1CUL) /* 1ST ORDER FILTER COEFF FOR LIMITED VEH ACCEL */
#define limit_on_max_unfiltered_veh_accel_1200_1200 (*(volatile uint16_t*)0x00807A1EUL) /* LIMIT ON MAX UNFILTERED VEH ACCEL */
#define limit_on_min_unfiltered_veh_accel_1200_1200 (*(volatile uint16_t*)0x00807A20UL) /* LIMIT ON MIN UNFILTERED VEH ACCEL */
#define minimum_amount_of_time_which_the_anc_fuel_limit_will_be_active_0_20 (*(volatile uint16_t*)0x00807A22UL) /* MINIMUM AMOUNT OF TIME WHICH THE ANC FUEL LIMIT... */
#define fuel_increment_added_to_anc_fueling_to_ramp_out_the_fueling_de_0_100 (*(volatile uint16_t*)0x00807A24UL) /* FUEL INCREMENT ADDED TO ANC_FUELING TO RAMP OUT... */
#define engine_acceleration_below_which_anc_may_limit_fueling_2560_2540 (*(volatile uint16_t*)0x00807A26UL) /* ENGINE ACCELERATION BELOW WHICH ANC MAY LIMIT F... */
#define filtered_engine_acceleration_above_which_anc_may_limit_fu_2560_2540 (*(volatile uint16_t*)0x00807A28UL) /* FILTERED ENGINE ACCELERATION ABOVE WHICH ANC MA... */
#define engine_speed_above_which_anc_may_limit_fueling_1000_3000 (*(volatile uint16_t*)0x00807A2AUL) /* ENGINE SPEED ABOVE WHICH ANC MAY LIMIT FUELING */
#define calibratible_engine_speed_constant_used_to_set_anc_engine_1000_3000 (*(volatile uint16_t*)0x00807A2CUL) /* CALIBRATIBLE ENGINE SPEED CONSTANT USED TO SET ... */
#define minimum_amount_of_time_which_the_anc_speed_limit_will_be_active_0_20 (*(volatile uint16_t*)0x00807A2EUL) /* MINIMUM AMOUNT OF TIME WHICH THE ANC SPEED LIMI... */
#define engine_speed_increment_added_to_anc_speed_to_ramp_out_the_eng_0_3000 (*(volatile uint16_t*)0x00807A30UL) /* ENGINE SPEED INCREMENT ADDED TO ANC_SPEED TO RA... */
#define filtered_engine_acceleration_above_which_anc_may_limit_en_2560_2540 (*(volatile uint16_t*)0x00807A32UL) /* FILTERED ENGINE ACCELERATION ABOVE WHICH ANC MA... */
#define engine_speed_above_which_anc_may_limit_engine_speed_1000_3000 (*(volatile uint16_t*)0x00807A34UL) /* ENGINE SPEED ABOVE WHICH ANC MAY LIMIT ENGINE S... */
#define engine_acceleration_below_which_anc_may_limit_engine_spee_2560_2540 (*(volatile uint16_t*)0x00807A36UL) /* ENGINE ACCELERATION BELOW WHICH ANC MAY LIMIT E... */
#define calibratible_coolant_temperature_above_which_maximum_timing_m_20_255 (*(volatile uint16_t*)0x00807A38UL) /* CALIBRATIBLE COOLANT TEMPERATURE ABOVE WHICH MA... */
#define minimum_amount_of_time_which_the_anc_timing_limit_will_be_activ_0_20 (*(volatile uint16_t*)0x00807A3AUL) /* MINIMUM AMOUNT OF TIME WHICH THE ANC TIMING LIM... */
#define timing_increment_added_to_anc_timing_to_ramp_out_the_timing_de_0_720 (*(volatile uint16_t*)0x00807A3CUL) /* TIMING INCREMENT ADDED TO ANC_TIMING TO RAMP OU... */
#define filtered_engine_acceleration_above_which_anc_may_limit_ti_2560_2540 (*(volatile uint16_t*)0x00807A3EUL) /* FILTERED ENGINE ACCELERATION ABOVE WHICH ANC MA... */
#define unfiltered_acceleration_limit_used_to_determine_anc_timi_2560_2540 (*(volatile uint16_t*)0x00807A40UL) /* UNFILTERED ACCELERATION LIMIT USED TO DETERMINE... */
#define engine_acceleration_first_stage_digital_filter_acceleration_time_0_1 (*(volatile uint16_t*)0x00807A42UL) /* ENGINE ACCELERATION FIRST STAGE DIGITAL FILTER ... */
#define engine_acceleration_second_stage_digital_filter_acceleration_tim_0_1 (*(volatile uint16_t*)0x00807A44UL) /* ENGINE ACCELERATION SECOND STAGE DIGITAL FILTER... */
#define upper_acceleration_bound_for_eng_accel_first_stage_filter_2560_2540 (*(volatile uint16_t*)0x00807A46UL) /* UPPER ACCELERATION BOUND FOR ENG ACCEL FIRST ST... */
#define lower_acceleration_bound_for_eng_accel_first_stage_filter_2560_2540 (*(volatile uint16_t*)0x00807A48UL) /* LOWER ACCELERATION BOUND FOR ENG ACCEL FIRST ST... */
#define duration_anc_speed_limit_will_be_disabled_after_a_bare_engine_a_0_20 (*(volatile uint16_t*)0x00807A4AUL) /* DURATION ANC SPEED LIMIT WILL BE DISABLED AFTER... */
#define duration_anc_fueling_limit_will_be_disabled_after_a_bare_engine_0_20 (*(volatile uint16_t*)0x00807A4CUL) /* DURATION ANC FUELING LIMIT WILL BE DISABLED AFT... */
#define duration_anc_timing_limit_will_be_disabled_after_a_bare_engine_0_20 (*(volatile uint16_t*)0x00807A4EUL) /* DURATION ANC TIMING LIMIT WILL BE DISABLED AFTE... */
#define engine_acceleration_below_which_anc_may_limit_timing_2560_2540 (*(volatile uint16_t*)0x00807A50UL) /* ENGINE ACCELERATION BELOW WHICH ANC MAY LIMIT T... */
#define priority_of_accelerator_interlock_feature_w_r_to_other_throttle_fe_0_9 (*(volatile uint16_t*)0x00807A52UL) /* PRIORITY OF ACCELERATOR INTERLOCK FEATURE W/R T... */
#define afc_fueling_derate_value_when_afc_override_is_enabled_0_100 (*(volatile uint16_t*)0x00807A5AUL) /* AFC FUELING DERATE VALUE WHEN AFC OVERRIDE IS E... */
#define rate_at_which_alpha_increases_while_alpha_is_below_the_alpha_thr_0_1 (*(volatile uint16_t*)0x00807AA0UL) /* RATE AT WHICH ALPHA INCREASES WHILE ALPHA IS BE... */
#define rate_at_which_alpha_increases_while_alpha_is_the_alpha_thres_0_1 (*(volatile uint16_t*)0x00807AA2UL) /* RATE AT WHICH ALPHA INCREASES WHILE ALPHA IS >=... */
#define value_of_alpha_at_which_the_ramp_rate_transition_takes_place_0_1 (*(volatile uint16_t*)0x00807AA4UL) /* VALUE OF ALPHA AT WHICH THE RAMP RATE TRANSITIO... */
#define time_that_must_elapse_without_afc_limiting_before_alpha_may_be_0_900 (*(volatile uint16_t*)0x00807AA6UL) /* TIME THAT MUST ELAPSE WITHOUT AFC LIMITING BEFO... */
#define time_alpha_is_latched_to_adalf_after_altitude_derate_stops_fue_0_900 (*(volatile uint16_t*)0x00807AAAUL) /* TIME ALPHA IS LATCHED TO ADALF AFTER ALTITUDE D... */
#define time_that_must_expire_without_lsg_commanding_fuel_before_alpha_0_900 (*(volatile uint16_t*)0x00807AAEUL) /* TIME THAT MUST EXPIRE WITHOUT LSG COMMANDING FU... */
#define time_constant_of_lb_hr_filter_used_in_the_alpha_fuel_rate_calcula_0_1 (*(volatile uint16_t*)0x00807AB0UL) /* TIME CONSTANT OF LB/HR FILTER USED IN THE ALPHA... */
#define APRSFLRT (*(volatile uint16_t*)0x00807AB2UL) /* FUEL RATE LIMIT BELOW WHICH ALPHA IS ZERO -RESE... */
#define APTDFLRT (*(volatile uint16_t*)0x00807AB4UL) /* FUEL RATE LIMIT ABOVE WHICH ALPHA MAY GO TO ONE */
#define engine_speed_above_which_derating_will_occur_when_ambient_air_0_8000 (*(volatile uint16_t*)0x00807ABAUL) /* ENGINE SPEED ABOVE WHICH DERATING WILL OCCUR WH... */
#define default_fueling_to_be_used_by_altitude_derate_if_ambient_air_p_0_100 (*(volatile uint16_t*)0x00807ABCUL) /* DEFAULT FUELING TO BE USED BY ALTITUDE DERATE I... */
#define ASDVDELM (*(volatile uint16_t*)0x00807ABEUL) /* ASG DERIVATIVE DEAD BAND LIMIT */
#define ASDVFTCF (*(volatile uint16_t*)0x00807AC0UL) /* ASG DERIVATIVE FILTER COEFFICIENT CALIBRATION */
#define ASDVLM (*(volatile uint16_t*)0x00807AC2UL) /* ASG DERIVATIVE LIMIT */
#define ASDPFGCN (*(volatile uint16_t*)0x00807AC4UL) /* CALIBRATION FOR ASG DROOP SELECTION FLAG; SELEC... */
#define ASTHPFRL (*(volatile uint16_t*)0x00807AC6UL) /* ASG THROTTLE REF RATE LIMIT FOR PREFILTER COEF.... */
#define ASQPCFXA ((volatile uint8_t*)0x00807B00UL) /* [13] CalTerm ASQPCFXA: X AXIS OF COEF. TABLE FOR ASG... */
#define ASQICFXA ((volatile uint8_t*)0x00807B38UL) /* [13] CalTerm ASQICFXA: X AXIS OF COEF. TABLE FOR ASG... */
#define ASQDCFXA ((volatile uint8_t*)0x00807B70UL) /* [13] CalTerm ASQDCFXA: X AXIS OF COEF. TABLE FOR ASG... */
#define ASJCFTCS (*(volatile uint16_t*)0x00807B8CUL) /* ASG JCOMM REFERENCE FILTER CONSTANT */
#define ASJCFLMX (*(volatile uint16_t*)0x00807B8EUL) /* ASG JCOMM FUELING HIGH LIMIT CALIBRATION */
#define ASJCFLMN (*(volatile uint16_t*)0x00807B90UL) /* ASG JCOMM FUELING LOWER LIMIT CALIBRATION */
#define ASJ100PP (*(volatile uint16_t*)0x00807B92UL) /* ASG PROPORTIONAL GAIN 1 - JCOMM MODE 00 */
#define ASJ200PP (*(volatile uint16_t*)0x00807B94UL) /* ASG PROPORTIONAL GAIN 2 - JCOMM MODE 00 */
#define ASJ100IT (*(volatile uint16_t*)0x00807B96UL) /* ASG INTEGRAL GAIN 1 - JCOMM MODE 00 */
#define ASJ200IT (*(volatile uint16_t*)0x00807B98UL) /* ASG INTEGRAL GAIN 2 - JCOMM MODE 00 */
#define ASJ100DV (*(volatile uint16_t*)0x00807B9AUL) /* ASG DERIVATIVE GAIN 1 - JCOMM MODE 00 */
#define ASJ200DV (*(volatile uint16_t*)0x00807B9CUL) /* ASG DERIVATIVE GAIN 2 - JCOMM MODE 00 */
#define ASJ100CF (*(volatile uint16_t*)0x00807B9EUL) /* ASG COMPENSATION FILTER COEF. 1 - JCOMM MODE 00 */
#define ASJ200CF (*(volatile uint16_t*)0x00807BA0UL) /* ASG COMPENSATION FILTER COEF. 2 - JCOMM MODE 00 */
#define ASJ300CF (*(volatile uint16_t*)0x00807BA2UL) /* ASG COMPENSATION FILTER COEF. 3 - JCOMM MODE 00 */
#define ASJ101PP (*(volatile uint16_t*)0x00807BA4UL) /* ASG PROPORTIONAL GAIN 1 - JCOMM MODE 01 */
#define ASJ201PP (*(volatile uint16_t*)0x00807BA6UL) /* ASG PROPORTIONAL GAIN 2 - JCOMM MODE 01 */
#define ASJ101IT (*(volatile uint16_t*)0x00807BA8UL) /* ASG INTEGRAL GAIN 1 - JCOMM MODE 01 */
#define ASJ201IT (*(volatile uint16_t*)0x00807BAAUL) /* ASG INTEGRAL GAIN 2 - JCOMM MODE 01 */
#define ASJ101DV (*(volatile uint16_t*)0x00807BACUL) /* ASG DERIVATIVE GAIN 1 - JCOMM MODE 01 */
#define ASJ201DV (*(volatile uint16_t*)0x00807BAEUL) /* ASG DERIVATIVE GAIN 2 - JCOMM MODE 01 */
#define ASJ101CF (*(volatile uint16_t*)0x00807BB0UL) /* ASG COMPENSATION FILTER COEF. 1 - JCOMM MODE 01 */
#define ASJ201CF (*(volatile uint16_t*)0x00807BB2UL) /* ASG COMPENSATION FILTER COEF. 2 - JCOMM MODE 01 */
#define ASJ301CF (*(volatile uint16_t*)0x00807BB4UL) /* ASG COMPENSATION FILTER COEF. 3 - JCOMM MODE 01 */
#define ASJ110PP (*(volatile uint16_t*)0x00807BB6UL) /* ASG PROPORTIONAL GAIN 1 - JCOMM MODE 10 */
#define ASJ210PP (*(volatile uint16_t*)0x00807BB8UL) /* ASG PROPORTIONAL GAIN 2 - JCOMM MODE 10 */
#define ASJ110IT (*(volatile uint16_t*)0x00807BBAUL) /* ASG INTEGRAL GAIN 1 - JCOMM MODE 10 */
#define ASJ210IT (*(volatile uint16_t*)0x00807BBCUL) /* ASG INTEGRAL GAIN 2 - JCOMM MODE 10 */
#define ASJ110DV (*(volatile uint16_t*)0x00807BBEUL) /* ASG DERIVATIVE GAIN 1 - JCOMM MODE 10 */
#define ASJ210DV (*(volatile uint16_t*)0x00807BC0UL) /* ASG DERIVATIVE GAIN 2 - JCOMM MODE 10 */
#define ASJ110CF (*(volatile uint16_t*)0x00807BC2UL) /* ASG COMPENSATION FILTER COEF. 1 - JCOMM MODE 10 */
#define ASJ210CF (*(volatile uint16_t*)0x00807BC4UL) /* ASG COMPENSATION FILTER COEF. 2 - JCOMM MODE 10 */
#define ASJ310CF (*(volatile uint16_t*)0x00807BC6UL) /* ASG COMPENSATION FILTER COEF. 3 - JCOMM MODE 10 */
#define ASJ111PP (*(volatile uint16_t*)0x00807BC8UL) /* ASG PROPORTIONAL GAIN 1 - JCOMM MODE 11 */
#define ASJ211PP (*(volatile uint16_t*)0x00807BCAUL) /* ASG PROPORTIONAL GAIN 2 - JCOMM MODE 11 */
#define ASJ111IT (*(volatile uint16_t*)0x00807BCCUL) /* ASG INTEGRAL GAIN 1 - JCOMM MODE 11 */
#define ASJ211IT (*(volatile uint16_t*)0x00807BCEUL) /* ASG INTEGRAL GAIN 2 - JCOMM MODE 11 */
#define ASJ111DV (*(volatile uint16_t*)0x00807BD0UL) /* ASG DERIVATIVE GAIN 1 - JCOMM MODE 11 */
#define ASJ211DV (*(volatile uint16_t*)0x00807BD2UL) /* ASG DERIVATIVE GAIN 2 - JCOMM MODE 11 */
#define ASJ111CF (*(volatile uint16_t*)0x00807BD4UL) /* ASG COMPENSATION FILTER COEF. 1 - JCOMM MODE 11 */
#define ASJ211CF (*(volatile uint16_t*)0x00807BD6UL) /* ASG COMPENSATION FILTER COEF. 2 - JCOMM MODE 11 */
#define ASJ311CF (*(volatile uint16_t*)0x00807BD8UL) /* ASG COMPENSATION FILTER COEF. 3 - JCOMM MODE 11 */
#define ASFTCF (*(volatile uint16_t*)0x00807BDAUL) /* ASG REFERENCE FILTER COEFFICIENT CALIBRATION */
#define ASCNHILM (*(volatile uint16_t*)0x00807BDCUL) /* ASG FUELING HIGH LIMIT CALIBRATION FOR THOTTLE ... */
#define ASCNLOLM (*(volatile uint16_t*)0x00807BDEUL) /* ASG FUELING LOWER LIMIT CALIBRATION FOR THOTTLE... */
#define asg_proportional_gain_1_calibration_0_0_135 (*(volatile uint16_t*)0x00807BE0UL) /* ASG PROPORTIONAL GAIN 1 CALIBRATION [CalTerm: A... */
#define ASPP02GN (*(volatile uint16_t*)0x00807BE2UL) /* ASG PROPORTIONAL GAIN 2 CALIBRATION */
#define asg_integral_gain_1_calibration_0_6_75 (*(volatile uint16_t*)0x00807BE4UL) /* ASG INTEGRAL GAIN 1 CALIBRATION [CalTerm: ASIT0... */
#define asg_integral_gain_2_calibration_0_6_75 (*(volatile uint16_t*)0x00807BE6UL) /* ASG INTEGRAL GAIN 2 CALIBRATION [CalTerm: ASIT0... */
#define asg_derivative_gain_1_calibration_0_0_0025 (*(volatile uint16_t*)0x00807BE8UL) /* ASG DERIVATIVE GAIN 1 CALIBRATION [CalTerm: ASD... */
#define ASDV02GN (*(volatile uint16_t*)0x00807BEAUL) /* ASG DERIVATIVE GAIN 2 CALIBRATION */
#define AS01CF (*(volatile uint16_t*)0x00807BECUL) /* ASG THROTTLE MODE COMPENSATION FILTER COEF. 1 C... */
#define AS02CF (*(volatile uint16_t*)0x00807BEEUL) /* ASG THROTTLE MODE COMPENSATION FILTER COEF. 2 C... */
#define AS03CF (*(volatile uint16_t*)0x00807BF0UL) /* ASG THROTTLE MODE COMPENSATION FILTER COEF. 3 C... */
#define offset_to_low_idle_reference_speed_used_in_lsg_to_no_adjust_t_0_4500 (*(volatile uint16_t*)0x00807BF2UL) /* OFFSET TO LOW IDLE REFERENCE SPEED USED IN LSG-... */
#define indicates_sep_inc_dec_sw_true_or_inc_dec_from_multi_purp_sw_f_0_1 (*(volatile uint16_t*)0x00807BF8UL) /* INDICATES SEP. INC/DEC SW.(TRUE) OR INC/DEC FRO... */
#define number_of_aux_driver_errors_that_must_be_seen_before_fault_is_1_10 (*(volatile uint16_t*)0x00807BFAUL) /* NUMBER OF AUX. DRIVER ERRORS THAT MUST BE SEEN ... */
#define specifies_number_of_bit_times_for_timer_2_timeout_0_255 (*(volatile uint16_t*)0x00807BFCUL) /* SPECIFIES NUMBER OF BIT TIMES FOR TIMER 2 TIMEOUT. */
#define specifies_number_of_bit_times_for_timer_3_timeout_0_255 (*(volatile uint16_t*)0x00807BFEUL) /* SPECIFIES NUMBER OF BIT TIMES FOR TIMER 3 TIMEOUT. */
#define enhanced_diag_number_good_samples_before_recovery_of_aux_drive_1_10 (*(volatile uint16_t*)0x00807C02UL) /* ENHANCED DIAG: NUMBER GOOD SAMPLES BEFORE RECOV... */
#define time_required_that_low_boost_cond_exist_before_birh_error_check_0_120 (*(volatile uint16_t*)0x00807C04UL) /* TIME REQUIRED THAT LOW BOOST COND. EXIST BEFORE... */
#define time_needed_for_out_of_range_high_boost_for_setting_birh_error_0_60 (*(volatile uint16_t*)0x00807C06UL) /* TIME NEEDED FOR OUT OF RANGE HIGH BOOST FOR SET... */
#define offset_added_to_lsg_ref_spd_resulting_in_rpm_limit_for_birh_tes_0_5000 (*(volatile uint16_t*)0x00807C0AUL) /* OFFSET ADDED TO LSG REF SPD RESULTING IN RPM LI... */
#define boost_threshold_for_bir_high_error_0_100 (*(volatile uint16_t*)0x00807C0CUL) /* BOOST THRESHOLD FOR BIR HIGH ERROR */
#define temp_below_which_cold_crank_can_run_50_293_7c0e (*(volatile uint16_t*)0x00807C0EUL) /* TEMP BELOW WHICH COLD CRANK CAN RUN */
#define temp_below_which_cold_crank_can_run_50_293_7c10 (*(volatile uint16_t*)0x00807C10UL) /* TEMP BELOW WHICH COLD CRANK CAN RUN */
#define time_constant_compared_with_prior_pulse_slope_in_final_cold_0_4000 (*(volatile uint16_t*)0x00807C12UL) /* TIME CONSTANT COMPARED WITH PRIOR PULSE SLOPE I... */
#define time_constant_compared_with_prior_pulse_time_in_final_cold_sy_400_0 (*(volatile uint16_t*)0x00807C14UL) /* TIME CONSTANT COMPARED WITH PRIOR PULSE TIME IN... */
#define engine_speed_limit_below_which_the_cold_crank_sync_determina_0_8000 (*(volatile uint16_t*)0x00807C16UL) /* ENGINE SPEED LIMIT BELOW WHICH THE COLD CRANK S... */
#define number_of_sync_errors_above_which_crank_fueling_will_be_inhib_0_200 (*(volatile uint16_t*)0x00807C18UL) /* NUMBER OF SYNC. ERRORS ABOVE WHICH CRANK FUELIN... */
#define replaced_old_crank_timer_count1_0 (*(volatile uint16_t*)0x00807C1AUL) /* REPLACED OLD CRANK_TIMER_COUNT1 */
#define replaced_old_crank_timer_count2_0 (*(volatile uint16_t*)0x00807C1CUL) /* REPLACED OLD CRANK_TIMER_COUNT2 */
#define value_used_to_detect_sync_pulse_0_100_7c1e (*(volatile uint16_t*)0x00807C1EUL) /* VALUE USED TO DETECT SYNC PULSE */
#define value_used_to_detect_sync_pulse_0_100_7c20 (*(volatile uint16_t*)0x00807C20UL) /* % VALUE USED TO DETECT SYNC PULSE */
#define cold_start_fuel_minimum_value (*(volatile uint16_t*)0x00807C22UL) /* Cold start fuel adjustment minimum value - acce... */
#define cold_start_rpm_threshold_high (*(volatile uint16_t*)0x00807C24UL) /* Cold start engine RPM threshold high */
#define cold_start_fuel_demand_threshold (*(volatile uint16_t*)0x00807C26UL) /* Cold start fuel demand minimum threshold - acce... */
#define cold_start_fuel_control_enable_flag (*(volatile uint16_t*)0x00807C28UL) /* Enables cold start fuel control sequence (8 refs) */
#define the_value_above_set_speed_where_e_brakes_will_turn_off_regard_0_5_10 (*(volatile uint16_t*)0x00807C2AUL) /* THE VALUE ABOVE SET SPEED WHERE E-BRAKES WILL T... */
#define the_point_on_the_braking_axis_where_engine_braking_will_begi_0_100 (*(volatile uint16_t*)0x00807C2CUL) /* THE POINT ON THE % BRAKING AXIS WHERE ENGINE BR... */
#define the_value_which_causes_one_add_n_l_brake_to_be_applied_at_a_gi_0_300 (*(volatile uint16_t*)0x00807C2EUL) /* THE VALUE WHICH CAUSES ONE ADD'N'L BRAKE TO BE ... */
#define the_minimum_speed_loss_required_to_reduce_e_brake_by_one_level_0_5_5 (*(volatile uint16_t*)0x00807C30UL) /* THE MINIMUM SPEED LOSS REQUIRED TO REDUCE E-BRA... */
#define the_deceleration_value_where_e_braking_will_be_removed_1_0_01 (*(volatile uint16_t*)0x00807C32UL) /* THE DECELERATION VALUE WHERE E-BRAKING WILL BE ... */
#define the_maximum_speed_a_customer_may_program_to_correspond_with_10_10_25 (*(volatile uint16_t*)0x00807C34UL) /* THE MAXIMUM SPEED A CUSTOMER MAY PROGRAM TO COR... */
#define the_minimum_speed_a_customer_may_program_to_correspond_with_1_1_5_15 (*(volatile uint16_t*)0x00807C36UL) /* THE MINIMUM SPEED A CUSTOMER MAY PROGRAM TO COR... */
#define the_maximum_speed_a_customer_may_program_to_correspond_with_s_1_5_15 (*(volatile uint16_t*)0x00807C38UL) /* THE MAXIMUM SPEED A CUSTOMER MAY PROGRAM TO COR... */
#define the_minimum_speed_a_customer_may_program_to_correspond_with_s_1_5_15 (*(volatile uint16_t*)0x00807C3AUL) /* THE MINIMUM SPEED A CUSTOMER MAY PROGRAM TO COR... */
#define speed_lookup_parameter_value (*(volatile uint16_t*)0x00807C3CUL) /* Speed-based parameter lookup input value (3 refs) */
#define CRACSWAC (*(volatile uint16_t*)0x00807C3EUL) /* RATE OF INCREMENT IN CRUISE CONTROL REFERENCE I... */
#define CRCNDTRF (*(volatile uint16_t*)0x00807C40UL) /* ADJUSTMENT IN CRUISE REFERENCE THAT IS TO BE MA... */
#define CRCNICRF (*(volatile uint16_t*)0x00807C42UL) /* ADJUSTMENT IN CRUISE REFERENCE THAT IS TO BE MA... */
#define CRCOSWAC (*(volatile uint16_t*)0x00807C44UL) /* RATE IN DECREMENT IN CRUISE CONTROL REFERENCE I... */
#define time_limit_for_finishing_gear_change_0_0_20_0 (*(volatile uint16_t*)0x00807C4EUL) /* TIME LIMIT FOR FINISHING GEAR CHANGE */
#define of_samples_of_gear_ratios_for_after_resume_test_0_8 (*(volatile uint16_t*)0x00807C52UL) /* # OF SAMPLES OF GEAR RATIOS FOR AFTER-RESUME TEST */
#define of_samples_of_gear_ratios_for_in_gear_calculation_0_8 (*(volatile uint16_t*)0x00807C54UL) /* # OF SAMPLES OF GEAR RATIOS FOR IN-GEAR CALCULA... */
#define gear_ratio_difference_for_in_gear_calculation_0_0_32 (*(volatile uint16_t*)0x00807C56UL) /* GEAR RATIO DIFFERENCE FOR IN GEAR CALCULATION */
#define gear_ratio_difference_for_after_resume_test_0_0_32_0 (*(volatile uint16_t*)0x00807C58UL) /* GEAR RATIO DIFFERENCE FOR AFTER RESUME TEST */
#define rpm_limit_for_in_gear_calculations_0_4500 (*(volatile uint16_t*)0x00807C5AUL) /* RPM LIMIT FOR IN-GEAR CALCULATIONS */
#define delay_time_for_in_gear_calc_after_clutch_engagement_0_0_4_0 (*(volatile uint16_t*)0x00807C5CUL) /* DELAY TIME FOR IN-GEAR CALC. AFTER CLUTCH ENGAG... */
#define min_vehicle_overspeed_needed_in_cc_in_order_to_detect_a_throttl_0_10 (*(volatile uint16_t*)0x00807C5EUL) /* MIN VEHICLE OVERSPEED NEEDED IN CC IN ORDER TO ... */
#define CRBODPOF (*(volatile uint16_t*)0x00807C62UL) /* CRUISE/RSG BOTTOM DROOP OFFSET. */
#define CRDVGNCN (*(volatile uint16_t*)0x00807C6CUL) /* THE DERIVATIVE GAIN OF THE CRUISE / RSG CALIBRA... */
#define CRDPFLTC (*(volatile uint16_t*)0x00807C70UL) /* TIME CONSTANT OF FUELING FILTER USED IN CC/RSG ... */
#define reference_speed_used_when_calculating_cc_and_rsg_upper_droops_on_0_255 (*(volatile uint16_t*)0x00807C78UL) /* REFERENCE SPEED USED WHEN CALCULATING CC AND RS... */
#define high_limit_for_cruise_rsg_error_delta_0_255 (*(volatile uint16_t*)0x00807C7AUL) /* HIGH LIMIT FOR CRUISE_RSG_ERROR_DELTA [CalTerm:... */
#define low_limit_for_cruise_rsg_error_delta_255_0 (*(volatile uint16_t*)0x00807C7CUL) /* LOW LIMIT FOR CRUISE_RSG_ERROR_DELTA */
#define CRDVGNC2 (*(volatile uint16_t*)0x00807C80UL) /* DERIVATIVE GAIN FOR CRUISE/RSG DURING LARGE TRA... */
#define port_pin_test_result (*(volatile uint8_t*)0x00807C86UL) /* Port pin test sequence 2 result (portPinTestSeq... */
#define CRGNADYA (*(volatile uint16_t*)0x00807C98UL) /* Y-AXIS OF TABLE USED BY CC/RSG TO ADJUST ERROR ... */
#define CCRFRTPS (*(volatile uint16_t*)0x00807CA6UL) /* POSITIVE SLEW RATE LIMIT ON CRUISE CONTROL REFE... */
#define CCRFRTNG (*(volatile uint16_t*)0x00807CA8UL) /* NEGATIVE SLEW RATE LIMIT ON CRUISE CONTROL REFE... */
#define CRDPMX (*(volatile uint16_t*)0x00807CAEUL) /* MAX LIMIT ON THE OUTPUT OFF THE DIFFERENTIAL PA... */
#define CRDPMN (*(volatile uint16_t*)0x00807CB0UL) /* MIN LIMIT ON THE OUTPUT OF THE DIFFERENTIAL PAT... */
#define CCMXFLLM (*(volatile uint16_t*)0x00807CB6UL) /* CC/RSG FUELING CLAMP MAX. */
#define CCMNFLLM (*(volatile uint16_t*)0x00807CB8UL) /* CC/RSG FUELING CLAMP MIN. */
#define CRGNSC (*(volatile uint16_t*)0x00807CBAUL) /* CRUISE CONTROL LOOP GAIN MULTIPLIER */
#define CRERGNUL (*(volatile uint16_t*)0x00807CC4UL) /* TOOL MAXIMUM ACCEPTABLE CRUISE_RSG_GAIN VALUE */
#define CRFLOFPZ (*(volatile uint16_t*)0x00807CC6UL) /* ADJUSTMENT TO RSG INTEGRATOR PRESET FUEL CALCUL... */
#define duty_cycle_monitor_config (*(volatile uint16_t*)0x00807CCAUL) /* Duty cycle monitor CAN initialization config (1... */
#define can1_timer_buffer_count (*(volatile uint8_t*)0x00807CCEUL) /* CAN1 timer buffer entry count - accessed via mo... */
#define can1_timer_buffer_reserved (*(volatile uint8_t*)0x00807CCFUL) /* CAN1 timer buffer reserved byte */
#define can1_timer_buffer_divisor (*(volatile uint8_t*)0x00807CD0UL) /* CAN1 timer buffer divisor config - accessed via... */
#define can1_timer_buffer_config_reserved (*(volatile uint8_t*)0x00807CD1UL) /* CAN1 timer buffer config reserved */
#define rpm_timer_interrupt_threshold_7cd2 (*(volatile uint16_t*)0x00807CD2UL) /* RPM timer interrupt threshold value (8 refs) */
#define can1_timer_callback_state (*(volatile uint16_t*)0x00807CD6UL) /* CAN1 timer callback state variable (9 refs) */
#define can1_timer_buffer_config (*(volatile uint8_t*)0x00807CDAUL) /* CAN1 timer buffer configuration value (can1Time... */
#define rpm_fault_limit_calibration (*(volatile uint16_t*)0x00807CDCUL) /* RPM-based fault limit calibration value (7 refs) */
#define engine_fault_timer_init (*(volatile uint16_t*)0x00807CDEUL) /* Engine fault timer init value (2 refs) */
#define time_to_delay_before_setting_a_new_throttle_min_0_25500 (*(volatile uint16_t*)0x00807CE6UL) /* TIME TO DELAY BEFORE SETTING A NEW THROTTLE_MIN */
#define flag_to_delay_resetting_of_throttle_min_when_sampled_thrott_true_false (*(volatile uint16_t*)0x00807CECUL) /* FLAG TO DELAY RESETTING OF THROTTLE_MIN WHEN SA... */
#define mph_above_which_throttle_faults_can_be_logged_for_uncalibrated_0_255 (*(volatile uint16_t*)0x00807CF2UL) /* MPH ABOVE WHICH THROTTLE FAULTS CAN BE LOGGED F... */
#define time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 (*(volatile uint16_t*)0x00807CF6UL) /* TIME FAULT CONDITIONS MUST EXIST BEFORE LOGGING... */
#define enable_flag_that_indicates_presence_of_an_ambient_air_press_true_false (*(volatile uint16_t*)0x00807CF8UL) /* ENABLE FLAG THAT INDICATES PRESENCE OF AN AMBIE... */
#define min_diff_between_desired_cylinder_pressure_and_calculated_cy_0_200 (*(volatile uint16_t*)0x00807CFAUL) /* MIN. DIFF. BETWEEN DESIRED CYLINDER PRESSURE AN... */
#define intake_manifold_temperature_at_maximum_fueling_condition_50_293 (*(volatile uint16_t*)0x00807CFCUL) /* INTAKE MANIFOLD TEMPERATURE AT MAXIMUM FUELING ... */
#define intake_manifold_temperature_at_motoring_conditions_50_293 (*(volatile uint16_t*)0x00807CFEUL) /* INTAKE MANIFOLD TEMPERATURE AT MOTORING CONDITI... */
#define minimum_difference_expected_and_measured_intake_temperature_0_200 (*(volatile uint16_t*)0x00807D00UL) /* MINIMUM DIFFERENCE EXPECTED AND MEASURED INTAKE... */
#define maximum_allowed_timing_advance_for_this_algorithm_0_20 (*(volatile uint8_t*)0x00807D02UL) /* MAXIMUM ALLOWED TIMING ADVANCE FOR THIS ALGORIT... */
#define can1_message_transmit_config (*(volatile uint8_t*)0x00807D03UL) /* CAN1 message transmit configuration value (can1... */
#define maximum_allowed_engine_speed_for_timing_advance_in_this_algor_0_4500 (*(volatile uint16_t*)0x00807D04UL) /* MAXIMUM ALLOWED ENGINE SPEED FOR TIMING ADVANCE... */
#define maximum_allowable_engine_speed_for_this_algorithm_to_operate_0_4500 (*(volatile uint16_t*)0x00807D06UL) /* MAXIMUM ALLOWABLE ENGINE SPEED FOR THIS ALGORIT... */
#define minimum_value_of_alpha_required_to_calculate_cylinder_maintenanc_0_1 (*(volatile uint16_t*)0x00807D08UL) /* MINIMUM VALUE OF ALPHA REQUIRED TO CALCULATE CY... */
#define minimum_allowed_engine_speed_for_timing_advance_in_this_algor_0_4500 (*(volatile uint16_t*)0x00807D0AUL) /* MINIMUM ALLOWED ENGINE SPEED FOR TIMING ADVANCE... */
#define minimum_allowed_timing_retard_for_this_algorithm_20_0 (*(volatile uint16_t*)0x00807D0CUL) /* MINIMUM ALLOWED TIMING RETARD FOR THIS ALGORITH... */
#define minimum_allowable_engine_speed_for_this_algorithm_to_operate_0_4500 (*(volatile uint16_t*)0x00807D0EUL) /* MINIMUM ALLOWABLE ENGINE SPEED FOR THIS ALGORIT... */
#define minimum_allowable_fueling_for_this_algorithm_to_operate_0_100 (*(volatile uint16_t*)0x00807D10UL) /* MINIMUM ALLOWABLE FUELING FOR THIS ALGORITHM TO... */
#define indicates_that_boost_press_sensor_is_absolute_pressure_sens_true_false (*(volatile uint16_t*)0x00807D12UL) /* INDICATES THAT BOOST PRESS SENSOR IS ABSOLUTE P... */
#define fuel_rate_at_maximum_fueling_conditions_32000_450000 (*(volatile uint16_t*)0x00807D14UL) /* FUEL RATE AT MAXIMUM FUELING CONDITIONS [CalTer... */
#define CPBS01 (*(volatile uint16_t*)0x00807D16UL) /* CYLINDER PRESSURE BLANK SPOT 1 */
#define DCMNHIES (*(volatile uint16_t*)0x00807D18UL) /* Duty cycle monitor high RPM limit for load fact... */
#define DCMNLOES (*(volatile uint16_t*)0x00807D1AUL) /* Duty cycle monitor low RPM limit for load facto... */
#define duty_cycle_short_term_log_time_period_1_0_1000_0 (*(volatile uint16_t*)0x00807D1CUL) /* DUTY CYCLE SHORT TERM LOG TIME PERIOD */
#define rpm_timer_interrupt_threshold_7d20 (*(volatile uint8_t*)0x00807D20UL) /* RPM timer interrupt threshold value (rpmTimerIn... */
#define rpm_source_selector_init (*(volatile uint16_t*)0x00807D2CUL) /* RPM source selector init value (2 refs) */
#define throttle_frictional_load_upper_threshold (*(volatile uint16_t*)0x00807D2EUL) /* Upper throttle threshold for frictional load ca... */
#define throttle_frictional_load_lower_threshold (*(volatile uint16_t*)0x00807D30UL) /* Lower throttle threshold for frictional load ca... */
#define DCMNLDTB (*(volatile uint16_t*)0x00807D32UL) /* CalTerm DCMNLDTB: DUTY CYCLE MON Y-AXIS %LOAD V... */
#define intake_temp_frictional_load_threshold (*(volatile uint16_t*)0x00807D34UL) /* Intake manifold temp threshold for frictional l... */
#define rpm_fuel_limit_blend_offset (*(volatile uint16_t*)0x00807D36UL) /* RPM fuel limit timing blend offset (5 refs) */
#define frictional_load_fuel_init (*(volatile uint16_t*)0x00807D38UL) /* Frictional load fuel offset init (2 refs) */
#define rpm_fuel_limit_threshold_max (*(volatile uint16_t*)0x00807D3AUL) /* RPM fuel limit threshold maximum value (4 refs) */
#define frictional_load_state_init (*(volatile uint16_t*)0x00807D3CUL) /* Frictional load calculator state init (2 refs) */
#define rpm_fuel_limit_state_max (*(volatile uint16_t*)0x00807D3EUL) /* RPM fuel limit state maximum value (4 refs) */
#define frictional_load_torque_init (*(volatile uint16_t*)0x00807D40UL) /* Frictional load torque interpolator init (2 refs) */
#define jcomm_frict_load_at_600_rpm_point_used_to_calculate_frictional_0_100 (*(volatile uint16_t*)0x00807D42UL) /* JCOMM FRICT LOAD AT 600 RPM POINT USED TO CALCU... */
#define jcomm_frict_load_line_slope_slope_used_to_calculate_frictiona_0_1_05 (*(volatile uint16_t*)0x00807D44UL) /* JCOMM FRICT LOAD LINE SLOPE SLOPE USED TO CALCU... */
#define jcomm_peak_torque_tau_0_torque_rating_of_engine_associated_wi_0_5000 (*(volatile uint16_t*)0x00807D46UL) /* JCOMM PEAK TORQUE TAU 0 TORQUE RATING OF ENGINE... */
#define JCPKT0RP (*(volatile uint16_t*)0x00807D48UL) /* CalTerm JCPKT0RP: JCOMM PEAK TORQUE RPM TAU 0 E... */
#define jcomm_peak_torque_min_fueling_tau_0_frict_load_fuel_at_peak_to_0_100 (*(volatile uint16_t*)0x00807D4AUL) /* JCOMM PEAK TORQUE MIN FUELING TAU 0 FRICT LOAD ... */
#define jcomm_peak_fueling_tau_0_max_fueling_on_100_throttle_curve_fo_0_100 (*(volatile uint16_t*)0x00807D4CUL) /* JCOMM PEAK FUELING TAU 0 MAX FUELING ON 100% TH... */
#define shutdown_protection_step_2 (*(volatile uint16_t*)0x00807D4EUL) /* Shutdown protection increment step 2 (2 refs) */
#define shutdown_protection_step_1 (*(volatile uint16_t*)0x00807D50UL) /* Shutdown protection increment step 1 (2 refs) */
#define engine_running_timer_threshold (*(volatile uint16_t*)0x00807D52UL) /* Engine running mode timer threshold (2 refs) */
#define frictional_load_torque_table_value (*(volatile uint16_t*)0x00807D54UL) /* Frictional load torque table value (frictionalL... */
#define frictional_load_torque_in_fueling_at_breakpoint_3_engine_rpm_0_100_7d56 (*(volatile uint16_t*)0x00807D56UL) /* FRICTIONAL LOAD TORQUE (IN FUELING) AT BREAKPOI... */
#define frictional_load_torque_in_fueling_at_breakpoint_4_engine_rpm_0_100_7d58 (*(volatile uint16_t*)0x00807D58UL) /* FRICTIONAL LOAD TORQUE (IN FUELING) AT BREAKPOI... */
#define frictional_load_torque_in_fueling_at_breakpoint_5_engine_rpm_0_100_7d5a (*(volatile uint16_t*)0x00807D5AUL) /* FRICTIONAL LOAD TORQUE (IN FUELING) AT BREAKPOI... */
#define frictional_load_torque_in_fueling_at_rated_engine_rpm_0_100_7d5c (*(volatile uint16_t*)0x00807D5CUL) /* FRICTIONAL LOAD TORQUE (IN FUELING) AT RATED EN... */
#define user_inversion_bit_mask_for_the_user_datalogger_switc_invert_no_invert (*(volatile uint32_t*)0x00807D5EUL) /* USER INVERSION BIT MASK FOR THE USER_DATALOGGER... */
#define engine_rpm_overspeed_exit_threshold (*(volatile uint16_t*)0x00807D60UL) /* Engine RPM overspeed exit threshold */
#define engine_overspeed_counter_limit (*(volatile uint16_t*)0x00807D62UL) /* Engine overspeed counter timeout limit */
#define engine_rpm_idle_threshold (*(volatile uint16_t*)0x00807D64UL) /* Engine RPM idle detection threshold */
#define protection_state_config_table (*(volatile uint16_t*)0x00807D66UL) /* Protection state configuration table base - 0x2... */
#define default_initialization_value_for_switch_31_on_off (*(volatile uint32_t*)0x00807D6AUL) /* DEFAULT/INITIALIZATION VALUE FOR SWITCH 31 */
#define default_initialization_value_for_auxiliary_shutdown_switch_on_off (*(volatile uint32_t*)0x00807D6EUL) /* DEFAULT/INITIALIZATION VALUE FOR AUXILIARY SHUT... */
#define time_abuse_event_must_be_continuously_present_before_it_will_b_0_100_7d7e (*(volatile uint16_t*)0x00807D7EUL) /* TIME ABUSE EVENT MUST BE CONTINUOUSLY PRESENT B... */
#define time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000_7d80 (*(volatile uint32_t*)0x00807D80UL) /* TIME THAT MUST ELASP SINCE LAST EVENT TO CONSID... */
#define EDMNMXBW (*(volatile uint16_t*)0x00807D84UL) /* CalTerm EDMNMXBW: DETERMINES DIRECTION FOR SEVE... */
#define time_abuse_event_must_be_continuously_present_before_it_will_b_0_100_7d88 (*(volatile uint16_t*)0x00807D88UL) /* TIME ABUSE EVENT MUST BE CONTINUOUSLY PRESENT B... */
#define time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000_7d8a (*(volatile uint32_t*)0x00807D8AUL) /* TIME THAT MUST ELASP SINCE LAST EVENT TO CONSID... */
#define EDMNMXCV (*(volatile uint16_t*)0x00807D8EUL) /* CalTerm EDMNMXCV: DETERMINES DIRECTION FOR SEVE... */
#define dzg_threshold_level_2 (*(volatile uint16_t*)0x00807D90UL) /* DZG state machine threshold level 2 (3 refs) */
#define time_abuse_event_must_be_continuously_present_before_it_will_b_0_100_7d92 (*(volatile uint16_t*)0x00807D92UL) /* TIME ABUSE EVENT MUST BE CONTINUOUSLY PRESENT B... */
#define time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000_7d94 (*(volatile uint32_t*)0x00807D94UL) /* TIME THAT MUST ELASP SINCE LAST EVENT TO CONSID... */
#define EDMNMXCP (*(volatile uint16_t*)0x00807D98UL) /* CalTerm EDMNMXCP: DETERMINES DIRECTION FOR SEVE... */
#define time_abuse_event_must_be_continuously_present_before_it_will_b_0_100_7d9c (*(volatile uint16_t*)0x00807D9CUL) /* TIME ABUSE EVENT MUST BE CONTINUOUSLY PRESENT B... */
#define time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000_7d9e (*(volatile uint32_t*)0x00807D9EUL) /* TIME THAT MUST ELASP SINCE LAST EVENT TO CONSID... */
#define EDMNMXCQ (*(volatile uint16_t*)0x00807DA2UL) /* CalTerm EDMNMXCQ: DETERMINES DIRECTION FOR SEVE... */
#define time_abuse_event_must_be_continuously_present_before_it_will_b_0_100_7da6 (*(volatile uint16_t*)0x00807DA6UL) /* TIME ABUSE EVENT MUST BE CONTINUOUSLY PRESENT B... */
#define time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000_7da8 (*(volatile uint32_t*)0x00807DA8UL) /* TIME THAT MUST ELASP SINCE LAST EVENT TO CONSID... */
#define EDMNMXOS (*(volatile uint16_t*)0x00807DACUL) /* CalTerm EDMNMXOS: DETERMINES DIRECTION FOR SEVE... */
#define time_abuse_event_must_be_continuously_present_before_it_will_0_100 (*(volatile uint16_t*)0x00807DB0UL) /* : TIME ABUSE EVENT MUST BE CONTINUOUSLY PRESENT... */
#define time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000_7db2 (*(volatile uint32_t*)0x00807DB2UL) /* TIME THAT MUST ELASP SINCE LAST EVENT TO CONSID... */
#define EDMNMXIM (*(volatile uint16_t*)0x00807DB6UL) /* CalTerm EDMNMXIM: DETERMINES DIRECTION FOR SEVE... */
#define time_abuse_event_must_be_continuously_present_before_it_will_b_0_100_7dba (*(volatile uint16_t*)0x00807DBAUL) /* TIME ABUSE EVENT MUST BE CONTINUOUSLY PRESENT B... */
#define time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000_7dbc (*(volatile uint32_t*)0x00807DBCUL) /* TIME THAT MUST ELASP SINCE LAST EVENT TO CONSID... */
#define EDMNMXO2 (*(volatile uint16_t*)0x00807DC0UL) /* CalTerm EDMNMXO2: DETERMINES DIRECTION FOR SEVE... */
#define time_abuse_event_must_be_continuously_present_before_it_will_b_0_100_7dc4 (*(volatile uint16_t*)0x00807DC4UL) /* TIME ABUSE EVENT MUST BE CONTINUOUSLY PRESENT B... */
#define time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000_7dc6 (*(volatile uint32_t*)0x00807DC6UL) /* TIME THAT MUST ELASP SINCE LAST EVENT TO CONSID... */
#define EDMNMXO3 (*(volatile uint16_t*)0x00807DCAUL) /* CalTerm EDMNMXO3: DETERMINES DIRECTION FOR SEVE... */
#define of_main_interrupts_cam_rev_used_for_total_revs_and_total_work_1_255 (*(volatile uint16_t*)0x00807DCEUL) /* # OF MAIN INTERRUPTS/CAM REV USED FOR TOTAL REV... */
#define of_backup_interrupts_cam_rev_used_for_total_revs_and_total_wor_1_255 (*(volatile uint16_t*)0x00807DD0UL) /* # OF BACKUP INTERRUPTS/CAM REV USED FOR TOTAL R... */
#define calibratible_threshold_for_rifle_oil_pressure_for_engine_warmu_0_100 (*(volatile uint16_t*)0x00807DD4UL) /* CALIBRATIBLE THRESHOLD FOR RIFLE OIL PRESSURE F... */
#define time_oil_pressure_must_continuously_be_above_oil_pressure_thres_0_60 (*(volatile uint16_t*)0x00807DD6UL) /* TIME OIL PRESSURE MUST CONTINUOUSLY BE ABOVE OI... */
#define maximum_time_engine_warmup_algorithm_will_run_0_100 (*(volatile uint16_t*)0x00807DD8UL) /* MAXIMUM TIME ENGINE WARMUP ALGORITHM WILL RUN */
#define max_time_algorithm_will_run_with_active_cool_or_oil_press_fa_0_100 (*(volatile uint16_t*)0x00807DDAUL) /* MAX TIME ALGORITHM WILL RUN WITH ACTIVE COOL. O... */
#define time_for_oil_to_drain_back_to_sump_with_engine_off_0_54 (*(volatile uint16_t*)0x00807DDCUL) /* TIME FOR OIL TO DRAIN BACK TO SUMP WITH ENGINE OFF */
#define delay_between_brakes_commanded_off_to_status_ebss_deactivati_0_1000 (*(volatile uint16_t*)0x00807DE2UL) /* DELAY BETWEEN BRAKES COMMANDED OFF TO STATUS(EB... */
#define delay_in_turning_engine_brakes_on_whenever_boost_sensor_fault_is_0_3 (*(volatile uint16_t*)0x00807DE4UL) /* DELAY IN TURNING ENGINE BRAKES ON WHENEVER BOOS... */
#define boost_pressure_above_which_engine_brakes_may_not_be_enabled_0_50 (*(volatile uint16_t*)0x00807DE6UL) /* BOOST PRESSURE ABOVE WHICH ENGINE BRAKES MAY NO... */
#define minimum_allowable_value_at_which_the_disable_rpm_may_be_set_825_1200 (*(volatile uint16_t*)0x00807DE8UL) /* MINIMUM ALLOWABLE VALUE AT WHICH THE DISABLE RP... */
#define maximum_allowable_value_at_which_the_disable_rpm_may_be_set_825_1200 (*(volatile uint16_t*)0x00807DEAUL) /* MAXIMUM ALLOWABLE VALUE AT WHICH THE DISABLE RP... */
#define EBCALBS1 (*(volatile uint16_t*)0x00807DECUL) /* CalTerm EBCALBS1: 0 = DO NOT DELAY ON E-BRAKE T... */
#define EBAEDYRP (*(volatile uint16_t*)0x00807DEEUL) /* CalTerm EBAEDYRP: RPM ABOVE THIS LIMIT = DELAY ... */
#define eb_calibration_blank_spot_2_none (*(volatile uint16_t*)0x00807DF4UL) /* EB CALIBRATION BLANK SPOT 2 */
#define EBDRBTB1 (*(volatile uint16_t*)0x00807E0AUL) /* CalTerm EBDRBTB1: BITMAPPED EB DRIVER TABLE TO ... */
#define EBDRBTB2 (*(volatile uint16_t*)0x00807E1AUL) /* CalTerm EBDRBTB2: BITMAPPED EB DRIVER TABLE TO ... */
#define EBDRBTB3 (*(volatile uint16_t*)0x00807E2AUL) /* CalTerm EBDRBTB3: BITMAPPED EB DRIVER TABLE TO ... */
#define EBDRBTB4 (*(volatile uint16_t*)0x00807E3AUL) /* CalTerm EBDRBTB4: BITMAPPED EB DRIVER TABLE TO ... */
#define EBDRBTB5 (*(volatile uint16_t*)0x00807E4AUL) /* CalTerm EBDRBTB5: BITMAPPED EB DRIVER TABLE TO ... */
#define EBDRBTB6 (*(volatile uint16_t*)0x00807E5AUL) /* CalTerm EBDRBTB6: BITMAPPED EB DRIVER TABLE TO ... */
#define protection_state2_config (*(volatile uint16_t*)0x00807E66UL) /* Protection state 2 threshold configuration (10 ... */
#define protection_state2_threshold_value (*(volatile uint16_t*)0x00807E68UL) /* Protection state 2 threshold calculator value (... */
#define diagnostic_protection_threshold (*(volatile uint16_t*)0x00807E70UL) /* Diagnostic protection threshold (diagnosticProt... */
#define EBSWLVTB (*(volatile uint16_t*)0x00807E7AUL) /* CalTerm EBSWLVTB: TRANSLATES BRAKE SELECTION SW... */
#define main_consec_error_thresh_threshold_count_at_which_ess_is_lost_0_255 (*(volatile uint8_t*)0x00807E9AUL) /* MAIN_CONSEC_ERROR_THRESH:THRESHOLD COUNT AT WHI... */
#define backup_consec_error_thresh_threshold_count_at_which_eps_is_los_0_255 (*(volatile uint8_t*)0x00807E9BUL) /* BACKUP_CONSEC_ERROR_THRESH:THRESHOLD COUNT AT W... */
#define external_consec_error_thresh_threshold_count_at_which_external_0_255 (*(volatile uint8_t*)0x00807E9CUL) /* EXTERNAL_CONSEC_ERROR_THRESH:THRESHOLD COUNT AT... */
#define engine_position_offset_distance_between_tooth_0_and_tdc_1_100_100 (*(volatile uint32_t*)0x00807E9EUL) /* ENGINE_POSITION_OFFSET:DISTANCE BETWEEN TOOTH 0... */
#define base_number_of_speed_pulses_per_cam_1_254 (*(volatile uint8_t*)0x00807EA2UL) /* BASE NUMBER OF SPEED PULSES PER CAM */
#define software_padding_0_7ea3 (*(volatile uint8_t*)0x00807EA3UL) /* SOFTWARE PADDING. */
#define eps_backup_ratio_threshold_for_detection_of_missing_ext_0_1_9921875 (*(volatile uint16_t*)0x00807EA6UL) /* EPS_BACKUP_RATIO: THRESHOLD FOR DETECTION OF MI... */
#define time_constant_for_the_filter_used_on_the_2_n_pulse_average_0_1 (*(volatile uint16_t*)0x00807EA8UL) /* TIME CONSTANT FOR THE FILTER USED ON THE 2^N PU... */
#define maximum_pulse_period_timeout_max_reset_value_for_main_lost_co_0_140 (*(volatile uint16_t*)0x00807EAAUL) /* MAXIMUM_PULSE_PERIOD_TIMEOUT: MAX RESET VALUE F... */
#define engine_speed_constant_1_conversion_factor_from_tcnts_to_rpm_0_2_29 (*(volatile uint32_t*)0x00807EACUL) /* ENGINE_SPEED_CONSTANT_1: CONVERSION FACTOR FROM... */
#define engine_speed_constant_1_backup_conversion_factor_from_tcnts_0_2_29 (*(volatile uint32_t*)0x00807EB0UL) /* ENGINE_SPEED_CONSTANT_1_BACKUP: CONVERSION FACT... */
#define engine_speed_constant_2_conversion_factor_from_tcnts_to_rpm_0_2_29 (*(volatile uint32_t*)0x00807EB4UL) /* ENGINE_SPEED_CONSTANT_2: CONVERSION FACTOR FROM... */
#define initialization_pulse_period_initial_value_for_pulse_period_table_2_32 (*(volatile uint32_t*)0x00807EB8UL) /* INITIALIZATION_PULSE_PERIOD: INITIAL VALUE FOR ... */
#define initialization_pulse_period_backup_initial_value_for_pulse_perio_2_32 (*(volatile uint32_t*)0x00807EBCUL) /* INITIALIZATION_PULSE_PERIOD_BACKUP: INITIAL VAL... */
#define period_meas_per_cam_number_of_primary_speed_pulse_periods_mea_0_255 (*(volatile uint8_t*)0x00807EC0UL) /* PERIOD_MEAS_PER_CAM: NUMBER OF PRIMARY SPEED PU... */
#define period_meas_per_cam_backup_number_of_backup_speed_pulse_perio_0_255 (*(volatile uint8_t*)0x00807EC1UL) /* PERIOD_MEAS_PER_CAM_BACKUP: NUMBER OF BACKUP SP... */
#define period_meas_per_average_num_of_primary_speed_pulse_periods_mea_0_255 (*(volatile uint8_t*)0x00807EC2UL) /* PERIOD_MEAS_PER_AVERAGE:NUM OF PRIMARY SPEED PU... */
#define period_meas_per_average_backup_num_of_backup_speed_pulse_perio_0_255 (*(volatile uint8_t*)0x00807EC3UL) /* PERIOD_MEAS_PER_AVERAGE_BACKUP:NUM OF BACKUP SP... */
#define crank_deg_per_period_meas_crank_degrees_between_primary_speed_0_720 (*(volatile uint16_t*)0x00807EC4UL) /* CRANK_DEG_PER_PERIOD_MEAS: CRANK DEGREES BETWEE... */
#define crank_deg_per_period_meas_backup_crank_degrees_between_backup_0_720 (*(volatile uint16_t*)0x00807EC6UL) /* CRANK_DEG_PER_PERIOD_MEAS_BACKUP: CRANK DEGREES... */
#define teeth_per_cam_rev_backup_number_of_teeth_seen_by_backup_input_1_512 (*(volatile uint16_t*)0x00807ECAUL) /* TEETH_PER_CAM_REV_BACKUP:NUMBER OF TEETH SEEN B... */
#define software_padding_0_7ecd (*(volatile uint8_t*)0x00807ECDUL) /* SOFTWARE PADDING. */
#define maximum_pulse_period_timeout_backup_max_reset_value_for_back_0_10000 (*(volatile uint16_t*)0x00807ECEUL) /* MAXIMUM_PULSE_PERIOD_TIMEOUT_BACKUP:MAX RESET V... */
#define reset_value_for_external_input_timeout_counter_0_10000 (*(volatile uint16_t*)0x00807ED0UL) /* RESET VALUE FOR EXTERNAL INPUT TIMEOUT COUNTER */
#define permissible_difference_between_main_and_ext_speed_0_4500 (*(volatile uint16_t*)0x00807ED2UL) /* PERMISSIBLE DIFFERENCE BETWEEN MAIN AND EXT SPEED */
#define ESSXSNEN (*(volatile uint16_t*)0x00807ED4UL) /* CalTerm ESSXSNEN: ENGINE_SPEED_SENSOR_ENABLES: ... */
#define CSCKES (*(volatile uint16_t*)0x00807ED8UL) /* RPM above which engine is considered running (n... */
#define eps_error_detection_performed_when_rpm_this_value_0_4500 (*(volatile uint16_t*)0x00807EDAUL) /* EPS ERROR DETECTION PERFORMED WHEN RPM > THIS V... */
#define max_cam_sync_lost_duration_0_20 (*(volatile uint16_t*)0x00807EDCUL) /* MAX_CAM_SYNC_LOST_DURATION [CalTerm: CMLSMXEL] */
#define max_crank_sync_lost_duration_0_20 (*(volatile uint16_t*)0x00807EDEUL) /* MAX_CRANK_SYNC_LOST_DURATION */
#define max_eps_main_lost_duration_0_20 (*(volatile uint16_t*)0x00807EE0UL) /* MAX_EPS_MAIN_LOST_DURATION */
#define max_eps_backup_lost_duration_0_20 (*(volatile uint16_t*)0x00807EE2UL) /* MAX_EPS_BACKUP_LOST_DURATION [CalTerm: BKLSMXEL] */
#define max_eps_external_lost_duration_0_20 (*(volatile uint16_t*)0x00807EE4UL) /* MAX_EPS_EXTERNAL_LOST_DURATION */
#define max_cam_sync_backup_lost_duration_amount_of_time_cam_lost_back_1_20 (*(volatile uint16_t*)0x00807EE6UL) /* MAX_CAM_SYNC_BACKUP_LOST_DURATION: AMOUNT OF TI... */
#define max_crank_sync_backup_lost_duration_amount_of_time_crank_lost_1_20 (*(volatile uint16_t*)0x00807EE8UL) /* MAX_CRANK_SYNC_BACKUP_LOST_DURATION: AMOUNT OF ... */
#define engine_speed_at_which_the_algorithm_stops_commanding_fuel_0_1400 (*(volatile uint16_t*)0x00807EEAUL) /* ENGINE SPEED AT WHICH THE ALGORITHM STOPS COMMA... */
#define crank_high_coolant_temperature_50_to_293 (*(volatile uint16_t*)0x00807EECUL) /* CRANK HIGH COOLANT TEMPERATURE [CalTerm: CKHTCLTP] */
#define crank_low_coolant_temperature_50_to_293 (*(volatile uint16_t*)0x00807EEEUL) /* CRANK LOW COOLANT TEMPERATURE [CalTerm: CKCDCLTP] */
#define crank_high_intake_manifold_temperature_50_to_293 (*(volatile uint16_t*)0x00807EF0UL) /* CRANK HIGH INTAKE MANIFOLD TEMPERATURE [CalTerm... */
#define crank_low_intake_manifold_temperature_50_to_293 (*(volatile uint16_t*)0x00807EF2UL) /* CRANK LOW INTAKE MANIFOLD TEMPERATURE [CalTerm:... */
#define crank_high_coolant_temperature_fueling_0_100 (*(volatile uint16_t*)0x00807EF6UL) /* CRANK HIGH COOLANT TEMPERATURE FUELING [CalTerm... */
#define crank_low_coolant_temperature_fueling_0_100 (*(volatile uint16_t*)0x00807EF8UL) /* CRANK LOW COOLANT TEMPERATURE FUELING [CalTerm:... */
#define crank_high_coolant_temperature_rpm_0_1000 (*(volatile uint16_t*)0x00807EFAUL) /* CRANK HIGH COOLANT TEMPERATURE RPM [CalTerm: CK... */
#define crank_low_coolant_temperature_rpm_0_1000 (*(volatile uint16_t*)0x00807EFCUL) /* CRANK LOW COOLANT TEMPERATURE RPM [CalTerm: CKC... */
#define crank_high_intake_manifold_temperature_timing_0_120 (*(volatile uint16_t*)0x00807EFEUL) /* CRANK HIGH INTAKE MANIFOLD TEMPERATURE TIMING [... */
#define crank_low_intake_manifold_temperature_tvc_0_120 (*(volatile uint16_t*)0x00807F00UL) /* CRANK LOW INTAKE MANIFOLD TEMPERATURE TVC [CalT... */
#define crank_high_intake_manifold_temperature_rpm_0_1000 (*(volatile uint16_t*)0x00807F02UL) /* CRANK HIGH INTAKE MANIFOLD TEMPERATURE RPM [Cal... */
#define crank_low_intake_manifold_temperature_rpm_0_1000 (*(volatile uint16_t*)0x00807F04UL) /* CRANK LOW INTAKE MANIFOLD TEMPERATURE RPM [CalT... */
#define crank_initial_reentry_speed_0_1000 (*(volatile uint16_t*)0x00807F06UL) /* CRANK INITIAL REENTRY SPEED [CalTerm: CKIIREES] */
#define crank_reentry_speed_offset_1000_1000 (*(volatile uint16_t*)0x00807F08UL) /* CRANK REENTRY SPEED OFFSET [CalTerm: CKREESOF] */
#define crank_jumpstart_time_0_13107 (*(volatile uint16_t*)0x00807F0AUL) /* CRANK JUMPSTART TIME [CalTerm: CKCNJSTM] */
#define crank_jumpstart_tvo_ramp_rate_0_100 (*(volatile uint16_t*)0x00807F0CUL) /* CRANK JUMPSTART TVO RAMP RATE [CalTerm: CKJSFLRT] */
#define crank_jumpstart_rpm_ramp_rate_0_1000 (*(volatile uint16_t*)0x00807F0EUL) /* CRANK JUMPSTART RPM RAMP RATE [CalTerm: CKJSESRT] */
#define crank_exit_time_0_13107 (*(volatile uint16_t*)0x00807F10UL) /* CRANK EXIT TIME [CalTerm: CKCNEXTM] */
#define crank_exited_initial_fueling_offset_100_100 (*(volatile uint16_t*)0x00807F12UL) /* CRANK EXITED INITIAL FUELING OFFSET [CalTerm: C... */
#define crank_exited_initial_rpm_offset_1000_1000 (*(volatile uint16_t*)0x00807F14UL) /* CRANK EXITED INITIAL RPM OFFSET [CalTerm: CKEXE... */
#define crank_exit_fuel_ramp_rpm_0_1000 (*(volatile uint16_t*)0x00807F16UL) /* CRANK EXIT FUEL RAMP RPM [CalTerm: CKFLRMES] */
#define crank_exit_fuel_ramp_rate_0_100 (*(volatile uint16_t*)0x00807F18UL) /* CRANK EXIT FUEL RAMP RATE [CalTerm: CKEXFLRT] */
#define crank_exit_fuel_ramp_rate_maximum_0_100 (*(volatile uint16_t*)0x00807F1AUL) /* CRANK EXIT FUEL RAMP RATE MAXIMUM [CalTerm: CKF... */
#define intake_manifold_temp_threshold (*(volatile uint16_t*)0x00807F1CUL) /* Intake manifold temp comparison threshold (2 refs) */
#define throttle_position_raw_threshold (*(volatile uint16_t*)0x00807F1EUL) /* Throttle position raw comparison threshold (2 r... */
#define intake_temp_upper_threshold (*(volatile uint16_t*)0x00807F20UL) /* Intake temp upper comparison threshold (2 refs) */
#define engine_speed_for_transition_into_out_of_crank_reentr_state_0_300 (*(volatile uint16_t*)0x00807F22UL) /* ENGINE SPEED FOR TRANSITION INTO/OUT OF CRANK(R... */
#define software_padding_0_7f24 (*(volatile uint8_t*)0x00807F24UL) /* SOFTWARE PADDING. */
#define software_padding_0_7f25 (*(volatile uint8_t*)0x00807F25UL) /* SOFTWARE PADDING. */
#define determines_how_engine_position_is_sync_d_to_cam_0 (*(volatile uint16_t*)0x00807F26UL) /* DETERMINES HOW ENGINE POSITION IS SYNC'D TO CAM */
#define software_padding_0_255 (*(volatile uint8_t*)0x00807F28UL) /* SOFTWARE PADDING. */
#define dummy_placeholder_0_255 (*(volatile uint8_t*)0x00807F29UL) /* DUMMY PLACEHOLDER */
#define max_crank_sync_backup_error_count_crank_sync_backup_errors_b_0_255 (*(volatile uint16_t*)0x00807F2EUL) /* MAX_CRANK_SYNC_BACKUP_ERROR_COUNT:# CRANK SYNC ... */
#define max_cam_sync_backup_error_count_of_cam_sync_backup_errors_be_0_255 (*(volatile uint16_t*)0x00807F30UL) /* MAX_CAM_SYNC_BACKUP_ERROR_COUNT:# OF CAM SYNC B... */
#define time_to_reach_full_derate_during_engine_protection_fuelin_0_0039_256 (*(volatile uint16_t*)0x00807F32UL) /* TIME TO REACH FULL DERATE DURING ENGINE PROTECT... */
#define period_of_time_after_powerup_during_which_no_oil_pres_faults_0_255 (*(volatile uint16_t*)0x00807F34UL) /* PERIOD OF TIME AFTER POWERUP DURING WHICH NO OI... */
#define fills_hole_left_by_making_engine_protection_rpm_delta_a_globa_0_3000 (*(volatile uint16_t*)0x00807F36UL) /* FILLS HOLE LEFT BY MAKING ENGINE_PROTECTION_RPM... */
#define EPMXDQRP (*(volatile uint16_t*)0x00807F38UL) /* Maximum engine RPM when fully derated (severity... */
#define maximum_rpm_limit_filter_time_constant_0_1_0 (*(volatile uint16_t*)0x00807F3AUL) /* MAXIMUM RPM LIMIT FILTER TIME CONSTANT. */
#define max_number_of_shutdowns_before_restart_is_not_allowed_0_255 (*(volatile uint16_t*)0x00807F3CUL) /* MAX NUMBER OF SHUTDOWNS BEFORE RESTART IS NOT A... */
#define intercept_fueling_between_lsg_ref_and_the_epf_curve_0_100 (*(volatile uint16_t*)0x00807F3EUL) /* INTERCEPT FUELING BETWEEN LSG REF AND THE EPF C... */
#define intercept_fueling_between_hsg_brkpt_and_the_epf_curve_0_100 (*(volatile uint16_t*)0x00807F40UL) /* INTERCEPT FUELING BETWEEN HSG BRKPT AND THE EPF... */
#define pmm_num_of_teeth_correct_tooth_count_at_missing_tooth_0_255 (*(volatile uint8_t*)0x00807F4EUL) /* PMM_NUM_OF_TEETH:CORRECT TOOTH COUNT AT MISSING... */
#define pmm_ratio_tooth_spacing_at_which_missing_tooth_is_found_0_1_9921875 (*(volatile uint8_t*)0x00807F4FUL) /* PMM_RATIO:TOOTH SPACING AT WHICH MISSING TOOTH ... */
#define tooth_count_at_which_missing_tooth_not_detct_err_0_255 (*(volatile uint8_t*)0x00807F50UL) /* TOOTH COUNT AT WHICH MISSING TOOTH NOT DETCT ERR */
#define ess_pulse_count_reset_reset_val_at_missed_tooth_for_period_mea_0_255 (*(volatile uint8_t*)0x00807F51UL) /* ESS_PULSE_COUNT_RESET:RESET VAL AT MISSED TOOTH... */
#define eps_missing_teeth_width_of_missing_tooth_gap_in_teeth_1_2 (*(volatile uint16_t*)0x00807F52UL) /* EPS_MISSING_TEETH: WIDTH OF MISSING TOOTH GAP I... */
#define eps_positive_out_of_phase_threshold_flag_thres_for_dif_32768_32767 (*(volatile uint16_t*)0x00807F58UL) /* EPS_POSITIVE_OUT_OF_PHASE_THRESHOLD: FLAG THRES... */
#define eps_negative_out_of_phase_threshold_flag_thres_for_dif_32768_32767 (*(volatile uint16_t*)0x00807F5AUL) /* EPS_NEGATIVE_OUT_OF_PHASE_THRESHOLD: FLAG THRES... */
#define eps_out_of_phase_persistence_cnts_input_is_bad_before_a_flag_0_65535 (*(volatile uint16_t*)0x00807F5CUL) /* EPS_OUT_OF_PHASE_PERSISTENCE: CNTS INPUT IS BAD... */
#define obs_was_max_crank_sync_error_count_csercumx_0_200 (*(volatile uint16_t*)0x00807F5EUL) /* OBS. WAS MAX_CRANK_SYNC_ERROR_COUNT  (CSERCUMX) */
#define esdn_backward_compat_0_1 (*(volatile uint16_t*)0x00807F60UL) /* ESDN BACKWARD COMPAT. */
#define abs_main_rpm_minus_backup_rpm_must_be_less_than_or_equal_to_0_4500 (*(volatile uint16_t*)0x00807F62UL) /* ABS(MAIN_RPM MINUS BACKUP_RPM) MUST BE LESS THA... */
#define filter_constant_in_filtered_engine_decel_rate_calculation_0_1 (*(volatile uint16_t*)0x00807F66UL) /* FILTER CONSTANT IN FILTERED ENGINE DECEL. RATE ... */
#define threshold_for_engine_deceleration_rate_to_activate_decel_timer_0_100 (*(volatile uint16_t*)0x00807F6AUL) /* THRESHOLD FOR ENGINE DECELERATION RATE TO ACTIV... */
#define lower_limitation_of_coolant_temperature_to_inhibit_high_hp_50_to_293 (*(volatile uint16_t*)0x00807F70UL) /* LOWER LIMITATION OF COOLANT TEMPERATURE TO INHI... */
#define lower_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293 (*(volatile uint16_t*)0x00807F72UL) /* LOWER LIMITATION OF INTAKE MANIFOLD TEMPERATURE... */
#define higher_limitation_of_coolant_temperature_to_inhibit_high_hp_50_to_293 (*(volatile uint16_t*)0x00807F74UL) /* HIGHER LIMITATION OF COOLANT TEMPERATURE TO INH... */
#define higher_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293 (*(volatile uint16_t*)0x00807F76UL) /* HIGHER LIMITATION OF INTAKE MANIFOLD TEMPERATUR... */
#define a_tolerance_for_throttle_100_fueling_0_10 (*(volatile uint16_t*)0x00807F7AUL) /* A TOLERANCE FOR THROTTLE_100_FUELING */
#define the_duration_throttle_is_below_a_value_and_remain_at_a_high_hor_0_30 (*(volatile uint16_t*)0x00807F7CUL) /* THE DURATION THROTTLE IS BELOW A VALUE AND REMA... */
#define blank_spot_0_434_8_7f82 (*(volatile uint16_t*)0x00807F82UL) /* BLANK_SPOT */
#define blank_spot_0_434_8_7f84 (*(volatile uint16_t*)0x00807F84UL) /* BLANK_SPOT */
#define blank_spot_0_434_8_7f86 (*(volatile uint16_t*)0x00807F86UL) /* BLANK_SPOT */
#define blank_spot_0_434_8_7f88 (*(volatile uint16_t*)0x00807F88UL) /* BLANK_SPOT */
#define blank_spot_0_434_8_7f8a (*(volatile uint16_t*)0x00807F8AUL) /* BLANK_SPOT */
#define blank_spot_0_434_8_7f8c (*(volatile uint16_t*)0x00807F8CUL) /* BLANK_SPOT */
#define blank_spot_0_434_8_7f8e (*(volatile uint16_t*)0x00807F8EUL) /* BLANK_SPOT */
#define blank_spot_0_434_8_7f90 (*(volatile uint16_t*)0x00807F90UL) /* BLANK_SPOT */
#define blank_spot_0_434_8_7f92 (*(volatile uint16_t*)0x00807F92UL) /* BLANK_SPOT */
#define eps_count_at_wide_ci_expected_eps_tooth_count_at_wide_ci_fallin_0_24 (*(volatile uint16_t*)0x00807F94UL) /* EPS_COUNT_AT_WIDE_CI:EXPECTED EPS TOOTH COUNT A... */
#define eps_count_at_narrow_ci_expected_eps_tooth_count_at_narrow_erp_f_0_24 (*(volatile uint16_t*)0x00807F96UL) /* EPS_COUNT_AT_NARROW_CI:EXPECTED EPS TOOTH COUNT... */
#define wide_ci_count_expected_eps_teeth_during_wide_ci_pulse_0_24 (*(volatile uint16_t*)0x00807F98UL) /* WIDE_CI_COUNT:EXPECTED EPS TEETH DURING WIDE CI... */
#define narrow_ci_count_expected_eps_teeth_during_narrow_ci_pulse_0_24 (*(volatile uint16_t*)0x00807F9AUL) /* NARROW_CI_COUNT:EXPECTED EPS TEETH DURING NARRO... */
#define ci_lost_count_max_reset_value_for_ci_timeout_counter_0_100 (*(volatile uint16_t*)0x00807F9CUL) /* CI_LOST_COUNT_MAX:RESET VALUE FOR CI TIMEOUT CO... */
#define if_crank_tooth_count_error_count_this_then_set_error_0_255 (*(volatile uint8_t*)0x00807F9EUL) /* IF CRANK_TOOTH_COUNT_ERROR_COUNT >= THIS THEN S... */
#define if_ci_tooth_count_error_count_this_then_set_error_0_255 (*(volatile uint8_t*)0x00807F9FUL) /* IF CI_TOOTH_COUNT_ERROR_COUNT >= THIS THEN SET ... */
#define if_ci_signal_error_count_this_then_set_error_0_255 (*(volatile uint8_t*)0x00807FA0UL) /* IF CI_SIGNAL_ERROR_COUNT >= THIS THEN SET ERROR... */
#define threshold_at_which_cam_sensor_no_longer_used_0_65535 (*(volatile uint16_t*)0x00807FA2UL) /* THRESHOLD AT WHICH CAM SENSOR NO LONGER USED */
#define limit_on_cam_sync_error_count_0_65535 (*(volatile uint16_t*)0x00807FA4UL) /* LIMIT ON CAM SYNC ERROR COUNT */
#define threshold_at_which_crank_sensor_no_longer_used_0_65535 (*(volatile uint16_t*)0x00807FA6UL) /* THRESHOLD AT WHICH CRANK SENSOR NO LONGER USED */
#define limit_on_crank_sync_error_count_0_65535 (*(volatile uint16_t*)0x00807FA8UL) /* LIMIT ON CRANK SYNC ERROR COUNT */
#define eps_sync_count_threshold_to_determine_cam_phase_0_7 (*(volatile uint8_t*)0x00807FAAUL) /* EPS_SYNC_COUNT THRESHOLD TO DETERMINE CAM PHASE */
#define expected_number_of_ess_teeth_between_eps_addtnl_0_255 (*(volatile uint8_t*)0x00807FABUL) /* EXPECTED NUMBER OF ESS TEETH BETWEEN EPS ADDTNL */
#define default_how_often_samples_are_taken_for_ac_1_3000 (*(volatile uint16_t*)0x00807FD8UL) /* DEFAULT HOW OFTEN SAMPLES ARE TAKEN FOR AC */
#define how_often_samples_are_taken_for_ct_1_3000_7fe2 (*(volatile uint16_t*)0x00807FE2UL) /* HOW OFTEN SAMPLES ARE TAKEN FOR CT */
#define how_often_samples_are_taken_for_imt_1_3000_7fec (*(volatile uint16_t*)0x00807FECUL) /* HOW OFTEN SAMPLES ARE TAKEN FOR IMT */
#define debounce_count_for_fpc_faults_none (*(volatile uint16_t*)0x0080800CUL) /* DEBOUNCE COUNT FOR FPC FAULTS */
#define bitmap_indicating_when_a_feature_should_clamp_a_fueling_point_0_ffff (*(volatile uint16_t*)0x0080801AUL) /* BITMAP INDICATING WHEN A FEATURE SHOULD CLAMP A... */
#define bitmap_indicating_which_algorithms_wish_to_set_rpms_0_15 (*(volatile uint16_t*)0x0080801CUL) /* BITMAP INDICATING WHICH ALGORITHMS WISH TO SET ... */
#define conversion_offset_of_line_converting_cubic_millimeter_fuel_to_0_100 (*(volatile uint16_t*)0x0080801EUL) /* CONVERSION OFFSET OF LINE CONVERTING CUBIC MILL... */
#define constant_used_to_convert_fuel_delivery_rate_from_rpm_fuel_to_l_50_5000 (*(volatile uint16_t*)0x00808020UL) /* CONSTANT USED TO CONVERT FUEL DELIVERY RATE FRO... */
#define gear_ratio_which_is_initialized_upon_power_up_0_1_16_00 (*(volatile uint16_t*)0x0080802AUL) /* GEAR RATIO WHICH IS INITIALIZED UPON POWER-UP */
#define time_delay_forced_for_rsg_override_for_mismatch_of_veh_and_en_0_100 (*(volatile uint16_t*)0x0080802EUL) /* TIME DELAY FORCED FOR RSG OVERRIDE FOR MISMATCH... */
#define GROGVSMN (*(volatile uint16_t*)0x00808030UL) /* CalTerm GROGVSMN: VEHICLE SPEED ABOVE WHICH AN ... */
#define blank_spot_0_1 (*(volatile uint16_t*)0x00808034UL) /* BLANK SPOT */
#define hsg_maximum_filtered_engine_speed_error_0_1000 (*(volatile uint16_t*)0x00808040UL) /* HSG MAXIMUM FILTERED ENGINE SPEED ERROR */
#define hsg_minimum_filtered_engine_speed_error_1000_0 (*(volatile uint16_t*)0x00808042UL) /* HSG MINIMUM FILTERED ENGINE SPEED ERROR */
#define hsg_maximum_integrator_fuel_output_0_100 (*(volatile uint16_t*)0x00808044UL) /* HSG MAXIMUM INTEGRATOR FUEL OUTPUT */
#define hsg_minimum_integrator_fuel_output_0_69_44 (*(volatile uint16_t*)0x00808046UL) /* HSG MINIMUM INTEGRATOR FUEL OUTPUT */
#define hsg_integrator_reset_value_used_to_adjust_integrator_under_def_0_100_8048 (*(volatile uint16_t*)0x00808048UL) /* HSG INTEGRATOR RESET VALUE USED TO ADJUST INTEG... */
#define engine_speed_below_which_the_hsg_integrator_is_reset_1000_1000 (*(volatile uint16_t*)0x0080804AUL) /* ENGINE SPEED BELOW WHICH THE HSG INTEGRATOR IS ... */
#define engine_fueling_below_which_the_hsg_integrator_may_be_reset_0_100 (*(volatile uint16_t*)0x0080804CUL) /* ENGINE FUELING BELOW WHICH THE HSG INTEGRATOR M... */
#define hsg_integrator_preset_minimum_0_100 (*(volatile uint16_t*)0x0080804EUL) /* HSG INTEGRATOR PRESET MINIMUM */
#define hsg_integrator_preset_maximum_0_100 (*(volatile uint16_t*)0x00808050UL) /* HSG INTEGRATOR PRESET MAXIMUM */
#define hsg_fueling_clamp_max_0_100 (*(volatile uint16_t*)0x00808052UL) /* HSG FUELING CLAMP MAX */
#define hsg_fueling_clamp_min_0_100 (*(volatile uint16_t*)0x00808054UL) /* HSG FUELING CLAMP MIN */
#define HSPZGVEN (*(volatile uint16_t*)0x00808056UL) /* CalTerm HSPZGVEN: 1 = RUN GOVERNOR IMMEDIATELY ... */
#define flag_to_enable_disable_the_hsg_derivative_gain_adjustment_scheme_0_1 (*(volatile uint16_t*)0x00808058UL) /* FLAG TO ENABLE/DISABLE THE HSG DERIVATIVE GAIN ... */
#define flag_to_enable_disable_the_hsg_proportional_gain_adjustment_sche_0_1 (*(volatile uint16_t*)0x0080805AUL) /* FLAG TO ENABLE/DISABLE THE HSG PROPORTIONAL GAI... */
#define flag_to_enable_disable_the_hsg_integral_gain_adjustment_scheme_0_1 (*(volatile uint16_t*)0x0080805CUL) /* FLAG TO ENABLE/DISABLE THE HSG INTEGRAL GAIN AD... */
#define hsg_pid_derivative_fueling_contribution_upper_limit_260_260 (*(volatile uint16_t*)0x0080805EUL) /* HSG PID DERIVATIVE FUELING CONTRIBUTION UPPER L... */
#define hsg_pid_derivative_fueling_contribution_lower_limit_260_260 (*(volatile uint16_t*)0x00808060UL) /* HSG PID DERIVATIVE FUELING CONTRIBUTION LOWER L... */
#define hsg_pid_proportional_fueling_contribution_upper_limit_160_160 (*(volatile uint16_t*)0x00808062UL) /* HSG PID PROPORTIONAL FUELING CONTRIBUTION UPPER... */
#define hsg_pid_proportional_fueling_contribution_lower_limit_160_160 (*(volatile uint16_t*)0x00808064UL) /* HSG PID PROPORTIONAL FUELING CONTRIBUTION LOWER... */
#define hsg_integrator_reset_value_used_to_adjust_integrator_under_def_0_100_8066 (*(volatile uint16_t*)0x00808066UL) /* HSG INTEGRATOR RESET VALUE USED TO ADJUST INTEG... */
#define HSDVCFXA ((volatile uint8_t*)0x00808084UL) /* [13] CalTerm HSDVCFXA: SPEED ERROR AXIS OF COEFFICIE... */
#define HSPPCFXA ((volatile uint8_t*)0x008080BCUL) /* [13] CalTerm HSPPCFXA: SPEED ERROR AXIS OF COEFFICIE... */
#define HSITCFXA ((volatile uint8_t*)0x008080F4UL) /* [13] CalTerm HSITCFXA: SPEED ERROR AXIS OF COEFFICIE... */
#define filter_coefficient_1_from_hsg_lead_lag_dynamic_compensator_0_1 (*(volatile uint16_t*)0x00808110UL) /* FILTER COEFFICIENT #1 FROM HSG LEAD/LAG DYNAMIC... */
#define filter_coefficient_2_from_hsg_lead_lag_dynamic_compensator_0_1 (*(volatile uint16_t*)0x00808112UL) /* FILTER COEFFICIENT #2 FROM HSG LEAD/LAG DYNAMIC... */
#define filter_coefficient_used_by_hsg_lead_lag_compensator_for_no_filteri_0_1 (*(volatile uint16_t*)0x00808114UL) /* FILTER COEFFICIENT USED BY HSG LEAD/LAG COMPENS... */
#define maximim_gear_ratio_value_for_permitting_hsg_lead_lag_comp_0_1_15_999 (*(volatile uint16_t*)0x00808116UL) /* MAXIMIM GEAR RATIO VALUE FOR PERMITTING HSG LEA... */
#define hsg_acceleration_rate_threshold_for_transient_conditions_0_2540 (*(volatile uint16_t*)0x00808118UL) /* HSG ACCELERATION RATE THRESHOLD FOR TRANSIENT C... */
#define hsg_acceleration_reference_time_for_transient_conditions_0_10 (*(volatile uint16_t*)0x0080811AUL) /* HSG ACCELERATION REFERENCE TIME FOR TRANSIENT C... */
#define hsg_speed_threshold_for_high_reference_speed_region_1400_5000 (*(volatile uint16_t*)0x0080811CUL) /* HSG SPEED THRESHOLD FOR HIGH REFERENCE SPEED RE... */
#define hsg_engine_speed_error_filter_time_constant_for_high_ref_speed_c_0_1 (*(volatile uint16_t*)0x00808120UL) /* HSG ENGINE SPEED ERROR FILTER TIME CONSTANT FOR... */
#define hsg_speed_threshold_for_low_reference_speed_region_1400_5000 (*(volatile uint16_t*)0x00808126UL) /* HSG SPEED THRESHOLD FOR LOW REFERENCE SPEED REGION */
#define hsg_engine_speed_error_filter_time_constant_for_low_ref_speed_co_0_1 (*(volatile uint16_t*)0x0080812AUL) /* HSG ENGINE SPEED ERROR FILTER TIME CONSTANT FOR... */
#define hsg_engine_speed_error_filter_time_constant_for_transient_condit_0_1 (*(volatile uint16_t*)0x00808132UL) /* HSG ENGINE SPEED ERROR FILTER TIME CONSTANT FOR... */
#define incremental_step_in_hsg_reference_used_when_reference_is_incre_0_300 (*(volatile uint16_t*)0x00808138UL) /* INCREMENTAL STEP IN HSG REFERENCE USED WHEN REF... */
#define blank_spot_in_hsg_calibration_0_0_1_0_813a (*(volatile uint16_t*)0x0080813AUL) /* BLANK SPOT IN HSG CALIBRATION */
#define blank_spot_in_hsg_calibration_0_0_1_0_813c (*(volatile uint16_t*)0x0080813CUL) /* BLANK SPOT IN HSG CALIBRATION */
#define maximum_allowable_fuel_that_may_be_used_to_determine_hsg_droop_0_100 (*(volatile uint16_t*)0x0080813EUL) /* MAXIMUM ALLOWABLE FUEL THAT MAY BE USED TO DETE... */
#define minimum_allowable_fuel_that_may_be_used_to_determine_hsg_droop_0_100 (*(volatile uint16_t*)0x00808140UL) /* MINIMUM ALLOWABLE FUEL THAT MAY BE USED TO DETE... */
#define blank_spot_0_20_255 (*(volatile uint16_t*)0x0080814AUL) /* BLANK SPOT 0 */
#define blank_spot_1_true_false (*(volatile uint16_t*)0x0080814EUL) /* BLANK SPOT 1 */
#define calibrated_engine_speed_limit_used_when_there_is_an_inj_f_1400_2100 (*(volatile uint16_t*)0x00808152UL) /* CALIBRATED ENGINE SPEED LIMIT USED WHEN THERE I... */
#define time_that_elapses_after_injector_fault_detection_before_speed_d_0_30 (*(volatile uint16_t*)0x00808154UL) /* TIME THAT ELAPSES AFTER INJECTOR FAULT DETECTIO... */
#define ramp_rate_from_initial_derate_to_full_engine_speed_derate_on_i_0_100 (*(volatile uint16_t*)0x00808156UL) /* RAMP RATE FROM INITIAL DERATE TO FULL ENGINE SP... */
#define global_default_for_engine_brake_0_100 (*(volatile uint16_t*)0x0080815AUL) /* GLOBAL DEFAULT FOR ENGINE BRAKE */
#define global_default_for_manual_fan_level_requested_fan_speed_0_100 (*(volatile uint16_t*)0x0080815CUL) /* GLOBAL DEFAULT FOR MANUAL FAN LEVEL (REQUESTED ... */
#define jcomm_peak_fueling_ref_fuel_for_all_indicated_percent_peak_tor_0_100 (*(volatile uint16_t*)0x0080815EUL) /* JCOMM PEAK FUELING REF FUEL FOR ALL INDICATED P... */
#define jcomm_reference_engine_torque_reference_engine_torque_that_c_0_64255 (*(volatile uint16_t*)0x00808160UL) /* JCOMM REFERENCE ENGINE TORQUE REFERENCE ENGINE ... */
#define JC39P3RP (*(volatile uint16_t*)0x00808162UL) /* J1939 engine speed point 3 RPM in engine config... */
#define JC39P4RP (*(volatile uint16_t*)0x00808164UL) /* J1939 engine speed point 4 RPM in engine config... */
#define JC39P5RP (*(volatile uint16_t*)0x00808166UL) /* CalTerm JC39P5RP: JCOMM ENGINE SPEED AT PT 5 RP... */
#define jcomm_fueling_value_at_idle_in_engine_config_message_when_tor_0_100 (*(volatile uint16_t*)0x00808168UL) /* JCOMM FUELING VALUE AT IDLE IN ENGINE CONFIG. M... */
#define jcomm_fueling_value_at_pt_3_in_engine_config_message_when_to_0_100 (*(volatile uint16_t*)0x0080816AUL) /* JCOMM FUELING VALUE AT PT. 3 IN ENGINE CONFIG. ... */
#define jcomm_fueling_value_at_pt_4_in_engine_config_message_when_to_0_100 (*(volatile uint16_t*)0x0080816CUL) /* JCOMM FUELING VALUE AT PT. 4 IN ENGINE CONFIG. ... */
#define jcomm_fueling_value_at_pt_5_in_engine_config_message_when_to_0_100 (*(volatile uint16_t*)0x0080816EUL) /* JCOMM FUELING VALUE AT PT. 5 IN ENGINE CONFIG. ... */
#define jcomm_rpm_low_hp_pt_2_in_engine_config_when_torque_dera_0_8031_875 (*(volatile uint16_t*)0x00808170UL) /* JCOMM RPM LOW HP PT. 2 IN ENGINE CONFIG. WHEN T... */
#define jcomm_fueling_low_hp_value_at_pt_2_in_engine_config_when_tor_0_100 (*(volatile uint16_t*)0x00808172UL) /* JCOMM FUELING LOW HP VALUE AT PT. 2 IN ENGINE C... */
#define jcomm_rpm_hi_hp_pt_2_in_engine_config_when_torque_derat_0_8031_875 (*(volatile uint16_t*)0x00808176UL) /* JCOMM RPM HI HP PT. 2 IN ENGINE CONFIG. WHEN TO... */
#define jcomm_fueling_hi_hp_value_at_pt_2_in_engine_config_when_torq_0_100 (*(volatile uint16_t*)0x00808178UL) /* JCOMM FUELING HI HP VALUE AT PT. 2 IN ENGINE CO... */
#define difference_between_the_lsg_breakpoint_and_the_lsg_reference_s_0_5000 (*(volatile uint16_t*)0x0080817CUL) /* DIFFERENCE BETWEEN THE LSG BREAKPOINT AND THE L... */
#define JCEGDSRP (*(volatile uint16_t*)0x0080817EUL) /* CalTerm JCEGDSRP: JCOMM ENGINE'S DESIRED OPERAT... */
#define jcomm_operating_speed_asymmetry_adjustment_engine_s_preference_0_250 (*(volatile uint16_t*)0x00808180UL) /* JCOMM OPERATING SPEED ASYMMETRY ADJUSTMENT ENGI... */
#define jcomm_engine_overspeed_to_time_out_for_jcomm_high_idle_overri_0_1000 (*(volatile uint16_t*)0x00808182UL) /* JCOMM ENGINE OVERSPEED TO TIME OUT FOR JCOMM_HI... */
#define jcomm_engine_overspeed_tl_time_limit_for_jcomm_high_idle_ove_0_25000 (*(volatile uint16_t*)0x00808184UL) /* JCOMM ENGINE OVERSPEED TL TIME LIMIT FOR JCOMM_... */
#define jcomm_recovery_time_time_that_time_limited_node_must_be_silen_0_1000 (*(volatile uint16_t*)0x00808188UL) /* JCOMM RECOVERY TIME TIME THAT TIME LIMITED NODE... */
#define jcomm_driveline_disengaged_to_time_out_for_jcomm_out_of_gear_0_1000 (*(volatile uint16_t*)0x0080818AUL) /* JCOMM DRIVELINE DISENGAGED TO TIME OUT FOR JCOM... */
#define jcomm_throttle_kickdown_threshold_throt_position_above_which_k_0_100 (*(volatile uint16_t*)0x0080818EUL) /* JCOMM THROTTLE KICKDOWN THRESHOLD THROT POSITIO... */
#define j1922_clear_occurrence_time_time_from_last_j1922_control_befo_0_2_29 (*(volatile uint32_t*)0x00808190UL) /* J1922 CLEAR OCCURRENCE TIME TIME FROM LAST J192... */
#define maximum_fueling_value_that_does_not_inject_fuel_0_100 (*(volatile uint16_t*)0x00808194UL) /* MAXIMUM FUELING VALUE THAT DOES NOT INJECT FUEL... */
#define JCHSODES (*(volatile uint16_t*)0x008081FAUL) /* CalTerm JCHSODES: SPEED TO WHICH HSG REF SHOULD... */
#define number_of_timeouts_allowed_before_setting_j1xxx_link_not_fast_0_1000 (*(volatile uint16_t*)0x008081FCUL) /* NUMBER OF TIMEOUTS ALLOWED BEFORE SETTING J1XXX... */
#define total_number_of_engine_brake_output_drivers_at_the_ecm_0_255 (*(volatile uint16_t*)0x008081FEUL) /* TOTAL NUMBER OF ENGINE BRAKE OUTPUT DRIVERS AT ... */
#define indicates_of_cyl_brakes_driven_by_eb_driver_1_for_j1939_ret_ma_0_6 (*(volatile uint16_t*)0x00808200UL) /* INDICATES # OF CYL. BRAKES DRIVEN BY EB DRIVER ... */
#define indicates_of_cyl_brakes_driven_by_eb_driver_2_for_j1939_ret_ma_0_6 (*(volatile uint16_t*)0x00808202UL) /* INDICATES # OF CYL. BRAKES DRIVEN BY EB DRIVER ... */
#define indicates_of_cyl_brakes_driven_by_eb_driver_3_for_j1939_ret_ma_0_6 (*(volatile uint16_t*)0x00808204UL) /* INDICATES # OF CYL. BRAKES DRIVEN BY EB DRIVER ... */
#define indicates_of_cyl_brakes_driven_by_eb_driver_4_for_j1939_ret_ma_0_6 (*(volatile uint16_t*)0x00808206UL) /* INDICATES # OF CYL. BRAKES DRIVEN BY EB DRIVER ... */
#define indicates_of_cyl_brakes_driven_by_eb_driver_5_for_j1939_ret_ma_0_6 (*(volatile uint16_t*)0x00808208UL) /* INDICATES # OF CYL. BRAKES DRIVEN BY EB DRIVER ... */
#define indicates_of_cyl_brakes_driven_by_eb_driver_6_for_j1939_ret_ma_0_6 (*(volatile uint16_t*)0x0080820AUL) /* INDICATES # OF CYL. BRAKES DRIVEN BY EB DRIVER ... */
#define fault_flash_count_number_of_times_each_fault_code_is_flashed_1_255 (*(volatile uint8_t*)0x0080820DUL) /* FAULT_FLASH_COUNT:NUMBER OF TIMES EACH FAULT CO... */
#define delta_rpm_threshold_for_aggressive_gains_activation_deactivat_0_3000 (*(volatile uint16_t*)0x00808220UL) /* DELTA RPM THRESHOLD FOR AGGRESSIVE GAINS ACTIVA... */
#define maximum_absolute_error_that_should_occur_in_lslgtztm_to_switc_0_3000 (*(volatile uint16_t*)0x00808222UL) /* MAXIMUM ABSOLUTE ERROR THAT SHOULD OCCUR IN LSL... */
#define offset_above_lsrf_to_change_lschst_to_after_first_ce_from_dur_0_3000 (*(volatile uint16_t*)0x0080822CUL) /* OFFSET ABOVE LSRF TO CHANGE LSCHST TO AFTER_FIR... */
#define added_to_4d_fueling_at_lsg_adjusted_reference_speed_to_det_max_5_5 (*(volatile uint16_t*)0x00808236UL) /* ADDED TO 4D FUELING AT LSG_ADJUSTED_REFERENCE_S... */
#define lsg_fueling_clamp_min_0_100 (*(volatile uint16_t*)0x00808238UL) /* LSG FUELING CLAMP MIN */
#define added_to_4d_fueling_at_lsg_adj_ref_speed_to_determine_lsg_integ_5_5_823a (*(volatile uint16_t*)0x0080823AUL) /* ADDED TO 4D FUELING AT LSG ADJ REF SPEED TO DET... */
#define added_to_4d_fueling_at_lsg_adj_ref_speed_to_determine_lsg_integ_5_5_8246 (*(volatile uint16_t*)0x00808246UL) /* ADDED TO 4D FUELING AT LSG ADJ REF SPEED TO DET... */
#define offset_to_lsg_reference_speed_over_which_lsg_integrator_m_1000_1000 (*(volatile uint16_t*)0x0080824CUL) /* OFFSET TO LSG REFERENCE SPEED OVER WHICH LSG IN... */
#define engine_fueling_below_which_the_lsg_integrator_may_be_reset_0_72_46 (*(volatile uint16_t*)0x0080824EUL) /* ENGINE FUELING BELOW WHICH THE LSG INTEGRATOR M... */
#define blank_spot_after_removal_of_lsg_db_int_gain_0_0_100_0 (*(volatile uint16_t*)0x00808250UL) /* BLANK SPOT AFTER REMOVAL OF LSG_DB_INT_GAIN */
#define blank_spot_after_removal_of_lsg_db_prop_gain_0_0_100_0 (*(volatile uint16_t*)0x00808252UL) /* BLANK SPOT AFTER REMOVAL OF LSG_DB_PROP_GAIN */
#define the_upper_limit_clamp_for_possible_lsg_reference_speed_300_2000 (*(volatile uint16_t*)0x00808256UL) /* THE UPPER LIMIT CLAMP FOR POSSIBLE LSG REFERENC... */
#define digital_filter_time_constant_used_in_throttle_deadband_fix_0_1_0 (*(volatile uint16_t*)0x00808258UL) /* DIGITAL FILTER TIME CONSTANT USED IN THROTTLE D... */
#define lsg_derivative_filter_coefficient_1_to_1 (*(volatile uint16_t*)0x0080825CUL) /* LSG DERIVATIVE FILTER COEFFICIENT */
#define flag_to_enable_disable_the_lsg_derivative_gain_adjustment_scheme_0_1 (*(volatile uint16_t*)0x0080825EUL) /* FLAG TO ENABLE/DISABLE THE LSG DERIVATIVE GAIN ... */
#define flag_to_enable_disable_the_lsg_proportional_gain_adjustment_sche_0_1 (*(volatile uint16_t*)0x00808260UL) /* FLAG TO ENABLE/DISABLE THE LSG PROPORTIONAL GAI... */
#define flag_to_enable_disable_the_lsg_integral_gain_adjustment_scheme_0_1 (*(volatile uint16_t*)0x00808262UL) /* FLAG TO ENABLE/DISABLE THE LSG INTEGRAL GAIN AD... */
#define lsg_proportional_gain_2_calibration_2_to_2 (*(volatile uint16_t*)0x00808268UL) /* LSG PROPORTIONAL GAIN 2 CALIBRATION */
#define lsg_derivative_gain_2_calibration_0_043_to_0_043 (*(volatile uint16_t*)0x0080826AUL) /* LSG DERIVATIVE GAIN 2 CALIBRATION */
#define LSDVCFXA ((volatile uint8_t*)0x00808288UL) /* [13] CalTerm LSDVCFXA: SPEED ERROR AXIS OF COEFFICIE... */
#define LSPPCFXA ((volatile uint8_t*)0x008082C0UL) /* [13] CalTerm LSPPCFXA: SPEED ERROR AXIS OF COEFFICIE... */
#define LSITCFXA ((volatile uint8_t*)0x008082F8UL) /* [13] CalTerm LSITCFXA: SPEED ERROR AXIS OF COEFFICIE... */
#define breakpoint_between_mid_gear_and_default_gains_based_on_over_0_2_255 (*(volatile uint16_t*)0x0080831AUL) /* BREAKPOINT BETWEEN MID_GEAR AND DEFAULT GAINS.(... */
#define breakpoint_between_mid_gear_and_high_gear_gains_based_on_ov_0_2_255 (*(volatile uint16_t*)0x0080831CUL) /* BREAKPOINT BETWEEN MID_GEAR AND HIGH_GEAR GAINS... */
#define gear_gains_not_used_if_lsfter_this_value_0_3000 (*(volatile uint16_t*)0x0080831EUL) /* GEAR GAINS NOT USED IF LSFTER > THIS VALUE */
#define gear_gains_not_used_if_lsfter_this_value_1000_0 (*(volatile uint16_t*)0x00808320UL) /* GEAR GAINS NOT USED IF LSFTER < THIS VALUE */
#define time_gear_gain_conditions_must_exist_before_using_gear_gains_0_65535 (*(volatile uint16_t*)0x00808322UL) /* TIME GEAR GAIN CONDITIONS MUST EXIST BEFORE USI... */
#define low_speed_governor_proportional_gain_when_in_high_gears_0_0_4348 (*(volatile uint16_t*)0x00808326UL) /* LOW SPEED GOVERNOR PROPORTIONAL GAIN WHEN IN HI... */
#define low_speed_governor_integral_gain_when_in_high_gears_0_0_21739 (*(volatile uint16_t*)0x00808328UL) /* LOW SPEED GOVERNOR INTEGRAL GAIN WHEN IN HIGH G... */
#define low_speed_governor_derivative_gain_when_in_high_gea_0_002265_0_0159 (*(volatile uint16_t*)0x0080832AUL) /* LOW SPEED GOVERNOR DERIVATIVE GAIN WHEN IN HIGH... */
#define low_speed_governor_proportional_gain_used_when_in_middle_ge_0_0_4348 (*(volatile uint16_t*)0x0080832CUL) /* LOW SPEED GOVERNOR PROPORTIONAL GAIN USED WHEN ... */
#define low_speed_governor_integral_gain_when_in_middle_gears_for_0_0_21739 (*(volatile uint16_t*)0x0080832EUL) /* LOW SPEED GOVERNOR INTEGRAL GAIN WHEN IN MIDDLE... */
#define low_speed_governor_derivative_gain_when_in_middle_g_0_002265_0_0159 (*(volatile uint16_t*)0x00808330UL) /* LOW SPEED GOVERNOR DERIVATIVE GAIN WHEN IN MIDD... */
#define idle_increment_decrement_step_value_0_100 (*(volatile uint16_t*)0x00808332UL) /* IDLE INCREMENT/DECREMENT STEP VALUE */
#define lsg_p_gain_passed_from_fuel_system_specific_algorithm_0_0_4348_8334 (*(volatile uint16_t*)0x00808334UL) /* LSG P GAIN PASSED FROM FUEL SYSTEM SPECIFIC ALG... */
#define lsg_i_gain_passed_from_fuel_system_specific_algorithm_0_0_217_8336 (*(volatile uint16_t*)0x00808336UL) /* LSG I GAIN PASSED FROM FUEL SYSTEM SPECIFIC ALG... */
#define lsg_d_gain_passed_from_fuel_system_specific_algorithm_0_0_0144_8338 (*(volatile uint16_t*)0x00808338UL) /* LSG D GAIN PASSED FROM FUEL SYSTEM SPECIFIC ALG... */
#define cold_idle_coolant_temperature_50_to_293 (*(volatile uint16_t*)0x0080833AUL) /* COLD IDLE COOLANT TEMPERATURE */
#define cold_idle_speed_300_1000 (*(volatile uint16_t*)0x0080833CUL) /* COLD IDLE SPEED */
#define cold_idle_time_0_65535 (*(volatile uint16_t*)0x0080833EUL) /* COLD IDLE TIME */
#define lsg_idle_ramp_rate_0_1000 (*(volatile uint16_t*)0x00808340UL) /* LSG IDLE RAMP RATE */
#define this_is_the_time_allowed_for_the_ocm_manual_reset_5_25 (*(volatile uint16_t*)0x00808424UL) /* THIS IS THE TIME ALLOWED FOR THE OCM MANUAL RESET. */
#define OCMITHTB (*(volatile uint16_t*)0x00808426UL) /* CalTerm OCMITHTB: TABLE CONTAINING INITIAL MILE... */
#define OCSGTB (*(volatile uint16_t*)0x00808450UL) /* CalTerm OCSGTB: LOOK UP TABLE USED FOR DETRMINI... */
#define fuel_demand_offset_threshold (*(volatile uint16_t*)0x0080845AUL) /* Fuel demand comparison offset threshold (2 refs) */
#define fuel_demand_proportional_param (*(volatile uint16_t*)0x0080845CUL) /* Fuel demand proportional calculation param (fue... */
#define fuel_delivery_gain_factor_init (*(volatile uint16_t*)0x0080845EUL) /* Fuel delivery gain factor init value (fuelDeliv... */
#define fuel_delivery_rate_limit_gain_init (*(volatile uint16_t*)0x00808460UL) /* Fuel delivery rate limit gain init (fuelDeliver... */
#define fuel_delivery_offset_factor_init (*(volatile uint16_t*)0x00808462UL) /* Fuel delivery offset factor init (fuelDeliveryS... */
#define fuel_delivery_rpm_deviation_param (*(volatile uint16_t*)0x00808466UL) /* Fuel delivery RPM deviation param (fuel_deliver... */
#define engine_speed_above_which_the_overspeed_algorithm_disables_fue_0_4000 (*(volatile uint16_t*)0x00808470UL) /* ENGINE SPEED ABOVE WHICH THE OVERSPEED ALGORITH... */
#define number_of_engine_speed_targets_per_crankshaft_revolution_1_255 (*(volatile uint8_t*)0x00808472UL) /* NUMBER OF ENGINE SPEED TARGETS PER CRANKSHAFT R... */
#define consecutive_occurances_of_engine_overspeed_to_cause_a_shutdown_0_7 (*(volatile uint8_t*)0x00808473UL) /* CONSECUTIVE OCCURANCES OF ENGINE OVERSPEED TO C... */
#define ESASOSTY (*(volatile uint8_t*)0x00808474UL) /* CalTerm ESASOSTY: ACTION AFTER AN OVERSPEED SHU... */
#define padding_to_preserve_word_alignment_0_1 (*(volatile uint8_t*)0x00808475UL) /* PADDING TO PRESERVE WORD ALIGNMENT. */
#define final_fuel_command_min (*(volatile uint16_t*)0x00808476UL) /* Final fuel delivery lower clamp (2 refs) */
#define final_fuel_command_max (*(volatile uint16_t*)0x00808478UL) /* Final fuel delivery upper clamp (2 refs) */
#define intercept_of_rpm_vs_phase_lag_line_defining_time_offset_for_syn_0_16 (*(volatile uint16_t*)0x0080847AUL) /* INTERCEPT OF RPM VS PHASE LAG LINE DEFINING TIM... */
#define slope_of_rpm_vs_phase_lag_line_defining_time_offset_for_s_0_0_031136 (*(volatile uint16_t*)0x0080847CUL) /* SLOPE OF RPM VS PHASE LAG LINE DEFINING TIME OF... */
#define fuel_rpm_deviation_calc_param (*(volatile uint16_t*)0x0080847EUL) /* Fuel RPM deviation calculation param (fuelRpmDe... */
#define number_of_consecutive_occurances_of_powerdown_data_lost_to_set_1_255 (*(volatile uint16_t*)0x00808480UL) /* NUMBER OF CONSECUTIVE OCCURANCES OF POWERDOWN D... */
#define enable_to_protects_parameter_block_data_at_powerdown_enabled_disabled (*(volatile uint16_t*)0x00808482UL) /* ENABLE TO PROTECTS PARAMETER BLOCK DATA AT POWE... */
#define flag_indicating_if_engine_should_be_ran_if_all_powerdown_da_true_false (*(volatile uint16_t*)0x00808484UL) /* FLAG INDICATING IF ENGINE SHOULD BE RAN IF ALL_... */
#define load_descriminator_to_determine_lugback_0_100_8486 (*(volatile uint16_t*)0x00808486UL) /* LOAD DESCRIMINATOR TO DETERMINE LUGBACK */
#define load_descriminator_to_determine_lugback_0_100_8488 (*(volatile uint16_t*)0x00808488UL) /* LOAD DESCRIMINATOR TO DETERMINE LUGBACK */
#define arbitrated_fuel_limit_min (*(volatile uint16_t*)0x0080848AUL) /* Arbitrated fuel lower limit (2 refs) */
#define allowed_rate_of_torque_limit_change_0_2000 (*(volatile uint16_t*)0x0080848CUL) /* ALLOWED RATE OF TORQUE LIMIT CHANGE */
#define the_can_1_cpu_interface_register_0_255 (*(volatile uint16_t*)0x00808490UL) /* THE CAN 1 CPU INTERFACE REGISTER */
#define the_can_1_bus_configuration_register_0_255 (*(volatile uint16_t*)0x00808492UL) /* THE CAN 1 BUS CONFIGURATION REGISTER */
#define the_can_1_bit_timing_0_register_0_255 (*(volatile uint16_t*)0x00808494UL) /* THE CAN 1 BIT TIMING 0 REGISTER */
#define the_can_1_bit_timing_1_register_0_255 (*(volatile uint16_t*)0x00808496UL) /* THE CAN 1 BIT TIMING 1 REGISTER */
#define the_can_1_extended_mask_0x0_0xffffffff (*(volatile uint32_t*)0x00808498UL) /* THE CAN 1 EXTENDED MASK */
#define the_can_1_standard_mask_0_65535 (*(volatile uint16_t*)0x0080849CUL) /* THE CAN 1 STANDARD MASK */
#define mask_used_for_can_msg_object_15_0_ffffffff_849e (*(volatile uint16_t*)0x0080849EUL) /* MASK USED FOR CAN MSG OBJECT 15. - accessed via... */
#define can_message_filter_init_value (*(volatile uint16_t*)0x008084A0UL) /* CAN message filter init value (canMessageFilter... */
#define the_can_cpu_interface_register_0_255 (*(volatile uint16_t*)0x008084A2UL) /* THE CAN CPU INTERFACE REGISTER */
#define the_can_bus_configuration_register_0_255 (*(volatile uint16_t*)0x008084A4UL) /* THE CAN BUS CONFIGURATION REGISTER */
#define the_can_bit_timing_0_register_0_255 (*(volatile uint16_t*)0x008084A6UL) /* THE CAN BIT TIMING 0 REGISTER */
#define the_can_bit_timing_1_register_0_255 (*(volatile uint16_t*)0x008084A8UL) /* THE CAN BIT TIMING 1 REGISTER */
#define the_can_extended_mask_0x0_0xffffffff (*(volatile uint32_t*)0x008084AAUL) /* THE CAN EXTENDED MASK */
#define can_global_mask_0_65535 (*(volatile uint16_t*)0x008084AEUL) /* CAN GLOBAL MASK */
#define mask_used_for_can_msg_object_15_0_ffffffff_84b0 (*(volatile uint32_t*)0x008084B0UL) /* MASK USED FOR CAN MSG OBJECT 15. */
#define can_number_of_engine_destination_specific_rx_objects_0_14 (*(volatile uint16_t*)0x008084B4UL) /* CAN NUMBER OF ENGINE DESTINATION-SPECIFIC RX OB... */
#define can_number_of_engine_destination_non_specific_rx_objects_0_14 (*(volatile uint16_t*)0x008084B6UL) /* CAN NUMBER OF ENGINE DESTINATION NON-SPECIFIC R... */
#define can_number_of_retarder_destination_specific_rx_objects_0_14 (*(volatile uint16_t*)0x008084B8UL) /* CAN NUMBER OF RETARDER DESTINATION-SPECIFIC RX ... */
#define can_number_of_retarder_destination_non_specific_rx_objects_0_14 (*(volatile uint16_t*)0x008084BAUL) /* CAN NUMBER OF RETARDER DESTINATION NON-SPECIFIC... */
#define number_of_valid_can_chip_message_objects_0_14 (*(volatile uint16_t*)0x008084BCUL) /* NUMBER OF VALID CAN CHIP MESSAGE OBJECTS */
#define JCCNRXFT (*(volatile uint32_t*)0x008084BEUL) /* CalTerm JCCNRXFT: J1939 CAN RECEIVE MESSAGE FILTER */
#define dtc_conversion_mode_flag (*(volatile uint8_t*)0x008084C3UL) /* DTC conversion mode flag (buildCanMessage) */
#define dtc_timestamp_format_flag (*(volatile uint8_t*)0x008084C4UL) /* DTC timestamp format flag (buildCanMessage) */
#define dm5_active_code_count_byte (*(volatile uint8_t*)0x008084C7UL) /* DM5 active diagnostic code count byte (diagnost... */
#define dm5_pending_code_count_byte (*(volatile uint8_t*)0x008084C9UL) /* DM5 pending diagnostic code count byte (diagnos... */
#define diagnostic_status_flags_word (*(volatile uint16_t*)0x008084CAUL) /* Diagnostic status flags for response builder (6... */
#define the_ram_address_to_copy_from_when_reprogramming_the_boot_block_none (*(volatile uint32_t*)0x008084F8UL) /* THE RAM ADDRESS TO COPY FROM WHEN REPROGRAMMING... */
#define the_flash_address_to_copy_to_when_reprogramming_the_boot_block_none (*(volatile uint32_t*)0x008084FCUL) /* THE FLASH ADDRESS TO COPY TO WHEN REPROGRAMMING... */
#define the_length_of_the_block_to_copy_when_reprogramming_the_boot_block_none (*(volatile uint32_t*)0x00808500UL) /* THE LENGTH OF THE BLOCK TO COPY WHEN REPROGRAMM... */
#define this_key_must_be_set_to_bad1_before_boot_block_is_programmed_none (*(volatile uint16_t*)0x00808504UL) /* THIS KEY MUST BE SET TO BAD1 BEFORE BOOT BLOCK ... */
#define amount_added_to_hsg_governed_speed_to_equal_hsg_breakpoint_speed_0_50 (*(volatile uint16_t*)0x00808506UL) /* AMOUNT ADDED TO HSG_GOVERNED_SPEED TO EQUAL HSG... */
#define param_scale_factor (*(volatile uint16_t*)0x008086C2UL) /* Scaling reference */
#define fuel_arbitrator_output_value (*(volatile uint16_t*)0x008086C4UL) /* Fuel arbitrator output for message (2 refs) */
#define fuel_table_blend_param_1 (*(volatile uint16_t*)0x008086C6UL) /* Fuel table blend interpolation parameter 1 (4 r... */
#define fuel_table_blend_param_2 (*(volatile uint16_t*)0x008086C8UL) /* Fuel table blend interpolation parameter 2 (4 r... */
#define fuel_mode_base_offset (*(volatile uint16_t*)0x008086CAUL) /* Fuel mode selection base offset value (8 refs) */
#define fuel_mode_blend_table_1 (*(volatile uint16_t*)0x008086CCUL) /* Fuel mode blend table 1 selector (1 ref) */
#define fuel_mode_blend_table_2 (*(volatile uint16_t*)0x008086CEUL) /* Fuel mode blend table 2 selector (1 ref) */
#define fuel_mode_state_table_1 (*(volatile uint16_t*)0x008086D0UL) /* Fuel mode state table 1 value (7 refs) */
#define fuel_mode_state_table_2 (*(volatile uint16_t*)0x008086D2UL) /* Fuel mode state table 2 value (8 refs) */
#define fuel_mode_override_table_1 (*(volatile uint16_t*)0x008086D4UL) /* Fuel mode override table 1 value (1 ref) */
#define fuel_mode_override_table_2 (*(volatile uint16_t*)0x008086D6UL) /* Fuel mode override table 2 value (1 ref) */
#define fuel_mode_arbitrated_threshold_1 (*(volatile uint16_t*)0x008086D8UL) /* Fuel mode arbitrated threshold 1 (1 ref) */
#define fuel_mode_timing_override_1 (*(volatile uint16_t*)0x008086DAUL) /* Fuel mode timing override table 1 (1 ref) */
#define fuel_mode_timing_override_2 (*(volatile uint16_t*)0x008086DCUL) /* Fuel mode timing override table 2 (1 ref) */
#define fuel_mode_arbitrated_threshold_2 (*(volatile uint16_t*)0x008086DEUL) /* Fuel mode arbitrated threshold 2 (1 ref) */
#define param_limit_value (*(volatile uint16_t*)0x008086E0UL) /* Parameter limits */
#define param_config_byte (*(volatile uint8_t*)0x008086E3UL) /* Configuration flags */
#define fuel_arbitrator_message_param (*(volatile uint16_t*)0x008086E4UL) /* Fuel arbitrator message handler param (fuelArbi... */
#define fuel_arbitrator_status_init (*(volatile uint16_t*)0x008086E6UL) /* Fuel arbitrator status timer init (2 refs) */
#define fuel_arbitrator_increment (*(volatile uint16_t*)0x008086E8UL) /* Fuel arbitrator counter increment (2 refs) */
#define io_control_timeout_table_base (*(volatile uint16_t*)0x008086EAUL) /* IO control timeout table lookup base address (5... */
#define fuel_arbitrator_timeout_param (*(volatile uint16_t*)0x008086ECUL) /* Fuel arbitrator timeout param (fuelArbitratorMe... */
#define fuel_arbitrator_session_init (*(volatile uint16_t*)0x008086EEUL) /* Fuel arbitrator session counter init (2 refs) */
#define proprietary_load_threshold (*(volatile uint16_t*)0x008086F0UL) /* Threshold for proprietary load status - determi... */
#define j1939_timeout_clear_value (*(volatile uint16_t*)0x008086F2UL) /* J1939 timeout data clear value (j1939TimeoutDat... */
#define param_ref_base (*(volatile uint16_t*)0x008086F6UL) /* Parameter reference base (lookup table for para... */
#define diagnostic_session_validator_param (*(volatile uint16_t*)0x008086F8UL) /* Diagnostic session validator param (diagnosticS... */
#define io_control_index_limit (*(volatile uint16_t*)0x0080875EUL) /* I/O control index comparison limit (2 refs) */
#define lamp_blink_on_duration (*(volatile uint16_t*)0x00808760UL) /* Lamp blink on duration in ticks */
#define lamp_blink_off_duration (*(volatile uint16_t*)0x00808762UL) /* Lamp blink off duration in ticks */
#define io_control_mask_state_array (*(volatile uint16_t*)0x00808768UL) /* IO control mask state array start (ioControlMas... */
#define cam_sync_scaling_factor (*(volatile uint16_t*)0x0080878AUL) /* Cam sync diagnostic scaling factor (1 ref) */
#define cam_sync_upper_limit (*(volatile uint16_t*)0x0080878CUL) /* Cam sync backup signal upper limit (2 refs) */
#define cam_sync_increment_rate (*(volatile uint16_t*)0x0080878EUL) /* Cam sync edge time increment rate (1 ref) */
#define cam_sync_base_offset (*(volatile uint16_t*)0x00808790UL) /* Cam sync base offset value (2 refs) */
#define cam_sync_default_value (*(volatile uint16_t*)0x00808792UL) /* Cam sync default edge time stamp (1 ref) */
#define eps_diagnostic_mode_checker_param (*(volatile uint16_t*)0x00808794UL) /* EPS diagnostic mode checker param (epsDiagnosti... */
#define governor_pid_fuel_sum_previous (*(volatile uint16_t*)0x008087C0UL) /* Governor PID fuel sum previous value (governorF... */
#define eps_backup_duration_init (*(volatile uint16_t*)0x008087C2UL) /* EPS backup duration init value (2 refs) */
#define governor_pid_proportional_term_87c4 (*(volatile uint16_t*)0x008087C4UL) /* Governor PID proportional term (governorFuelPid... */
#define governor_pid_integral_max (*(volatile uint16_t*)0x008087C6UL) /* Governor PID integral upper limit (2 refs) */
#define governor_pid_integral_term (*(volatile uint16_t*)0x008087CAUL) /* Governor PID integral term (governorFuelPidCont... */
#define governor_pid_integral_limit_low (*(volatile uint16_t*)0x008087CCUL) /* Governor PID fuel controller integral limit low... */
#define governor_pid_integral_limit_high (*(volatile uint16_t*)0x008087CEUL) /* Governor PID fuel calculator integral limit hig... */
#define governor_pid_derivative_term_87d0 (*(volatile uint16_t*)0x008087D0UL) /* Governor PID derivative term (governorFuelPidCo... */
#define governor_pid_integral_min (*(volatile uint16_t*)0x008087D2UL) /* Governor PID integral minimum (2 refs) */
#define governor_pid_scale_factor (*(volatile uint16_t*)0x008087D4UL) /* Governor PID scale factor (governorFuelPidContr... */
#define governor_pid_error_term (*(volatile uint16_t*)0x008087D6UL) /* Governor PID error term (governorFuelPidControl... */
#define governor_pid_output_limit (*(volatile uint16_t*)0x008087D8UL) /* Governor PID output limit (governorFuelPidContr... */
#define governor_rpm_target_max (*(volatile uint16_t*)0x008087E0UL) /* Governor RPM target upper clamp (2 refs) */
#define governor_pid_max_clamp (*(volatile uint16_t*)0x008087E4UL) /* Governor PID maximum clamp value (governorFuelP... */
#define governor_pid_min_clamp (*(volatile uint16_t*)0x008087E8UL) /* Governor PID minimum clamp value (governorFuelP... */
#define eps_acceleration_timer_threshold (*(volatile uint16_t*)0x008087ECUL) /* EPS acceleration timer comparison threshold (4 ... */
#define rpm_offset_adjustment (*(volatile uint16_t*)0x008087EEUL) /* RPM offset for EPS calculation (2 refs) */
#define eps_accel_threshold_lower (*(volatile uint16_t*)0x008087F0UL) /* EPS acceleration threshold lower (epsAccelerati... */
#define eps_accel_threshold_upper (*(volatile uint16_t*)0x008087F2UL) /* EPS acceleration threshold upper (epsAccelerati... */
#define throttle_position_threshold (*(volatile uint16_t*)0x008087F4UL) /* Throttle position comparison threshold (2 refs) */
#define eps_duration_lower_limit (*(volatile uint16_t*)0x008087F6UL) /* EPS duration lower comparison (2 refs) */
#define eps_duration_upper_limit (*(volatile uint16_t*)0x008087F8UL) /* EPS duration upper comparison (2 refs) */
#define eps_accel_duration_counter (*(volatile uint16_t*)0x008087FAUL) /* EPS acceleration duration counter (epsAccelerat... */
#define eps_accel_mode_state (*(volatile uint16_t*)0x008087FCUL) /* EPS acceleration mode state (epsAccelerationMon... */
#define eps_control_mode_duration_value_8804 (*(volatile uint16_t*)0x00808804UL) /* EPS control mode duration calculation value (3 ... */
#define eps_control_mode_duration_value_8806 (*(volatile uint16_t*)0x00808806UL) /* EPS control mode duration value (epsControlMode... */
#define eps_control_mode_selector_state_8808 (*(volatile uint32_t*)0x00808808UL) /* EPS control mode selector state pointer (epsCon... */
#define eps_fuel_demand_upper (*(volatile uint16_t*)0x0080880AUL) /* EPS fuel demand upper comparison (2 refs) */
#define eps_fuel_demand_threshold (*(volatile uint16_t*)0x0080880CUL) /* EPS fuel demand flags threshold (2 refs) */
#define eps_diagnostic_lower_limit (*(volatile uint16_t*)0x0080880EUL) /* EPS diagnostic mode lower limit (epsDiagnosticM... */
#define eps_diagnostic_upper_limit (*(volatile uint16_t*)0x00808810UL) /* EPS diagnostic mode upper limit (epsDiagnosticM... */
#define eps_diagnostic_counter_limit (*(volatile uint16_t*)0x00808812UL) /* EPS diagnostic counter comparison (2 refs) */
#define eps_fuel_demand_delta (*(volatile uint16_t*)0x00808814UL) /* EPS fuel demand delta subtractor (2 refs) */
#define fuel_timing_offset_step (*(volatile uint16_t*)0x00808828UL) /* Fuel timing offset adjustment step (2 refs) */
#define fuel_timing_offset_max (*(volatile uint16_t*)0x0080882AUL) /* Fuel timing offset upper limit (2 refs) */
#define fuel_timing_offset_min (*(volatile uint16_t*)0x0080882CUL) /* Fuel timing offset lower limit (2 refs) */
#define engine_mode_timing_adjust_param_1 (*(volatile uint16_t*)0x0080882EUL) /* Engine mode timing adjuster param 1 (engineMode... */
#define engine_mode_timing_adjust_param_2 (*(volatile uint16_t*)0x00808830UL) /* Engine mode timing adjuster param 2 (engineMode... */
#define fuel_arbitrator_timer_threshold (*(volatile uint16_t*)0x00808832UL) /* Fuel arbitrator timer threshold (2 refs) */
#define engine_timing_decrement_step (*(volatile uint16_t*)0x00808834UL) /* Engine timing adjuster decrement step (2 refs) */
#define fuel_timing_offset_min_limit (*(volatile uint16_t*)0x00808836UL) /* Minimum fuel timing offset limit (4 refs) */
#define fuel_timing_offset_limit (*(volatile uint16_t*)0x00808838UL) /* Fuel timing offset value limit (2 refs) */
#define crank_debounce_threshold (*(volatile uint16_t*)0x0080888AUL) /* Crank debounce threshold value (4 refs) */
#define max_allowed_error_term_0_1000 (*(volatile uint16_t*)0x0080889CUL) /* MAX. ALLOWED ERROR TERM */
#define min_allowed_error_term_1000_0 (*(volatile uint16_t*)0x0080889EUL) /* MIN. ALLOWED ERROR TERM */
#define max_alloved_fueling_0_100 (*(volatile uint16_t*)0x008088A0UL) /* MAX. ALLOVED FUELING */
#define min_allowed_fueling_0_100 (*(volatile uint16_t*)0x008088A2UL) /* MIN. ALLOWED FUELING */
#define reference_speed_change_const_0_1 (*(volatile uint16_t*)0x008088ACUL) /* REFERENCE SPEED CHANGE CONST. */
#define pwm_output_frequency_divisor (*(volatile uint16_t*)0x008088B0UL) /* PWM output frequency divisor (pwmOutputInit) */
#define pwm_output_period_multiplier (*(volatile uint16_t*)0x008088B2UL) /* PWM output period multiplier (pwmOutputInit) */
#define pwm_output_channel_select (*(volatile uint8_t*)0x008088B3UL) /* PWM output channel select bits (pwmOutputInit) */
#define pwm_output_enable_flag (*(volatile uint8_t*)0x008088B4UL) /* PWM output enable flag (pwmOutputInit) */
#define redundant_sensor_compare_threshold (*(volatile uint16_t*)0x008088C0UL) /* Redundant sensor compare threshold (2 refs) */
#define can_controller_1_status_byte (*(volatile uint8_t*)0x008088C3UL) /* CAN controller 1 status byte (dualCanController... */
#define can_controller_1_filter_byte_1 (*(volatile uint8_t*)0x008088C5UL) /* CAN controller 1 filter byte 1 (dualCanControll... */
#define can_controller_1_filter_byte_2 (*(volatile uint8_t*)0x008088C7UL) /* CAN controller 1 filter byte 2 (dualCanControll... */
#define can_controller_1_filter_byte_3 (*(volatile uint8_t*)0x008088C9UL) /* CAN controller 1 filter byte 3 (dualCanControll... */
#define can_controller_1_baud_byte_0 (*(volatile uint8_t*)0x008088CAUL) /* CAN controller 1 baud rate byte 0 (dualCanContr... */
#define can_controller_1_baud_byte_1 (*(volatile uint8_t*)0x008088CBUL) /* CAN controller 1 baud rate byte 1 (dualCanContr... */
#define PTGNQDTB (*(volatile uint16_t*)0x008088CCUL) /* CalTerm PTGNQDTB: QUADRATIC DERIVATIVE GAIN ADJ... */
#define can_controller_1_timing_word (*(volatile uint16_t*)0x008088CEUL) /* CAN controller 1 timing config word (dualCanCon... */
#define can_controller_2_status_byte (*(volatile uint8_t*)0x008088D1UL) /* CAN controller 2 status byte (dualCanController... */
#define can_controller_2_filter_byte_1 (*(volatile uint8_t*)0x008088D3UL) /* CAN controller 2 filter byte 1 (dualCanControll... */
#define can_controller_2_filter_byte_2 (*(volatile uint8_t*)0x008088D5UL) /* CAN controller 2 filter byte 2 (dualCanControll... */
#define can_controller_2_filter_byte_3 (*(volatile uint8_t*)0x008088D7UL) /* CAN controller 2 filter byte 3 (dualCanControll... */
#define can_controller_2_baud_byte_0 (*(volatile uint8_t*)0x008088D8UL) /* CAN controller 2 baud rate byte 0 (dualCanContr... */
#define can_controller_2_baud_byte_1 (*(volatile uint8_t*)0x008088D9UL) /* CAN controller 2 baud rate byte 1 (dualCanContr... */
#define can_controller_2_baud_byte_2 (*(volatile uint8_t*)0x008088DAUL) /* CAN controller 2 baud rate byte 2 (dualCanContr... */
#define can_controller_2_baud_byte_3 (*(volatile uint8_t*)0x008088DBUL) /* CAN controller 2 baud rate byte 3 (dualCanContr... */
#define can_controller_2_timing_word (*(volatile uint16_t*)0x008088DCUL) /* CAN controller 2 timing config word (dualCanCon... */
#define histogram_bin_count_3 (*(volatile uint8_t*)0x008088DEUL) /* Histogram bin 3 iteration count (2 refs) */
#define histogram_bin_count_0 (*(volatile uint8_t*)0x008088E0UL) /* Histogram bin 0 iteration count (2 refs) */
#define histogram_bin_count_1 (*(volatile uint8_t*)0x008088E2UL) /* Histogram bin 1 iteration count (2 refs) */
#define histogram_bin_count_2 (*(volatile uint8_t*)0x008088E4UL) /* Histogram bin 2 iteration count (2 refs) */
#define PTGNQITB (*(volatile uint16_t*)0x00808904UL) /* CalTerm PTGNQITB: QUADRATIC INTEGRAL GAIN ADJUS... */
#define flash_bootloader_param (*(volatile uint16_t*)0x00808912UL) /* Flash bootloader programmer param (flashBootloa... */
#define rpm_multiplier_0 (*(volatile uint16_t*)0x0080891CUL) /* RPM calculation multiplier 0 (2 refs) */
#define rpm_multiplier_1 (*(volatile uint16_t*)0x0080891EUL) /* RPM calculation multiplier 1 (2 refs) */
#define oil_pressure_protection_threshold (*(volatile uint16_t*)0x00808920UL) /* Advanced oil pressure protection system thresho... */
#define oil_pressure_rpm_limit_step (*(volatile uint16_t*)0x00808924UL) /* Oil pressure RPM limit step adjustment value (4... */
#define oil_pressure_rate_limit_step (*(volatile uint16_t*)0x00808926UL) /* Rate limiting step size for oil pressure transi... */
#define rpm_range_upper_limit (*(volatile uint16_t*)0x0080892AUL) /* RPM range upper limit for validation (2 refs) */
#define rpm_range_lower_limit (*(volatile uint16_t*)0x0080892CUL) /* RPM range lower limit for validation (2 refs) */
#define oil_pressure_validation_threshold (*(volatile uint16_t*)0x00808932UL) /* Oil pressure validation timer threshold (3 refs) */
#define pwm_output_scaling_factor (*(volatile uint16_t*)0x00808934UL) /* PWM output scaling factor */
#define pwm_output_2_scaling_factor (*(volatile uint16_t*)0x00808936UL) /* PWM output 2 scaling factor for fuel arbitratio... */
#define pwm_output_3_scaling_factor (*(volatile uint16_t*)0x00808938UL) /* PWM output 3 scaling factor for DZG timing (9 r... */
#define pwm_output_4_scaling_factor (*(volatile uint16_t*)0x0080893AUL) /* PWM output 4 scaling factor for DZG pressure (9... */
#define PTGNQPTB (*(volatile uint16_t*)0x0080893CUL) /* CalTerm PTGNQPTB: QUADRATIC PROPORTIONAL GAIN A... */
#define oil_pressure_fault_debounce_threshold (*(volatile uint16_t*)0x00808940UL) /* Oil pressure fault debounce threshold (2 refs) */
#define oil_pressure_rpm_fault_threshold (*(volatile uint16_t*)0x00808942UL) /* Oil pressure RPM fault detection threshold (2 r... */
#define water_in_fuel_fault_threshold (*(volatile uint16_t*)0x00808948UL) /* Water in fuel sensor fault detection threshold ... */
#define vp44_fuel_temperature_raw (*(volatile uint16_t*)0x0080894AUL) /* VP44 fuel temperature raw sensor value (3 refs) */
#define cached_parameter_upper_limit (*(volatile uint16_t*)0x0080894CUL) /* Cached parameter upper limit comparison (2 refs) */
#define vp44_sensor_value_3 (*(volatile uint16_t*)0x0080894EUL) /* VP44 sensor value 3 for CAN message (2 refs) */
#define vp44_sensor_value_4 (*(volatile uint16_t*)0x00808950UL) /* VP44 sensor value 4 for CAN message (2 refs) */
#define vp44_sensor_value_5 (*(volatile uint16_t*)0x00808952UL) /* VP44 sensor value 5 for CAN message (2 refs) */
#define vp44_sensor_value_1 (*(volatile uint16_t*)0x00808954UL) /* VP44 sensor value 1 for CAN message (2 refs) */
#define retarder_torque_point_2_value (*(volatile uint16_t*)0x00808956UL) /* Retarder torque point 2 value (retarderConfigDa... */
#define retarder_torque_point_3_value (*(volatile uint16_t*)0x00808958UL) /* Retarder torque point 3 value (retarderConfigDa... */
#define retarder_torque_point_4_value (*(volatile uint16_t*)0x0080895AUL) /* Retarder torque point 4 value (retarderConfigDa... */
#define retarder_torque_point_5_value (*(volatile uint16_t*)0x0080895CUL) /* Retarder torque point 5 value (retarderConfigDa... */
#define vp44_sensor_value_2 (*(volatile uint16_t*)0x0080895EUL) /* VP44 sensor value 2 for CAN message (2 refs) */
#define insite_parameter_table_start (*(volatile uint8_t*)0x00808962UL) /* INSITE parameter table start address (3 refs) */
#define max_engine_speed_for_pto_engagement_600_2500 (*(volatile uint16_t*)0x00808984UL) /* MAX ENGINE SPEED FOR PTO ENGAGEMENT */
#define min_engine_speed_for_pto_engagement_500_2500 (*(volatile uint16_t*)0x00808986UL) /* MIN ENGINE SPEED FOR PTO ENGAGEMENT */
#define patch_hole_0_255_8988 (*(volatile uint16_t*)0x00808988UL) /* PATCH HOLE */
#define patch_hole_0_255_898a (*(volatile uint16_t*)0x0080898AUL) /* PATCH HOLE */
#define amount_of_time_before_remote_pto_switch_is_considered_stationary_0_10 (*(volatile uint16_t*)0x0080898CUL) /* AMOUNT OF TIME BEFORE REMOTE PTO SWITCH IS CONS... */
#define number_of_errors_to_be_detected_on_pwm1_driver_before_pwm1_error_0_255 (*(volatile uint16_t*)0x0080898EUL) /* NUMBER OF ERRORS TO BE DETECTED ON PWM1 DRIVER ... */
#define number_of_errors_to_be_detected_on_pwm2_driver_before_pwm1_error_0_255 (*(volatile uint16_t*)0x00808990UL) /* NUMBER OF ERRORS TO BE DETECTED ON PWM2 DRIVER ... */
#define number_of_errors_to_be_detected_on_pwm3_driver_before_pwm1_error_0_255 (*(volatile uint16_t*)0x00808992UL) /* NUMBER OF ERRORS TO BE DETECTED ON PWM3 DRIVER ... */
#define number_of_errors_to_be_detected_on_pwm4_driver_before_pwm1_error_0_255 (*(volatile uint16_t*)0x00808994UL) /* NUMBER OF ERRORS TO BE DETECTED ON PWM4 DRIVER ... */
#define number_of_errors_to_be_detected_on_pwm5_driver_before_pwm1_error_0_255 (*(volatile uint16_t*)0x00808996UL) /* NUMBER OF ERRORS TO BE DETECTED ON PWM5 DRIVER ... */
#define blank_spot_for_pwm_a_period_0_7 (*(volatile uint16_t*)0x008089A2UL) /* BLANK SPOT FOR PWM_A_PERIOD */
#define priority_of_remote_throttle_feature_w_r_to_other_throttle_0_to_10 (*(volatile uint16_t*)0x008089A4UL) /* PRIORITY OF REMOTE THROTTLE FEATURE W/R TO OTHE... */
#define jcomm_reference_retarder_torque_reference_ret_torque_that_co_0_64255 (*(volatile uint16_t*)0x008089A6UL) /* JCOMM REFERENCE RETARDER TORQUE REFERENCE RET T... */
#define limit_to_which_user_fueling_is_compared_to_determine_if_engine_0_100 (*(volatile uint16_t*)0x008089A8UL) /* LIMIT TO WHICH USER FUELING IS COMPARED TO DETE... */
#define JCRDISRP (*(volatile uint16_t*)0x008089AAUL) /* CalTerm JCRDISRP: JCOMM RETARDER SPEED AT IDLE ... */
#define jcomm_retarder_torque_at_idle_available_torque_that_retarder_0_125 (*(volatile uint16_t*)0x008089B2UL) /* JCOMM RETARDER TORQUE AT IDLE   AVAILABLE TORQU... */
#define jcomm_retarder_torque_at_max_speed_available_torque_that_retar_0_125 (*(volatile uint16_t*)0x008089B4UL) /* JCOMM RETARDER TORQUE AT MAX SPEED AVAILABLE TO... */
#define jcomm_retarder_torque_at_pt_3_available_torque_that_retarder_0_125 (*(volatile uint16_t*)0x008089B6UL) /* JCOMM RETARDER TORQUE AT PT 3   AVAILABLE TORQU... */
#define jcomm_retarder_torque_at_pt_4_available_torque_that_retarder_0_125 (*(volatile uint16_t*)0x008089B8UL) /* JCOMM RETARDER TORQUE AT PT 4   AVAILABLE TORQU... */
#define JCMXEBRP (*(volatile uint16_t*)0x008089BAUL) /* CalTerm JCMXEBRP: JCOMM MAX RETARDER SPEED MAXI... */
#define maximum_time_between_tailshaft_pulses_allowed_before_vehicle_0_04_40 (*(volatile uint16_t*)0x008089BEUL) /* MAXIMUM TIME BETWEEN TAILSHAFT PULSES ALLOWED B... */
#define percent_gear_ratio_difference_used_to_detect_top_gear_and_gear_0_100 (*(volatile uint16_t*)0x008089C4UL) /* PERCENT GEAR RATIO DIFFERENCE USED TO DETECT TO... */
#define engine_load_discriminator_for_transient_and_steady_state_condi_0_100 (*(volatile uint16_t*)0x008089C6UL) /* ENGINE LOAD DISCRIMINATOR FOR TRANSIENT AND STE... */
#define the_rate_at_which_the_limit_speed_is_ramped_down_to_the_low_lim_0_10 (*(volatile uint16_t*)0x008089C8UL) /* THE RATE AT WHICH THE LIMIT SPEED IS RAMPED DOW... */
#define load_needed_to_transition_to_higher_limit_speed_when_load_is_0_100 (*(volatile uint16_t*)0x008089CCUL) /* %LOAD NEEDED TO TRANSITION TO HIGHER LIMIT SPEE... */
#define tool_low_lim_on_high_load_vehicle_speed_limits_non_top_ge_0_255_9961 (*(volatile uint16_t*)0x008089D2UL) /* TOOL LOW LIM ON HIGH LOAD VEHICLE SPEED LIMITS ... */
#define tool_upp_lim_on_next_gd_delta_values_0_255_9961 (*(volatile uint16_t*)0x008089D8UL) /* TOOL UPP LIM ON NEXT GD DELTA VALUES */
#define special_engine_monitor_broadcast_table_none (*(volatile uint16_t*)0x008089DAUL) /* SPECIAL ENGINE MONITOR BROADCAST TABLE [CalTerm... */
#define insite_live_data_offset (*(volatile uint16_t*)0x008089E0UL) /* INSITE live data handler offset (insiteLiveData... */
#define minimum_elapsed_time_before_brake_switch_is_valid_to_avoid_coun_0_10 (*(volatile uint32_t*)0x00808A42UL) /* MINIMUM ELAPSED TIME BEFORE BRAKE SWITCH IS VAL... */
#define minimum_elapsed_time_top_gear_must_be_true_before_top_gear_is_0_300 (*(volatile uint16_t*)0x00808A4AUL) /* MINIMUM ELAPSED TIME TOP GEAR MUST BE TRUE BEFO... */
#define minimum_time_gear_down_is_true_before_gear_down_is_declared_va_0_300 (*(volatile uint16_t*)0x00808A4CUL) /* MINIMUM TIME GEAR DOWN IS TRUE BEFORE GEAR DOWN... */
#define mask_used_by_a_tool_to_id_the_trip_faults_found_in_the_trip_in_0_03f (*(volatile uint16_t*)0x00808A4EUL) /* MASK USED BY A TOOL TO ID THE TRIP FAULTS FOUND... */
#define road_speed_below_which_esp_distance_does_not_accumulate_0_10 (*(volatile uint16_t*)0x00808A50UL) /* ROAD SPEED BELOW WHICH ESP DISTANCE DOES NOT AC... */
#define the_minimum_time_a_fault_must_be_present_before_logged_in_trip_in_0_30 (*(volatile uint16_t*)0x00808A54UL) /* THE MINIMUM TIME A FAULT MUST BE PRESENT BEFORE... */
#define fuel_statistics_mode_selector (*(volatile uint16_t*)0x00808A56UL) /* Fuel statistics mode selector (1 ref) */
#define if_the_engine_load_exceeds_this_threshold_the_engine_is_deemed_0_127_5 (*(volatile uint16_t*)0x00808A58UL) /* IF THE ENGINE LOAD EXCEEDS THIS THRESHOLD THE E... */
#define minimum_time_the_engine_must_idle_before_shutdown_if_high_loa_0_1800 (*(volatile uint16_t*)0x00808A5AUL) /* MINIMUM TIME THE ENGINE MUST IDLE BEFORE SHUTDO... */
#define rpm_histogram_non_idle_threshold_8a5c (*(volatile uint16_t*)0x00808A5CUL) /* RPM histogram non-idle time threshold (1 ref) */
#define minimum_time_the_engine_must_idle_before_shutdown_if_at_high_0_1800 (*(volatile uint16_t*)0x00808A60UL) /* MINIMUM TIME THE ENGINE MUST IDLE BEFORE SHUTDO... */
#define rpm_histogram_high_speed_threshold (*(volatile uint16_t*)0x00808A62UL) /* RPM histogram high speed threshold (1 ref) */
#define minimum_idle_time_if_the_engine_was_at_high_speed_to_avoid_ho_0_1800 (*(volatile uint16_t*)0x00808A64UL) /* MINIMUM IDLE TIME IF THE ENGINE WAS AT HIGH SPE... */
#define rpm_histogram_bin_size (*(volatile uint16_t*)0x00808A66UL) /* RPM histogram bin size divisor (2 refs) */
#define rpm_histogram_temp_threshold (*(volatile uint16_t*)0x00808A68UL) /* RPM histogram temperature threshold (1 ref) */
#define fuel_statistics_divisor (*(volatile uint16_t*)0x00808A6AUL) /* Fuel statistics proportional calc divisor (1 ref) */
#define calibratible_timing_increment_that_is_added_to_base_timing_any_0_120 (*(volatile uint16_t*)0x00808A6EUL) /* CALIBRATIBLE TIMING INCREMENT THAT IS ADDED TO ... */
#define diagnostic_fuel_arbitration_state_9_value (*(volatile uint16_t*)0x00808A70UL) /* Diagnostic fuel arbitration state 9 value (diag... */
#define fuel_demand_state_24_override_value (*(volatile uint16_t*)0x00808A72UL) /* Fuel demand state 24 override value (fuelDemand... */
#define fuel_limit_floor_value (*(volatile uint16_t*)0x00808A74UL) /* Fuel limit minimum clamp value (2 refs) */
#define diagnostic_fuel_arbitration_state_10_value (*(volatile uint16_t*)0x00808A76UL) /* Diagnostic fuel arbitration state 10 value (dia... */
#define pwm_timing_cycle_count (*(volatile uint8_t*)0x00808A78UL) /* PWM timing advance cycle count (3 refs) */
#define pwm_timer_cycle_advance_param (*(volatile uint8_t*)0x00808A79UL) /* PWM timer cycle advance param (pwmTimerCycleAdv... */
#define user_specified_number_of_engine_data_samples_taken_by_trending_f_0_100 (*(volatile uint16_t*)0x00808A7AUL) /* USER-SPECIFIED NUMBER OF ENGINE DATA SAMPLES TA... */
#define time_that_trigger_must_be_satisfied_to_allow_trending_data_co_0_3600 (*(volatile uint16_t*)0x00808A7EUL) /* TIME THAT TRIGGER MUST BE SATISFIED TO ALLOW TR... */
#define rpm_divisor_value (*(volatile uint16_t*)0x00808A82UL) /* RPM divisor for fuel calculations (2 refs) */
#define upper_limit_at_which_loading_trigger_is_satisfied_in_trendin_0_127_5 (*(volatile uint16_t*)0x00808A84UL) /* UPPER LIMIT AT WHICH LOADING TRIGGER IS SATISFI... */
#define lower_limit_at_which_loading_trigger_is_satisfied_in_trendin_0_127_5 (*(volatile uint16_t*)0x00808A86UL) /* LOWER LIMIT AT WHICH LOADING TRIGGER IS SATISFI... */
#define count_limit_for_constant_freq_detection_alg_0_10000 (*(volatile uint16_t*)0x00808A9AUL) /* COUNT LIMIT FOR CONSTANT FREQ. DETECTION ALG. */
#define count_minimum_for_percent_load_to_be_low_0_100 (*(volatile uint16_t*)0x00808A9CUL) /* COUNT MINIMUM FOR PERCENT LOAD TO BE LOW */
#define max_percent_load_during_a_legitimate_gear_change_0_100 (*(volatile uint16_t*)0x00808A9EUL) /* MAX. PERCENT LOAD DURING A LEGITIMATE GEAR CHANGE */
#define percent_load_pcld_threshold_0_127_5 (*(volatile uint16_t*)0x00808AACUL) /* PERCENT LOAD (PCLD) THRESHOLD */
#define indicates_if_vss_tamper_algs_are_enabled_when_vss_highway_is_off_0_2_3_8ab8 (*(volatile uint16_t*)0x00808AB8UL) /* INDICATES IF VSS TAMPER ALGS ARE ENABLED WHEN V... */
#define indicates_if_vss_tamper_algs_are_enabled_when_vss_highway_is_off_0_2_3_8aba (*(volatile uint16_t*)0x00808ABAUL) /* INDICATES IF VSS TAMPER ALGS ARE ENABLED WHEN V... */
#define indicates_if_vss_tamper_algs_are_enabled_when_vss_highway_is_on_0_2_3_8abc (*(volatile uint16_t*)0x00808ABCUL) /* INDICATES IF VSS TAMPER ALGS ARE ENABLED WHEN V... */
#define indicates_if_vss_tamper_algs_are_enabled_when_vss_highway_is_on_0_2_3_8abe (*(volatile uint16_t*)0x00808ABEUL) /* INDICATES IF VSS TAMPER ALGS ARE ENABLED WHEN V... */
#define threshold_for_determining_if_vehicle_is_on_hill_0_127_5 (*(volatile uint16_t*)0x00808AC0UL) /* THRESHOLD FOR DETERMINING IF VEHICLE IS ON HILL */
#define diagnostic_tx_buffer_base (*(volatile uint8_t*)0x00808B00UL) /* Diagnostic transmit buffer base address (diagno... */
#define diagnostic_rx_buffer_base (*(volatile uint8_t*)0x00808C00UL) /* Diagnostic receive buffer base address (diagnos... */
#define vector_table_init_address (*(volatile uint32_t*)0x00808DC2UL) /* Vector table init address (initVectorTable) */
#define can_message_isr_register_address (*(volatile uint32_t*)0x00808E32UL) /* CAN message ISR register address (canMessageInt... */
#define serial_comm_isr_register_address (*(volatile uint32_t*)0x00808E36UL) /* Serial communication ISR register address (seri... */
#define state_machine_return_address (*(volatile uint32_t*)0x00808EC2UL) /* State machine return address pointer (3 refs) */
#define duty_cycle_monitor_slot_config (*(volatile uint16_t*)0x00808EC6UL) /* Duty cycle monitor slot configuration value (5 ... */
#define timer_capture_hardware_init_address (*(volatile uint32_t*)0x00808ECAUL) /* Timer capture hardware init address (timerCaptu... */
#define pwm_timer_mode_1_update_address (*(volatile uint32_t*)0x00808ECEUL) /* PWM timer mode 1 update address (pwmTimerMode1U... */
#define rpm_timer_interrupt_handler_ptr (*(volatile uint32_t*)0x00808EEAUL) /* Pointer to active RPM timer interrupt handler (... */
#define engine_speed_isr_register_address (*(volatile uint32_t*)0x00808FEEUL) /* Engine speed ISR register address (engineSpeedI... */
#define fuel_limit_shutdown (*(volatile uint16_t*)0x008091C4UL) /* Fuel limit during shutdown */
#define high_rpm_fuel_limit (*(volatile uint16_t*)0x008091C6UL) /* High RPM fuel control limit */
#define low_rpm_fuel_protection_limit (*(volatile uint16_t*)0x008091C8UL) /* Low RPM fuel protection limit */
#define rpm_rate_limiter_output (*(volatile uint16_t*)0x008091CAUL) /* RPM rate limiter output */
#define rpm_rate_limited_value (*(volatile uint16_t*)0x008091CCUL) /* RPM rate limited value */
#define rpm_rate_secondary_calc (*(volatile uint16_t*)0x008091CEUL) /* Secondary RPM rate calculation result */
#define rpm_state_accumulator (*(volatile uint16_t*)0x008091D0UL) /* RPM state accumulator */
#define high_rpm_fuel_accumulator (*(volatile uint16_t*)0x008091D2UL) /* High RPM fuel accumulator */
#define low_rpm_fuel_accumulator (*(volatile uint16_t*)0x008091D4UL) /* Low RPM fuel accumulator */
#define fuel_demand_before_limiting (*(volatile uint16_t*)0x008091D6UL) /* Fuel demand saved before limiting */
#define rpm_rate_limit_active_flag (*(volatile uint16_t*)0x008091D8UL) /* RPM rate limiting active flag (0=inactive 1=act... */
#define rpm_threshold_exceeded_flag (*(volatile uint16_t*)0x008091DAUL) /* Flag indicating RPM threshold was exceeded */
#define none_none (*(volatile uint16_t*)0x008091DCUL) /* NONE */
#define rpm_control_override_flag (*(volatile uint16_t*)0x008091DEUL) /* Override flag for RPM control logic */
#define request_to_strobe_set_0_then_set_1_fso_driver_0_1 (*(volatile uint8_t*)0x008091E0UL) /* REQUEST TO STROBE (SET 0 THEN SET 1) FSO DRIVER */
#define request_to_strobe_set_0_then_set_1_engine_braker_driver_0_1 (*(volatile uint8_t*)0x008091E1UL) /* REQUEST TO STROBE (SET 0 THEN SET 1) ENGINE BRA... */
#define request_to_strobe_set_0_then_set_1_cold_start_aid_1_driver_0_1 (*(volatile uint8_t*)0x008091E2UL) /* REQUEST TO STROBE (SET 0 THEN SET 1) COLD START... */
#define request_to_strobe_set_0_then_set_1_cold_start_aid_2_driver_0_1 (*(volatile uint8_t*)0x008091E3UL) /* REQUEST TO STROBE (SET 0 THEN SET 1) COLD START... */
#define request_to_strobe_set_0_then_set_1_ether_start_driver_0_1 (*(volatile uint16_t*)0x008091E4UL) /* REQUEST TO STROBE (SET 0 THEN SET 1) ETHER STAR... */
#define coolant_level_low_switch_used_as_an_input_source_by_t_1_true_0_false (*(volatile uint16_t*)0x008091E6UL) /* COOLANT LEVEL LOW SWITCH USED AS AN INPUT SOURC... */
#define intake_manifold_temp_raw (*(volatile uint16_t*)0x008091EAUL) /* Intake manifold temperature raw ADC value */
#define engine_fluid_level_temp_data (*(volatile uint16_t*)0x00809200UL) /* Engine fluid level temperature data (engineFlui... */
#define insite_parameter_display_value (*(volatile uint16_t*)0x00809242UL) /* INSITE parameter display value (1 ref) */
#define intake_manifold_temp_processed (*(volatile uint16_t*)0x00809258UL) /* Intake manifold temperature processed */
#define throttle_position_raw (*(volatile uint16_t*)0x0080926EUL) /* Raw throttle position reading */
#define rpm_histogram_temp_value (*(volatile uint16_t*)0x008092B0UL) /* RPM histogram temperature comparison value (4 r... */
#define load_percentage (*(volatile uint16_t*)0x008092C6UL) /* Engine load percentage */
#define insite_diagnostic_reading (*(volatile uint16_t*)0x008092F2UL) /* INSITE diagnostic reading value (1 ref) */
#define retarder_input_value (*(volatile uint16_t*)0x00809308UL) /* Retarder input value for calculations */
#define vp44_state_debounce_value_938c (*(volatile VP44_STATE*)0x0080938CUL) /* VP44 state debounce filter value (12 refs) */
#define vp44_fault_register_bit2_threshold (*(volatile uint16_t*)0x008093A2UL) /* VP44 fault register bit 2 threshold (vp44FaultR... */
#define clutch_time_accumulator_1_9488 (*(volatile uint32_t*)0x00809488UL) /* Clutch time accumulator 1 (2 refs) */
#define boost_pressure_stats_accumulator_948c (*(volatile uint32_t*)0x0080948CUL) /* Boost pressure statistics accumulator (2 refs) */
#define clutch_time_accumulator_2_9490 (*(volatile uint32_t*)0x00809490UL) /* Clutch time accumulator 2 (2 refs) */
#define clutch_time_accumulator_3_9494 (*(volatile uint32_t*)0x00809494UL) /* Clutch time accumulator 3 (2 refs) */
#define clutch_transition_accumulator_9498 (*(volatile uint32_t*)0x00809498UL) /* Clutch transition accumulator (4 refs) */
#define clutch_statistics_status_flags_949c (*(volatile uint16_t*)0x0080949CUL) /* Clutch statistics status flags bitmap (4 refs) */
#define derate_event_counter_949e (*(volatile uint16_t*)0x0080949EUL) /* Derate event counter (2 refs) */
#define clutch_slip_event_counter_94a0 (*(volatile uint16_t*)0x008094A0UL) /* Clutch slip event counter (2 refs) */
#define fuel_limit_exceedance_counter_1_94a2 (*(volatile uint16_t*)0x008094A2UL) /* Fuel limit exceedance counter 1 (2 refs) */
#define fuel_source_10_statistics_counter_94a4 (*(volatile uint16_t*)0x008094A4UL) /* Fuel source 10 idle statistics counter (2 refs) */
#define fuel_temp_exceedance_counter_94a6 (*(volatile uint16_t*)0x008094A6UL) /* Fuel temp exceedance counter (2 refs) */
#define boost_pressure_stats_arg_94a8 (*(volatile uint32_t*)0x008094A8UL) /* Boost pressure statistics argument (2 refs) */
#define derate_time_accumulator_94ac (*(volatile uint32_t*)0x008094ACUL) /* Derate time accumulator (3 refs) */
#define derate_time_accumulator_arg_94b0 (*(volatile uint32_t*)0x008094B0UL) /* Derate time accumulator argument (2 refs) */
#define fuel_demand_exceeded_accumulator_94b4 (*(volatile uint32_t*)0x008094B4UL) /* Fuel demand exceeded accumulator (2 refs) */
#define fuel_source_10_time_accumulator_94b8 (*(volatile uint32_t*)0x008094B8UL) /* Fuel source 10 time accumulator (2 refs) */
#define fuel_demand_exceeded_counter_94bc (*(volatile uint16_t*)0x008094BCUL) /* Fuel demand exceeded counter (2 refs) */
#define fuel_demand_exceeded_arg_94be (*(volatile uint32_t*)0x008094BEUL) /* Fuel demand exceeded argument (2 refs) */
#define fuel_source_10_time_arg_94c2 (*(volatile uint32_t*)0x008094C2UL) /* Fuel source 10 time argument (2 refs) */
#define fuel_limit_near_exceedance_accum_94c6 (*(volatile uint32_t*)0x008094C6UL) /* Fuel limit near exceedance accumulator (2 refs) */
#define fuel_temp_exceedance_accumulator_94ca (*(volatile uint32_t*)0x008094CAUL) /* Fuel temp exceedance accumulator (2 refs) */
#define fuel_limit_near_exceedance_arg_94ce (*(volatile uint32_t*)0x008094CEUL) /* Fuel limit near exceedance argument (2 refs) */
#define fuel_temp_exceedance_arg_94d2 (*(volatile uint32_t*)0x008094D2UL) /* Fuel temp exceedance argument (2 refs) */
#define clutch_rpm_proportional_calc_94d6 (*(volatile uint32_t*)0x008094D6UL) /* Clutch RPM proportional calculation (3 refs) */
#define fuel_temp_protection_counter_1_94da (*(volatile uint16_t*)0x008094DAUL) /* Fuel temp protection counter 1 (2 refs) */
#define fuel_temp_protection_counter_2_94dc (*(volatile uint16_t*)0x008094DCUL) /* Fuel temp protection counter 2 (2 refs) */
#define clutch_statistics_ratio_calc_94de (*(volatile uint32_t*)0x008094DEUL) /* Clutch statistics ratio calculation (3 refs) */
#define clutch_rpm_delta_94e2 (*(volatile uint32_t*)0x008094E2UL) /* Clutch RPM delta for slip detection (2 refs) */
#define clutch_slip_detection_state_94e6 (*(volatile uint16_t*)0x008094E6UL) /* Clutch slip detection state (3 refs) */
#define clutch_sample_divider_94e8 (*(volatile uint16_t*)0x008094E8UL) /* Clutch sample divider counter (3 refs) */
#define clutch_rpm_previous_94ea (*(volatile uint16_t*)0x008094EAUL) /* Clutch RPM previous value for delta (3 refs) */
#define derate_event_state_machine_94ec (*(volatile DERATE_EVENT_STATE*)0x008094ECUL) /* Derate event state machine (4 refs) */
#define derate_event_timer_94ee (*(volatile uint16_t*)0x008094EEUL) /* Derate event timer (3 refs) */
#define adc_channel_config_buffer (*(volatile uint16_t*)0x00809526UL) /* ADC channel configuration buffer (initADCChanne... */
#define adc_oil_pressure_filter_ptr (*(volatile uint32_t*)0x00809528UL) /* ADC oil pressure filter constant pointer (initA... */
#define adc_coolant_temp_fault_clear_ptr (*(volatile uint32_t*)0x0080952EUL) /* ADC coolant temp fault clear counts pointer (in... */
#define adc_throttle_fault_increment_ptr (*(volatile uint32_t*)0x00809532UL) /* ADC throttle fault increment pointer (initADCCh... */
#define adc_throttle_fault_set_ptr (*(volatile uint32_t*)0x00809534UL) /* ADC sampled throttle fault clear counts pointer... */
#define adc_sampled_throttle_fault_clear_ptr (*(volatile uint32_t*)0x0080953AUL) /* ADC sampled throttle fault clear ptr (initADCCh... */
#define adc_channel_3_config_value (*(volatile uint16_t*)0x0080953EUL) /* ADC channel 3 config value 2 (initADCChannelCon... */
#define adc_ambient_air_pressure_filter_ptr (*(volatile uint32_t*)0x00809540UL) /* ADC ambient air pressure filter ptr (initADCCha... */
#define adc_channel_3_mux_ptr (*(volatile uint32_t*)0x00809546UL) /* ADC channel 3 mux setting ptr (initADCChannelCo... */
#define adc_channel_4_config_value (*(volatile uint16_t*)0x0080954AUL) /* ADC channel 4 config value 2 (initADCChannelCon... */
#define adc_battery_voltage_error_limit_ptr (*(volatile uint32_t*)0x0080954CUL) /* ADC battery voltage high error limit ptr (initA... */
#define adc_channel_4_mux_ptr (*(volatile uint32_t*)0x00809552UL) /* ADC channel 4 mux setting ptr (initADCChannelCo... */
#define adc_channel_5_config_value (*(volatile uint16_t*)0x00809556UL) /* ADC channel 5 config value 2 (initADCChannelCon... */
#define adc_channel_5_filter_ptr (*(volatile uint32_t*)0x00809558UL) /* ADC channel 5 digital filter ptr (initADCChanne... */
#define adc_channel_5_error_limit_ptr (*(volatile uint32_t*)0x0080955EUL) /* ADC channel 5 high error limit ptr (initADCChan... */
#define adc_channel_6_config_value (*(volatile uint16_t*)0x00809562UL) /* ADC channel 6 config value 2 (initADCChannelCon... */
#define adc_channel_6_filter_ptr (*(volatile uint32_t*)0x00809564UL) /* ADC channel 6 digital filter ptr (initADCChanne... */
#define adc_channel_6_fault_set_ptr (*(volatile uint32_t*)0x0080956AUL) /* ADC channel 6 fault set ptr (initADCChannelConf... */
#define adc_channel_7_config_value (*(volatile uint16_t*)0x0080956EUL) /* ADC channel 7 config value 2 (initADCChannelCon... */
#define adc_throttle_error_number_ptr (*(volatile uint32_t*)0x00809570UL) /* ADC throttle position error number ptr (initADC... */
#define adc_channel_7_filter_ptr (*(volatile uint32_t*)0x00809576UL) /* ADC channel 7 digital filter ptr (initADCChanne... */
#define adc_channel_8_config_value (*(volatile uint16_t*)0x0080957AUL) /* ADC channel 8 config value 2 (initADCChannelCon... */
#define adc_water_in_fuel_fault_clear_ptr (*(volatile uint32_t*)0x0080957CUL) /* ADC water in fuel fault clear counts ptr (initA... */
#define adc_water_in_fuel_fault_set_ptr (*(volatile uint32_t*)0x00809582UL) /* ADC water in fuel fault set ptr (initADCChannel... */
#define adc_channel_9_config_value (*(volatile uint16_t*)0x00809586UL) /* ADC channel 9 config value 2 (initADCChannelCon... */
#define adc_water_in_fuel_channel_addr_ptr (*(volatile uint32_t*)0x00809588UL) /* ADC water in fuel channel address ptr (initADCC... */
#define adc_water_in_fuel_tristate_ptr (*(volatile uint32_t*)0x0080958EUL) /* ADC water in fuel tri-state error ptr (initADCC... */
#define adc_channel_10_config_value (*(volatile uint16_t*)0x00809592UL) /* ADC channel 10 config value 2 (initADCChannelCo... */
#define adc_channel_10_fault_clear_ptr (*(volatile uint32_t*)0x00809594UL) /* ADC channel 10 fault clear counts ptr (initADCC... */
#define adc_channel_10_fault_set_ptr (*(volatile uint32_t*)0x0080959AUL) /* ADC channel 10 fault set ptr (initADCChannelCon... */
#define adc_channel_11_config_value (*(volatile uint16_t*)0x0080959EUL) /* ADC channel 11 config value 2 (initADCChannelCo... */
#define adc_egr_feedback_channel_addr_ptr (*(volatile uint32_t*)0x008095A0UL) /* ADC EGR feedback channel address ptr (initADCCh... */
#define adc_channel_11_fault_decrement_ptr (*(volatile uint32_t*)0x008095A6UL) /* ADC channel 11 fault decrement ptr (initADCChan... */
#define adc_channel_12_config_value (*(volatile uint16_t*)0x008095AAUL) /* ADC channel 12 config value 2 (initADCChannelCo... */
#define adc_programming_pulse_error_ptr (*(volatile uint32_t*)0x008095ACUL) /* ADC programming pulse error number ptr (initADC... */
#define adc_channel_12_fault_ptr (*(volatile uint32_t*)0x008095B2UL) /* ADC channel 12 ADHBSVFD ptr (initADCChannelConf... */
#define adc_channel_13_config_value (*(volatile uint16_t*)0x008095B6UL) /* ADC channel 13 config value 2 (initADCChannelCo... */
#define adc_channel_13_fault_ptr (*(volatile uint32_t*)0x008095B8UL) /* ADC channel 13 ADHBSVCA ptr (initADCChannelConf... */
#define adc_channel_13_default_ptr (*(volatile uint32_t*)0x008095BEUL) /* ADC channel 13 global default ptr (initADCChann... */
#define adc_channel_14_config_value (*(volatile uint16_t*)0x008095C2UL) /* ADC channel 14 config value 2 (initADCChannelCo... */
#define adc_channel_14_error_limit_ptr (*(volatile uint32_t*)0x008095C4UL) /* ADC channel 14 high error limit ptr (initADCCha... */
#define adc_channel_14_mux_ptr (*(volatile uint32_t*)0x008095CAUL) /* ADC channel 14 mux setting ptr (initADCChannelC... */
#define adc_channel_15_config_value (*(volatile uint16_t*)0x008095CEUL) /* ADC channel 15 config value 2 (initADCChannelCo... */
#define adc_channel_15_table_ptr_1 (*(volatile uint32_t*)0x008095D0UL) /* ADC channel 15 table pointer 1 0x806d3a (initAD... */
#define adc_channel_15_table_ptr_2 (*(volatile uint32_t*)0x008095D6UL) /* ADC channel 15 table pointer 2 0x806d40 (initAD... */
#define adc_channel_16_config_value (*(volatile uint16_t*)0x008095DAUL) /* ADC channel 16 config value 2 (initADCChannelCo... */
#define adc_channel_16_table_ptr_1 (*(volatile uint32_t*)0x008095DCUL) /* ADC channel 16 table pointer 1 0x806d46 (initAD... */
#define adc_channel_16_table_ptr_2 (*(volatile uint32_t*)0x008095E2UL) /* ADC channel 16 table pointer 2 0x806d4c (initAD... */
#define adc_channel_17_config_value (*(volatile uint16_t*)0x008095E6UL) /* ADC channel 17 config value 2 (initADCChannelCo... */
#define adc_channel_17_table_ptr_1 (*(volatile uint32_t*)0x008095E8UL) /* ADC channel 17 table pointer 1 0x806d52 (initAD... */
#define adc_channel_17_table_ptr_2 (*(volatile uint32_t*)0x008095EEUL) /* ADC channel 17 table pointer 2 0x806d58 (initAD... */
#define adc_channel_18_config_value (*(volatile uint16_t*)0x008095F2UL) /* ADC channel 18 config value 2 (initADCChannelCo... */
#define adc_channel_18_table_ptr_1 (*(volatile uint32_t*)0x008095F4UL) /* ADC channel 18 table pointer 1 0x806d5e (initAD... */
#define adc_channel_18_table_ptr_2 (*(volatile uint32_t*)0x008095FAUL) /* ADC channel 18 table pointer 2 0x806d64 (initAD... */
#define adc_channel_19_config_value (*(volatile uint16_t*)0x008095FEUL) /* ADC channel 19 config value 2 (initADCChannelCo... */
#define adc_channel_19_table_ptr_1 (*(volatile uint32_t*)0x00809600UL) /* ADC channel 19 table pointer 1 0x806d6a (initAD... */
#define adc_channel_19_table_ptr_2 (*(volatile uint32_t*)0x00809606UL) /* ADC channel 19 table pointer 2 0x806d70 (initAD... */
#define adc_channel_20_config_value (*(volatile uint16_t*)0x0080960AUL) /* ADC channel 20 config value 2 (initADCChannelCo... */
#define adc_channel_20_table_ptr_1 (*(volatile uint32_t*)0x0080960CUL) /* ADC channel 20 table pointer 1 0x806d76 (initAD... */
#define adc_channel_20_table_ptr_2 (*(volatile uint32_t*)0x00809612UL) /* ADC channel 20 table pointer 2 0x806d9c (initAD... */
#define adc_channel_21_config_value (*(volatile uint16_t*)0x00809616UL) /* ADC channel 21 config value 2 (initADCChannelCo... */
#define adc_channel_21_table_ptr_1 (*(volatile uint32_t*)0x00809618UL) /* ADC channel 21 table pointer 1 0x806dc2 (initAD... */
#define adc_channel_21_table_ptr_2 (*(volatile uint32_t*)0x0080961EUL) /* ADC channel 21 table pointer 2 0x806dd4 (initAD... */
#define adc_channel_22_config_value (*(volatile uint16_t*)0x00809622UL) /* ADC channel 22 config value 2 (initADCChannelCo... */
#define adc_channel_22_table_ptr_1 (*(volatile uint32_t*)0x00809624UL) /* ADC channel 22 table pointer 1 0x806de6 (initAD... */
#define adc_channel_22_table_ptr_2 (*(volatile uint32_t*)0x0080962AUL) /* ADC channel 22 table pointer 2 0x806dee (initAD... */
#define adc_channel_23_config_value (*(volatile uint16_t*)0x0080962EUL) /* ADC channel 23 config value 2 (initADCChannelCo... */
#define adc_channel_23_table_ptr_1 (*(volatile uint32_t*)0x00809630UL) /* ADC channel 23 table pointer 1 0x806df6 (initAD... */
#define adc_channel_23_table_ptr_2 (*(volatile uint32_t*)0x00809636UL) /* ADC channel 23 table pointer 2 0x806dfc (initAD... */
#define adc_channel_24_config_value (*(volatile uint16_t*)0x0080963AUL) /* ADC channel 24 config value 2 (initADCChannelCo... */
#define adc_channel_24_table_ptr_1 (*(volatile uint32_t*)0x0080963CUL) /* ADC channel 24 table pointer 1 0x806e02 (initAD... */
#define adc_channel_24_table_ptr_2 (*(volatile uint32_t*)0x00809642UL) /* ADC channel 24 table pointer 2 0x806e08 (initAD... */
#define adc_channel_25_config_value (*(volatile uint16_t*)0x00809646UL) /* ADC channel 25 config value 2 (initADCChannelCo... */
#define adc_channel_25_table_ptr_1 (*(volatile uint32_t*)0x00809648UL) /* ADC channel 25 table pointer 1 0x806e0e (initAD... */
#define adc_channel_25_table_ptr_2 (*(volatile uint32_t*)0x0080964EUL) /* ADC channel 25 table pointer 2 0x806e14 (initAD... */
#define current_fuel_demand_limit (*(volatile uint16_t*)0x00809652UL) /* Current fuel demand limit value */
#define diagnostic_fuel_control_mode (*(volatile uint16_t*)0x00809654UL) /* Fuel/diagnostic mode selector: 10=INSITE displa... */
#define diagnostic_mode_buffer (*(volatile uint8_t*)0x00809658UL) /* Diagnostic mode buffer/state value (2 refs) */
#define fuel_timing_mode_blend_factor_965a (*(volatile uint16_t*)0x0080965AUL) /* Fuel timing mode blend factor Q14 */
#define timing_protection_blend_ramp (*(volatile uint16_t*)0x0080965CUL) /* Timing protection blend ramp 0-16384 */
#define timing_mode_source_selector (*(volatile TIMING_MODE_SOURCE*)0x0080965EUL) /* Timing mode source selector 0-4 */
#define timing_transition_result (*(volatile uint16_t*)0x00809660UL) /* Timing mode transition result */
#define timing_fuel_blend_result (*(volatile uint16_t*)0x00809662UL) /* Timing fuel blend result */
#define timing_oil_pressure_result (*(volatile uint16_t*)0x00809664UL) /* Timing oil pressure condition result */
#define timing_mode_11_result (*(volatile uint16_t*)0x00809666UL) /* Timing mode 11 countdown result */
#define timing_protection_counter_1 (*(volatile uint16_t*)0x00809668UL) /* Timing protection counter 1 */
#define timing_protection_counter_2 (*(volatile uint16_t*)0x0080966AUL) /* Timing protection counter 2 */
#define timing_blend_state (*(volatile uint16_t*)0x0080966CUL) /* Timing blend state */
#define vp44_control_structure_init_value (*(volatile uint16_t*)0x0080966EUL) /* VP44 control structure init value (vp44ControlS... */
#define timing_blend_accumulator (*(volatile uint16_t*)0x00809672UL) /* Timing blend accumulator */
#define fuel_source_mode_11_state (*(volatile uint16_t*)0x00809676UL) /* Fuel source mode 11 state */
#define fuel_source_mode_11_timer (*(volatile uint16_t*)0x00809678UL) /* Fuel source mode 11 timer */
#define fuel_mode_transition_state (*(volatile uint16_t*)0x0080967AUL) /* Fuel mode transition state */
#define fuel_mode_transition_timer (*(volatile uint16_t*)0x0080967CUL) /* Fuel mode transition timer */
#define vp44_status_threshold_flag (*(volatile uint16_t*)0x0080967EUL) /* VP44 status threshold comparison flag (4 refs) */
#define shutdown_protection_fuel_limit (*(volatile uint16_t*)0x00809682UL) /* Shutdown protection calculator fuel limit (6 refs) */
#define rpm_timing_delta_result_flag_1 (*(volatile uint8_t*)0x00809684UL) /* RPM timing delta comparison result flag 1 (7 refs) */
#define rpm_timing_delta_result_flag_2 (*(volatile uint8_t*)0x00809685UL) /* RPM timing delta comparison result flag 2 (7 refs) */
#define rpm_timing_capture_delta (*(volatile uint16_t*)0x00809686UL) /* Delta between current and previous RPM timing c... */
#define engine_run_time_counter (*(volatile uint16_t*)0x00809688UL) /* Engine run time accumulation counter */
#define intake_temp_derate_timer (*(volatile uint16_t*)0x0080968CUL) /* Intake temp derate timer counter (7 refs) */
#define fuel_timing_transition_state_968e (*(volatile uint16_t*)0x0080968EUL) /* Fuel timing transition state machine state (fue... */
#define fuel_pressure_filtered (*(volatile uint16_t*)0x00809690UL) /* Filtered fuel pressure value */
#define intake_temp_protection_accumulator (*(volatile uint16_t*)0x00809692UL) /* Intake temp shutdown threshold accumulator (7 r... */
#define protection_fuel_limit_rpm_based (*(volatile uint16_t*)0x00809694UL) /* RPM-based protection fuel limit */
#define protection_fuel_limit_mode_based (*(volatile uint16_t*)0x00809696UL) /* Mode-based protection fuel limit */
#define protection_fuel_limit_alternate (*(volatile uint16_t*)0x00809698UL) /* Alternate protection fuel limit value */
#define boost_pressure_protection_active (*(volatile uint16_t*)0x0080969AUL) /* Boost pressure protection system active flag */
#define boost_pressure_accumulator (*(volatile uint16_t*)0x0080969CUL) /* Boost pressure protection accumulator */
#define vp44_injection_system_active (*(volatile uint16_t*)0x0080969EUL) /* VP44 injection system active flag - forces emer... */
#define retarder_input_flags (*(volatile uint16_t*)0x008096A0UL) /* Retarder input mode flags */
#define fuel_demand_limit_source (*(volatile FUEL_DEMAND_LIMIT*)0x008096A2UL) /* Fuel demand limit source state machine */
#define throttle_position_value (*(volatile uint16_t*)0x008096A6UL) /* Throttle position value */
#define throttle_position_filtered (*(volatile uint16_t*)0x008096A8UL) /* Throttle position filtered value */
#define fuel_temp_protection_threshold_flag (*(volatile uint16_t*)0x008096AAUL) /* Fuel temperature protection threshold flag */
#define fuel_limit_protection (*(volatile uint16_t*)0x008096ACUL) /* Fuel limit from protection systems */
#define fuel_limit_rpm_based (*(volatile uint16_t*)0x008096AEUL) /* RPM-based fuel limit */
#define fuel_mode_state_selector (*(volatile uint16_t*)0x008096B0UL) /* Fuel mode state selector (1/2/3 states) (3 refs) */
#define fuel_demand_limit_source_2_flag (*(volatile uint8_t*)0x008096B2UL) /* Fuel demand limit source 2 selector flag (6 refs) */
#define vp44_operating_condition_value (*(volatile VP44_OPERATING_CONDITION*)0x008096B4UL) /* VP44 operating condition check value */
#define vp44_diagnostic_mode_state (*(volatile VP44_DIAG_MODE*)0x008096B6UL) /* VP44 diagnostic mode state machine */
#define protection_param_2 (*(volatile uint16_t*)0x008096C2UL) /* Protection table parameter 2 (2 refs) */
#define diagnostic_mode_fuel_adjustment (*(volatile uint16_t*)0x008096C4UL) /* Diagnostic mode fuel adjustment value */
#define diagnostic_fuel_gain_factor_96c6 (*(volatile uint16_t*)0x008096C6UL) /* Diagnostic fuel gain from protection table look... */
#define protection_param_1 (*(volatile uint16_t*)0x008096C8UL) /* Protection table parameter 1 (2 refs) */
#define protection_param_3 (*(volatile uint16_t*)0x008096CAUL) /* Protection table parameter 3 (2 refs) */
#define protection_param_0 (*(volatile uint16_t*)0x008096CCUL) /* Protection table parameter 0 (3 refs) */
#define protection_table_pointer (*(volatile uint32_t*)0x008096E2UL) /* Pointer to active protection table (3 refs) */
#define diagnostic_rpm_limit_clamped (*(volatile uint16_t*)0x008096E6UL) /* Diagnostic RPM limit clamped value (4 refs) */
#define protection_scaling_factor (*(volatile uint16_t*)0x008096E8UL) /* Protection scaling factor from calculation (3 r... */
#define fuel_pressure_error (*(volatile uint16_t*)0x008096EAUL) /* Fuel pressure error (setpoint - actual) */
#define fuel_pressure_delta (*(volatile uint16_t*)0x008096ECUL) /* Fuel pressure delta for control loop */
#define boost_pressure_control_state (*(volatile uint16_t*)0x008096F0UL) /* Boost pressure control and diagnostics state (1... */
#define boost_pressure_diagnostic_timer (*(volatile uint16_t*)0x008096F2UL) /* Boost pressure diagnostic timer (4 refs) */
#define boost_pressure_diagnostic_state (*(volatile uint16_t*)0x008096F4UL) /* Boost pressure diagnostic state (5 refs) */
#define diagnostic_mode_boost_state (*(volatile uint16_t*)0x008096F6UL) /* Diagnostic mode boost control state (4 refs) */
#define diagnostic_mode_fuel_state (*(volatile uint16_t*)0x008096F8UL) /* Diagnostic mode fuel adjustment state (39 refs) */
#define boost_pressure_protection_state_96fa (*(volatile uint16_t*)0x008096FAUL) /* Boost pressure protection state machine value (... */
#define vp44_diagnostic_mode_state_2 (*(volatile VP44_DIAG_MODE*)0x008096FCUL) /* VP44 diagnostic mode state machine 2 (11 refs) */
#define vp44_diagnostic_fault_state (*(volatile uint16_t*)0x008096FEUL) /* VP44 diagnostic fault monitor state (9 refs) */
#define fuel_demand_override_state (*(volatile uint16_t*)0x00809700UL) /* Fuel demand override state selector (4 refs) */
#define fuel_temp_limit_state_2 (*(volatile uint16_t*)0x00809702UL) /* Fuel temp limit state 2 */
#define fuel_demand_state_24_write_flag (*(volatile uint16_t*)0x00809704UL) /* Fuel demand state 24 override write flag (fuelD... */
#define fuel_temp_limit_primary (*(volatile uint16_t*)0x00809706UL) /* Fuel temp limiting primary output */
#define fuel_temp_limit_secondary (*(volatile uint16_t*)0x00809708UL) /* Fuel temp limiting secondary output */
#define fuel_temp_limit_output_970a (*(volatile uint16_t*)0x0080970AUL) /* Fuel temp limit final output */
#define fuel_temp_output_control_status (*(volatile uint16_t*)0x0080970CUL) /* Fuel temp output control status copy (1 ref) */
#define fuel_temp_protection_timer_1 (*(volatile uint16_t*)0x0080970EUL) /* Fuel temp protection timer 1 */
#define fuel_temp_protection_timer_2 (*(volatile uint16_t*)0x00809710UL) /* Fuel temp protection timer 2 */
#define fuel_temp_limit_mode_selector (*(volatile uint16_t*)0x00809712UL) /* Fuel temp limit mode selector (4 refs) */
#define fuel_temp_primary_countdown_timer (*(volatile uint16_t*)0x00809714UL) /* Fuel temp primary countdown timer (3 refs) */
#define fuel_temp_secondary_countdown (*(volatile uint16_t*)0x00809716UL) /* Fuel temp secondary countdown timer (3 refs) */
#define fuel_temp_protection_timer_3 (*(volatile uint16_t*)0x00809718UL) /* Fuel temp protection timer 3 */
#define fuel_temp_protection_current (*(volatile uint16_t*)0x0080971AUL) /* Fuel temp protection current value */
#define fuel_temp_calculated_limit_971c (*(volatile uint16_t*)0x0080971CUL) /* Fuel temp calculated limit */
#define fuel_temp_limit_delta (*(volatile uint16_t*)0x0080971EUL) /* Fuel temp limit delta value */
#define fuel_temp_rpm_timer (*(volatile uint16_t*)0x00809720UL) /* Fuel temp RPM derate timer countdown (4 refs) */
#define fuel_temp_protection_timer_9722 (*(volatile uint16_t*)0x00809722UL) /* Fuel temp protection timer countdown (4 refs) */
#define fuel_temp_limit_output_9724 (*(volatile uint16_t*)0x00809724UL) /* Fuel temp limit output value (2 refs) */
#define crank_protection_time_delta (*(volatile uint32_t*)0x00809726UL) /* Crank protection time delta value (5 refs) */
#define crank_protection_divisor (*(volatile uint16_t*)0x0080972AUL) /* Crank protection calculation divisor (3 refs) */
#define shutdown_limit_selector_value (*(volatile uint16_t*)0x0080972CUL) /* Shutdown limit selector calculated value (4 refs) */
#define clutch_rpm_accumulator (*(volatile uint16_t*)0x0080972EUL) /* Accumulated RPM for clutch statistics */
#define clutch_rpm_calc_numerator (*(volatile uint32_t*)0x00809730UL) /* Clutch RPM calculation numerator (2 refs) */
#define derate_table_pointer (*(volatile uint32_t*)0x00809734UL) /* Derate table EPFLTB pointer (derateTablePointer... */
#define derate_table_init_flag (*(volatile uint32_t*)0x00809738UL) /* Derate table init flag (derateTablePointerInit) */
#define boost_pressure_target_data (*(volatile uint16_t*)0x0080973CUL) /* Boost pressure target calculated value */
#define boost_pressure_rpm_comparison (*(volatile uint16_t*)0x0080973EUL) /* Boost pressure RPM comparison threshold */
#define boost_pressure_rpm_threshold (*(volatile uint16_t*)0x00809742UL) /* Boost pressure RPM threshold */
#define boost_pressure_state_machine (*(volatile uint16_t*)0x00809746UL) /* Boost pressure state machine state */
#define boost_pressure_active_flag (*(volatile uint16_t*)0x00809748UL) /* Boost pressure calculation active flag */
#define boost_pressure_interpolation_result (*(volatile uint16_t*)0x0080974AUL) /* Boost pressure interpolation result */
#define clutch_rpm_proportional_calc_974c (*(volatile uint32_t*)0x0080974CUL) /* Clutch RPM proportional calculation result (6 r... */
#define clutch_statistics_ratio_calc_9750 (*(volatile uint32_t*)0x00809750UL) /* Clutch statistics ratio calculation result (5 r... */
#define timer_capture_raw (*(volatile uint16_t*)0x00809758UL) /* Timer capture raw value from QSM (5 refs) */
#define timer_capture_average (*(volatile uint16_t*)0x0080975CUL) /* Timer capture average value for fuel temp calc ... */
#define timer_capture_countdown (*(volatile uint16_t*)0x00809760UL) /* Timer capture countdown for averaging (4 refs) */
#define vp44_fault_mode_flags (*(volatile uint16_t*)0x00809762UL) /* VP44 fault mode enable flags bitmap (5 refs) */
#define vp44_fault_threshold_calc (*(volatile uint16_t*)0x00809764UL) /* VP44 fault threshold calculated value (4 refs) */
#define oil_pressure_debounce_counter (*(volatile uint16_t*)0x00809766UL) /* Debounce counter for oil pressure monitoring */
#define governor_reference_fuel (*(volatile uint16_t*)0x00809768UL) /* Reference fuel value for governor calculations */
#define vp44_injection_timing_state (*(volatile uint16_t*)0x0080976AUL) /* VP44 injection timing slow cycle coordinator st... */
#define vp44_injection_timing_counter (*(volatile uint16_t*)0x0080976CUL) /* VP44 injection timing slow cycle counter (5 refs) */
#define schedule_armed (*(volatile uint16_t*)0x0080976EUL) /* Scheduler enable flag - when set enables main l... */
#define scheduler_overrun_counter (*(volatile uint16_t*)0x00809770UL) /* Scheduler phase overrun event counter (3 refs) */
#define scheduler_wait_loop_counter (*(volatile uint16_t*)0x00809772UL) /* Scheduler wait loop iteration counter (2 refs) */
#define scheduler_wait_loop_limit (*(volatile uint16_t*)0x00809776UL) /* Scheduler wait loop iteration limit (2 refs) */
#define scheduler_wait_loop_index (*(volatile uint16_t*)0x00809778UL) /* Scheduler wait loop current index (3 refs) */
#define scheduler_phase_slot_count (*(volatile uint16_t*)0x0080977AUL) /* Scheduler phase slot count config (1 ref) */
#define scheduler_phase_timeout (*(volatile uint16_t*)0x0080977CUL) /* Scheduler phase timeout value config (1 ref) */
#define scheduler_overrun_threshold (*(volatile uint16_t*)0x0080977EUL) /* Scheduler phase overrun threshold limit (2 refs) */
#define scheduler_tick_interval (*(volatile uint16_t*)0x00809780UL) /* Scheduler tick interval config (1 ref) */
#define scheduler_phase_table (*(volatile scheduler_phase_table_t*)0x00809782UL) /* 40-slot task scheduler phase table (16 bytes pe... */
#define output_control_state_flags (*(volatile uint8_t*)0x00809A03UL) /* Output control state machine flags */
#define output_control_timer_value (*(volatile uint16_t*)0x00809A04UL) /* Output control timer current value */
#define output_control_timing_value (*(volatile uint16_t*)0x00809A06UL) /* Output control state 4 handler timing value (12... */
#define output_control_timing_state_9a08 (*(volatile uint16_t*)0x00809A08UL) /* Output control timing generator state (1=mode A... */
#define vp44_communication_status_9a0a (*(volatile uint16_t*)0x00809A0AUL) /* VP44 pump communication/operating status (9 refs) */
#define engine_mode_output_control_state_9a0c (*(volatile uint16_t*)0x00809A0CUL) /* Engine mode output control state machine value ... */
#define output_control_state_4_write_flag (*(volatile uint16_t*)0x00809A0EUL) /* Output control state 4 write flag (outputContro... */
#define sensor_fault_rpm_source_value (*(volatile uint16_t*)0x00809A10UL) /* Sensor fault-based RPM source selector output v... */
#define sensor_fault_rpm_threshold (*(volatile uint16_t*)0x00809A12UL) /* Sensor fault RPM threshold calculated value (4 ... */
#define rpm_load_parameter_lookup_result (*(volatile uint16_t*)0x00809A32UL) /* RPM load parameter lookup result (5 refs) */
#define fuel_demand_limit_previous (*(volatile uint16_t*)0x00809A34UL) /* Fuel demand limit previous value before selecto... */
#define rpm_derate_percent_scaled (*(volatile uint16_t*)0x00809A36UL) /* Scaled RPM derate percentage (multiplied by 80) */
#define rpm_derate_scaling_factor (*(volatile uint16_t*)0x00809A38UL) /* RPM derate percent scaling factor (1 ref) */
#define derate_rpm_adjustment (*(volatile uint16_t*)0x00809A3AUL) /* Derate RPM adjustment value */
#define rpm_derate_duty_cycle (*(volatile uint16_t*)0x00809A3CUL) /* RPM derate duty cycle output value */
#define derate_rpm_limit_low (*(volatile uint16_t*)0x00809A3EUL) /* Derate RPM limit lower bound */
#define derate_rpm_limit_high (*(volatile uint16_t*)0x00809A40UL) /* Derate RPM limit upper bound */
#define vp44_msg_300_fault_fuel_limit_2 (*(volatile uint16_t*)0x00809A42UL) /* VP44 msg 300 fault 2 fuel limit (5 refs) */
#define vp44_fso_bit0_fuel_limit (*(volatile uint16_t*)0x00809A44UL) /* VP44 FSO bit 0 fuel limit output (5 refs) */
#define vp44_msg_300_fault_fuel_limit_1 (*(volatile uint16_t*)0x00809A46UL) /* VP44 msg 300 fault 1 fuel limit (5 refs) */
#define fso_protection_fuel_limit (*(volatile uint16_t*)0x00809A48UL) /* FSO protection fuel limit value */
#define vp44_fso_bit15_fuel_limit (*(volatile uint16_t*)0x00809A4AUL) /* VP44 FSO bit 15 fuel limit output (5 refs) */
#define vp44_fso_fuel_limit_output (*(volatile uint16_t*)0x00809A4CUL) /* VP44 FSO fuel limit output value (4 refs) */
#define vp44_timing_mode_selector (*(volatile uint16_t*)0x00809A4EUL) /* VP44 timing fault mode selector (10 refs) */
#define lift_pump_combined_fuel_value (*(volatile uint16_t*)0x00809A50UL) /* Lift pump combined fuel value (1 ref) */
#define vp44_timing_intermediate_value (*(volatile uint16_t*)0x00809A52UL) /* VP44 timing intermediate calculation value (5 r... */
#define vp44_timing_final_value (*(volatile uint16_t*)0x00809A54UL) /* VP44 timing final calculated value (6 refs) */
#define fso_monitoring_command_value (*(volatile uint16_t*)0x00809A58UL) /* FSO monitoring command value */
#define lift_pump_table_lookup_result (*(volatile uint16_t*)0x00809A5AUL) /* Lift pump table interpolation result (2 refs) */
#define vp44_can_msg_100_timing_value (*(volatile uint16_t*)0x00809A5CUL) /* VP44 CAN msg 100 timing value (2 refs) */
#define vp44_can_msg_100_status_flags (*(volatile uint16_t*)0x00809A5EUL) /* VP44 CAN msg 100 status flags (8 refs) */
#define vp44_status_register_9a5f (*(volatile uint8_t*)0x00809A5FUL) /* VP44 status register from CAN message byte 7 - ... */
#define vp44_can_msg_200_word_0 (*(volatile uint16_t*)0x00809A60UL) /* VP44 CAN msg 200 parsed word 0 (4 refs) */
#define vp44_can_msg_200_word_1 (*(volatile uint16_t*)0x00809A62UL) /* VP44 CAN msg 200 parsed word 1 (2 refs) */
#define vp44_can_msg_200_word_2_copy (*(volatile uint16_t*)0x00809A64UL) /* VP44 CAN msg 200 parsed word 2 copy (2 refs) */
#define vp44_can_msg_200_word_3 (*(volatile uint16_t*)0x00809A66UL) /* VP44 CAN msg 200 parsed word 3 (2 refs) */
#define lift_pump_fuel_offset_calc (*(volatile uint16_t*)0x00809A68UL) /* Lift pump fuel offset calculation (3 refs) */
#define vp44_can_msg_300_fault_flags (*(volatile uint8_t*)0x00809A6BUL) /* VP44 CAN msg 300 fault flags byte (8 refs) */
#define vp44_timing_base_offset (*(volatile uint16_t*)0x00809A6CUL) /* VP44 timing base offset from table (2 refs) */
#define vp44_can_msg_200_combined_value (*(volatile uint32_t*)0x00809A6EUL) /* VP44 CAN msg 200 combined value (7 refs) */
#define vp44_can_msg_200_max_value (*(volatile uint32_t*)0x00809A72UL) /* VP44 CAN msg 200 maximum tracked value (3 refs) */
#define vp44_can_msg_200_min_value (*(volatile uint32_t*)0x00809A76UL) /* VP44 CAN msg 200 minimum tracked value (7 refs) */
#define lift_pump_timing_delta (*(volatile uint16_t*)0x00809A7AUL) /* Lift pump timing delta from previous (7 refs) */
#define vp44_timing_range_table_ptr (*(volatile uint16_t*)0x00809A7CUL) /* VP44 timing range validation table pointer (vp4... */
#define vp44_fault_protection_can_id_1 (*(volatile uint16_t*)0x00809A8AUL) /* VP44 fault protection CAN ID 1 0x5559 (vp44Faul... */
#define vp44_timing_system_monitor_ptr (*(volatile uint16_t*)0x00809A8CUL) /* VP44 timing system monitor pointer (vp44FaultPr... */
#define vp44_fault_protection_mask_1 (*(volatile uint16_t*)0x00809A8EUL) /* VP44 fault protection mask 1 (vp44FaultProtecti... */
#define vp44_fault_protection_flags_1 (*(volatile uint8_t*)0x00809A90UL) /* VP44 fault protection flags 1 0x88 (vp44FaultPr... */
#define vp44_timing_cmd_out_low_byte (*(volatile uint8_t*)0x00809A91UL) /* VP44 timing command output low byte (3 refs) */
#define vp44_timing_cmd_out_high_byte (*(volatile uint8_t*)0x00809A92UL) /* VP44 timing command output high byte (3 refs) */
#define vp44_feedback_pulse_out_low_byte (*(volatile uint8_t*)0x00809A93UL) /* VP44 feedback pulse output low byte (1 ref) */
#define vp44_feedback_pulse_out_high_byte (*(volatile uint8_t*)0x00809A94UL) /* VP44 feedback pulse output high byte (1 ref) */
#define vp44_timing_range_out_low_byte (*(volatile uint8_t*)0x00809A95UL) /* VP44 timing range output low byte (1 ref) */
#define vp44_timing_range_out_high_byte (*(volatile uint8_t*)0x00809A96UL) /* VP44 timing range output high byte (1 ref) */
#define vp44_fuel_demand_out_low_byte (*(volatile uint8_t*)0x00809A97UL) /* VP44 fuel demand output low byte (1 ref) */
#define vp44_fuel_demand_out_high_byte (*(volatile uint8_t*)0x00809A98UL) /* VP44 fuel demand output high byte (1 ref) */
#define vp44_fault_protection_can_id_2 (*(volatile uint16_t*)0x00809A9AUL) /* VP44 fault protection CAN ID 2 0x9955 (vp44Faul... */
#define vp44_fault_protection_addr_2 (*(volatile uint16_t*)0x00809A9CUL) /* VP44 fault protection address 2 0x2240 (vp44Fau... */
#define vp44_fault_protection_mask_2 (*(volatile uint16_t*)0x00809A9EUL) /* VP44 fault protection mask 2 (vp44FaultProtecti... */
#define vp44_fault_protection_flags_2 (*(volatile uint8_t*)0x00809AA0UL) /* VP44 fault protection flags 2 0x80 (vp44FaultPr... */
#define vp44_can_msg_100_byte_0 (*(volatile uint8_t*)0x00809AA1UL) /* VP44 CAN msg 100 raw byte 0 (2 refs) */
#define vp44_can_msg_100_byte_1 (*(volatile uint8_t*)0x00809AA2UL) /* VP44 CAN msg 100 raw byte 1 (2 refs) */
#define vp44_can_msg_100_byte_2 (*(volatile uint8_t*)0x00809AA3UL) /* VP44 CAN msg 100 raw byte 2 (2 refs) */
#define vp44_can_msg_100_byte_3 (*(volatile uint8_t*)0x00809AA4UL) /* VP44 CAN msg 100 raw byte 3 (2 refs) */
#define vp44_can_msg_100_byte_4 (*(volatile uint8_t*)0x00809AA5UL) /* VP44 CAN msg 100 raw byte 4 (1 ref) */
#define vp44_can_msg_100_byte_5 (*(volatile uint8_t*)0x00809AA6UL) /* VP44 CAN msg 100 raw byte 5 (1 ref) */
#define vp44_can_msg_100_byte_6 (*(volatile uint8_t*)0x00809AA7UL) /* VP44 CAN msg 100 raw byte 6 (1 ref) */
#define vp44_can_msg_100_byte_7 (*(volatile uint8_t*)0x00809AA8UL) /* VP44 CAN msg 100 raw byte 7 (1 ref) */
#define vp44_fault_protection_can_id_3 (*(volatile uint16_t*)0x00809AAAUL) /* VP44 fault protection CAN ID 3 0x5559 (vp44Faul... */
#define vp44_fault_protection_addr_3 (*(volatile uint16_t*)0x00809AACUL) /* VP44 fault protection address 3 0xa000 (vp44Fau... */
#define vp44_fault_protection_mask_3 (*(volatile uint16_t*)0x00809AAEUL) /* VP44 fault protection mask 3 (vp44FaultProtecti... */
#define vp44_fault_protection_flags_3 (*(volatile uint8_t*)0x00809AB0UL) /* VP44 fault protection flags 3 0x88 (vp44FaultPr... */
#define vp44_can_msg_100_tx_byte_7 (*(volatile uint8_t*)0x00809AB1UL) /* VP44 CAN msg 100 transmit byte 7 */
#define vp44_can_msg_100_tx_byte_6 (*(volatile uint8_t*)0x00809AB2UL) /* VP44 CAN msg 100 transmit byte 6 */
#define vp44_can_msg_100_tx_byte_5 (*(volatile uint8_t*)0x00809AB3UL) /* VP44 CAN msg 100 transmit byte 5 */
#define vp44_can_msg_100_tx_byte_4 (*(volatile uint8_t*)0x00809AB4UL) /* VP44 CAN msg 100 transmit byte 4 */
#define vp44_can_msg_100_tx_byte_3 (*(volatile uint8_t*)0x00809AB5UL) /* VP44 CAN msg 100 transmit byte 3 */
#define vp44_can_msg_100_tx_byte_2 (*(volatile uint8_t*)0x00809AB6UL) /* VP44 CAN msg 100 transmit byte 2 */
#define vp44_can_msg_100_tx_byte_1 (*(volatile uint8_t*)0x00809AB7UL) /* VP44 CAN msg 100 transmit byte 1 */
#define vp44_can_msg_100_tx_byte_0 (*(volatile uint8_t*)0x00809AB8UL) /* VP44 CAN msg 100 transmit byte 0 */
#define vp44_fault_protection_can_id_4 (*(volatile uint16_t*)0x00809ABAUL) /* VP44 fault protection CAN ID 4 0x9955 (vp44Faul... */
#define vp44_fault_protection_addr_4 (*(volatile uint16_t*)0x00809ABCUL) /* VP44 fault protection address 4 0xa240 (vp44Fau... */
#define vp44_fault_protection_mask_4 (*(volatile uint16_t*)0x00809ABEUL) /* VP44 fault protection mask 4 (vp44FaultProtecti... */
#define vp44_fault_protection_flags_4 (*(volatile uint8_t*)0x00809AC0UL) /* VP44 fault protection flags 4 0x80 (vp44FaultPr... */
#define vp44_can_msg_200_byte_0 (*(volatile uint8_t*)0x00809AC1UL) /* VP44 CAN msg 200 raw byte 0 (2 refs) */
#define vp44_can_msg_200_byte_1 (*(volatile uint8_t*)0x00809AC2UL) /* VP44 CAN message 200 parsed byte 1 (vp44CanMess... */
#define vp44_can_msg_200_byte_2 (*(volatile uint8_t*)0x00809AC3UL) /* VP44 CAN message 200 parsed byte 2 (vp44CanMess... */
#define vp44_can_msg_200_byte_3 (*(volatile uint8_t*)0x00809AC4UL) /* VP44 CAN message 200 parsed byte 3 (vp44CanMess... */
#define vp44_can_msg_200_byte_4 (*(volatile uint8_t*)0x00809AC5UL) /* VP44 CAN message 200 parsed byte 4 (vp44CanMess... */
#define vp44_can_msg_200_byte_5 (*(volatile uint8_t*)0x00809AC6UL) /* VP44 CAN message 200 parsed byte 5 (vp44CanMess... */
#define vp44_can_msg_200_byte_6 (*(volatile uint8_t*)0x00809AC7UL) /* VP44 CAN message 200 parsed byte 6 (vp44CanMess... */
#define vp44_can_msg_200_byte_7 (*(volatile uint8_t*)0x00809AC8UL) /* VP44 CAN message 200 parsed byte 7 (vp44CanMess... */
#define vp44_fault_protection_can_id_5 (*(volatile uint16_t*)0x00809ACAUL) /* VP44 fault protection CAN ID 5 0x5559 (vp44Faul... */
#define vp44_fault_protection_addr_5 (*(volatile uint16_t*)0x00809ACCUL) /* VP44 fault protection address 5 0xe000 (vp44Fau... */
#define vp44_fault_protection_mask_5 (*(volatile uint16_t*)0x00809ACEUL) /* VP44 fault protection mask 5 (vp44FaultProtecti... */
#define vp44_fault_protection_flags_5 (*(volatile uint8_t*)0x00809AD0UL) /* VP44 fault protection flags 5 0x88 (vp44FaultPr... */
#define vp44_can_msg_200_parsed_byte_8 (*(volatile uint8_t*)0x00809AD1UL) /* VP44 CAN message 200 parsed byte 8 (vp44CanMess... */
#define vp44_can_msg_200_parsed_byte_9 (*(volatile uint8_t*)0x00809AD2UL) /* VP44 CAN message 200 parsed byte 9 (vp44CanMess... */
#define vp44_can_msg_200_parsed_byte_10 (*(volatile uint8_t*)0x00809AD3UL) /* VP44 CAN message 200 parsed byte 10 (vp44CanMes... */
#define vp44_can_msg_200_parsed_byte_11 (*(volatile uint8_t*)0x00809AD4UL) /* VP44 CAN message 200 parsed byte 11 (vp44CanMes... */
#define vp44_can_msg_200_parsed_byte_12 (*(volatile uint8_t*)0x00809AD5UL) /* VP44 CAN message 200 parsed byte 12 (vp44CanMes... */
#define vp44_can_msg_200_parsed_byte_13 (*(volatile uint8_t*)0x00809AD6UL) /* VP44 CAN message 200 parsed byte 13 (vp44CanMes... */
#define vp44_can_msg_200_parsed_byte_14 (*(volatile uint8_t*)0x00809AD7UL) /* VP44 CAN message 200 parsed byte 14 (vp44CanMes... */
#define vp44_can_msg_200_parsed_byte_15 (*(volatile uint8_t*)0x00809AD8UL) /* VP44 CAN message 200 parsed byte 15 (vp44CanMes... */
#define vp44_fault_protection_can_id_6 (*(volatile uint16_t*)0x00809ADAUL) /* VP44 fault protection CAN ID 6 0x9955 (vp44Faul... */
#define vp44_fault_protection_addr_6 (*(volatile uint16_t*)0x00809ADCUL) /* VP44 fault protection address 6 0xe240 (vp44Fau... */
#define vp44_fault_protection_mask_6 (*(volatile uint16_t*)0x00809ADEUL) /* VP44 fault protection mask 6 (vp44FaultProtecti... */
#define vp44_fault_protection_flags_6 (*(volatile uint8_t*)0x00809AE0UL) /* VP44 fault protection flags 6 0x80 (vp44FaultPr... */
#define vp44_can_msg_300_fault_flags_copy (*(volatile uint8_t*)0x00809AE1UL) /* VP44 CAN msg 300 fault flags copy (2 refs) */
#define vp44_can_msg_300_byte_1 (*(volatile uint8_t*)0x00809AE2UL) /* VP44 CAN msg 300 raw byte 1 (1 ref) */
#define vp44_can_msg_300_byte_2 (*(volatile uint8_t*)0x00809AE3UL) /* VP44 CAN msg 300 raw byte 2 (1 ref) */
#define vp44_can_msg_300_byte_3 (*(volatile uint8_t*)0x00809AE4UL) /* VP44 CAN msg 300 raw byte 3 (1 ref) */
#define vp44_can_msg_300_byte_4 (*(volatile uint8_t*)0x00809AE5UL) /* VP44 CAN msg 300 raw byte 4 (1 ref) */
#define vp44_can_msg_300_byte_5 (*(volatile uint8_t*)0x00809AE6UL) /* VP44 CAN msg 300 raw byte 5 (1 ref) */
#define vp44_can_msg_300_byte_6 (*(volatile uint8_t*)0x00809AE7UL) /* VP44 CAN msg 300 raw byte 6 (1 ref) */
#define vp44_can_msg_300_byte_7 (*(volatile uint8_t*)0x00809AE8UL) /* VP44 CAN msg 300 raw byte 7 (1 ref) */
#define vp44_fault_protection_state_array (*(volatile uint8_t*)0x00809AEAUL) /* VP44 fault protection state array (vp44FaultPro... */
#define vp44_can_msg_100_mode_bits (*(volatile uint8_t*)0x00809AF0UL) /* VP44 CAN msg 100 mode bits (1 ref) */
#define vp44_timing_table_index (*(volatile uint8_t*)0x00809AF1UL) /* VP44 timing table index selector (4 refs) */
#define vp44_can_msg_200_word_2 (*(volatile uint16_t*)0x00809AF2UL) /* VP44 CAN msg 200 parsed word 2 (3 refs) */
#define vp44_timing_actual_value (*(volatile uint16_t*)0x00809AF4UL) /* VP44 timing fault actual value (4 refs) */
#define lift_pump_run_time_calculated (*(volatile uint16_t*)0x00809AF6UL) /* Lift pump calculated run time (2 refs) */
#define vp44_fso_circuit_fault_fuel_limit (*(volatile uint16_t*)0x00809AF8UL) /* VP44 FSO circuit fault fuel limit (6 refs) */
#define vp44_timing_expected_value (*(volatile uint16_t*)0x00809AFAUL) /* VP44 timing fault expected value (4 refs) */
#define vp44_timing_error_delta (*(volatile uint16_t*)0x00809AFCUL) /* VP44 timing error delta (5 refs) */
#define vp44_can_msg_200_last_word (*(volatile uint16_t*)0x00809AFEUL) /* VP44 CAN msg 200 last word copy (2 refs) */
#define vp44_rpm_based_fault_state (*(volatile uint16_t*)0x00809B00UL) /* VP44 RPM-based fault detector state (2 refs) */
#define dzg_pressure_control_state (*(volatile uint16_t*)0x00809B02UL) /* DZG pressure control state variable (9 refs) */
#define vp44_sensor_diagnostic_write_state (*(volatile uint16_t*)0x00809B04UL) /* VP44 sensor diagnostic control write state (5 r... */
#define vp44_sensor_diagnostic_read_state (*(volatile uint16_t*)0x00809B06UL) /* VP44 sensor diagnostic control read state (3 refs) */
#define dzg_timing_pressure_state_2 (*(volatile uint16_t*)0x00809B08UL) /* DZG timing and pressure control state variable ... */
#define dzg_timing_pressure_state_1 (*(volatile uint16_t*)0x00809B0AUL) /* DZG timing and pressure control state variable ... */
#define fuel_cylinder_average (*(volatile uint16_t*)0x00809B0CUL) /* Fuel cylinder exponential moving average (2 refs) */
#define time_delta_calculator_state (*(volatile uint16_t*)0x00809B0EUL) /* Time delta calculator state (timeDeltaCalculator) */
#define hour_meter_conversion_data (*(volatile uint32_t*)0x00809B10UL) /* Hour meter conversion data accumulator (12 refs) */
#define engine_runtime_histogram_counter (*(volatile uint32_t*)0x00809B14UL) /* Engine runtime histogram accumulator counter (9... */
#define engine_runtime_histogram_value (*(volatile uint16_t*)0x00809B18UL) /* Engine runtime histogram calculated value - acc... */
#define engine_runtime_histogram_index (*(volatile uint8_t*)0x00809B1AUL) /* Engine runtime histogram bin index - accessed v... */
#define engine_runtime_histogram_mode (*(volatile ENGINE_HISTOGRAM_MODE*)0x00809B1BUL) /* Engine runtime histogram mode flag (A4 register) */
#define hour_meter_conversion_init_value_1 (*(volatile uint16_t*)0x00809B1CUL) /* Hour meter conversion init value 1 (initHourMet... */
#define hour_meter_conversion_data_1 (*(volatile uint32_t*)0x00809B1EUL) /* Hour meter conversion data buffer 1 (writeHourM... */
#define hour_meter_conversion_init_value_2 (*(volatile uint16_t*)0x00809BE6UL) /* Hour meter conversion init value 2 (initHourMet... */
#define hour_meter_conversion_data_2 (*(volatile uint32_t*)0x00809BE8UL) /* Hour meter conversion data buffer 2 (writeHourM... */
#define fuel_timing_mode_arbitration_param_1 (*(volatile uint16_t*)0x00809CB2UL) /* Fuel timing mode arbitration param 1 (fuelTimin... */
#define fuel_timing_mode_arbitration_param_2 (*(volatile uint16_t*)0x00809CBCUL) /* Fuel timing mode arbitration param 2 (fuelTimin... */
#define governor_mode_init_error_prev (*(volatile uint16_t*)0x00809CBEUL) /* Governor mode 1 init previous error (2 refs) */
#define governor_mode_init_integral (*(volatile uint16_t*)0x00809CC0UL) /* Governor mode 1 init PID integral value (2 refs) */
#define governor_mode_init_rpm_ref (*(volatile uint16_t*)0x00809CC2UL) /* Governor mode 1 init RPM reference (2 refs) */
#define governor_mode_init_deriv_prev (*(volatile uint16_t*)0x00809CC4UL) /* Governor mode 1 init derivative term previous (... */
#define governor_mode_init_output_prev (*(volatile uint16_t*)0x00809CC6UL) /* Governor mode 1 init PID output previous (2 refs) */
#define governor_mode_init_fuel_delta (*(volatile uint16_t*)0x00809CC8UL) /* Governor mode 1 init fuel command delta (2 refs) */
#define diag_governor_copy_enable_flag (*(volatile uint16_t*)0x00809CCAUL) /* Diagnostic governor copy enable flag (1 ref) */
#define diag_governor_target_rpm_source (*(volatile uint16_t*)0x00809CCCUL) /* Diagnostic governor target RPM source (1 ref) */
#define diag_governor_blend_factor_1 (*(volatile uint16_t*)0x00809CCEUL) /* Diagnostic governor blend factor 1 source (1 ref) */
#define diag_governor_blend_factor_2 (*(volatile uint16_t*)0x00809CD0UL) /* Diagnostic governor blend factor 2 source (1 ref) */
#define diag_governor_output_upper_limit (*(volatile uint16_t*)0x00809CD4UL) /* Diagnostic governor output upper limit source (... */
#define diag_governor_output_lower_limit (*(volatile uint16_t*)0x00809CD6UL) /* Diagnostic governor output lower limit source (... */
#define diag_governor_mode_state_source (*(volatile uint16_t*)0x00809CD8UL) /* Diagnostic governor mode state source (1 ref) */
#define diag_governor_error_prev_source (*(volatile uint16_t*)0x00809CDAUL) /* Diagnostic governor error previous source (1 ref) */
#define diag_governor_integral_source (*(volatile uint16_t*)0x00809CDCUL) /* Diagnostic governor integral source (1 ref) */
#define diag_governor_rpm_ref_source (*(volatile uint16_t*)0x00809CDEUL) /* Diagnostic governor RPM reference source (1 ref) */
#define diag_governor_deriv_prev_source (*(volatile uint16_t*)0x00809CE0UL) /* Diagnostic governor derivative previous source ... */
#define diagnostic_data_copy_source (*(volatile uint16_t*)0x00809CE2UL) /* Diagnostic data copy source offset (diagnosticD... */
#define diagnostic_data_copy_dest (*(volatile uint16_t*)0x00809CE4UL) /* Diagnostic data copy destination offset (diagno... */
#define governor_derivative_filtered (*(volatile uint16_t*)0x00809CF8UL) /* Governor filtered derivative term */
#define governor_rpm_error_delta (*(volatile uint16_t*)0x00809CFAUL) /* Governor RPM error rate of change */
#define governor_rpm_change_rate (*(volatile uint16_t*)0x00809CFCUL) /* Governor RPM change since last sample */
#define target_engine_rpm (*(volatile uint16_t*)0x00809CFEUL) /* Governor calculated target engine RPM */
#define governor_mode_changed_flag (*(volatile uint16_t*)0x00809D00UL) /* Flag indicating governor mode has changed */
#define governor_output_clamped (*(volatile uint16_t*)0x00809D02UL) /* Governor output after clamping */
#define governor_rpm_error (*(volatile uint16_t*)0x00809D04UL) /* Governor RPM error (target - current) */
#define governor_pid_intermediate (*(volatile uint16_t*)0x00809D06UL) /* Governor PID intermediate calculation result */
#define governor_pid_derivative_term_9d08 (*(volatile uint16_t*)0x00809D08UL) /* Governor PID derivative term output */
#define governor_pid_combined_output (*(volatile uint16_t*)0x00809D0AUL) /* Governor PID combined output (P+D) */
#define governor_fuel_command_delta (*(volatile uint16_t*)0x00809D0CUL) /* Governor fuel command differential for PID */
#define governor_interpolation_input_1 (*(volatile uint16_t*)0x00809D0EUL) /* Governor interpolation input value 1 (5 refs) */
#define target_rpm_scaled (*(volatile uint32_t*)0x00809D12UL) /* Target RPM scaled value */
#define diagnostic_target_rpm_setpoint (*(volatile uint16_t*)0x00809D1AUL) /* Diagnostic mode target RPM setpoint (10 refs) */
#define governor_blend_factor_1 (*(volatile uint16_t*)0x00809D1CUL) /* Governor calculation blending factor 1 */
#define governor_blend_factor_2 (*(volatile uint16_t*)0x00809D1EUL) /* Governor calculation blending factor 2 */
#define diag_governor_blend_result_1 (*(volatile uint16_t*)0x00809D20UL) /* Diagnostic governor blend calculation result 1 ... */
#define diag_governor_blend_result_2 (*(volatile uint16_t*)0x00809D22UL) /* Diagnostic governor blend calculation result 2 ... */
#define diag_interpolation_result (*(volatile uint16_t*)0x00809D24UL) /* Diagnostic table interpolation result (3 refs) */
#define governor_output_upper_limit (*(volatile uint16_t*)0x00809D26UL) /* Governor output upper clamp limit */
#define governor_output_lower_limit (*(volatile uint16_t*)0x00809D28UL) /* Governor output lower clamp limit */
#define governor_mode_state (*(volatile uint16_t*)0x00809D2AUL) /* Governor mode state flag */
#define governor_speed_setpoint (*(volatile uint16_t*)0x00809D32UL) /* Governor speed setpoint value */
#define diagnostic_command_state (*(volatile uint16_t*)0x00809D3EUL) /* Diagnostic command state machine */
#define retarder_scaled_percentage_output (*(volatile uint16_t*)0x00809D40UL) /* Retarder percentage scaled output (0-32000) (7 ... */
#define throttle_validation_result_1 (*(volatile uint16_t*)0x00809D42UL) /* Throttle validation result 1 (1 ref) */
#define throttle_validation_result_2 (*(volatile uint16_t*)0x00809D44UL) /* Throttle validation result 2 (2 refs) */
#define serial_port_1_isr_counter (*(volatile uint16_t*)0x00809D46UL) /* Serial port 1 ISR handler counter (serialPort1I... */
#define serial_port_2_status_byte (*(volatile uint8_t*)0x00809D47UL) /* Serial port 2 status byte (2 refs) */
#define serial_node_address_offset (*(volatile uint16_t*)0x00809D48UL) /* Serial/CAN node address iterator (increments by... */
#define serial_port_1_isr_state (*(volatile uint16_t*)0x00809D4AUL) /* Serial port 1 ISR handler state (serialPort1Isr... */
#define proprietary_load_percent (*(volatile uint16_t*)0x00809D4CUL) /* Proprietary load percentage 0-400 (0-100%) for ... */
#define derate_threshold_monitor_value (*(volatile uint16_t*)0x00809D4EUL) /* Derate threshold monitor calculated value (21 r... */
#define proprietary_load_active_flag (*(volatile uint16_t*)0x00809D50UL) /* Flag indicating proprietary load calculation is... */
#define derate_fault_controller_value (*(volatile uint16_t*)0x00809D52UL) /* Derate fault controller calculated value (11 refs) */
#define derate_threshold_monitor_state (*(volatile uint16_t*)0x00809D54UL) /* Derate threshold monitor and fault controller s... */
#define derate_threshold_state_counter (*(volatile uint16_t*)0x00809D56UL) /* Derate threshold monitor state counter (11 refs) */
#define derate_fault_recovery_state (*(volatile uint16_t*)0x00809D58UL) /* Derate fault recovery controller state (9 refs) */
#define derate_protection_timer (*(volatile uint16_t*)0x00809D5AUL) /* Derate protection coordinator timer (9 refs) */
#define proprietary_load_calculated (*(volatile uint16_t*)0x00809D5CUL) /* Calculated proprietary load value before fault ... */
#define load_from_parameter (*(volatile uint16_t*)0x00809D62UL) /* Load value from parameter lookup */
#define timing_table_lookup_result (*(volatile uint16_t*)0x00809D66UL) /* Result from timing table lookup */
#define rpm_delta_for_timing (*(volatile uint16_t*)0x00809D68UL) /* RPM delta used for timing calculation */
#define oil_pressure_protection_snapshot (*(volatile uint16_t*)0x00809D6AUL) /* Oil pressure protection threshold snapshot valu... */
#define cold_start_fuel_control_state (*(volatile uint16_t*)0x00809D6CUL) /* Cold start fuel control coordinator state (10 r... */
#define cold_start_fuel_control_mode (*(volatile uint8_t*)0x00809D6EUL) /* Cold start fuel control slow cycle mode indicat... */
#define cold_start_fuel_limit_value (*(volatile uint16_t*)0x00809D70UL) /* Cold start fuel limit value for proportional ca... */
#define vp44_next_read_address (*(volatile uint32_t*)0x00809D7EUL) /* VP44 next read address in circular buffer (1 ref) */
#define can1_timer_buffer_init_value (*(volatile uint16_t*)0x00809D88UL) /* CAN1 timer buffer init value (can1TimerBufferIn... */
#define enable_for_the_executive_timing_data_gatherer_enabled_disabled (*(volatile uint16_t*)0x00809EDEUL) /* ENABLE FOR THE EXECUTIVE TIMING DATA GATHERER. */
#define number_of_times_which_frame_overflow_has_occured_in_executive_0_65535 (*(volatile uint16_t*)0x00809EE0UL) /* NUMBER OF TIMES WHICH FRAME OVERFLOW HAS OCCURE... */
#define number_of_loop_delays_cal_0_65535 (*(volatile uint16_t*)0x00809EE6UL) /* NUMBER OF LOOP DELAYS CAL */
#define loop_counter_for_idle_loop_0_65535 (*(volatile uint16_t*)0x00809EE8UL) /* LOOP COUNTER FOR IDLE LOOP. */
#define SSECTMHE ((volatile uint8_t*)0x00809EEAUL) /* [8] CalTerm SSECTMHE: ACCESS TO BLOCK STRUCTURE WHI... */
#define SSECTMDX ((volatile uint8_t*)0x00809EF2UL) /* [640] CalTerm SSECTMDX: ACCESS TO BLOCK STRUCTURE WHI... */
#define fuel_limit_from_pump_analog_error_algorithm_0_to_300 (*(volatile uint16_t*)0x0080A172UL) /* FUEL LIMIT FROM PUMP ANALOG ERROR ALGORITHM */
#define fuel_limit_from_fuel_solenoid_error_algorithm_0_to_300 (*(volatile uint16_t*)0x0080A174UL) /* FUEL LIMIT FROM FUEL SOLENOID ERROR ALGORITHM */
#define fuel_limit_from_pump_eeprom_error_algorithm_0_to_300 (*(volatile uint16_t*)0x0080A176UL) /* FUEL LIMIT FROM PUMP EEPROM ERROR ALGORITHM */
#define fuel_limit_from_fuel_temp_error_algorithm_0_to_300 (*(volatile uint16_t*)0x0080A178UL) /* FUEL LIMIT FROM FUEL TEMP ERROR ALGORITHM */
#define fuel_limit_from_vp44_engine_sync_error_algorithm_0_to_300 (*(volatile uint16_t*)0x0080A17AUL) /* FUEL LIMIT FROM VP44_ENGINE_SYNC ERROR ALGORITHM */
#define fuel_limit_from_timing_error_algorithm_0_to_300 (*(volatile uint16_t*)0x0080A17CUL) /* FUEL LIMIT FROM TIMING ERROR ALGORITHM */
#define output_of_line_delay_table_60_to_60 (*(volatile uint16_t*)0x0080A18AUL) /* OUTPUT OF LINE DELAY TABLE */
#define ram_image_of_metering_valve_duration_from_pump_controller_0_to_96 (*(volatile uint16_t*)0x0080A18CUL) /* RAM IMAGE OF METERING VALVE DURATION FROM PUMP ... */
#define pump_ram_contents_at_ram_address_1_0_to_ffff (*(volatile uint16_t*)0x0080A190UL) /* PUMP RAM CONTENTS AT RAM_ADDRESS_1 */
#define pump_ram_contents_at_ram_address_2_0_to_ffff (*(volatile uint16_t*)0x0080A192UL) /* PUMP RAM CONTENTS AT RAM_ADDRESS_2 */
#define pump_ram_contents_at_ram_address_3_0_to_ffff (*(volatile uint16_t*)0x0080A194UL) /* PUMP RAM CONTENTS AT RAM_ADDRESS_3 */
#define pump_ram_contents_at_ram_address_4_0_to_ffff (*(volatile uint16_t*)0x0080A196UL) /* PUMP RAM CONTENTS AT RAM_ADDRESS_4 */
#define ram_image_of_self_test_results_contained_in_start_up_pump_me_0_to_ffff (*(volatile uint16_t*)0x0080A19AUL) /* RAM IMAGE OF SELF TEST RESULTS CONTAINED IN STA... */
#define maximum_observed_pump_measured_ring_cam_position_0_to_ffffffff (*(volatile uint32_t*)0x0080A1A2UL) /* MAXIMUM OBSERVED PUMP-MEASURED RING CAM POSITION */
#define minimum_observed_pump_measured_ring_cam_position_0_to_ffffffff (*(volatile uint32_t*)0x0080A1A6UL) /* MINIMUM OBSERVED PUMP-MEASURED RING CAM POSITION */
#define first_4_bytes_of_ecm_to_pcm_fuel_timing_command_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A1C1UL) /* 1ST 4 BYTES OF ECM TO PCM FUEL & TIMING COMMAND... */
#define last_4_bytes_of_ecm_to_pcm_fuel_timing_command_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A1C5UL) /* LAST 4 BYTES OF ECM TO PCM FUEL & TIMING COMMAN... */
#define first_4_bytes_of_pcm_to_ecm_cylinder_event_messages_0_to_ffffffff (*(volatile uint32_t*)0x0080A1D1UL) /* 1ST 4 BYTES OF PCM TO ECM CYLINDER EVENT MESSAGES */
#define last_4_bytes_of_pcm_to_ecm_cylinder_event_messages_0_to_ffffffff (*(volatile uint32_t*)0x0080A1D5UL) /* LAST 4 BYTES OF PCM TO ECM CYLINDER EVENT MESSAGES */
#define first_4_bytes_of_ecm_to_pcm_ram_request_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A1E1UL) /* 1ST 4 BYTES OF ECM TO PCM RAM REQUEST MESSAGE */
#define last_4_bytes_of_ecm_to_pcm_ram_request_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A1E5UL) /* LAST 4 BYTES OF ECM TO PCM RAM REQUEST MESSAGE */
#define first_4_bytes_of_pcm_to_ecm_ram_request_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A1F1UL) /* 1ST 4 BYTES OF PCM TO ECM RAM REQUEST MESSAGE */
#define last_4_bytes_of_pcm_to_ecm_ram_request_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A1F5UL) /* LAST 4 BYTES OF PCM TO ECM RAM REQUEST MESSAGE */
#define first_4_bytes_of_ecm_to_pcm_security_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A201UL) /* 1ST 4 BYTES OF ECM TO PCM SECURITY MESSAGE */
#define last_4_bytes_of_ecm_to_pcm_security_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A205UL) /* LAST 4 BYTES OF ECM TO PCM SECURITY MESSAGE */
#define first_4_bytes_of_pcm_to_ecm_security_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A211UL) /* 1ST 4 BYTES OF PCM TO ECM SECURITY MESSAGE */
#define last_4_bytes_of_pcm_to_ecm_security_message_0_to_ffffffff (*(volatile uint32_t*)0x0080A215UL) /* LAST 4 BYTES OF PCM TO ECM SECURITY MESSAGE */
#define flag_to_enable_or_disable_fueling_for_cyl_1_0_to_ff (*(volatile uint8_t*)0x0080A21AUL) /* FLAG TO ENABLE OR DISABLE FUELING FOR CYL 1 */
#define flag_to_enable_or_disable_fueling_for_cyl_2_0_to_ff (*(volatile uint8_t*)0x0080A21BUL) /* FLAG TO ENABLE OR DISABLE FUELING FOR CYL 2 */
#define flag_to_enable_or_disable_fueling_for_cyl_3_0_to_ff (*(volatile uint8_t*)0x0080A21CUL) /* FLAG TO ENABLE OR DISABLE FUELING FOR CYL 3 */
#define flag_to_enable_or_disable_fueling_for_cyl_4_0_to_ff (*(volatile uint8_t*)0x0080A21DUL) /* FLAG TO ENABLE OR DISABLE FUELING FOR CYL 4 */
#define flag_to_enable_or_disable_fueling_for_cyl_5_0_to_ff (*(volatile uint8_t*)0x0080A21EUL) /* FLAG TO ENABLE OR DISABLE FUELING FOR CYL 5 */
#define flag_to_enable_or_disable_fueling_for_cyl_6_0_to_ff (*(volatile uint8_t*)0x0080A21FUL) /* FLAG TO ENABLE OR DISABLE FUELING FOR CYL 6 */
#define ram_image_of_cylinder_counter_maintained_by_pump_controller_0_to_16 (*(volatile uint8_t*)0x0080A220UL) /* RAM IMAGE OF CYLINDER COUNTER MAINTAINED BY PUM... */
#define next_injected_cylinder_FLCYCU (*(volatile uint8_t*)0x0080A221UL) /* Next injected cylinder parameter from CalTerm F... */
#define filtered_pump_voltage_while_solenoid_is_off_0_to_40 (*(volatile uint16_t*)0x0080A22AUL) /* FILTERED PUMP VOLTAGE WHILE SOLENOID IS OFF */
#define pump_voltage_drop_while_solenoid_is_on_0_to_40 (*(volatile uint16_t*)0x0080A22CUL) /* PUMP VOLTAGE DROP WHILE SOLENOID IS ON */
#define temp_signal_used_in_postheat_0_imt_1_battery_temp_for_chrysler_0_1 (*(volatile uint16_t*)0x0080A262UL) /* TEMP SIGNAL USED IN POSTHEAT (0=IMT/1=BATTERY T... */
#define pre_processed_imt_for_epf_due_to_exhaust_brake_on_50_to_293 (*(volatile uint16_t*)0x0080A26AUL) /* PRE-PROCESSED IMT FOR EPF DUE TO EXHAUST BRAKE ON */
#define timer_used_to_disable_imt_epf_when_exhaust_brake_on_0_65535 (*(volatile uint16_t*)0x0080A26CUL) /* TIMER USED TO DISABLE IMT EPF WHEN EXHAUST BRAK... */
#define output_of_the_misfire_timing_limit_table_60_to_60 (*(volatile uint16_t*)0x0080A26EUL) /* OUTPUT OF THE MISFIRE TIMING LIMIT TABLE [CalTe... */
#define BSTABELM (*(volatile uint16_t*)0x0080A270UL) /* DESIRED SOI BEFORE BEING LIMITED BY MISFIRE ALG... */
#define the_percent_load_override_as_the_output_signal_for_the_transmis_0_255 (*(volatile uint16_t*)0x0080A274UL) /* THE PERCENT LOAD OVERRIDE AS THE OUTPUT SIGNAL ... */
#define DRTXCSKD (*(volatile uint16_t*)0x0080A27AUL) /* CalTerm DRTXCSKD: IF > TRANS_SPEED_KICK_DOWN, T... */
#define DRTXCSKU (*(volatile uint16_t*)0x0080A27CUL) /* CalTerm DRTXCSKU: IF < TRANS_SPEED_KICK_UP, THE... */
#define command_to_a_c_compressor_clutch_solenoid_on_off (*(volatile uint16_t*)0x0080A27EUL) /* COMMAND TO A/C COMPRESSOR CLUTCH SOLENOID [CalT... */
#define rapid_vehicle_accel_flag_on_off (*(volatile uint16_t*)0x0080A280UL) /* RAPID VEHICLE ACCEL FLAG [CalTerm: ACHIAC] */
#define ACSWERCU (*(volatile uint16_t*)0x0080A282UL) /* CalTerm ACSWERCU: COUNTER FOR CYCLE, HIGH PRESS... */
#define duty_cycle_requested_for_pwm_cool_temp_gauge_driver_0_100 (*(volatile uint16_t*)0x0080A284UL) /* DUTY CYCLE REQUESTED FOR PWM COOL TEMP GAUGE DR... */
#define duty_cycle_requested_for_pwm_oil_pressure_gauge_driver_0_100 (*(volatile uint16_t*)0x0080A286UL) /* DUTY CYCLE REQUESTED FOR PWM OIL PRESSURE GAUGE... */
#define filtered_vehicle_acceleration_1200_1200 (*(volatile uint16_t*)0x0080A288UL) /* FILTERED VEHICLE ACCELERATION */
#define engine_acceleration_after_first_stage_low_pass_filtering_2560_2540 (*(volatile uint16_t*)0x0080A294UL) /* ENGINE ACCELERATION AFTER FIRST STAGE LOW PASS ... */
#define engine_acceleration_after_second_stage_low_pass_filtering_2560_2540 (*(volatile uint16_t*)0x0080A296UL) /* ENGINE ACCELERATION AFTER SECOND STAGE LOW PASS... */
#define sstatus_indicating_conditions_proper_for_a_fuel_lim_active_or_inactive (*(volatile uint16_t*)0x0080A298UL) /* SSTATUS INDICATING CONDITIONS PROPER FOR A FUEL... */
#define status_indicating_conditions_proper_for_a_timing_li_active_or_inactive (*(volatile uint16_t*)0x0080A29AUL) /* STATUS INDICATING CONDITIONS PROPER FOR A TIMIN... */
#define status_indicating_conditions_proper_for_a_speed_lim_active_or_inactive (*(volatile uint16_t*)0x0080A29CUL) /* STATUS INDICATING CONDITIONS PROPER FOR A SPEED... */
#define timing_advance_limit_as_just_before_modification_by_anc_timing_0_120 (*(volatile uint16_t*)0x0080A29EUL) /* TIMING ADVANCE LIMIT AS JUST BEFORE MODIFICATIO... */
#define anc_speed_limit_disable_due_to_bare_engine_accel_active_inactive (*(volatile uint16_t*)0x0080A2A0UL) /* ANC SPEED LIMIT DISABLE DUE TO BARE ENGINE ACCEL */
#define anc_fueling_limit_disable_due_to_bare_engine_accel_active_inactive (*(volatile uint16_t*)0x0080A2A2UL) /* ANC FUELING LIMIT DISABLE DUE TO BARE ENGINE ACCEL */
#define anc_timing_limit_disable_due_to_bare_engine_accel_active_inactive (*(volatile uint16_t*)0x0080A2A4UL) /* ANC TIMING LIMIT DISABLE DUE TO BARE ENGINE ACCEL */
#define application_specific_anc_override_flag_1_engage_anc_0_1 (*(volatile uint16_t*)0x0080A2A6UL) /* APPLICATION SPECIFIC ANC OVERRIDE FLAG(1 = ENGA... */
#define application_specific_anc_enable_disable_flag_set_to_false_to_dis_0_1 (*(volatile uint16_t*)0x0080A2A8UL) /* APPLICATION SPECIFIC ANC ENABLE/DISABLE FLAG(SE... */
#define filtered_and_linearized_intake_manifold_temperature_50_to_293 (*(volatile uint16_t*)0x0080A2B2UL) /* FILTERED AND LINEARIZED INTAKE MANIFOLD TEMPERA... */
#define unfiltered_and_linearized_intake_manifold_temperature_50_to_293 (*(volatile uint16_t*)0x0080A2B4UL) /* UNFILTERED AND LINEARIZED INTAKE MANIFOLD TEMPE... */
#define raw_counts_for_intake_manifold_temperature_0_1023 (*(volatile uint16_t*)0x0080A2BAUL) /* RAW COUNTS FOR INTAKE MANIFOLD TEMPERATURE [Cal... */
#define filtered_and_linearized_fuel_temperature_50_to_293 (*(volatile uint16_t*)0x0080A2C8UL) /* FILTERED AND LINEARIZED FUEL TEMPERATURE [CalTe... */
#define unfiltered_and_linearized_fuel_temperature_50_to_293 (*(volatile uint16_t*)0x0080A2CAUL) /* UNFILTERED AND LINEARIZED FUEL TEMPERATURE [Cal... */
#define raw_counts_for_fuel_temperature_0_255 (*(volatile uint16_t*)0x0080A2D0UL) /* RAW COUNTS FOR FUEL TEMPERATURE [CalTerm: ADFLT... */
#define coolant_level_filtered_and_linearized_0_2 (*(volatile uint16_t*)0x0080A2DEUL) /* COOLANT LEVEL FILTERED AND LINEARIZED [CalTerm:... */
#define coolant_level_linearized_and_unfiltered_0_2 (*(volatile uint16_t*)0x0080A2E0UL) /* COOLANT LEVEL LINEARIZED AND UNFILTERED [CalTer... */
#define coolant_level_raw_value_from_a_d_converter_channel_7_0_2 (*(volatile uint16_t*)0x0080A2E6UL) /* COOLANT LEVEL RAW VALUE FROM A/D CONVERTER CHAN... */
#define adsyfpft_param (*(volatile uint16_t*)0x0080A2F4UL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define adsyfpuf_param (*(volatile uint16_t*)0x0080A2F6UL) /* UNFILTERED AND LINEARIZED [CalTerm: ADSYFPUF] */
#define adsyfprc_param (*(volatile uint16_t*)0x0080A2FCUL) /* RAW COUNTS [CalTerm: ADSYFPRC] */
#define flitered_and_linearized_oil_pressure_0_100 (*(volatile uint16_t*)0x0080A30AUL) /* FLITERED AND LINEARIZED OIL PRESSURE [CalTerm: ... */
#define unfiltered_and_linearized_oil_pressure_0_100 (*(volatile uint16_t*)0x0080A30CUL) /* UNFILTERED AND LINEARIZED OIL PRESSURE [CalTerm... */
#define raw_counts_for_oil_pressure_0_1023 (*(volatile uint16_t*)0x0080A312UL) /* RAW COUNTS FOR OIL PRESSURE [CalTerm: ADOLPRRC] */
#define boost_pressure_0_100 (*(volatile uint16_t*)0x0080A320UL) /* BOOST PRESSURE [CalTerm: ADFTBSPR] */
#define unfiltered_and_linearized_boost_pressure_0_10 (*(volatile uint16_t*)0x0080A322UL) /* UNFILTERED AND LINEARIZED BOOST PRESSURE [CalTe... */
#define raw_counts_for_boost_pressure_0_1023 (*(volatile uint16_t*)0x0080A328UL) /* RAW COUNTS FOR BOOST PRESSURE [CalTerm: ADRWBSPR] */
#define filtered_and_linearized_coolant_temperature_50_to_293 (*(volatile uint16_t*)0x0080A336UL) /* FILTERED AND LINEARIZED COOLANT TEMPERATURE [Ca... */
#define unfiltered_and_linearized_coolant_temperature_50_to_293 (*(volatile uint16_t*)0x0080A338UL) /* UNFILTERED AND LINEARIZED COOLANT TEMPERATURE [... */
#define raw_counts_for_coolant_temperature_0_1023 (*(volatile uint16_t*)0x0080A33EUL) /* RAW COUNTS FOR COOLANT TEMPERATURE [CalTerm: AD... */
#define ADTTFT (*(volatile uint16_t*)0x0080A34CUL) /* FILTERED AND LINEARIZED */
#define ADTTUF (*(volatile uint16_t*)0x0080A34EUL) /* CHANNEL 7   LINEARIZED AND UNFILTERED */
#define raw_value_from_a_d_converter_channel_7_0_1023 (*(volatile uint16_t*)0x0080A354UL) /* RAW VALUE FROM A/D CONVERTER CHANNEL 7 [CalTerm... */
#define filtered_and_linearized_50_to_293 (*(volatile uint16_t*)0x0080A362UL) /* FILTERED AND LINEARIZED [CalTerm: ADPOTPFT] */
#define channel_7_linearized_and_unfiltered_50_to_293 (*(volatile uint16_t*)0x0080A364UL) /* CHANNEL 7   LINEARIZED AND UNFILTERED [CalTerm:... */
#define raw_value_from_a_d_converter_channel_7_0_255 (*(volatile uint16_t*)0x0080A36AUL) /* RAW VALUE FROM A/D CONVERTER CHANNEL 7 [CalTerm... */
#define adsyepft_param (*(volatile uint16_t*)0x0080A378UL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define adsyepuf_param (*(volatile uint16_t*)0x0080A37AUL) /* UNFILTERED AND LINEARIZED [CalTerm: ADSYEPUF] */
#define adsyeprc_param (*(volatile uint16_t*)0x0080A380UL) /* RAW COUNTS [CalTerm: ADSYEPRC] */
#define ADSATHFT (*(volatile uint16_t*)0x0080A38EUL) /* CalTerm ADSATHFT: THROTTLE AFTER BEING SAMPLED,... */
#define unfiltered_and_linearized_throttle_0_100 (*(volatile uint16_t*)0x0080A390UL) /* UNFILTERED AND LINEARIZED THROTTLE [CalTerm: AD... */
#define raw_counts_for_throttle_0_1023 (*(volatile uint16_t*)0x0080A396UL) /* RAW COUNTS FOR THROTTLE [CalTerm: ADSATHRC] */
#define filtered_and_linearized_remote_throttle_0_100 (*(volatile uint16_t*)0x0080A3A4UL) /* FILTERED AND LINEARIZED REMOTE THROTTLE [CalTer... */
#define unfiltered_and_linearized_remote_throttle_0_100 (*(volatile uint16_t*)0x0080A3A6UL) /* UNFILTERED AND LINEARIZED REMOTE THROTTLE [CalT... */
#define raw_counts_for_remote_throttle_0_1023 (*(volatile uint16_t*)0x0080A3ACUL) /* RAW COUNTS FOR REMOTE THROTTLE [CalTerm: ADROTHRC] */
#define filtered_ambient_air_pressure_as_read_and_scaled_from_a_d_algor_0_15 (*(volatile uint16_t*)0x0080A3BAUL) /* FILTERED AMBIENT AIR PRESSURE AS READ AND SCALE... */
#define unfiltered_and_linearized_ambient_air_pressure_0_15 (*(volatile uint16_t*)0x0080A3BCUL) /* UNFILTERED AND LINEARIZED AMBIENT AIR PRESSURE ... */
#define raw_counts_for_ambient_air_pressure_0_1023 (*(volatile uint16_t*)0x0080A3C2UL) /* RAW COUNTS FOR AMBIENT AIR PRESSURE [CalTerm: A... */
#define filtered_and_linearized_battery_voltage_0_40 (*(volatile uint16_t*)0x0080A3D0UL) /* FILTERED AND LINEARIZED BATTERY VOLTAGE [CalTer... */
#define unfiltered_and_linearized_battery_voltage_0_40 (*(volatile uint16_t*)0x0080A3D2UL) /* UNFILTERED AND LINEARIZED BATTERY VOLTAGE [CalT... */
#define raw_counts_for_battery_voltage_0_1023 (*(volatile uint16_t*)0x0080A3D8UL) /* RAW COUNTS FOR BATTERY VOLTAGE [CalTerm: ADRWBTVT] */
#define adessvft_param (*(volatile uint16_t*)0x0080A3E6UL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define adessvuf_param (*(volatile uint16_t*)0x0080A3E8UL) /* UNFILTERED AND LINEARIZED [CalTerm: ADESSVUF] */
#define adessvrc_param (*(volatile uint16_t*)0x0080A3EEUL) /* RAW COUNTS [CalTerm: ADESSVRC] */
#define adthsvft_param (*(volatile uint16_t*)0x0080A3FCUL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define adthsvuf_param (*(volatile uint16_t*)0x0080A3FEUL) /* UNFILTERED AND LINEARIZED [CalTerm: ADTHSVUF] */
#define adthsvrc_param (*(volatile uint16_t*)0x0080A404UL) /* RAW COUNTS [CalTerm: ADTHSVRC] */
#define advhsvft_param (*(volatile uint16_t*)0x0080A412UL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define advhsvuf_param (*(volatile uint16_t*)0x0080A414UL) /* UNFILTERED AND LINEARIZED [CalTerm: ADVHSVUF] */
#define advhsvrc_param (*(volatile uint16_t*)0x0080A41AUL) /* RAW COUNTS [CalTerm: ADVHSVRC] */
#define filtered_engine_sensor_supply_voltage_as_read_and_scaled_from_a_0_6 (*(volatile uint16_t*)0x0080A428UL) /* FILTERED ENGINE SENSOR SUPPLY VOLTAGE AS READ A... */
#define engine_sensor_supply_voltage_unfiltered_and_linearized_0_6 (*(volatile uint16_t*)0x0080A42AUL) /* ENGINE SENSOR SUPPLY VOLTAGE UNFILTERED AND LIN... */
#define engine_sensor_supply_voltage_raw_counts_0_1023 (*(volatile uint16_t*)0x0080A430UL) /* ENGINE SENSOR SUPPLY VOLTAGE RAW COUNTS [CalTer... */
#define adftsvft_param (*(volatile uint16_t*)0x0080A43EUL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define adftsvuf_param (*(volatile uint16_t*)0x0080A440UL) /* UNFILTERED AND LINEARIZED [CalTerm: ADFTSVUF] */
#define adftsvrc_param (*(volatile uint16_t*)0x0080A446UL) /* RAW COUNTS [CalTerm: ADFTSVRC] */
#define unfiltered_and_linearized_cc_switch_mux_0_5 (*(volatile uint16_t*)0x0080A456UL) /* UNFILTERED AND LINEARIZED CC SWITCH MUX [CalTer... */
#define raw_counts_for_cc_switch_mux_0_1023 (*(volatile uint16_t*)0x0080A45CUL) /* RAW COUNTS FOR CC SWITCH MUX [CalTerm: ADCRRC] */
#define filtered_water_in_fuel_as_read_and_scaled_from_a_d_algorithm_2_0_3 (*(volatile uint16_t*)0x0080A46AUL) /* FILTERED WATER IN FUEL AS READ AND SCALED FROM ... */
#define ADWFUF (*(volatile uint16_t*)0x0080A46CUL) /* CalTerm ADWFUF: WATER IN FUEL UNFILTERED AND LI... */
#define water_in_fuel_raw_counts_0_1023 (*(volatile uint16_t*)0x0080A472UL) /* WATER IN FUEL RAW COUNTS [CalTerm: ADWFRC] */
#define adegcfft_param (*(volatile uint16_t*)0x0080A480UL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define adegcfuf_param (*(volatile uint16_t*)0x0080A482UL) /* UNFILTERED AND LINEARIZED [CalTerm: ADEGCFUF] */
#define adegcfrc_param (*(volatile uint16_t*)0x0080A488UL) /* RAW COUNTS [CalTerm: ADEGCFRC] */
#define adpssvft_param (*(volatile uint16_t*)0x0080A496UL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define adpssvuf_param (*(volatile uint16_t*)0x0080A498UL) /* UNFILTERED AND LINEARIZED [CalTerm: ADPSSVUF] */
#define adpssvrc_param (*(volatile uint16_t*)0x0080A49EUL) /* RAW COUNTS [CalTerm: ADPSSVRC] */
#define ADHBSVFT (*(volatile uint16_t*)0x0080A4ACUL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define ADHBSVUF (*(volatile uint16_t*)0x0080A4AEUL) /* UNFILTERED AND LINEARIZED */
#define adhbsvrc_param (*(volatile uint16_t*)0x0080A4B4UL) /* RAW COUNTS [CalTerm: ADHBSVRC] */
#define adocsvft_param (*(volatile uint16_t*)0x0080A4C2UL) /* FILTERED VALUE AS READ AND SCALED FROM A/D ALGO... */
#define adocsvuf_param (*(volatile uint16_t*)0x0080A4C4UL) /* UNFILTERED AND LINEARIZED [CalTerm: ADOCSVUF] */
#define adocsvrc_param (*(volatile uint16_t*)0x0080A4CAUL) /* RAW COUNTS [CalTerm: ADOCSVRC] */
#define priority_of_client_overriding_filtered_intake_manifold_temperatur_0_ff (*(volatile uint16_t*)0x0080A6CAUL) /* PRIORITY OF CLIENT OVERRIDING FILTERED INTAKE M... */
#define priority_of_client_overriding_filtered_fuel_temperature_0_ff (*(volatile uint16_t*)0x0080A6CCUL) /* PRIORITY OF CLIENT OVERRIDING FILTERED FUEL TEM... */
#define priority_of_client_overriding_filtered_coolant_level_0_ff (*(volatile uint16_t*)0x0080A6CEUL) /* PRIORITY OF CLIENT OVERRIDING FILTERED COOLANT_... */
#define priority_of_client_overriding_filtered_fuel_pressure_0_ff (*(volatile uint16_t*)0x0080A6D0UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED FUEL PRE... */
#define priority_of_client_overriding_filtered_oil_pressure_0_ff (*(volatile uint16_t*)0x0080A6D2UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED OIL PRES... */
#define priority_of_client_overriding_filtered_boost_pressure_0_ff (*(volatile uint16_t*)0x0080A6D4UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED BOOST PR... */
#define priority_of_client_overriding_filtered_coolant_temperature_0_ff (*(volatile uint16_t*)0x0080A6D6UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED COOLANT ... */
#define priority_of_client_overriding_filtered_ambient_air_temperature_0_ff (*(volatile uint16_t*)0x0080A6D8UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED AMBIENT ... */
#define priority_of_client_overriding_final_power_steering_temperature_0_ff (*(volatile uint16_t*)0x0080A6DAUL) /* PRIORITY OF CLIENT OVERRIDING FINAL POWER STEER... */
#define priority_of_client_overriding_spare_channel_1_0_ff (*(volatile uint16_t*)0x0080A6DCUL) /* PRIORITY OF CLIENT OVERRIDING SPARE_CHANNEL_1 */
#define priority_of_client_overriding_final_sampled_throttle_0_ff (*(volatile uint16_t*)0x0080A6DEUL) /* PRIORITY OF CLIENT OVERRIDING FINAL SAMPLED  TH... */
#define priority_of_client_overriding_final_remote_throttle_0_ff (*(volatile uint16_t*)0x0080A6E0UL) /* PRIORITY OF CLIENT OVERRIDING FINAL REMOTE THRO... */
#define priority_of_client_overriding_final_ambient_air_pressure_0_ff (*(volatile uint16_t*)0x0080A6E2UL) /* PRIORITY OF CLIENT OVERRIDING FINAL AMBIENT AIR... */
#define priority_of_client_overriding_filtered_battery_voltage_0_ff (*(volatile uint16_t*)0x0080A6E4UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED BATTERY ... */
#define priority_of_client_overriding_filtered_engine_speed_sensor_supply_0_ff (*(volatile uint16_t*)0x0080A6E6UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED ENGINE S... */
#define priority_of_client_overriding_final_throttle_position_sensor_0_ff (*(volatile uint16_t*)0x0080A6E8UL) /* PRIORITY OF CLIENT OVERRIDING FINAL THROTTLE PO... */
#define priority_of_client_overriding_final_vehicle_connector_sensors_vol_0_ff (*(volatile uint16_t*)0x0080A6EAUL) /* PRIORITY OF CLIENT OVERRIDING FINAL VEHICLE CON... */
#define priority_of_client_overriding_filtered_engine_conn_supply_voltage_0_ff (*(volatile uint16_t*)0x0080A6ECUL) /* PRIORITY OF CLIENT OVERRIDING FILTERED ENGINE C... */
#define priority_of_client_overriding_filtered_frequency_throttle_supply_0_ff (*(volatile uint16_t*)0x0080A6EEUL) /* PRIORITY OF CLIENT OVERRIDING FILTERED FREQUENC... */
#define priority_of_client_overriding_filtered_cruise_switch_mux_0_ff (*(volatile uint16_t*)0x0080A6F0UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED CRUISE S... */
#define priority_of_client_overriding_final_water_in_fuel_0_ff (*(volatile uint16_t*)0x0080A6F2UL) /* PRIORITY OF CLIENT OVERRIDING FINAL WATER IN FUEL */
#define priority_of_client_overriding_filtered_egr_current_feedback_0_ff (*(volatile uint16_t*)0x0080A6F4UL) /* PRIORITY OF CLIENT OVERRIDING FILTERED EGR CURR... */
#define priority_of_client_overriding_final_programming_pulse_0_ff (*(volatile uint16_t*)0x0080A6F6UL) /* PRIORITY OF CLIENT OVERRIDING FINAL PROGRAMMING... */
#define priority_of_client_overriding_filtered_op_amp_and_comp_0_ff (*(volatile uint16_t*)0x0080A6FAUL) /* PRIORITY OF CLIENT OVERRIDING FILTERED OP AMP A... */
#define priority_of_client_overriding_raw_intake_manifold_temperature_0_ff (*(volatile uint16_t*)0x0080A6FCUL) /* PRIORITY OF CLIENT OVERRIDING RAW INTAKE MANIFO... */
#define priority_of_client_overriding_raw_fuel_temperature_0_ff (*(volatile uint16_t*)0x0080A6FEUL) /* PRIORITY OF CLIENT OVERRIDING RAW FUEL TEMPERATURE */
#define priority_of_client_overriding_raw_coolant_level_0_ff (*(volatile uint16_t*)0x0080A700UL) /* PRIORITY OF CLIENT OVERRIDING RAW COOLANT LEVEL */
#define priority_of_client_overriding_raw_fuel_pressure_0_ff (*(volatile uint16_t*)0x0080A702UL) /* PRIORITY OF CLIENT OVERRIDING RAW FUEL PRESSURE */
#define priority_of_client_overriding_raw_oil_pressure_0_ff (*(volatile uint16_t*)0x0080A704UL) /* PRIORITY OF CLIENT OVERRIDING RAW OIL PRESSURE */
#define priority_of_client_overriding_raw_boost_pressure_0_ff (*(volatile uint16_t*)0x0080A706UL) /* PRIORITY OF CLIENT OVERRIDING RAW BOOST PRESSURE */
#define priority_of_client_overriding_raw_coolant_temperature_0_ff (*(volatile uint16_t*)0x0080A708UL) /* PRIORITY OF CLIENT OVERRIDING RAW COOLANT TEMPE... */
#define priority_of_client_overriding_raw_ambient_air_temperature_0_ff (*(volatile uint16_t*)0x0080A70AUL) /* PRIORITY OF CLIENT OVERRIDING RAW AMBIENT AIR T... */
#define priority_of_client_overriding_raw_power_steering_temperature_0_ff (*(volatile uint16_t*)0x0080A70CUL) /* PRIORITY OF CLIENT OVERRIDING RAW POWER STEERIN... */
#define priority_of_client_overriding_raw_sampled_throttle_0_ff (*(volatile uint16_t*)0x0080A710UL) /* PRIORITY OF CLIENT OVERRIDING RAW SAMPLED  THRO... */
#define priority_of_client_overriding_raw_remote_throttle_0_ff (*(volatile uint16_t*)0x0080A712UL) /* PRIORITY OF CLIENT OVERRIDING RAW REMOTE THROTTLE */
#define priority_of_client_overriding_ambient_air_press_raw_0_ff (*(volatile uint16_t*)0x0080A714UL) /* PRIORITY OF CLIENT OVERRIDING AMBIENT AIR PRESS... */
#define priority_of_client_overriding_raw_ambient_battery_voltage_0_ff (*(volatile uint16_t*)0x0080A716UL) /* PRIORITY OF CLIENT OVERRIDING RAW AMBIENT BATTE... */
#define priority_of_client_overriding_raw_engine_speed_sensor_supply_volt_0_ff (*(volatile uint16_t*)0x0080A718UL) /* PRIORITY OF CLIENT OVERRIDING RAW ENGINE SPEED ... */
#define priority_of_client_overriding_raw_throttle_position_sensor_0_ff (*(volatile uint16_t*)0x0080A71AUL) /* PRIORITY OF CLIENT OVERRIDING RAW THROTTLE POSI... */
#define priority_of_client_overriding_raw_vehicle_connector_sensors_volta_0_ff (*(volatile uint16_t*)0x0080A71CUL) /* PRIORITY OF CLIENT OVERRIDING RAW VEHICLE CONNE... */
#define priority_of_client_overriding_raw_engine_conn_supply_voltage_0_ff (*(volatile uint16_t*)0x0080A71EUL) /* PRIORITY OF CLIENT OVERRIDING RAW ENGINE CONN S... */
#define priority_of_client_overriding_raw_frequency_throttle_supply_volta_0_ff (*(volatile uint16_t*)0x0080A720UL) /* PRIORITY OF CLIENT OVERRIDING RAW FREQUENCY THR... */
#define priority_of_client_overriding_raw_cruise_switch_mux_0_ff (*(volatile uint16_t*)0x0080A722UL) /* PRIORITY OF CLIENT OVERRIDING RAW CRUISE SWITCH... */
#define priority_of_client_overriding_raw_water_in_fuel_0_ff (*(volatile uint16_t*)0x0080A724UL) /* PRIORITY OF CLIENT OVERRIDING RAW WATER IN FUEL */
#define priority_of_client_overriding_raw_egr_current_feedback_0_ff (*(volatile uint16_t*)0x0080A726UL) /* PRIORITY OF CLIENT OVERRIDING RAW EGR CURRENT F... */
#define priority_of_client_overriding_raw_programming_pulse_0_ff (*(volatile uint16_t*)0x0080A728UL) /* PRIORITY OF CLIENT OVERRIDING RAW PROGRAMMING P... */
#define priority_of_client_overriding_raw_op_amp_and_comp_0_ff (*(volatile uint16_t*)0x0080A72CUL) /* PRIORITY OF CLIENT OVERRIDING RAW OP AMP AND COMP */
#define user_value_100_to_255 (*(volatile uint16_t*)0x0080A73CUL) /* USER VALUE */
#define ambient_air_temperature_raw_user_value_0_1023 (*(volatile uint16_t*)0x0080A76EUL) /* AMBIENT AIR TEMPERATURE RAW USER VALUE */
#define frequency_throttle_input_sv_raw_user_value_0_to_6 (*(volatile uint16_t*)0x0080A784UL) /* FREQUENCY THROTTLE INPUT SV RAW USER VALUE */
#define indicator_as_to_which_algorithm_is_in_control_of_fueling_after_it_1_12 (*(volatile uint16_t*)0x0080A8F2UL) /* INDICATOR AS TO WHICH ALGORITHM IS IN CONTROL O... */
#define APAPBA (*(volatile uint16_t*)0x0080A8FAUL) /* CalTerm APAPBA: RESULT OF AFC, LSG, ON GOVERNOR... */
#define APAPST (*(volatile uint16_t*)0x0080A8FCUL) /* INDICATOR AS TO WHICH PART OF THE ALPHA ALGORIT... */
#define APAFSS (*(volatile uint16_t*)0x0080A8FEUL) /* RESULT OF AFC ALGORITHM */
#define APFLRTAP (*(volatile uint16_t*)0x0080A900UL) /* RESULT OF FUEL RATE ALGORITHM */
#define APGVAP (*(volatile uint16_t*)0x0080A902UL) /* RESULT OF ON GOVERNOR */
#define APLSAP (*(volatile uint16_t*)0x0080A904UL) /* RESULT OF LSG ALGORITHM */
#define semaphore_used_to_latch_afc_events_that_occur_betwe_0_false_1_true (*(volatile uint16_t*)0x0080A906UL) /* SEMAPHORE USED TO LATCH AFC EVENTS THAT OCCUR B... */
#define semaphore_used_to_latch_lsg_events_that_occur_betwe_0_false_1_true (*(volatile uint16_t*)0x0080A908UL) /* SEMAPHORE USED TO LATCH LSG EVENTS THAT OCCUR B... */
#define APAAPRSS (*(volatile uint16_t*)0x0080A90AUL) /* CalTerm APAAPRSS: ALPHA BASED ONLY ON AMBIENT A... */
#define trace_the_time_since_fueling_state_has_left_lsg_state_0_900 (*(volatile uint16_t*)0x0080A910UL) /* TRACE THE TIME SINCE FUELING STATE HAS LEFT LSG... */
#define override_fueling_to_slave_fuel_selection_0_100 (*(volatile uint16_t*)0x0080A924UL) /* OVERRIDE FUELING TO SLAVE FUEL SELECTION */
#define override_timing_to_slave_timing_selection_0_120 (*(volatile uint16_t*)0x0080A928UL) /* OVERRIDE TIMING TO SLAVE TIMING SELECTION */
#define enable_allowing_overriding_of_engine_speed_enable_disable (*(volatile uint16_t*)0x0080A92EUL) /* ENABLE ALLOWING OVERRIDING OF ENGINE SPEED */
#define ASALPHA (*(volatile uint16_t*)0x0080A930UL) /* ALPHA VALUE USED TO OVERRIDE SLAVE ECM. */
#define asg_reset_state_x1_2000_2000 (*(volatile uint16_t*)0x0080A932UL) /* ASG RESET STATE X1 [CalTerm: ASRSSTX1] */
#define asg_reset_state_x2_0_100 (*(volatile uint16_t*)0x0080A934UL) /* ASG RESET STATE X2 [CalTerm: ASRSSTX2] */
#define asg_reset_state_x3_0_4500 (*(volatile uint16_t*)0x0080A936UL) /* ASG RESET STATE X3 [CalTerm: ASRSSTX3] */
#define asg_reset_state_x4_100_100 (*(volatile uint16_t*)0x0080A938UL) /* ASG RESET STATE X4 [CalTerm: ASRSSTX4] */
#define asg_reset_state_x5_0_100 (*(volatile uint16_t*)0x0080A93AUL) /* ASG RESET STATE X5 [CalTerm: ASRSSTX5] */
#define ASRSSTX6 (*(volatile uint16_t*)0x0080A93CUL) /* ASG RESET STATE X6 */
#define asg_application_specific_reference_override_mode_true_false (*(volatile uint16_t*)0x0080A93EUL) /* ASG APPLICATION SPECIFIC REFERENCE OVERRIDE MOD... */
#define asg_application_specific_reference_speed_0_4500 (*(volatile uint16_t*)0x0080A940UL) /* ASG APPLICATION SPECIFIC REFERENCE SPEED [CalTe... */
#define asg_application_specific_droop_gain_1_0_2 (*(volatile uint16_t*)0x0080A942UL) /* ASG APPLICATION SPECIFIC DROOP GAIN 1 [CalTerm:... */
#define asg_application_specific_droop_gain_2_0_2 (*(volatile uint16_t*)0x0080A944UL) /* ASG APPLICATION SPECIFIC DROOP GAIN 2 [CalTerm:... */
#define asg_application_specific_reference_filter_coefficient_0_1 (*(volatile uint16_t*)0x0080A946UL) /* ASG APPLICATION SPECIFIC REFERENCE FILTER COEFF... */
#define asg_application_specific_fueling_high_limit_0_100 (*(volatile uint16_t*)0x0080A948UL) /* ASG APPLICATION SPECIFIC FUELING HIGH LIMIT [Ca... */
#define asg_application_specific_fueling_lower_limit_0_50 (*(volatile uint16_t*)0x0080A94AUL) /* ASG APPLICATION SPECIFIC FUELING LOWER LIMIT [C... */
#define asg_application_specific_reset_true_false (*(volatile uint16_t*)0x0080A94CUL) /* ASG APPLICATION SPECIFIC RESET [CalTerm: ASAPRS] */
#define asg_application_specific_state_x1_reset_value_2000_2000 (*(volatile uint16_t*)0x0080A94EUL) /* ASG APPLICATION SPECIFIC STATE X1 RESET VALUE [... */
#define asg_application_specific_state_x2_reset_value_0_100 (*(volatile uint16_t*)0x0080A950UL) /* ASG APPLICATION SPECIFIC STATE X2 RESET VALUE [... */
#define asg_application_specific_state_x3_reset_value_0_4500 (*(volatile uint16_t*)0x0080A952UL) /* ASG APPLICATION SPECIFIC STATE X3 RESET VALUE [... */
#define asg_application_specific_state_x4_reset_value_100_100 (*(volatile uint16_t*)0x0080A954UL) /* ASG APPLICATION SPECIFIC STATE X4 RESET VALUE [... */
#define asg_application_specific_state_x5_reset_value_0_100 (*(volatile uint16_t*)0x0080A956UL) /* ASG APPLICATION SPECIFIC STATE X5 RESET VALUE [... */
#define ASAPSTX6 (*(volatile uint16_t*)0x0080A958UL) /* ASG APPLICATION SPECIFIC STATE X6 RESET VALUE */
#define asg_application_specific_proportional_gain_1_0_0_135 (*(volatile uint16_t*)0x0080A95AUL) /* ASG APPLICATION SPECIFIC PROPORTIONAL GAIN 1 [C... */
#define asg_application_specific_proportional_gain_2_0_0_135 (*(volatile uint16_t*)0x0080A95CUL) /* ASG APPLICATION SPECIFIC PROPORTIONAL GAIN 2 [C... */
#define asg_application_specific_integral_gain_1_0_6_75 (*(volatile uint16_t*)0x0080A95EUL) /* ASG APPLICATION SPECIFIC INTEGRAL GAIN 1 [CalTe... */
#define asg_application_specific_integral_gain_2_0_6_75 (*(volatile uint16_t*)0x0080A960UL) /* ASG APPLICATION SPECIFIC INTEGRAL GAIN 2 [CalTe... */
#define asg_application_specific_derivative_gain_1_0_0_0025 (*(volatile uint16_t*)0x0080A962UL) /* ASG APPLICATION SPECIFIC DERIVATIVE GAIN 1 [Cal... */
#define asg_application_specific_derivative_gain_2_0_0_0025 (*(volatile uint16_t*)0x0080A964UL) /* ASG APPLICATION SPECIFIC DERIVATIVE GAIN 2 [Cal... */
#define asg_application_specific_compensation_filter_coef_1_0_10 (*(volatile uint16_t*)0x0080A966UL) /* ASG APPLICATION SPECIFIC COMPENSATION FILTER CO... */
#define asg_application_specific_compensation_filter_coef_2_0_10 (*(volatile uint16_t*)0x0080A968UL) /* ASG APPLICATION SPECIFIC COMPENSATION FILTER CO... */
#define asg_application_specific_compensation_filter_coef_3_0_10 (*(volatile uint16_t*)0x0080A96AUL) /* ASG APPLICATION SPECIFIC COMPENSATION FILTER CO... */
#define asg_error_difference_2000_2000 (*(volatile uint16_t*)0x0080A96EUL) /* ASG ERROR DIFFERENCE [CalTerm: ASERDC] */
#define asg_feedback_difference_term_1000_1000 (*(volatile uint16_t*)0x0080A970UL) /* ASG FEEDBACK DIFFERENCE TERM [CalTerm: ASFBDC] */
#define asg_filtered_reference_speed_0_4500 (*(volatile uint16_t*)0x0080A972UL) /* ASG FILTERED REFERENCE SPEED [CalTerm: ASFTRF] */
#define ASMXFL (*(volatile uint16_t*)0x0080A976UL) /* CalTerm ASMXFL: FUELING FROM 4D TABLES USING AS... */
#define asg_state_x1_2000_2000 (*(volatile uint16_t*)0x0080A978UL) /* ASG STATE X1 */
#define asg_state_x2_100_100 (*(volatile uint16_t*)0x0080A97AUL) /* ASG STATE X2 */
#define asg_state_x4_100_100 (*(volatile uint16_t*)0x0080A97CUL) /* ASG STATE X4 */
#define asg_state_x5_100_100 (*(volatile uint16_t*)0x0080A97EUL) /* ASG STATE X5 */
#define asg_state_x6_100_100 (*(volatile uint16_t*)0x0080A980UL) /* ASG STATE X6 */
#define stcg_enable_stcg_switch_xor_user_selected_throttle_control_0_1 (*(volatile uint16_t*)0x0080A982UL) /* = (STCG_ENABLE & STCG_SWITCH) XOR USER_SELECTED... */
#define asg_droop_compensated_error_2000_2000 (*(volatile uint16_t*)0x0080A984UL) /* ASG DROOP COMPENSATED ERROR */
#define asg_quadratic_derivative_adjustment_100_100 (*(volatile uint32_t*)0x0080A986UL) /* ASG QUADRATIC DERIVATIVE ADJUSTMENT */
#define qpid_adjusted_asg_droop_compensated_error_derivative_2000_2000 (*(volatile uint32_t*)0x0080A98AUL) /* QPID ADJUSTED ASG DROOP COMPENSATED ERROR-DERIV... */
#define all_speed_governor_reference_speed_based_upon_throttle_positi_0_3000 (*(volatile uint16_t*)0x0080A98CUL) /* ALL SPEED GOVERNOR REFERENCE SPEED BASED UPON T... */
#define asg_quadratic_integral_adjustment_500_500 (*(volatile uint32_t*)0x0080A98EUL) /* ASG QUADRATIC INTEGRAL ADJUSTMENT */
#define qpid_adjusted_asg_droop_compensated_error_integral_2000_2000 (*(volatile uint32_t*)0x0080A992UL) /* QPID ADJUSTED ASG DROOP COMPENSATED ERROR-INTEG... */
#define asg_droop_gain_2_0_2 (*(volatile uint16_t*)0x0080A994UL) /* ASG DROOP GAIN 2 [CalTerm: ASDPGN02] */
#define asg_throttle_droop_gain_1_0_1 (*(volatile uint16_t*)0x0080A996UL) /* ASG THROTTLE DROOP GAIN 1 [CalTerm: ASTH01DP] */
#define asg_throttle_droop_gain_2_0_5_1 (*(volatile uint16_t*)0x0080A998UL) /* ASG THROTTLE DROOP GAIN 2 [CalTerm: ASTH02DP] */
#define asg_selected_droop_slope_0_30 (*(volatile uint16_t*)0x0080A99AUL) /* ASG SELECTED DROOP SLOPE [CalTerm: ASSLDP] */
#define asg_fueling_high_limit_0_100 (*(volatile uint16_t*)0x0080A99CUL) /* ASG FUELING HIGH LIMIT [CalTerm: ASFLHILM] */
#define asg_fueling_lower_limit_0_50 (*(volatile uint16_t*)0x0080A99EUL) /* ASG FUELING LOWER LIMIT [CalTerm: ASFLLOLM] */
#define asg_external_reset_flag_true_false (*(volatile uint16_t*)0x0080A9A0UL) /* ASG EXTERNAL RESET FLAG [CalTerm: ASETRS] */
#define asg_reference_speed_for_0_throttle_input_should_be_less_tha_0_4500 (*(volatile uint16_t*)0x0080A9A4UL) /* ASG REFERENCE SPEED FOR 0% THROTTLE INPUT -SHOU... */
#define asg_reference_speed_for_100_throttle_input_should_be_greate_0_4500 (*(volatile uint16_t*)0x0080A9A6UL) /* ASG REFERENCE SPEED FOR 100% THROTTLE INPUT -SH... */
#define steady_state_approximation_of_user_fuel_0_100 (*(volatile uint16_t*)0x0080A9C2UL) /* STEADY STATE APPROXIMATION OF USER FUEL */
#define sampled_road_speed_after_it_has_been_filtered_0_255_9961 (*(volatile uint16_t*)0x0080A9D0UL) /* SAMPLED ROAD SPEED AFTER IT HAS BEEN FILTERED */
#define filtered_transmission_gear_ratio_0_1_15_999 (*(volatile uint16_t*)0x0080A9D2UL) /* FILTERED TRANSMISSION GEAR RATIO */
#define vss_tamper_derate_rpm_0_3000 (*(volatile uint16_t*)0x0080A9D8UL) /* VSS TAMPER DERATE RPM */
#define EB39CNID (*(volatile uint16_t*)0x0080A9DAUL) /* CalTerm EB39CNID: J1939 DEVICE CONTROLLING ENGI... */
#define maximum_fueling_of_all_the_fueling_curves_in_the_ecm_0_100 (*(volatile uint16_t*)0x0080A9E2UL) /* MAXIMUM FUELING OF ALL THE FUELING CURVES IN TH... */
#define speed_assoc_w_maximum_fueling_of_all_the_fueling_curves_in_th_0_8000 (*(volatile uint16_t*)0x0080A9E4UL) /* SPEED ASSOC. W. MAXIMUM FUELING OF ALL THE FUEL... */
#define maximum_fueling_of_all_the_tau_1_fueling_curves_in_the_ecm_0_100 (*(volatile uint16_t*)0x0080A9E6UL) /* MAXIMUM FUELING OF ALL THE TAU 1 FUELING CURVES... */
#define speed_assoc_w_maximum_fueling_of_all_the_tau_1_fueling_curves_0_8000 (*(volatile uint16_t*)0x0080A9E8UL) /* SPEED ASSOC. W. MAXIMUM FUELING OF ALL THE TAU ... */
#define maximum_fueling_of_all_the_tau_0_fueling_curves_in_the_ecm_0_100 (*(volatile uint16_t*)0x0080A9EAUL) /* MAXIMUM FUELING OF ALL THE TAU 0 FUELING CURVES... */
#define speed_assoc_w_maximum_fueling_of_all_the_tau_0_fueling_curves_0_8000 (*(volatile uint16_t*)0x0080A9ECUL) /* SPEED ASSOC. W. MAXIMUM FUELING OF ALL THE TAU ... */
#define unsigned_roll_over_counter_of_ess_main_isr_occurances_0_65535 (*(volatile uint16_t*)0x0080A9F4UL) /* UNSIGNED ROLL-OVER COUNTER OF ESS MAIN ISR OCCU... */
#define unsigned_roll_over_counter_of_ess_backup_isr_occurances_0_65535 (*(volatile uint16_t*)0x0080A9F6UL) /* UNSIGNED ROLL-OVER COUNTER OF ESS BACKUP ISR OC... */
#define bit_3_of_0_15_indicator_of_engine_usage_1_means_driving_true_false (*(volatile uint16_t*)0x0080A9FAUL) /* BIT 3 OF 0-15 INDICATOR OF ENGINE USAGE 1 MEANS... */
#define bit_2_0_15_enables_j1939_71_engine_broadcast_1_on_0_off (*(volatile uint16_t*)0x0080AA12UL) /* BIT 2 (0:15) ENABLES J1939/71 ENGINE BROADCAST */
#define jcomm_ind_retarder_torque_amount_of_torque_provided_by_retarde_0_125 (*(volatile uint16_t*)0x0080AA14UL) /* JCOMM IND RETARDER TORQUE AMOUNT OF TORQUE PROV... */
#define can_s_last_message_object_used_0_15 (*(volatile uint16_t*)0x0080AA1CUL) /* CAN'S LAST MESSAGE OBJECT USED */
#define can_1_chip_s_last_message_object_used_0_15 (*(volatile uint16_t*)0x0080AA1EUL) /* CAN 1 CHIP'S LAST MESSAGE OBJECT USED */
#define CRARFG (*(volatile uint16_t*)0x0080AA2EUL) /* CRUISE CONTROL AUTO RESUME FLAG (INACTIVE/ACTIV... */
#define CRCM (*(volatile uint16_t*)0x0080AA30UL) /* CRUISE COMMAND MODE (OFF/SET/RESUME/COAST/ACCEL... */
#define CROGESIE (*(volatile uint16_t*)0x0080AA36UL) /* CalTerm CROGESIE: INDICATES IF CRUISE WAS INACT... */
#define CRALDP (*(volatile uint16_t*)0x0080AA38UL) /* STATUS OF CRUISE DROOP STATE MACHINE */
#define CRBODO (*(volatile uint16_t*)0x0080AA3CUL) /* CRUISE BOTTOM DROOP OFFSET PASSED TO THE DESIRE... */
#define slope_of_the_bottom_droop_line_calculated_in_cc_rsg_droop_0_0_35 (*(volatile uint16_t*)0x0080AA3EUL) /* SLOPE OF THE BOTTOM DROOP LINE CALCULATED IN CC... */
#define CREVBU (*(volatile uint16_t*)0x0080AA40UL) /* FLAG INDICATING CRUISE GOVERNOR SHALL PERFORM A... */
#define CRERDC (*(volatile uint16_t*)0x0080AA44UL) /* AMOUNT THE CRUISE/RSG MPH ERROR SIGNAL IS MODIF... */
#define slope_of_the_top_droop_line_computed_in_cc_rsg_droop_algorith_0_0_35 (*(volatile uint16_t*)0x0080AA52UL) /* SLOPE OF THE TOP DROOP LINE COMPUTED IN CC/RSG ... */
#define slope_of_the_bottom_droop_line_computed_in_the_cc_rsg_droop_a_0_0_35 (*(volatile uint16_t*)0x0080AA58UL) /* SLOPE OF THE BOTTOM DROOP LINE COMPUTED IN THE ... */
#define slope_of_the_top_droop_line_computed_in_the_cc_rsg_droop_algo_0_0_35 (*(volatile uint16_t*)0x0080AA5EUL) /* SLOPE OF THE TOP DROOP LINE COMPUTED IN THE CC/... */
#define offset_of_the_cc_rsg_top_droop_0_100 (*(volatile uint16_t*)0x0080AA60UL) /* OFFSET OF THE CC/RSG TOP DROOP */
#define CRERDP (*(volatile uint16_t*)0x0080AA6CUL) /* CRUISE RSG ERROR AFTER DROOP */
#define CRETRS (*(volatile uint16_t*)0x0080AA6EUL) /* FLAG INDICATING CC/RSG SHALL PERFORM A RESET */
#define gain_used_to_adjust_droop_error_can_change_with_rear_axle_ratio_1_294 (*(volatile uint16_t*)0x0080AA78UL) /* GAIN USED TO ADJUST DROOP ERROR. CAN CHANGE WIT... */
#define flag_to_denote_if_valid_resume_speed_is_available_valid_invalid (*(volatile uint16_t*)0x0080AA80UL) /* FLAG TO DENOTE IF VALID RESUME SPEED IS AVAILABLE */
#define validated_percent_throttle_commanded_by_driver_0_100 (*(volatile uint16_t*)0x0080AA82UL) /* VALIDATED PERCENT THROTTLE COMMANDED BY DRIVER */
#define minimum_sampled_throttle_detected_0_21 (*(volatile uint16_t*)0x0080AA8CUL) /* MINIMUM SAMPLED_THROTTLE DETECTED */
#define intermediate_calculated_value_of_commanded_throttle_based_on_s_0_100 (*(volatile uint16_t*)0x0080AA92UL) /* INTERMEDIATE CALCULATED VALUE OF COMMANDED THRO... */
#define state_of_selected_alternate_throttle_priority_0_9 (*(volatile uint16_t*)0x0080AA94UL) /* STATE OF SELECTED ALTERNATE THROTTLE PRIORITY */
#define requested_throttle_after_being_lin_and_fil_via_freq_thr_algo_0_100 (*(volatile uint16_t*)0x0080AA98UL) /* REQUESTED THROTTLE AFTER BEING LIN. AND FIL. VI... */
#define expected_intake_temperature_based_on_mass_fuel_rate_calcula_50_to_293 (*(volatile uint16_t*)0x0080AA9CUL) /* EXPECTED INTAKE TEMPERATURE BASED ON MASS FUEL ... */
#define increment_timing_value_output_by_cylinder_pressure_maintenanc_20_20 (*(volatile uint16_t*)0x0080AA9EUL) /* INCREMENT TIMING VALUE OUTPUT BY CYLINDER PRESS... */
#define calculated_cylinder_pressure_1500_3000 (*(volatile uint16_t*)0x0080AAA0UL) /* CALCULATED CYLINDER PRESSURE [CalTerm: CPCYPR] */
#define fss_offset_corrected_soi_before_cyl_maintenance_parameter_120_120 (*(volatile uint16_t*)0x0080AAA6UL) /* FSS OFFSET CORRECTED SOI_BEFORE_CYL_MAINTENANCE... */
#define actual_starting_ram_address_of_the_data_collector_buffer_none (*(volatile uint32_t*)0x0080AAAAUL) /* ACTUAL STARTING RAM ADDRESS OF THE DATA COLLECT... */
#define physical_ram_address_of_the_end_of_the_data_collector_buffer_none (*(volatile uint32_t*)0x0080AAAEUL) /* PHYSICAL RAM ADDRESS OF THE END OF THE DATA COL... */
#define logical_beginning_address_of_the_data_collector_buffer_none (*(volatile uint32_t*)0x0080AAB2UL) /* LOGICAL BEGINNING ADDRESS OF THE DATA COLLECTOR... */
#define logical_address_canter_value_stored_to_the_data_collector_buffer_none (*(volatile uint32_t*)0x0080AAB6UL) /* LOGICAL ADDRESS CANTER VALUE STORED TO THE DATA... */
#define logical_address_of_the_last_value_stored_to_the_data_collector_bu_none (*(volatile uint32_t*)0x0080AABAUL) /* LOGICAL ADDRESS OF THE LAST VALUE STORED TO THE... */
#define short_term_map_1_processing_total_0_500_0 (*(volatile uint32_t*)0x0080BACCUL) /* SHORT TERM MAP 1 PROCESSING TOTAL */
#define short_term_map_2_processing_total_0_500_0 (*(volatile uint32_t*)0x0080BAD0UL) /* SHORT TERM MAP 2 PROCESSING TOTAL */
#define duty_cycle_monitor_calculated_load_factor_0_0_130_0 (*(volatile uint16_t*)0x0080BAD4UL) /* DUTY CYCLE MONITOR CALCULATED LOAD FACTOR */
#define duty_cycle_monitor_current_operating_map_region_1_50 (*(volatile uint8_t*)0x0080BAD6UL) /* DUTY CYCLE MONITOR CURRENT OPERATING MAP REGION */
#define DCMNSHNU (*(volatile uint8_t*)0x0080BAD7UL) /* CalTerm DCMNSHNU: SHORT TERM MAP PROCESSING; 0=... */
#define DCSHPR01 (*(volatile uint32_t*)0x0080BAD8UL) /* CalTerm DCSHPR01: SHORT TERM PROCESSING MAP 1 */
#define DCSHPR02 (*(volatile uint32_t*)0x0080BBA6UL) /* CalTerm DCSHPR02: SHORT TERM PROCESSING MAP 2 */
#define jcomm_no_load_torque_estimated_frictional_no_load_fueling_val_0_100 (*(volatile uint16_t*)0x0080BC74UL) /* JCOMM NO LOAD TORQUE  ESTIMATED FRICTIONAL NO L... */
#define jcomm_percent_peak_torque_based_on_current_engine_speed_and_128_127 (*(volatile uint16_t*)0x0080BC76UL) /* JCOMM PERCENT PEAK TORQUE BASED ON CURRENT ENGI... */
#define jcomm_percent_peak_torque_at_breakpoint_3_percent_peak_torq_128_127 (*(volatile uint16_t*)0x0080BC78UL) /* JCOMM PERCENT PEAK TORQUE AT BREAKPOINT 3 PERCE... */
#define jcomm_percent_peak_torque_at_breakpoint_4_percent_peak_torq_128_127 (*(volatile uint16_t*)0x0080BC7AUL) /* JCOMM PERCENT PEAK TORQUE AT BREAKPOINT 4 PERCE... */
#define jcomm_percent_peak_torque_at_breakpoint_5_percent_peak_torq_128_127 (*(volatile uint16_t*)0x0080BC7CUL) /* JCOMM PERCENT PEAK TORQUE AT BREAKPOINT 5 PERCE... */
#define jcomm_percent_peak_torque_at_idle_speed_percent_peak_torque_128_127 (*(volatile uint16_t*)0x0080BC7EUL) /* JCOMM PERCENT PEAK TORQUE AT IDLE SPEED PERCENT... */
#define jcomm_percent_peak_torque_at_rated_speed_percent_peak_torqu_128_127 (*(volatile uint16_t*)0x0080BC80UL) /* JCOMM PERCENT PEAK TORQUE AT RATED SPEED PERCEN... */
#define frictional_load_interpolated_from_the_no_load_curve_at_lsg_ref_s_0_100 (*(volatile uint16_t*)0x0080BC82UL) /* FRICTIONAL LOAD INTERPOLATED FROM THE NO LOAD C... */
#define frictional_load_torque_in_fueling_at_rated_engine_rpm_0_100_bc84 (*(volatile uint16_t*)0x0080BC84UL) /* FRICTIONAL LOAD TORQUE (IN FUELING) AT RATED EN... */
#define frictional_load_torque_in_fueling_at_breakpoint_3_engine_rpm_0_100_bc86 (*(volatile uint16_t*)0x0080BC86UL) /* FRICTIONAL LOAD TORQUE (IN FUELING) AT BREAKPOI... */
#define frictional_load_torque_in_fueling_at_breakpoint_4_engine_rpm_0_100_bc88 (*(volatile uint16_t*)0x0080BC88UL) /* FRICTIONAL LOAD TORQUE (IN FUELING) AT BREAKPOI... */
#define frictional_load_torque_in_fueling_at_breakpoint_5_engine_rpm_0_100_bc8a (*(volatile uint16_t*)0x0080BC8AUL) /* FRICTIONAL LOAD TORQUE (IN FUELING) AT BREAKPOI... */
#define bit_mapped_system_switch_status_0_false_1_true_bcc8 (*(volatile uint16_t*)0x0080BCC8UL) /* BIT MAPPED SYSTEM SWITCH STATUS */
#define bit_mapped_system_switch_status_0_false_1_true_bcca (*(volatile uint16_t*)0x0080BCCAUL) /* BIT MAPPED SYSTEM SWITCH STATUS */
#define bit_mapped_system_switch_status_0_false_1_true_bccc (*(volatile uint16_t*)0x0080BCCCUL) /* BIT MAPPED SYSTEM SWITCH STATUS */
#define value_used_for_monitoring_switch_data_0_1_2089_10_24 (*(volatile uint32_t*)0x0080BCCEUL) /* VALUE USED FOR MONITORING SWITCH DATA. */
#define debounced_switch_value_for_switch_16_on_off (*(volatile uint8_t*)0x0080BCCFUL) /* DEBOUNCED SWITCH VALUE FOR SWITCH 16 */
#define debounced_value_for_rear_axle_ratio_switch_on_off (*(volatile uint8_t*)0x0080BCD0UL) /* DEBOUNCED VALUE FOR REAR_AXLE_RATIO_SWITCH */
#define state_of_the_throttle_interlock_switch_on_off (*(volatile uint8_t*)0x0080BCD1UL) /* STATE OF THE THROTTLE INTERLOCK SWITCH */
#define switch_status_cruise_coast_switch_bit_3_on_off (*(volatile uint8_t*)0x0080BCD4UL) /* SWITCH STATUS [CalTerm: CRACELSW] */
#define DSPTSESW (*(volatile uint8_t*)0x0080BCD5UL) /* CalTerm DSPTSESW: PTO SET SWITCH (BIT 2 OF 0 TO... */
#define switch_status_for_torque_derate_feature_on_off (*(volatile uint8_t*)0x0080BCD6UL) /* SWITCH STATUS FOR TORQUE DERATE FEATURE */
#define user_supplied_value_for_ptp_switched_input_input_on_off (*(volatile uint8_t*)0x0080BCD8UL) /* USER SUPPLIED VALUE FOR PTP SWITCHED INPUT INPUT */
#define DSUSEBSW (*(volatile uint8_t*)0x0080BCD9UL) /* CalTerm DSUSEBSW: BYTE 1,BIT 4 OF 0-7,USER OVER... */
#define user_supplied_value_for_coolant_level_low_switch_input_on_off (*(volatile uint8_t*)0x0080BCDAUL) /* USER SUPPLIED VALUE FOR COOLANT LEVEL LOW SWITC... */
#define user_selected_value_for_stcg_asg_droop_input_on_off (*(volatile uint8_t*)0x0080BCDBUL) /* USER SELECTED VALUE FOR STCG ASG DROOP INPUT */
#define clien_specified_value_for_water_in_fuel_lamp_feedback_on_off (*(volatile uint8_t*)0x0080BCDCUL) /* CLIEN SPECIFIED VALUE FOR WATER IN FUEL LAMP FE... */
#define client_specified_value_for_the_solenoid_b_feedback_on_off (*(volatile uint8_t*)0x0080BCDDUL) /* CLIENT SPECIFIED VALUE FOR THE SOLENOID_B FEEDBACK */
#define user_supplied_value_for_the_pto_set_switch_on_off (*(volatile uint8_t*)0x0080BCDFUL) /* USER SUPPLIED VALUE FOR THE PTO SET SWITCH */
#define user_supplied_value_for_the_torque_derate_switch_on_off (*(volatile uint8_t*)0x0080BCE0UL) /* USER SUPPLIED VALUE FOR THE TORQUE DERATE SWITCH */
#define binary_value_of_not_idle_switch_off_on (*(volatile uint8_t*)0x0080BCEDUL) /* BINARY VALUE OF NOT IDLE SWITCH. */
#define bit_6_which_enables_the_warning_lamp_driver_enable_disable (*(volatile uint8_t*)0x0080BCF6UL) /* BIT 6 WHICH ENABLES THE WARNING LAMP DRIVER. */
#define commanded_driver_true_on_0_1 (*(volatile uint8_t*)0x0080BCF7UL) /* COMMANDED DRIVER. 'TRUE' = ON */
#define enable_flag_to_allow_boot_block_programming_enable_disable (*(volatile uint8_t*)0x0080BCF8UL) /* ENABLE FLAG TO ALLOW BOOT BLOCK PROGRAMMING. */
#define bit_4_of_master_status_byte_a_0_1 (*(volatile uint8_t*)0x0080BCF9UL) /* BIT 4 OF MASTER_STATUS_BYTE_A. */
#define status_of_the_water_in_fuel_lamp_output_on_off (*(volatile uint8_t*)0x0080BD02UL) /* STATUS OF THE WATER IN FUEL LAMP OUTPUT */
#define DSFMCHFB (*(volatile uint8_t*)0x0080BD03UL) /* CalTerm DSFMCHFB: BIT 7 OF BYTE 5 DEBOUNCE, FEE... */
#define priority_of_client_currently_overriding_wait_to_start_lamp_00_ff (*(volatile uint8_t*)0x0080BD1AUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING WAIT TO... */
#define priority_of_client_currently_overriding_stop_engine_lamp_00_ff (*(volatile uint8_t*)0x0080BD1BUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING STOP EN... */
#define priority_of_the_client_which_is_currently_overriding_rly7_00_ff (*(volatile uint8_t*)0x0080BD25UL) /* PRIORITY OF THE CLIENT WHICH IS CURRENTLY OVERR... */
#define priority_of_client_which_is_currently_overriding_cruise_resume_sw_0_ff (*(volatile uint8_t*)0x0080BD4BUL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_cruise_set_switc_0_ff (*(volatile uint8_t*)0x0080BD4CUL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_cruise_on_switch_0_ff (*(volatile uint8_t*)0x0080BD4DUL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_currently_overriding_fan_clutch_switch_0_ff (*(volatile uint8_t*)0x0080BD4EUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING FAN CLU... */
#define priority_of_client_currently_overriding_ptp_switched_input_switch_0_ff (*(volatile uint8_t*)0x0080BD4FUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING PTP SWI... */
#define priority_of_client_currently_overriding_hsg_droop_select_switch_0_ff (*(volatile uint8_t*)0x0080BD50UL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING HSG DRO... */
#define priority_of_client_which_is_currently_overriding_switch_8_0_ff (*(volatile uint8_t*)0x0080BD51UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_switch_9_0_ff (*(volatile uint8_t*)0x0080BD52UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_currently_overriding_accelerator_interlock_swi_0_ff (*(volatile uint8_t*)0x0080BD53UL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING ACCELER... */
#define priority_of_client_which_is_currently_overriding_switch_11_0_ff (*(volatile uint8_t*)0x0080BD54UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_switch_12_0_ff (*(volatile uint8_t*)0x0080BD55UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_currently_overriding_engine_brrake_switch_0_ff (*(volatile uint8_t*)0x0080BD56UL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING ENGINE ... */
#define priority_of_client_which_is_currently_overriding_switch_14_0_ff (*(volatile uint8_t*)0x0080BD57UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_switch_15_0_ff (*(volatile uint8_t*)0x0080BD58UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_switch_16_0_ff (*(volatile uint8_t*)0x0080BD59UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_switch_17_0_ff (*(volatile uint8_t*)0x0080BD5AUL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_currently_overriding_the_ac_pressure_turnkey_s_0_ff (*(volatile uint8_t*)0x0080BD5BUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING THE AC ... */
#define priority_of_client_currently_overriding_rear_axle_ratio_switch_0_ff (*(volatile uint8_t*)0x0080BD5CUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING REAR AX... */
#define priority_of_client_which_is_currently_overriding_switch_20_0_ff (*(volatile uint8_t*)0x0080BD5DUL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_switch_21_0_ff (*(volatile uint8_t*)0x0080BD5EUL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_currently_overriding_coolant_level_low_switch_0_ff (*(volatile uint8_t*)0x0080BD5FUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING COOLANT... */
#define priority_of_client_currently_overriding_user_datalogger_switch_0_ff (*(volatile uint8_t*)0x0080BD60UL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING USER_DA... */
#define priority_of_client_which_is_currently_overriding_parking_brake_sw_0_ff (*(volatile uint8_t*)0x0080BD61UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_currently_overriding_coolant_level_high_switch_0_ff (*(volatile uint8_t*)0x0080BD62UL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING COOLANT... */
#define priority_of_client_currently_overriding_stcg_asg_droop_switch_0_ff (*(volatile uint8_t*)0x0080BD63UL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING STCG AS... */
#define priority_of_client_which_is_currently_overriding_switch_27_0_ff (*(volatile uint8_t*)0x0080BD64UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_currently_overriding_ac_high_pressure_switch_0_ff (*(volatile uint8_t*)0x0080BD65UL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING AC HIGH... */
#define priority_of_client_which_is_currently_overriding_engine_brake_sel_0_ff (*(volatile uint8_t*)0x0080BD66UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_pto2_0_ff (*(volatile uint8_t*)0x0080BD67UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_overriding_ac_on_off_switch_0_ff (*(volatile uint8_t*)0x0080BD68UL) /* PRIORITY OF CLIENT OVERRIDING AC ON OFF SWITCH */
#define priority_of_client_which_is_currently_overriding_switch_31_0_ff (*(volatile uint8_t*)0x0080BD69UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_currently_overriding_solenoid_a_0_ff (*(volatile uint8_t*)0x0080BD6AUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING SOLENOID_A */
#define priority_of_client_currently_overriding_stop_engine_lamp_feedbac_00_ff (*(volatile uint8_t*)0x0080BD6BUL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING STOP EN... */
#define priority_of_the_client_that_is_currently_overriding_water_in_fue_00_ff (*(volatile uint8_t*)0x0080BD6CUL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_the_client_that_is_currently_overriding_lamp4_feedba_00_ff (*(volatile uint8_t*)0x0080BD6DUL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_the_client_that_is_currently_overriding_malfunction_00_ff (*(volatile uint8_t*)0x0080BD6EUL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_the_client_that_is_currently_overriding_lamp6_feedba_00_ff (*(volatile uint8_t*)0x0080BD6FUL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_the_client_that_is_currently_overriding_warning_lamp_00_ff (*(volatile uint8_t*)0x0080BD70UL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_client_currently_overriding_vp44_pump_enable_00_ff (*(volatile uint8_t*)0x0080BD71UL) /* PRIORITY OF CLIENT CURRENTLY OVERRIDING VP44 PU... */
#define priority_of_client_which_is_currently_overriding_rly1_00_ff (*(volatile uint8_t*)0x0080BD72UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_the_client_that_is_currently_overriding_rly2_feedbac_00_ff (*(volatile uint8_t*)0x0080BD73UL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_the_client_that_is_currently_overriding_rly3_feedbac_00_ff (*(volatile uint8_t*)0x0080BD74UL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_the_client_that_is_currently_overriding_rly7_feedbac_00_ff (*(volatile uint8_t*)0x0080BD75UL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_the_client_that_is_currently_overriding_rly5_feedbac_00_ff (*(volatile uint8_t*)0x0080BD76UL) /* PRIORITY OF THE CLIENT THAT IS CURRENTLY OVERRI... */
#define priority_of_client_overriding_solenoid_b_feedback_0_ff (*(volatile uint8_t*)0x0080BD79UL) /* PRIORITY OF CLIENT OVERRIDING SOLENOID_B FEEDBACK */
#define priority_of_client_which_is_currently_overriding_pto_resume_switc_0_ff (*(volatile uint8_t*)0x0080BD82UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_pto_set_switch_0_ff (*(volatile uint8_t*)0x0080BD84UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_pto_enable_switc_0_ff (*(volatile uint8_t*)0x0080BD86UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define priority_of_client_which_is_currently_overriding_torque_derate_sw_0_ff (*(volatile uint8_t*)0x0080BD8AUL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define fuel_demand_percentage_current (*(volatile uint16_t*)0x0080BD8CUL) /* Fuel demand percentage calculator current value... */
#define fuel_demand_percentage (*(volatile uint16_t*)0x0080BD8EUL) /* Fuel demand percentage value */
#define manifold_temp_calculated (*(volatile uint16_t*)0x0080BD90UL) /* Manifold temp calculated value (2 refs) */
#define speed_difference_interp_result_1 (*(volatile uint16_t*)0x0080BD92UL) /* Speed difference interpolation result 1 (2 refs) */
#define speed_difference_interp_result_2 (*(volatile uint16_t*)0x0080BD94UL) /* Speed difference interpolation result 2 (2 refs) */
#define speed_difference_interp_result_3 (*(volatile uint16_t*)0x0080BD96UL) /* Speed difference interpolation result 3 (2 refs) */
#define speed_difference_interp_result_4 (*(volatile uint16_t*)0x0080BD98UL) /* Speed difference interpolation result 4 (2 refs) */
#define manifold_temp_lookup_result_1 (*(volatile uint16_t*)0x0080BD9AUL) /* Manifold temp table lookup result 1 (2 refs) */
#define manifold_temp_lookup_result (*(volatile uint16_t*)0x0080BD9CUL) /* Manifold temp table interpolation result (2 refs) */
#define manifold_temp_lookup_result_2 (*(volatile uint16_t*)0x0080BD9EUL) /* Manifold temp table lookup result 2 (2 refs) */
#define boost_pressure_protection_state_bda0 (*(volatile uint16_t*)0x0080BDA0UL) /* Boost pressure protection state machine value (... */
#define DPFLPSWD (*(volatile uint16_t*)0x0080BDA2UL) /* CalTerm DPFLPSWD: FUELING PULSE WIDTH, FUELING ... */
#define hour_meter_ecm_run_time_none (*(volatile uint32_t*)0x0080BDA4UL) /* HOUR METER (ECM RUN TIME) [CalTerm: CMECTR] */
#define fault_flag_snapshot_register_3 (*(volatile uint8_t*)0x0080BDC0UL) /* Fault flag snapshot register 3 (4 refs) */
#define fault_flag_snapshot_register_2 (*(volatile uint8_t*)0x0080BDC2UL) /* Fault flag snapshot register 2 (4 refs) */
#define fault_flag_snapshot_register_1 (*(volatile uint8_t*)0x0080BDC4UL) /* Fault flag snapshot register 1 (4 refs) */
#define vp44_communication_status_bdc6 (*(volatile uint8_t*)0x0080BDC6UL) /* VP44 communication health flags - bit 1 indicat... */
#define derate_status_byte (*(volatile uint8_t*)0x0080BDC7UL) /* Derate status byte */
#define vp44_sensor_history_state (*(volatile uint8_t*)0x0080BDC8UL) /* VP44 sensor history and protection state (6 refs) */
#define vp44_sensor_diagnostic_state_bdc9 (*(volatile uint8_t*)0x0080BDC9UL) /* VP44 sensor diagnostic control state (12 refs) */
#define io_control_state_delay (*(volatile uint8_t*)0x0080BDCAUL) /* I/O control state machine delay value (10 refs) */
#define vp44_io_can_fault_state (*(volatile uint8_t*)0x0080BDCBUL) /* VP44 I/O and CAN fault monitor state (10 refs) */
#define vp44_sensor_status_register (*(volatile uint8_t*)0x0080BDCCUL) /* VP44 sensor status multi-bit register (61 refs) */
#define vp44_extended_status_byte_4 (*(volatile uint8_t*)0x0080BDCDUL) /* VP44 extended status collection byte 4 (vp44_st... */
#define vp44_status_history_flag (*(volatile uint8_t*)0x0080BDCEUL) /* VP44 status history tracking flag (2 refs) */
#define vp44_fuel_temperature_state (*(volatile uint8_t*)0x0080BDCFUL) /* VP44 fuel temperature sensor diagnostic state (... */
#define vp44_diagnostic_sensor_state (*(volatile uint8_t*)0x0080BDD1UL) /* VP44 diagnostic sensor monitor state (9 refs) */
#define vp44_fuel_temp_sensor_flags (*(volatile uint8_t*)0x0080BDD3UL) /* VP44 fuel temperature sensor flags (9 refs) */
#define vp44_can_response_state (*(volatile uint8_t*)0x0080BDE2UL) /* VP44 CAN message response state (9 refs) */
#define vp44_status_data_flag_2 (*(volatile uint8_t*)0x0080BDE4UL) /* VP44 status data collector flag 2 (1 ref) */
#define vp44_status_data_flag_1 (*(volatile uint8_t*)0x0080BDE6UL) /* VP44 status data collector flag 1 (1 ref) */
#define vp44_sensor_diagnostic_state_bde8 (*(volatile uint8_t*)0x0080BDE8UL) /* VP44 redundant sensor diagnostic state (9 refs) */
#define io_control_source_register (*(volatile uint8_t*)0x0080BDEEUL) /* I/O control source data register - copied direc... */
#define io_control_flags (*(volatile uint8_t*)0x0080BDEFUL) /* I/O control flags register - processed with bit... */
#define sim_data_direction_control (*(volatile uint8_t*)0x0080BDF0UL) /* SIM data direction control register - controls ... */
#define output_control_status_byte (*(volatile uint8_t*)0x0080BDF1UL) /* Output control status byte */
#define can_pin_switching_control_flags (*(volatile uint8_t*)0x0080BDF3UL) /* CAN pin switching control - bit 5 (0x20) select... */
#define circular_buffer_metadata (*(volatile uint16_t*)0x0080BDFAUL) /* Circular buffer metadata/timestamps */
#define circular_buffer_data (*(volatile uint8_t*)0x0080C1FAUL) /* Circular buffer data storage (512 bytes) */
#define circular_buffer_read_index (*(volatile uint16_t*)0x0080C3FAUL) /* Circular buffer read index (masked to 9 bits) (... */
#define circular_buffer_write_index (*(volatile uint16_t*)0x0080C3FCUL) /* Circular buffer write index (512 entries max) */
#define circular_buffer_count (*(volatile uint16_t*)0x0080C3FEUL) /* Number of entries in circular buffer */
#define parameter_circular_buffer_value (*(volatile uint16_t*)0x0080C402UL) /* Parameter circular buffer write value (5 refs) */
#define engine_rpm_period_value (*(volatile uint16_t*)0x0080C404UL) /* Engine RPM period measurement value */
#define current_rpm_from_timing (*(volatile uint16_t*)0x0080C406UL) /* Current instantaneous RPM calculated from timin... */
#define current_engine_rpm (*(volatile uint16_t*)0x0080C408UL) /* Current engine RPM value */
#define rpm_period_running_sum (*(volatile uint32_t*)0x0080C40AUL) /* Running sum for RPM period calculation */
#define rpm_timing_accumulator (*(volatile uint32_t*)0x0080C412UL) /* RPM timing delta accumulator (12 refs) */
#define throttle_position_buffer_ptr (*(volatile uint16_t*)0x0080C41AUL) /* Throttle position buffer pointer */
#define duty_cycle_buffer_current_ptr (*(volatile uint32_t*)0x0080C41EUL) /* Duty cycle monitor buffer current pointer in th... */
#define rpm_calculation_mode_selector (*(volatile uint16_t*)0x0080C42AUL) /* RPM calculation mode selector 0-2 */
#define rpm_filter_buffer_start (*(volatile uint32_t*)0x0080C430UL) /* Circular buffer base address for RPM filtering ... */
#define duty_cycle_monitor_buffer_start (*(volatile uint32_t*)0x0080C5C0UL) /* Duty cycle monitor circular buffer base address... */
#define rpm_period_accumulator (*(volatile uint32_t*)0x0080C750UL) /* RPM period accumulator for averaging */
#define timer_capture_accumulator (*(volatile uint32_t*)0x0080C754UL) /* Timer capture averaging accumulator (11 refs) */
#define timer_capture_delta_count (*(volatile uint16_t*)0x0080C758UL) /* Timer capture delta increment counter (9 refs) */
#define timer_capture_sample_count (*(volatile uint16_t*)0x0080C75AUL) /* Timer capture averaging sample count (12 refs) */
#define rpm_timer_interrupt_capture (*(volatile uint16_t*)0x0080C75CUL) /* RPM timer interrupt capture value (29 refs) */
#define duty_cycle_timing_capture_value (*(volatile uint16_t*)0x0080C760UL) /* Duty cycle monitor timing capture value (12 refs) */
#define rpm_timing_capture_previous (*(volatile uint16_t*)0x0080C764UL) /* Previous RPM timing capture for delta compariso... */
#define rpm_timing_capture_current (*(volatile uint16_t*)0x0080C766UL) /* Current RPM timing capture for delta comparison... */
#define rpm_timing_offset_value (*(volatile uint16_t*)0x0080C768UL) /* RPM timing offset for filtering (9 refs) */
#define engine_fault_rpm_timing_state (*(volatile uint16_t*)0x0080C76AUL) /* Engine fault RPM timing state (4 refs) */
#define rpm_timing_delta_value (*(volatile uint16_t*)0x0080C76CUL) /* RPM timing delta calculation value (9 refs) */
#define rpm_timing_capture_buffer (*(volatile uint16_t*)0x0080C76EUL) /* RPM timing capture buffer value (9 refs) */
#define rpm_timing_comparison_value (*(volatile uint16_t*)0x0080C770UL) /* RPM timing comparison and validation value (9 r... */
#define engine_fault_rpm_source_value (*(volatile uint16_t*)0x0080C772UL) /* Engine fault monitoring RPM source value (9 refs) */
#define rpm_based_limit_2 (*(volatile uint16_t*)0x0080C774UL) /* RPM-based calculation limit 2 */
#define rpm_scaling_divisor_mode_0 (*(volatile uint16_t*)0x0080C776UL) /* RPM scaling divisor for mode 0 */
#define rpm_scaling_divisor_mode_1 (*(volatile uint16_t*)0x0080C77AUL) /* RPM scaling divisor for mode 1 */
#define rpm_filter_buffer_end (*(volatile uint32_t*)0x0080C77EUL) /* End pointer for RPM filter buffer */
#define duty_cycle_buffer_end_ptr (*(volatile uint32_t*)0x0080C782UL) /* Duty cycle monitor buffer end pointer in thrott... */
#define fuel_demand_smoothed (*(volatile uint16_t*)0x0080C786UL) /* Fuel demand after smoothing filter */
#define duty_cycle_monitor_buffer_ptr (*(volatile uint32_t*)0x0080C78AUL) /* Duty cycle monitor buffer pointer (3 refs) */
#define can1_timer_buffer_state (*(volatile uint16_t*)0x0080C792UL) /* CAN1 timer buffer state (can1TimerBufferInitCon... */
#define pwm_timer_mode_dispatch_state (*(volatile uint8_t*)0x0080C79BUL) /* PWM timer mode dispatcher state (pwmTimerModeDi... */
#define throttle_fault_threshold_low (*(volatile uint16_t*)0x0080C7A2UL) /* Throttle fault threshold low value (2 refs) */
#define throttle_fault_threshold_high (*(volatile uint16_t*)0x0080C7A4UL) /* Throttle fault threshold high value (2 refs) */
#define throttle_fault_threshold_alt (*(volatile uint16_t*)0x0080C7A6UL) /* Throttle fault threshold alternate value (2 refs) */
#define rpm_sample_index (*(volatile uint16_t*)0x0080C7AEUL) /* Index for RPM sample circular buffer */
#define rpm_sample_comparison_index (*(volatile uint16_t*)0x0080C7B0UL) /* RPM sample array comparison index (2 refs) */
#define rpm_timer_capture_state (*(volatile RPM_CAPTURE_STATE*)0x0080C7B2UL) /* RPM timer capture state flag - accessed via cmp... */
#define rpm_timer_capture_mode (*(volatile uint8_t*)0x0080C7B3UL) /* RPM timer capture mode flag - accessed via cmpi.b */
#define pwm_timer_calc_value_1 (*(volatile uint16_t*)0x0080C7B4UL) /* PWM timer calculation value 1 (pwmTimerModeDisp... */
#define pwm_timer_calc_value_2 (*(volatile uint16_t*)0x0080C7B6UL) /* PWM timer calculation value 2 (pwmTimerModeDisp... */
#define throttle_fault_delay_counter (*(volatile uint16_t*)0x0080C7B8UL) /* Throttle fault detection delay counter (6 refs) */
#define fuel_timing_oil_pressure_mode_state (*(volatile uint8_t*)0x0080C7C0UL) /* Fuel timing oil pressure mode controller state ... */
#define rpm_moving_average (*(volatile uint16_t*)0x0080C7C2UL) /* RPM exponential moving average (2 refs) */
#define fuel_timing_control_value (*(volatile uint16_t*)0x0080C7C4UL) /* Primary fuel timing control value for oil press... */
#define fuel_timing_state (*(volatile uint16_t*)0x0080C7C6UL) /* Fuel timing state machine value */
#define fuel_timing_oil_pressure_state (*(volatile uint16_t*)0x0080C7C8UL) /* Fuel timing oil pressure mode state (9 refs) */
#define fuel_timing_oil_pressure_timer (*(volatile uint16_t*)0x0080C7CAUL) /* Fuel timing oil pressure mode timer (4 refs) */
#define fuel_timing_transition_value_2 (*(volatile uint16_t*)0x0080C7CCUL) /* Fuel timing transition state machine value 2 (6... */
#define fuel_timing_transition_value_1 (*(volatile uint16_t*)0x0080C7CEUL) /* Fuel timing transition state machine value 1 (6... */
#define duty_cycle_monitor_buffer_state (*(volatile uint8_t*)0x0080C7D0UL) /* Duty cycle monitor buffer state (3 refs) */
#define duty_cycle_error_counter (*(volatile uint8_t*)0x0080C7D1UL) /* Duty cycle monitor error debounce counter (12 r... */
#define duty_cycle_monitor_fault_counter (*(volatile uint8_t*)0x0080C7D2UL) /* Duty cycle monitor ISR fault counter (9 refs) */
#define rpm_sensor_fault_counter (*(volatile uint8_t*)0x0080C7D3UL) /* RPM sensor fault debounce counter (12 refs) */
#define rpm_sensor_fault_debounce (*(volatile uint8_t*)0x0080C7D4UL) /* RPM sensor fault debounce counter (7 refs) */
#define can_initialization_clear_flag (*(volatile uint16_t*)0x0080C7DEUL) /* CAN initialization clear/reset flag (4 refs) */
#define can1_init_state_flag (*(volatile uint16_t*)0x0080C7E4UL) /* CAN1 initialization state flag (4 refs) */
#define fuel_demand_override (*(volatile uint16_t*)0x0080C7E8UL) /* Fuel demand override value */
#define timing_advance_value (*(volatile uint16_t*)0x0080C7EAUL) /* Timing advance value */
#define fuel_timing_blend_rpm_component (*(volatile uint16_t*)0x0080C7ECUL) /* Fuel timing mode blend RPM-based component (5 r... */
#define engine_running_mode_timer (*(volatile uint16_t*)0x0080C7EEUL) /* Engine running mode 3 time accumulator */
#define engine_rpm_cranking_threshold (*(volatile uint16_t*)0x0080C7F0UL) /* Engine RPM cranking to running threshold */
#define fuel_timing_blend_lookup_result (*(volatile uint16_t*)0x0080C7F2UL) /* Fuel timing blend lookup table interpolation re... */
#define fuel_timing_intake_temp_correction (*(volatile uint16_t*)0x0080C7F4UL) /* Fuel timing intake manifold temperature correct... */
#define frictional_load_fuel_offset (*(volatile uint16_t*)0x0080C7F6UL) /* Frictional load fuel limit offset value (4 refs) */
#define frictional_load_torque_interpolator_result (*(volatile uint16_t*)0x0080C7F8UL) /* Frictional load torque interpolator result (6 r... */
#define peak_torque_correction_state (*(volatile uint16_t*)0x0080C7FAUL) /* Peak torque fuel correction state (3 refs) */
#define rpm_source_selector_value (*(volatile uint16_t*)0x0080C7FCUL) /* RPM source selector for fuel timing (14 refs) */
#define rpm_based_fuel_limit_threshold (*(volatile uint16_t*)0x0080C7FEUL) /* RPM-based fuel limit calculator threshold (4 refs) */
#define rpm_based_fuel_limit_state (*(volatile uint16_t*)0x0080C800UL) /* RPM-based fuel limit calculator state (9 refs) */
#define frictional_load_calculator_state (*(volatile uint16_t*)0x0080C802UL) /* Frictional load interpolation calculator state ... */
#define frictional_load_interpolation_value (*(volatile uint16_t*)0x0080C804UL) /* Frictional load torque interpolator value (7 refs) */
#define fuel_timing_mode_blend_factor_c806 (*(volatile uint16_t*)0x0080C806UL) /* Fuel timing mode blend calculation factor (11 r... */
#define fuel_timing_mode_blend_value (*(volatile uint16_t*)0x0080C808UL) /* Fuel timing mode blend calculator value (3 refs) */
#define engine_mode_transition_state (*(volatile uint16_t*)0x0080C80AUL) /* Engine mode transition state updater value (1 ref) */
#define shutdown_protection_state_2 (*(volatile uint16_t*)0x0080C80CUL) /* Shutdown protection coordinator state 2 (6 refs) */
#define shutdown_protection_state_1 (*(volatile uint16_t*)0x0080C80EUL) /* Shutdown protection coordinator state 1 (6 refs) */
#define engine_operating_mode (*(volatile ENGINE_OPERATING_MODE*)0x0080C810UL) /* Engine operating mode state machine (1=IDLE */
#define engine_shutdown_complete_flag (*(volatile uint16_t*)0x0080C812UL) /* Engine shutdown complete flag for scheduler */
#define protection_state_rpm_threshold (*(volatile uint16_t*)0x0080C814UL) /* Protection state RPM threshold table pointer (1... */
#define pwm_timer_output_value (*(volatile uint16_t*)0x0080C818UL) /* PWM timer output value (pwmTimerModeDispatcher) */
#define protection_state_3b_rpm_array (*(volatile uint16_t*)0x0080C82CUL) /* Protection state 3b RPM monitor array (protecti... */
#define pwm_timer_counter (*(volatile uint16_t*)0x0080C83AUL) /* PWM timer counter (pwmTimerModeDispatcher) */
#define pwm_timer_state (*(volatile uint16_t*)0x0080C842UL) /* PWM timer state (pwmTimerModeDispatcher) */
#define engine_protection_oil_pressure_ptr_1 (*(volatile uint32_t*)0x0080C84CUL) /* Engine protection oil pressure table ptr 1 (eng... */
#define engine_protection_oil_pressure_ptr_2 (*(volatile uint32_t*)0x0080C850UL) /* Engine protection oil pressure table ptr 2 (eng... */
#define engine_protection_oil_pressure_ptr_3 (*(volatile uint32_t*)0x0080C854UL) /* Engine protection oil pressure table ptr 3 (eng... */
#define engine_protection_boost_ptr_1 (*(volatile uint32_t*)0x0080C868UL) /* Engine protection boost pressure table ptr 1 (e... */
#define engine_protection_boost_ptr_2 (*(volatile uint32_t*)0x0080C86CUL) /* Engine protection boost pressure table ptr 2 (e... */
#define engine_protection_boost_ptr_3 (*(volatile uint32_t*)0x0080C870UL) /* Engine protection boost pressure table ptr 3 (e... */
#define engine_protection_intake_temp_ptr_1 (*(volatile uint32_t*)0x0080C87AUL) /* Engine protection intake temp table ptr 1 (engi... */
#define engine_protection_intake_temp_ptr_2 (*(volatile uint32_t*)0x0080C87EUL) /* Engine protection intake temp table ptr 2 (engi... */
#define engine_protection_intake_temp_ptr_3 (*(volatile uint32_t*)0x0080C882UL) /* Engine protection intake temp table ptr 3 (engi... */
#define engine_protection_coolant_ptr_1 (*(volatile uint32_t*)0x0080C896UL) /* Engine protection coolant temp table ptr 1 (eng... */
#define engine_protection_coolant_ptr_2 (*(volatile uint32_t*)0x0080C89AUL) /* Engine protection coolant temp table ptr 2 (eng... */
#define engine_protection_coolant_ptr_3 (*(volatile uint32_t*)0x0080C89EUL) /* Engine protection coolant temp table ptr 3 (eng... */
#define engine_protection_fuel_temp_ptr_1 (*(volatile uint32_t*)0x0080C8A8UL) /* Engine protection fuel temp table ptr 1 (engine... */
#define engine_protection_fuel_temp_ptr_2 (*(volatile uint32_t*)0x0080C8B0UL) /* Engine protection fuel temp table ptr 2 (engine... */
#define engine_protection_sensor_ptr_1 (*(volatile uint32_t*)0x0080C8C4UL) /* Engine protection sensor table ptr 1 (enginePro... */
#define engine_protection_sensor_ptr_2 (*(volatile uint32_t*)0x0080C8C8UL) /* Engine protection sensor table ptr 2 (enginePro... */
#define engine_protection_sensor_ptr_3 (*(volatile uint32_t*)0x0080C8CCUL) /* Engine protection sensor table ptr 3 (enginePro... */
#define engine_protection_shutdown_ptr_1 (*(volatile uint32_t*)0x0080C8D6UL) /* Engine protection shutdown table ptr 1 (engineP... */
#define engine_protection_shutdown_ptr_2 (*(volatile uint32_t*)0x0080C8DAUL) /* Engine protection shutdown table ptr 2 (engineP... */
#define engine_protection_derate_ptr_1 (*(volatile uint32_t*)0x0080C8F2UL) /* Engine protection derate table ptr 1 (enginePro... */
#define engine_protection_derate_ptr_2 (*(volatile uint32_t*)0x0080C8FAUL) /* Engine protection derate table ptr 2 (enginePro... */
#define engine_protection_limit_ptr_1 (*(volatile uint32_t*)0x0080C904UL) /* Engine protection limit table ptr 1 (engineProt... */
#define engine_protection_state_ptr_1 (*(volatile uint32_t*)0x0080C956UL) /* Engine protection state table ptr 1 (engineProt... */
#define engine_protection_state_ptr_2 (*(volatile uint32_t*)0x0080C960UL) /* Engine protection state table ptr 2 (engineProt... */
#define protection_emergency_rpm_value (*(volatile uint16_t*)0x0080C984UL) /* Protection emergency RPM value (protectionUpdat... */
#define protection_emergency_fuel_value (*(volatile uint16_t*)0x0080C986UL) /* Protection emergency fuel value (protectionUpda... */
#define protection_shutdown_fuel_limit (*(volatile uint16_t*)0x0080C98EUL) /* Protection shutdown fuel limit value (6 refs) */
#define protection_mode_state (*(volatile uint16_t*)0x0080C990UL) /* Protection mode state */
#define fuel_demand_from_table (*(volatile uint16_t*)0x0080C992UL) /* Fuel demand from table interpolation */
#define high_rpm_protection_triggered_flag (*(volatile uint16_t*)0x0080C994UL) /* High RPM protection triggered flag (4 refs) */
#define high_rpm_shutdown_active_flag (*(volatile uint16_t*)0x0080C996UL) /* High RPM shutdown active flag */
#define lamp_3_blink_trigger (*(volatile uint16_t*)0x0080C998UL) /* Lamp 3 blink trigger flag */
#define diagnostic_queue_message_type (*(volatile uint16_t*)0x0080C99AUL) /* Diagnostic message queue type/ID written by dia... */
#define diagnostic_condition_flag (*(volatile uint8_t*)0x0080C99CUL) /* Diagnostic condition check flag (2 refs) */
#define fuel_demand_command (*(volatile uint16_t*)0x0080C9A4UL) /* Current fuel demand value set by fuelDemandMode... */
#define vp44_engine_state (*(volatile VP44_ENGINE_STATE*)0x0080C9A6UL) /* VP44 engine operating state - determines status... */
#define diagnostic_parameter_buffer (*(volatile uint16_t*)0x0080C9A8UL) /* Buffer for diagnostic parameter values */
#define fuel_timing_blend_factor (*(volatile uint16_t*)0x0080C9AAUL) /* Fuel timing blend factor 0-16384 */
#define fuel_demand_table_output (*(volatile uint16_t*)0x0080C9ACUL) /* Fuel demand table calculation output */
#define fuel_limit_minimum_value (*(volatile uint16_t*)0x0080C9AEUL) /* Fuel limit minimum selected value */
#define fuel_demand_source_id (*(volatile FUEL_DEMAND_SOURCE*)0x0080C9B0UL) /* Fuel demand source - identifies which limiter/c... */
#define fuel_adjustment_active_flag (*(volatile uint16_t*)0x0080C9B2UL) /* Fuel adjustment active flag */
#define diagnostic_fuel_arbitration_state_c9b4 (*(volatile uint16_t*)0x0080C9B4UL) /* Diagnostic mode fuel arbitration handler state ... */
#define engine_control_system_ready (*(volatile uint16_t*)0x0080C9C6UL) /* Engine control system ready flag - must be 0 fo... */
#define base_timing_fuel_demand_input (*(volatile uint16_t*)0x0080C9C8UL) /* Base timing lookup fuel demand input (1 ref) */
#define fuel_statistics_alt_value (*(volatile uint16_t*)0x0080C9CAUL) /* Fuel statistics alternate calculation value (1 ... */
#define fuel_timing_clamp_value (*(volatile uint16_t*)0x0080C9CCUL) /* Fuel timing clamp value (0 or 32000) (3 refs) */
#define fuel_timing_interpolated (*(volatile uint16_t*)0x0080C9D8UL) /* Interpolated fuel timing value */
#define fuel_delivery_phase_lag_result (*(volatile uint16_t*)0x0080CC3AUL) /* Fuel delivery phase lag calculation result (4 r... */
#define fuel_rpm_deviation_value (*(volatile uint16_t*)0x0080CC3CUL) /* Calculated fuel-RPM deviation for control */
#define fuel_delivery_state_variable (*(volatile uint16_t*)0x0080CC42UL) /* Fuel delivery controller state variable (fuel_d... */
#define fuel_limit_source_id (*(volatile uint16_t*)0x0080CC4AUL) /* ID of current fuel limit source (arbitrator out... */
#define fuel_demand_limited (*(volatile uint16_t*)0x0080CC4CUL) /* Rate-limited fuel demand */
#define fuel_limit_arbitration_threshold (*(volatile uint16_t*)0x0080CC4EUL) /* Fuel limit arbitration threshold */
#define fuel_demand_delta (*(volatile uint16_t*)0x0080CC50UL) /* Fuel demand delta for rate limiting */
#define fuel_demand_maximum_limit (*(volatile uint16_t*)0x0080CC52UL) /* Maximum fuel demand limit */
#define fuel_limit_offset_value (*(volatile uint16_t*)0x0080CC54UL) /* Fuel limit offset value */
#define fuel_limit_comparison_low (*(volatile uint16_t*)0x0080CC56UL) /* Fuel limit comparison low value */
#define fuel_limit_comparison_high (*(volatile uint16_t*)0x0080CC58UL) /* Fuel limit comparison high value */
#define fuel_demand_rate_limit (*(volatile uint16_t*)0x0080CC5AUL) /* Fuel demand rate limiting value */
#define param_pointer_set_1 (*(volatile uint32_t*)0x0080CC5EUL) /* Parameter pointer set 1 - points to different p... */
#define param_pointer_set_2 (*(volatile uint32_t*)0x0080CC62UL) /* Parameter pointer set 2 - points to different p... */
#define param_pointer_set_3 (*(volatile uint32_t*)0x0080CC66UL) /* Parameter pointer set 3 - points to different p... */
#define high_rpm_protection_fault_flag (*(volatile uint16_t*)0x0080CC6AUL) /* High RPM protection fault active flag */
#define high_rpm_protection_state (*(volatile HIGH_RPM_PROTECTION_STATE*)0x0080CC6CUL) /* High RPM protection state machine state */
#define high_rpm_protection_timer (*(volatile uint16_t*)0x0080CC6EUL) /* High RPM protection countdown timer */
#define high_rpm_protection_warning_flag (*(volatile uint16_t*)0x0080CC72UL) /* High RPM protection warning active flag */
#define timer_counting_against_oil_pressure_threshold_time_0_60 (*(volatile uint16_t*)0x0080CCC4UL) /* TIMER COUNTING AGAINST OIL_PRESSURE_THRESHOLD_TIME */
#define EBODCOAG (*(volatile uint16_t*)0x0080CCCEUL) /* CalTerm EBODCOAG: EB OVRD. SRC. 1=JC_OVRD,2=CRU... */
#define timing_command_prior_to_engine_brake_override_of_the_value_0_120 (*(volatile uint16_t*)0x0080CCD2UL) /* TIMING COMMAND PRIOR TO ENGINE BRAKE OVERRIDE O... */
#define EBNOODCS (*(volatile uint16_t*)0x0080CCE6UL) /* CalTerm EBNOODCS: SOURCE OF EB REQ.: 1=JC_OVRD,... */
#define level_of_eng_braking_req_by_non_override_algorithms_0_100 (*(volatile uint16_t*)0x0080CCE8UL) /* LEVEL OF ENG. BRAKING REQ. BY NON-OVERRIDE ALGO... */
#define eps_pulse_number_eps_tooth_counter_0_24 (*(volatile uint16_t*)0x0080CCEAUL) /* EPS_PULSE_NUMBER:EPS TOOTH COUNTER */
#define eps_pulse_number_backup_eps_backup_tooth_counter_0_24 (*(volatile uint16_t*)0x0080CCECUL) /* EPS_PULSE_NUMBER_BACKUP: EPS BACKUP TOOTH COUNTER */
#define time_that_the_engine_is_not_in_stop_state_0_2_29 (*(volatile uint32_t*)0x0080CCEEUL) /* TIME THAT THE ENGINE IS NOT IN STOP STATE [CalT... */
#define fuel_demand_blend_mode_select (*(volatile uint8_t*)0x0080CCF2UL) /* Fuel demand blend mode selector (fuelDemandTabl... */
#define average_pulse_period_time_period_over_1_cyl_of_primary_s_1000_65535 (*(volatile uint32_t*)0x0080CCF8UL) /* AVERAGE_PULSE_PERIOD: TIME PERIOD OVER 1 CYL OF... */
#define average_pulse_period_backup_time_period_over_1_cyl_of_secondary_2_32 (*(volatile uint32_t*)0x0080CCFCUL) /* AVERAGE_PULSE_PERIOD_BACKUP: TIME PERIOD OVER 1... */
#define sample_crank_degrees_crank_degrees_between_vss_interrupts_0_36000 (*(volatile uint32_t*)0x0080CD00UL) /* SAMPLE_CRANK_DEGREES: CRANK DEGREES BETWEEN VSS... */
#define next_table_position_pointer_to_next_spot_in_pulse_per_800000_83ffff (*(volatile uint32_t*)0x0080CD08UL) /* NEXT_TABLE_POSITION: POINTER TO NEXT SPOT IN PU... */
#define next_table_position_backup_pointer_to_next_spot_in_ba_800000_83ffff (*(volatile uint32_t*)0x0080CD0CUL) /* NEXT_TABLE_POSITION_BACKUP: POINTER TO NEXT SPO... */
#define main_lost_counter_timeout_counter_for_primary_speed_sensor_0_10000 (*(volatile uint16_t*)0x0080CD10UL) /* MAIN_LOST_COUNTER: TIMEOUT COUNTER FOR PRIMARY ... */
#define backup_lost_counter_timeout_counter_for_secondary_speed_inp_0_10000 (*(volatile uint16_t*)0x0080CD12UL) /* BACKUP_LOST_COUNTER: TIMEOUT COUNTER FOR SECOND... */
#define external_lost_counter_timeout_counter_for_external_speed_inp_0_10000 (*(volatile uint16_t*)0x0080CD14UL) /* EXTERNAL_LOST_COUNTER:TIMEOUT COUNTER FOR EXTER... */
#define sample_crank_degrees_backup_crank_degrees_between_vss_inter_0_36000 (*(volatile uint32_t*)0x0080CD1AUL) /* SAMPLE_CRANK_DEGREES_BACKUP: CRANK DEGREES BETW... */
#define pulse_period_table_table_containing_main_speed_pulse_per_1000_65535 (*(volatile uint32_t*)0x0080CD1EUL) /* PULSE_PERIOD_TABLE: TABLE CONTAINING MAIN SPEED... */
#define pulse_period_table_backup_table_containing_main_speed_pulse_peri_2_32 (*(volatile uint32_t*)0x0080CEAEUL) /* PULSE_PERIOD_TABLE_BACKUP: TABLE CONTAINING MAI... */
#define can_transmit_buffer_ptr_2 (*(volatile uint32_t*)0x0080CF78UL) /* CAN transmit buffer pointer 2 (7 refs) */
#define can_transmit_buffer_ptr_1 (*(volatile uint32_t*)0x0080CF7CUL) /* CAN transmit buffer pointer 1 (7 refs) */
#define serial_receive_buffer_state (*(volatile uint16_t*)0x0080CF80UL) /* Serial receive buffer state machine */
#define timer_task_scheduler_state (*(volatile uint16_t*)0x0080CF84UL) /* Timer-based task scheduler state machine (11 refs) */
#define can_single_frame_transmit_flag (*(volatile uint8_t*)0x0080CF88UL) /* CAN single frame transmit flag (sendCanSingleFr... */
#define serial_receive_timer (*(volatile uint8_t*)0x0080CF89UL) /* Serial receive buffer processor timer (5 refs) */
#define serial_node_transmit_ptr (*(volatile uint32_t*)0x0080CF8CUL) /* Serial port transmit buffer pointer (7 refs) */
#define can_transmit_retry_count (*(volatile uint16_t*)0x0080CFA2UL) /* CAN transmit retry count config (1 ref) */
#define can_transmission_scheduler_data (*(volatile uint32_t*)0x0080CFA4UL) /* CAN transmission scheduler data buffer (canTran... */
#define fuel_arbitrator_state (*(volatile uint16_t*)0x0080CFA8UL) /* Fuel arbitrator state machine */
#define retarder_mode_can_source_priority (*(volatile uint16_t*)0x0080CFAAUL) /* CAN source priority for retarder mode selection... */
#define retarder_control_can_source (*(volatile uint8_t*)0x0080CFACUL) /* Retarder control mode CAN source address (6 refs) */
#define retarder_control_source_byte (*(volatile uint8_t*)0x0080CFADUL) /* Retarder control source status byte (diagnostic... */
#define retarder_mode_control_byte_cached (*(volatile uint16_t*)0x0080CFAEUL) /* Cached copy of retarder_mode_control_byte_mirro... */
#define retarder_mode_threshold_result (*(volatile uint8_t*)0x0080CFB0UL) /* Retarder mode threshold calculation result */
#define retarder_mode_table_count (*(volatile uint8_t*)0x0080CFB2UL) /* Number of active retarder mode threshold tables... */
#define retarder_percentage_scaled_output (*(volatile uint16_t*)0x0080CFB4UL) /* Result from retarderPercentageScaler (0x6400 or... */
#define serial_node_address_state (*(volatile uint16_t*)0x0080CFB6UL) /* Serial communication node address state (11 refs) */
#define serial_node_address_limit (*(volatile uint16_t*)0x0080CFB8UL) /* Serial node address maximum limit (4 refs) */
#define can_filter_mask_array_low (*(volatile uint16_t*)0x0080CFBAUL) /* CAN message filter mask array low word (canMess... */
#define j1939_multiframe_source_address (*(volatile uint8_t*)0x0080CFC2UL) /* J1939 multi-frame transmission source address (... */
#define j1939_source_address_primary (*(volatile uint8_t*)0x0080CFC3UL) /* J1939 source address for primary ECU (0xC3 = 19... */
#define can_filter_mask_array_high (*(volatile uint16_t*)0x0080CFC4UL) /* CAN message filter mask array high word (canMes... */
#define can_cpu_interface_address (*(volatile uint8_t*)0x0080CFCCUL) /* CAN CPU interface register address (4 refs) */
#define j1939_source_address_secondary (*(volatile uint8_t*)0x0080CFCDUL) /* J1939 source address for secondary functions (0... */
#define diagnostic_mode_state (*(volatile uint8_t*)0x0080CFCEUL) /* Diagnostic mode state flag (2 refs) */
#define param_table_main (*(volatile uint16_t*)0x0080CFD6UL) /* Primary parameter storage (param_lookup_1 target) */
#define param_table_aux (*(volatile uint16_t*)0x0080CFD8UL) /* Auxiliary parameters */
#define param_table_ctrl (*(volatile uint16_t*)0x0080CFDAUL) /* Control parameters (param_lookup_2 target) */
#define param_table_ext (*(volatile uint16_t*)0x0080CFDCUL) /* Extended parameters */
#define param_table_calc (*(volatile uint16_t*)0x0080CFDEUL) /* Calculated parameter values (param_lookup_3 tar... */
#define calculated_2 (*(volatile uint16_t*)0x0080CFE0UL) /* More calculated values */
#define calculated_3 (*(volatile uint16_t*)0x0080CFE2UL) /* Additional calculated */
#define calculated_4 (*(volatile uint16_t*)0x0080CFE4UL) /* Final calculated values */
#define result_buffer (*(volatile uint16_t*)0x0080CFE6UL) /* Final result storage */
#define fuel_offset_blend_value (*(volatile uint16_t*)0x0080CFE8UL) /* Fuel offset blend calculation value (11 refs) */
#define fuel_mode_selection_offset (*(volatile uint16_t*)0x0080CFEAUL) /* Fuel mode selection calculated offset value (11... */
#define fuel_mode_blend_state (*(volatile uint16_t*)0x0080CFECUL) /* Fuel mode selection blend state (3 refs) */
#define fuel_mode_blend_result (*(volatile uint16_t*)0x0080CFEEUL) /* Fuel mode blend calculation result (9 refs) */
#define fuel_parameter_blend_value (*(volatile uint16_t*)0x0080CFF0UL) /* Fuel parameter blend calculator value (3 refs) */
#define fuel_parameter_blend_state (*(volatile uint16_t*)0x0080CFF2UL) /* Fuel parameter blend calculator state (3 refs) */
#define fuel_mode_selection_state (*(volatile uint16_t*)0x0080CFF4UL) /* Fuel mode selection calculator state (8 refs) */
#define param_system_mode_state (*(volatile uint16_t*)0x0080CFF6UL) /* Parameter system mode controller state (5 refs) */
#define fuel_arbitrator_control_mode (*(volatile uint16_t*)0x0080D01AUL) /* Fuel arbitrator control mode */
#define timer_capture_value (*(volatile uint16_t*)0x0080D01EUL) /* Timer capture register value */
#define retarder_control_mode_state (*(volatile uint16_t*)0x0080D022UL) /* Retarder control mode handler state (7 refs) */
#define fuel_arbitrator_response_timer (*(volatile uint16_t*)0x0080D026UL) /* Fuel arbitrator response countdown timer (12 refs) */
#define torque_control_mode_timer (*(volatile uint16_t*)0x0080D028UL) /* Torque control mode handler timer (18 refs) */
#define fuel_arbitrator_status_counter (*(volatile uint16_t*)0x0080D02AUL) /* Fuel arbitrator status processor counter (6 refs) */
#define retarder_control_mode_timer (*(volatile uint16_t*)0x0080D02CUL) /* Retarder control mode state timer (11 refs) */
#define fuel_arbitrator_speed_timer (*(volatile uint16_t*)0x0080D02EUL) /* Fuel arbitrator speed limit timer (10 refs) */
#define fuel_arbitrator_status_timer (*(volatile uint16_t*)0x0080D030UL) /* Fuel arbitrator status processor timer (6 refs) */
#define fuel_arbitrator_session_timer (*(volatile uint16_t*)0x0080D032UL) /* Fuel arbitrator session countdown timer (11 refs) */
#define fuel_arbitrator_session_counter (*(volatile uint16_t*)0x0080D034UL) /* Fuel arbitrator session message counter (9 refs) */
#define fuel_arbitrator_throttle_override (*(volatile uint16_t*)0x0080D036UL) /* Fuel arbitrator throttle override value */
#define retarder_mode_override_flag (*(volatile uint8_t*)0x0080D038UL) /* Cleared during state transitions in mode 2/3 */
#define fuel_demand_change_flag (*(volatile uint8_t*)0x0080D03AUL) /* Fuel demand/governor RPM change flag (4 refs) */
#define crank_state_transition_flag (*(volatile uint8_t*)0x0080D03CUL) /* Crank state transition detection flag (3 refs) */
#define io_control_bit0_state (*(volatile IO_CONTROL_STATE*)0x0080D03EUL) /* I/O control state for bit 0 of io_control_sourc... */
#define io_control_bit1_state (*(volatile IO_CONTROL_STATE*)0x0080D040UL) /* I/O control state for bit 1 of io_control_sourc... */
#define accumulated_backup_eps_period_between_vss_interrupts_0_65535 (*(volatile uint16_t*)0x0080D042UL) /* ACCUMULATED BACKUP EPS PERIOD BETWEEN VSS INTER... */
#define io_control_bit6_state (*(volatile IO_CONTROL_STATE*)0x0080D044UL) /* I/O control state for bit 6 of io_control_sourc... */
#define io_control_bit4_state (*(volatile IO_CONTROL_STATE*)0x0080D046UL) /* I/O control state for bit 4 of io_control_sourc... */
#define number_of_backup_eps_interrupts_between_vss_interrupts_0_65535 (*(volatile uint16_t*)0x0080D048UL) /* NUMBER OF BACKUP EPS INTERRUPTS BETWEEN VSS INT... */
#define io_control_handshake_state (*(volatile uint8_t*)0x0080D04AUL) /* I/O control 3-state handshake protocol (0 1 2) ... */
#define io_control_active_mask (*(volatile uint16_t*)0x0080D04CUL) /* IO control active mask built from table */
#define eps_period_backup_time_between_the_two_most_recent_eps_200_16777216 (*(volatile uint16_t*)0x0080D04EUL) /* EPS_PERIOD_BACKUP: TIME BETWEEN THE TWO MOST RE... */
#define crank_state_active_flag (*(volatile uint8_t*)0x0080D050UL) /* Crank state active flag (4 refs) */
#define main_signal_edge_time_stamp_0_65535 (*(volatile uint16_t*)0x0080D052UL) /* MAIN SIGNAL EDGE TIME STAMP */
#define backup_signal_edge_time_stamp_0_65535 (*(volatile uint16_t*)0x0080D054UL) /* BACKUP SIGNAL EDGE TIME STAMP */
#define cam_sync_lost_duration_0_20 (*(volatile uint16_t*)0x0080D056UL) /* CAM_SYNC_LOST_DURATION [CalTerm: CMLSEL] */
#define dzg_pressure_threshold_high (*(volatile uint16_t*)0x0080D058UL) /* DZG pressure state high threshold (3 refs) */
#define eps_main_lost_duration_0_20 (*(volatile uint16_t*)0x0080D05AUL) /* EPS_MAIN_LOST_DURATION */
#define eps_external_lost_duration_0_20 (*(volatile uint16_t*)0x0080D05EUL) /* EPS_EXTERNAL_LOST_DURATION */
#define governor_pid_proportional_term_d060 (*(volatile uint16_t*)0x0080D060UL) /* Governor PID proportional term output (2 refs) */
#define governor_pid_derivative_term_d062 (*(volatile uint16_t*)0x0080D062UL) /* Governor PID derivative term output (4 refs) */
#define eps_raw_period_backup_raw_time_between_teeth_not_norm_d_to_1_200000 (*(volatile uint32_t*)0x0080D064UL) /* EPS_RAW_PERIOD_BACKUP: RAW TIME BETWEEN TEETH N... */
#define cam_sync_backup_lost_duration_duration_in_no_sync_state_0_20 (*(volatile uint16_t*)0x0080D068UL) /* CAM_SYNC_BACKUP_LOST_DURATION:DURATION IN NO SY... */
#define crank_sync_backup_lost_duration_amount_of_time_crank_sync_lost_1_20 (*(volatile uint16_t*)0x0080D06AUL) /* CRANK_SYNC_BACKUP_LOST_DURATION: AMOUNT OF TIME... */
#define governor_rpm_target_adjusted (*(volatile uint16_t*)0x0080D06CUL) /* Governor RPM target with offset adjustment (7 r... */
#define eps_acceleration_active_flag (*(volatile uint16_t*)0x0080D076UL) /* EPS acceleration monitor active flag (5 refs) */
#define eps_control_mode_param_1 (*(volatile uint16_t*)0x0080D078UL) /* EPS control mode parameter 1 from selector (4 r... */
#define eps_control_mode_param_2 (*(volatile uint16_t*)0x0080D07AUL) /* EPS control mode parameter 2 integral gain (2 r... */
#define eps_control_mode_param_3 (*(volatile uint16_t*)0x0080D07CUL) /* EPS control mode parameter 3 derivative gain (3... */
#define eps_acceleration_monitor_value (*(volatile uint16_t*)0x0080D07EUL) /* EPS acceleration monitor value (12 refs) */
#define eps_override_output_state (*(volatile uint16_t*)0x0080D080UL) /* EPS override output state (3 refs) */
#define eps_override_checker_state (*(volatile uint16_t*)0x0080D082UL) /* EPS override checker state (2 refs) */
#define eps_control_mode_init_value_2 (*(volatile uint16_t*)0x0080D084UL) /* EPS control mode init value 2 (1 ref) */
#define eps_control_mode_init_value_1 (*(volatile uint16_t*)0x0080D086UL) /* EPS control mode init value 1 (1 ref) */
#define eps_control_mode_init_state (*(volatile uint16_t*)0x0080D088UL) /* EPS control mode init state (1 ref) */
#define eps_acceleration_monitor_state (*(volatile uint16_t*)0x0080D08AUL) /* EPS acceleration monitor state (4 refs) */
#define eps_control_mode_selector_state_d08e (*(volatile uint16_t*)0x0080D08EUL) /* EPS control mode selector state (5 refs) */
#define governor_rpm_error_value (*(volatile uint16_t*)0x0080D092UL) /* Governor PID RPM error tracking value (23 refs) */
#define engine_mode_timing_adjuster_state (*(volatile uint16_t*)0x0080D094UL) /* Engine mode timing adjuster state (7 refs) */
#define fuel_timing_offset_value (*(volatile uint16_t*)0x0080D096UL) /* Governor fuel PID timing offset value (9 refs) */
#define engine_mode_timing_init_flag (*(volatile uint16_t*)0x0080D098UL) /* Engine mode timing adjuster init flag (2 refs) */
#define four_d_timing_output_by_crank_0_120 (*(volatile uint16_t*)0x0080D09CUL) /* 4D TIMING OUTPUT BY CRANK [CalTerm: CK4DTA] */
#define crank_exit_timer_0_13107 (*(volatile uint16_t*)0x0080D09EUL) /* CRANK EXIT TIMER */
#define timer_used_to_dictate_a_jumpstart_condition_0_13107 (*(volatile uint16_t*)0x0080D0A0UL) /* TIMER USED TO DICTATE A JUMPSTART CONDITION [Ca... */
#define coolant_advance_timing_output_by_crank_0_700 (*(volatile uint16_t*)0x0080D0A2UL) /* COOLANT ADVANCE TIMING OUTPUT BY CRANK [CalTerm... */
#define wet_stack_timing_outputed_by_crank_0_120 (*(volatile uint16_t*)0x0080D0A4UL) /* WET STACK TIMING OUTPUTED BY CRANK [CalTerm: CK... */
#define fsmxthfl_calc_input (*(volatile uint16_t*)0x0080D0AAUL) /* FSMXTHFL calculation input variable (_DAT_0080d... */
#define crank_fuel_limit_source_selector (*(volatile uint16_t*)0x0080D0ACUL) /* Crank fuel limit source selector (5 refs) */
#define crank_adjusted_initial_fuel_0_100 (*(volatile uint16_t*)0x0080D0AEUL) /* CRANK ADJUSTED INITIAL FUEL [CalTerm: CKAJIIFL] */
#define crank_adjusted_initial_rpm_0_1000 (*(volatile uint16_t*)0x0080D0B0UL) /* CRANK ADJUSTED INITIAL RPM [CalTerm: CKAJIIES] */
#define crank_initial_fuel_break_speed_0_1000 (*(volatile uint16_t*)0x0080D0B2UL) /* CRANK INITIAL FUEL BREAK SPEED [CalTerm: CKIIFLES] */
#define crank_initial_advace_break_speed_0_1000 (*(volatile uint16_t*)0x0080D0B4UL) /* CRANK INITIAL ADVACE BREAK SPEED [CalTerm: CKII... */
#define crank_exit_fuel_adjustment_0_100 (*(volatile uint16_t*)0x0080D0B6UL) /* CRANK EXIT FUEL ADJUSTMENT [CalTerm: CKEXFLAJ] */
#define crank_exit_advance_0_120 (*(volatile uint16_t*)0x0080D0B8UL) /* CRANK EXIT ADVANCE */
#define timing_command_before_cranking_is_envoked_0_120 (*(volatile uint16_t*)0x0080D0BAUL) /* TIMING COMMAND BEFORE CRANKING IS ENVOKED */
#define fueling_val_to_be_added_to_crank_initial_fuel_val_0_100 (*(volatile uint16_t*)0x0080D0BCUL) /* FUELING VAL. TO BE ADDED TO CRANK INITIAL FUEL ... */
#define eng_spd_val_to_be_added_to_crk_init_fuel_brk_spd_0_1000 (*(volatile uint16_t*)0x0080D0BEUL) /* ENG. SPD. VAL. TO BE ADDED TO CRK INIT FUEL BRK... */
#define crank_fuel_divisor (*(volatile uint16_t*)0x0080D0C0UL) /* Crank fuel proportional calculation divisor (3 ... */
#define param_scaling_factor (*(volatile uint16_t*)0x0080D0C2UL) /* Parameter scaling factor used in calculations */
#define io_output_flag_byte_0 (*(volatile uint8_t*)0x0080D0C4UL) /* IO output flag byte 0 */
#define io_output_flag_byte_1 (*(volatile uint8_t*)0x0080D0C5UL) /* IO output flag byte 1 */
#define asthrfes_calc_input (*(volatile uint16_t*)0x0080D0C6UL) /* ASTHRFES throttle position speed calculation in... */
#define smoke_limiter_output_value (*(volatile uint16_t*)0x0080D0C8UL) /* Smoke limiter calculation output */
#define CMSYSS (*(volatile uint8_t*)0x0080D0CCUL) /* CalTerm CMSYSS: CAM_SYNC_STATE: 0=NO SYNC,1=HAV... */
#define CMSYRSFG (*(volatile uint8_t*)0x0080D0CEUL) /* CAM_CYCLE_RESET:FLAG INDICATING OCCURRENCE OF E... */
#define flag_indicating_crank_rev_1_or_2_of_cam_rev_0_1 (*(volatile uint8_t*)0x0080D0CFUL) /* FLAG INDICATING CRANK REV 1 OR 2 OF CAM REV [Ca... */
#define CMSYBKSS (*(volatile uint8_t*)0x0080D0D0UL) /* CalTerm CMSYBKSS: CAM_SYNC_STATE_BACKUP: 0 = NO... */
#define CRSYBKSS (*(volatile uint8_t*)0x0080D0D1UL) /* CalTerm CRSYBKSS: CRANK_SYNC_STATE_BACKUP: 0 = ... */
#define incremented_6_cam_when_crank_not_synched_0_65535 (*(volatile uint16_t*)0x0080D0D4UL) /* INCREMENTED 6/CAM WHEN CRANK NOT SYNCHED */
#define number_of_losses_of_cam_sync_for_backup_0_200 (*(volatile uint16_t*)0x0080D0D6UL) /* NUMBER OF LOSSES OF CAM SYNC FOR BACKUP */
#define number_of_losses_of_crank_sync_for_backup_0_65535 (*(volatile uint16_t*)0x0080D0D8UL) /* NUMBER OF LOSSES OF CRANK SYNC FOR BACKUP */
#define state_flag_to_use_epf_s_rpm_breakpoints_for_j1939_0_ffff (*(volatile uint16_t*)0x0080D0DAUL) /* STATE FLAG TO USE EPF'S RPM BREAKPOINTS FOR J1939. */
#define mask_for_input_of_coolant_level_0_65535 (*(volatile uint16_t*)0x0080D0E0UL) /* MASK FOR INPUT OF COOLANT LEVEL */
#define amount_of_time_since_coolant_level_low_failure_was_detected_0_65535 (*(volatile uint16_t*)0x0080D0E2UL) /* AMOUNT OF TIME SINCE COOLANT LEVEL LOW FAILURE ... */
#define amount_of_time_since_coolant_level_low_rpm_failure_was_detec_0_65535 (*(volatile uint16_t*)0x0080D0E4UL) /* AMOUNT OF TIME SINCE COOLANT LEVEL LOW RPM FAIL... */
#define pointer_to_coolant_level_fuel_min_threshold_0_2_32 (*(volatile uint32_t*)0x0080D0E6UL) /* POINTER TO COOLANT LEVEL FUEL MIN THRESHOLD */
#define pointer_to_coolant_level_fuel_max_threshold_0_2_32 (*(volatile uint32_t*)0x0080D0EAUL) /* POINTER TO COOLANT LEVEL FUEL MAX THRESHOLD */
#define pointer_to_coolant_level_rpm_limit_threshold_0_2_32 (*(volatile uint32_t*)0x0080D0EEUL) /* POINTER TO COOLANT LEVEL RPM LIMIT THRESHOLD */
#define EPCVEREN (*(volatile uint16_t*)0x0080D0F2UL) /* CalTerm EPCVEREN: TRUE = COOLANT LEVEL ERROR AL... */
#define coolant_level_system_error_detected_before_cranking_i_1_true_0_false (*(volatile uint16_t*)0x0080D0F4UL) /* COOLANT LEVEL SYSTEM ERROR DETECTED BEFORE CRAN... */
#define amount_of_time_over_coolant_level_fuel_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D0F6UL) /* AMOUNT OF TIME OVER COOLANT LEVEL FUEL SHUTDOWN... */
#define amount_of_time_over_coolant_level_rpm_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D0F8UL) /* AMOUNT OF TIME OVER COOLANT LEVEL RPM SHUTDOWN ... */
#define delay_before_warning_about_shutdown_from_coolant_level_fuel_0_65535 (*(volatile uint16_t*)0x0080D0FAUL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM COOLAN... */
#define delay_before_warning_about_shutdown_from_coolant_leve_rpm_0_65535 (*(volatile uint16_t*)0x0080D0FCUL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM COOLAN... */
#define time_since_rpm_crossed_coolant_lev_start_mon_rpm_0_65535 (*(volatile uint16_t*)0x0080D0FEUL) /* TIME SINCE RPM CROSSED COOLANT LEV. START MON RPM */
#define errors_allowed_timer_running_flag_for_coolant_lev_0_1 (*(volatile uint16_t*)0x0080D100UL) /* ERRORS ALLOWED TIMER RUNNING FLAG FOR COOLANT LEV. */
#define pointer_to_coolant_level_fuel_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D102UL) /* POINTER TO COOLANT LEVEL FUEL FAULT LOG DATA */
#define pointer_to_coolant_level_rpm_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D106UL) /* POINTER TO COOLANT LEVEL RPM FAULT LOG DATA */
#define mask_for_input_of_coolant_temp_0_65535 (*(volatile uint16_t*)0x0080D10EUL) /* MASK FOR INPUT OF COOLANT TEMP */
#define amount_of_time_since_coolant_temp_failure_was_detected_0_65535 (*(volatile uint16_t*)0x0080D110UL) /* AMOUNT OF TIME SINCE COOLANT TEMP FAILURE WAS D... */
#define time_duration_since_coolant_temperature_failure_was_detected_0_65535 (*(volatile uint16_t*)0x0080D112UL) /* TIME DURATION SINCE COOLANT TEMPERATURE FAILURE... */
#define pointer_to_coolant_temperature_fuel_min_threshold_0_2_32 (*(volatile uint32_t*)0x0080D114UL) /* POINTER TO COOLANT TEMPERATURE FUEL MIN THRESHOLD */
#define pointer_to_coolant_temperature_fuel_max_threshold_0_2_32 (*(volatile uint32_t*)0x0080D118UL) /* POINTER TO COOLANT TEMPERATURE FUEL MAX THRESHOLD */
#define pointer_to_coolant_temperature_rpm_limit_threshold_0_2_32 (*(volatile uint32_t*)0x0080D11CUL) /* POINTER TO COOLANT TEMPERATURE RPM LIMIT THRESHOLD */
#define EPCQEREN (*(volatile uint16_t*)0x0080D120UL) /* CalTerm EPCQEREN: TRUE = COOLANT TEMP. ERROR AL... */
#define imt_error_detected_before_cranking_in_restart_situati_1_true_0_false (*(volatile uint16_t*)0x0080D122UL) /* IMT ERROR DETECTED BEFORE CRANKING IN RESTART S... */
#define amount_of_time_over_coolant_temp_fuel_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D124UL) /* AMOUNT OF TIME OVER COOLANT TEMP. FUEL SHUTDOWN... */
#define amount_of_time_over_coolant_temp_rpm_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D126UL) /* AMOUNT OF TIME OVER COOLANT TEMP. RPM SHUTDOWN ... */
#define delay_before_warning_about_shutdown_from_coolant_temp_fuel_0_65535 (*(volatile uint16_t*)0x0080D128UL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM COOLAN... */
#define delay_before_warning_about_shutdown_from_coolant_temp_rpm_0_65535 (*(volatile uint16_t*)0x0080D12AUL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM COOLAN... */
#define time_since_rpm_crossed_coolant_temp_start_mon_rpm_0_65535 (*(volatile uint16_t*)0x0080D12CUL) /* TIME SINCE RPM CROSSED COOLANT TEMP. START MON RPM */
#define errors_allowed_timer_running_flag_for_coolant_temp_0_1 (*(volatile uint16_t*)0x0080D12EUL) /* ERRORS ALLOWED TIMER RUNNING FLAG FOR COOLANT T... */
#define pointer_to_coolant_temperature_fuel_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D130UL) /* POINTER TO COOLANT TEMPERATURE FUEL FAULT LOG DATA */
#define pointer_to_coolant_temperature_rpm_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D134UL) /* POINTER TO COOLANT TEMPERATURE RPM FAULT LOG DATA */
#define mask_for_input_of_the_intake_man_temp_0_65535 (*(volatile uint16_t*)0x0080D13CUL) /* MASK FOR INPUT OF THE INTAKE MAN TEMP */
#define time_duration_since_im_temperature_failure_was_detected_0_65535 (*(volatile uint16_t*)0x0080D13EUL) /* TIME DURATION SINCE IM TEMPERATURE FAILURE WAS ... */
#define time_duration_since_imt_failure_was_detedted_0_65535 (*(volatile uint16_t*)0x0080D140UL) /* TIME DURATION SINCE IMT FAILURE WAS DETEDTED. */
#define pointer_to_intake_man_temp_fuel_min_threshold_0_2_32 (*(volatile uint32_t*)0x0080D142UL) /* POINTER TO INTAKE MAN. TEMP FUEL MIN THRESHOLD */
#define pointer_to_intake_man_temp_fuel_max_threshold_0_2_32 (*(volatile uint32_t*)0x0080D146UL) /* POINTER TO INTAKE MAN. TEMP FUEL MAX THRESHOLD */
#define pointer_to_intake_man_temp_rpm_limit_threshold_0_2_32 (*(volatile uint32_t*)0x0080D14AUL) /* POINTER TO INTAKE MAN. TEMP RPM LIMIT THRESHOLD */
#define EPIMEREN (*(volatile uint16_t*)0x0080D14EUL) /* CalTerm EPIMEREN: TRUE = INTAKE TEMP. ERROR ALL... */
#define oil_temperature_error_detected_before_cranking_in_res_1_true_0_false (*(volatile uint16_t*)0x0080D150UL) /* OIL TEMPERATURE ERROR DETECTED BEFORE CRANKING ... */
#define amount_of_time_over_intake_temp_fuel_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D152UL) /* AMOUNT OF TIME OVER INTAKE TEMP. FUEL SHUTDOWN ... */
#define amount_of_time_over_intake_temp_rpm_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D154UL) /* AMOUNT OF TIME OVER INTAKE TEMP. RPM SHUTDOWN T... */
#define delay_before_warning_about_shutdown_from_intake_temp_fuel_0_65535 (*(volatile uint16_t*)0x0080D156UL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM INTAKE... */
#define delay_before_warning_about_shutdown_from_intake_temp_rpm_0_65535 (*(volatile uint16_t*)0x0080D158UL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM INTAKE... */
#define time_since_rpm_crossed_intake_temp_start_mon_rpm_0_65535 (*(volatile uint16_t*)0x0080D15AUL) /* TIME SINCE RPM CROSSED INTAKE TEMP. START MON RPM */
#define errors_allowed_timer_running_flag_for_intake_temp_0_1 (*(volatile uint16_t*)0x0080D15CUL) /* ERRORS ALLOWED TIMER RUNNING FLAG FOR INTAKE TEMP. */
#define pointer_to_intake_man_temp_fuel_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D15EUL) /* POINTER TO INTAKE MAN. TEMP FUEL FAULT LOG DATA */
#define pointer_to_intake_man_temp_rpm_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D162UL) /* POINTER TO INTAKE MAN. TEMP RPM FAULT LOG DATA */
#define mask_for_input_of_the_oil_pressure_input_0_65535 (*(volatile uint16_t*)0x0080D16AUL) /* MASK FOR INPUT OF THE OIL PRESSURE INPUT */
#define amount_of_time_since_oil_pressure_failure_was_detected_0_65535 (*(volatile uint16_t*)0x0080D16CUL) /* AMOUNT OF TIME SINCE OIL PRESSURE FAILURE WAS D... */
#define time_duration_since_oil_pressure_fault_was_detected_0_65535 (*(volatile uint16_t*)0x0080D16EUL) /* TIME DURATION SINCE OIL PRESSURE FAULT WAS DETE... */
#define oil_pressure_fuel_min_threshold (*(volatile uint16_t*)0x0080D170UL) /* Oil pressure fuel minimum threshold value (6 refs) */
#define oil_pressure_fuel_min_threshold_high (*(volatile uint16_t*)0x0080D172UL) /* Oil pressure fuel min threshold high byte (unused) */
#define oil_pressure_fuel_max_threshold (*(volatile uint16_t*)0x0080D174UL) /* Oil pressure fuel maximum threshold value (18 r... */
#define oil_pressure_fuel_max_threshold_high (*(volatile uint16_t*)0x0080D176UL) /* Oil pressure fuel max threshold high byte (unused) */
#define oil_pressure_rpm_limit_threshold (*(volatile uint16_t*)0x0080D178UL) /* Oil pressure RPM limit threshold value (10 refs) */
#define oil_pressure_protection_enabled (*(volatile uint16_t*)0x0080D17AUL) /* Oil pressure protection system enable flag */
#define sensor_history_state_machine (*(volatile SENSOR_HISTORY_STATE*)0x0080D17CUL) /* Sensor status history state machine [CalTerm: E... */
#define true_oil_pressure_precrank_error_1_true_0_false (*(volatile uint16_t*)0x0080D17EUL) /* TRUE = OIL PRESSURE PRECRANK ERROR */
#define amount_of_time_over_oil_pressure_fuel_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D180UL) /* AMOUNT OF TIME OVER OIL PRESSURE FUEL SHUTDOWN ... */
#define amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D182UL) /* AMOUNT OF TIME OVER OIL PRESSURE RPM SHUTDOWN T... */
#define delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 (*(volatile uint16_t*)0x0080D184UL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM OIL PR... */
#define delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535 (*(volatile uint16_t*)0x0080D186UL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM OIL PR... */
#define time_since_rpm_crossed_oil_pres_start_mon_rpm_0_65535 (*(volatile uint16_t*)0x0080D188UL) /* TIME SINCE RPM CROSSED OIL PRES. START MON RPM */
#define errors_allowed_timer_running_flag_for_oil_pres_0_1 (*(volatile uint16_t*)0x0080D18AUL) /* ERRORS ALLOWED TIMER RUNNING FLAG FOR OIL PRES. */
#define oil_pressure_fuel_fault_timer (*(volatile uint16_t*)0x0080D18CUL) /* Oil pressure fuel fault log timer/counter (4 refs) */
#define oil_pressure_rpm_fault_delay (*(volatile uint16_t*)0x0080D18EUL) /* Oil pressure RPM fault delay timer (6 refs) */
#define oil_pressure_rpm_fault_counter (*(volatile uint16_t*)0x0080D190UL) /* Oil pressure RPM fault detection counter (8 refs) */
#define oil_pressure_fuel_fault_counter (*(volatile uint16_t*)0x0080D192UL) /* Oil pressure fuel fault detection counter (8 refs) */
#define mask_for_input_of_water_in_fuel_0_65535 (*(volatile uint16_t*)0x0080D198UL) /* MASK FOR INPUT OF WATER IN FUEL */
#define amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535_d19a (*(volatile uint16_t*)0x0080D19AUL) /* AMOUNT OF TIME SINCE WATER IN FUEL LOW FAILURE ... */
#define amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535_d19c (*(volatile uint16_t*)0x0080D19CUL) /* AMOUNT OF TIME SINCE WATER IN FUEL LOW FAILURE ... */
#define engine_sync_fuel_pressure_min_threshold_flag (*(volatile uint16_t*)0x0080D19EUL) /* Engine sync fuel pressure minimum threshold fla... */
#define calibration_checksum_workspace (*(volatile uint32_t*)0x0080D1A0UL) /* Calibration data checksum workspace in calibrat... */
#define points_to_water_in_fuel_fuel_maximum_threshold_0_2_32 (*(volatile uint32_t*)0x0080D1A2UL) /* POINTS TO WATER IN FUEL FUEL MAXIMUM THRESHOLD */
#define system_logging_state (*(volatile uint16_t*)0x0080D1A4UL) /* System data logging state flag (1=active 2=erro... */
#define pointer_to_water_in_fuel_rpm_limit_threshold_0_2_32 (*(volatile uint32_t*)0x0080D1A6UL) /* POINTER TO WATER IN FUEL RPM LIMIT THRESHOLD */
#define EPWFEREN (*(volatile uint16_t*)0x0080D1AAUL) /* CalTerm EPWFEREN: TRUE=WATER IN FUEL ERROR ALLO... */
#define true_water_in_fuel_precrank_error_0_1 (*(volatile uint16_t*)0x0080D1ACUL) /* TRUE=WATER IN FUEL PRECRANK ERROR */
#define amount_of_time_over_water_in_fuel_fuel_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D1AEUL) /* AMOUNT OF TIME OVER WATER IN FUEL FUEL SHUTDOWN... */
#define amount_of_time_over_water_in_fuel_rpm_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D1B0UL) /* AMOUNT OF TIME OVER WATER IN FUEL RPM SHUTDOWN ... */
#define delay_before_warning_about_shutdown_from_water_in_fuel_0_65535 (*(volatile uint16_t*)0x0080D1B2UL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM WATER ... */
#define delay_before_warning_abuot_shutdown_from_water_in_fuel_rpm_0_65535 (*(volatile uint16_t*)0x0080D1B4UL) /* DELAY BEFORE WARNING ABUOT SHUTDOWN FROM WATER ... */
#define time_since_rpm_crossed_water_in_fuel_start_mon_rpm_0_65535 (*(volatile uint16_t*)0x0080D1B6UL) /* TIME SINCE RPM CROSSED WATER IN FUEL. START MON... */
#define errors_allowed_timer_running_flag_for_water_in_fuel_0_1 (*(volatile uint16_t*)0x0080D1B8UL) /* ERRORS ALLOWED TIMER RUNNING FLAG FOR WATER IN ... */
#define pointer_to_water_in_fuel_fuel_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D1BAUL) /* POINTER TO WATER IN FUEL FUEL FAULT LOG DATA */
#define pointer_to_water_in_fuel_rpm_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D1BEUL) /* POINTER TO WATER IN FUEL RPM FAULT LOG DATA */
#define mask_for_input_of_boost_pressure_0_65535 (*(volatile uint16_t*)0x0080D1C6UL) /* MASK FOR INPUT OF BOOST PRESSURE */
#define amount_of_time_since_boost_pressure_low_failure_was_detected_0_65535_d1c8 (*(volatile uint16_t*)0x0080D1C8UL) /* AMOUNT OF TIME SINCE BOOST PRESSURE LOW FAILURE... */
#define amount_of_time_since_boost_pressure_low_failure_was_detected_0_65535_d1ca (*(volatile uint16_t*)0x0080D1CAUL) /* AMOUNT OF TIME SINCE BOOST PRESSURE LOW FAILURE... */
#define engine_sync_fuel_pressure_min_threshold_flag_2 (*(volatile uint16_t*)0x0080D1CCUL) /* Engine sync fuel pressure minimum threshold flag 2 */
#define points_to_boost_pressure_fuel_maximum_threshold_0_2_32 (*(volatile uint32_t*)0x0080D1D0UL) /* POINTS TO BOOST PRESSURE FUEL MAXIMUM THRESHOLD */
#define pointer_to_boost_pressure_rpm_limit_threshold_0_2_32 (*(volatile uint32_t*)0x0080D1D4UL) /* POINTER TO BOOST PRESSURE RPM LIMIT THRESHOLD */
#define EPBSEREN (*(volatile uint16_t*)0x0080D1D8UL) /* CalTerm EPBSEREN: TRUE=BOOST PRESSURE ERROR ALL... */
#define true_boost_pressure_precrank_error_0_1 (*(volatile uint16_t*)0x0080D1DAUL) /* TRUE=BOOST PRESSURE PRECRANK ERROR */
#define amount_of_time_over_boost_pressure_fuel_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D1DCUL) /* AMOUNT OF TIME OVER BOOST PRESSURE FUEL SHUTDOW... */
#define amount_of_time_over_boost_pressure_rpm_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D1DEUL) /* AMOUNT OF TIME OVER BOOST PRESSURE RPM SHUTDOWN... */
#define delay_before_warning_about_shutdown_from_boost_pressure_fuel_0_65535 (*(volatile uint16_t*)0x0080D1E0UL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM BOOST ... */
#define delay_before_warning_abuot_shutdown_from_boost_pressure_rpm_0_65535 (*(volatile uint16_t*)0x0080D1E2UL) /* DELAY BEFORE WARNING ABUOT SHUTDOWN FROM BOOST ... */
#define time_since_rpm_crossed_boost_pressure_start_mon_rpm_0_65535 (*(volatile uint16_t*)0x0080D1E4UL) /* TIME SINCE RPM CROSSED BOOST PRESSURE. START MO... */
#define errors_allowed_timer_running_flag_for_boost_pressure_0_1 (*(volatile uint16_t*)0x0080D1E6UL) /* ERRORS ALLOWED TIMER RUNNING FLAG FOR BOOST PRE... */
#define pointer_to_boost_pressure_fuel_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D1E8UL) /* POINTER TO BOOST PRESSURE FUEL FAULT LOG DATA */
#define pointer_to_boost_pressure_rpm_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D1ECUL) /* POINTER TO BOOST PRESSURE RPM FAULT LOG DATA */
#define mask_for_input_of_engine_sync_fuel_pressure_0_65535 (*(volatile uint16_t*)0x0080D1F4UL) /* MASK FOR INPUT OF ENGINE SYNC FUEL PRESSURE */
#define amount_of_time_since_eng_sync_fuel_pressure_low_failure_was_de_0_65535_d1f6 (*(volatile uint16_t*)0x0080D1F6UL) /* AMOUNT OF TIME SINCE ENG SYNC FUEL PRESSURE LOW... */
#define amount_of_time_since_eng_sync_fuel_pressure_low_failure_was_de_0_65535_d1f8 (*(volatile uint16_t*)0x0080D1F8UL) /* AMOUNT OF TIME SINCE ENG SYNC FUEL PRESSURE LOW... */
#define engine_sync_fuel_pressure_min_threshold_flag_3 (*(volatile uint16_t*)0x0080D1FAUL) /* Engine sync fuel pressure minimum threshold flag 3 */
#define engine_sync_fuel_pressure_reserved (*(volatile uint16_t*)0x0080D1FCUL) /* Engine sync fuel pressure reserved */
#define engine_sync_fuel_pressure_max_threshold_flag (*(volatile uint16_t*)0x0080D1FEUL) /* Engine sync fuel pressure maximum threshold flag */
#define pointer_to_engine_sync_fuel_pressure_rpm_limit_threshold_0_2_32 (*(volatile uint32_t*)0x0080D202UL) /* POINTER TO ENGINE SYNC FUEL PRESSURE RPM LIMIT ... */
#define EPFPEREN (*(volatile uint16_t*)0x0080D206UL) /* CalTerm EPFPEREN: TRUE=ENG SYNC FUEL PRESSURE E... */
#define true_eng_sync_fuel_pressure_precrank_error_0_1 (*(volatile uint16_t*)0x0080D208UL) /* TRUE=ENG SYNC FUEL PRESSURE PRECRANK ERROR */
#define amount_of_time_over_eng_sync_fuel_pressure_fuel_shutdown_thres_0_65535 (*(volatile uint16_t*)0x0080D20AUL) /* AMOUNT OF TIME OVER ENG SYNC FUEL PRESSURE FUEL... */
#define amount_of_time_over_eng_sync_fuel_pressure_rpm_shutdown_thresh_0_65535 (*(volatile uint16_t*)0x0080D20CUL) /* AMOUNT OF TIME OVER ENG SYNC FUEL PRESSURE RPM ... */
#define delay_before_warning_about_shutdown_from_engine_sync_fuel_pres_0_65535 (*(volatile uint16_t*)0x0080D20EUL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM ENGINE... */
#define delay_before_warning_abuot_shutdown_from_eng_sync_fuel_pressur_0_65535 (*(volatile uint16_t*)0x0080D210UL) /* DELAY BEFORE WARNING ABUOT SHUTDOWN FROM ENG SY... */
#define time_since_rpm_crossed_eng_sync_fuel_pressure_start_mon_rpm_0_65535 (*(volatile uint16_t*)0x0080D212UL) /* TIME SINCE RPM CROSSED ENG SYNC FUEL PRESSURE. ... */
#define errors_allowed_timer_running_flag_for_eng_sync_fuel_pressure_0_1 (*(volatile uint16_t*)0x0080D214UL) /* ERRORS ALLOWED TIMER RUNNING FLAG FOR ENG SYNC ... */
#define pointer_to_fuel_pressure_fuel_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D216UL) /* POINTER TO FUEL PRESSURE FUEL FAULT LOG DATA */
#define pointer_to_fuel_pressure_rpm_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D21AUL) /* POINTER TO FUEL PRESSURE RPM FAULT LOG DATA */
#define mask_for_source_of_fuel_temperature_0_65535 (*(volatile uint16_t*)0x0080D222UL) /* MASK FOR SOURCE OF FUEL TEMPERATURE */
#define amount_of_time_since_fuel_temperature_failure_was_detected_0_65535_d224 (*(volatile uint16_t*)0x0080D224UL) /* AMOUNT OF TIME SINCE FUEL TEMPERATURE FAILURE W... */
#define amount_of_time_since_fuel_temperature_failure_was_detected_0_65535_d226 (*(volatile uint16_t*)0x0080D226UL) /* AMOUNT OF TIME SINCE FUEL TEMPERATURE FAILURE W... */
#define pointer_to_fuel_temperature_min_threshold_0_2_32 (*(volatile uint32_t*)0x0080D228UL) /* POINTER TO FUEL TEMPERATURE MIN THRESHOLD */
#define pointer_to_fuel_temperature_max_threshold_0_2_32 (*(volatile uint32_t*)0x0080D22CUL) /* POINTER TO FUEL TEMPERATURE MAX THRESHOLD */
#define pointer_to_fuel_temperature_rpm_limit_threshold_0_2_32 (*(volatile uint32_t*)0x0080D230UL) /* POINTER TO FUEL TEMPERATURE RPM LIMIT THRESHOLD */
#define EPFTEREN (*(volatile uint16_t*)0x0080D234UL) /* CalTerm EPFTEREN: TRUE = FUEL TEMPERATURE ERROR... */
#define fuel_temperature_system_error_detected_before_crankin_1_true_0_false (*(volatile uint16_t*)0x0080D236UL) /* FUEL TEMPERATURE SYSTEM ERROR DETECTED BEFORE C... */
#define amount_of_time_over_fuel_temperature_fuel_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D238UL) /* AMOUNT OF TIME OVER FUEL TEMPERATURE FUEL SHUTD... */
#define amount_of_time_over_fuel_temperature_rpm_shutdown_threshold_0_65535 (*(volatile uint16_t*)0x0080D23AUL) /* AMOUNT OF TIME OVER FUEL TEMPERATURE RPM SHUTDO... */
#define time_to_start_of_warning_after_fuel_temp_fuel_error_declared_0_65535 (*(volatile uint16_t*)0x0080D23CUL) /* TIME TO START OF WARNING AFTER FUEL TEMP FUEL E... */
#define time_to_start_of_warning_after_fuel_temp_rpm_error_declared_0_65535 (*(volatile uint16_t*)0x0080D23EUL) /* TIME TO START OF WARNING AFTER FUEL TEMP RPM ER... */
#define time_since_rpm_crossed_fuel_temperature_start_threshold_0_65535 (*(volatile uint16_t*)0x0080D240UL) /* TIME SINCE RPM CROSSED FUEL TEMPERATURE START T... */
#define flag_indicating_fuel_temp_errors_allowed_timer_is_ru_1_true_0_false (*(volatile uint16_t*)0x0080D242UL) /* FLAG INDICATING FUEL TEMP. ERRORS ALLOWED TIMER... */
#define pointer_to_fuel_temperature_fuel_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D244UL) /* POINTER TO FUEL TEMPERATURE FUEL FAULT LOG DATA */
#define pointer_to_fuel_temperature_rpm_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D248UL) /* POINTER TO FUEL TEMPERATURE RPM FAULT LOG DATA */
#define mask_for_input_of_ambient_air_pressure_0_65535 (*(volatile uint16_t*)0x0080D250UL) /* MASK FOR INPUT OF AMBIENT AIR PRESSURE */
#define amount_of_time_since_ambient_air_pressure_low_failure_was_dete_0_65535_d252 (*(volatile uint16_t*)0x0080D252UL) /* AMOUNT OF TIME SINCE AMBIENT AIR PRESSURE LOW F... */
#define amount_of_time_since_ambient_air_pressure_low_failure_was_dete_0_65535_d254 (*(volatile uint16_t*)0x0080D254UL) /* AMOUNT OF TIME SINCE AMBIENT AIR PRESSURE LOW F... */
#define engine_sync_fuel_pressure_min_threshold_flag_4 (*(volatile uint16_t*)0x0080D256UL) /* Engine sync fuel pressure minimum threshold flag 4 */
#define points_to_ambient_air_pressure_fuel_maximum_threshold_0_2_32 (*(volatile uint32_t*)0x0080D25AUL) /* POINTS TO AMBIENT AIR PRESSURE FUEL MAXIMUM THR... */
#define pointer_to_ambient_air_pressure_rpm_limit_threshold_0_2_32 (*(volatile uint32_t*)0x0080D25EUL) /* POINTER TO AMBIENT AIR PRESSURE RPM LIMIT THRES... */
#define EPAAEREN (*(volatile uint16_t*)0x0080D262UL) /* CalTerm EPAAEREN: TRUE=AMBIENT AIR PRESSURE ERR... */
#define true_ambient_air_pressure_precrank_error_0_1 (*(volatile uint16_t*)0x0080D264UL) /* TRUE=AMBIENT AIR PRESSURE PRECRANK ERROR */
#define amount_of_time_over_ambient_air_pressure_fuel_shutdown_thresho_0_65535 (*(volatile uint16_t*)0x0080D266UL) /* AMOUNT OF TIME OVER AMBIENT AIR PRESSURE FUEL S... */
#define amount_of_time_over_ambient_air_pressure_rpm_shutdown_threshol_0_65535 (*(volatile uint16_t*)0x0080D268UL) /* AMOUNT OF TIME OVER AMBIENT AIR PRESSURE RPM SH... */
#define delay_before_warning_about_shutdown_from_ambient_air_pressure_0_65535 (*(volatile uint16_t*)0x0080D26AUL) /* DELAY BEFORE WARNING ABOUT SHUTDOWN FROM AMBIEN... */
#define delay_before_warning_abuot_shutdown_from_ambient_air_pressure_0_65535 (*(volatile uint16_t*)0x0080D26CUL) /* DELAY BEFORE WARNING ABUOT SHUTDOWN FROM AMBIEN... */
#define time_since_rpm_crossed_ambient_air_pressure_start_mon_rpm_0_65535 (*(volatile uint16_t*)0x0080D26EUL) /* TIME SINCE RPM CROSSED AMBIENT AIR PRESSURE. ST... */
#define errors_allowed_timer_running_flag_for_ambient_air_pressure_0_1 (*(volatile uint16_t*)0x0080D270UL) /* ERRORS ALLOWED TIMER RUNNING FLAG FOR AMBIENT A... */
#define pointer_to_ambient_air_pressure_fuel_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D272UL) /* POINTER TO AMBIENT AIR PRESSURE FUEL FAULT LOG ... */
#define pointer_to_ambient_air_pressure_rpm_fault_log_data_0_2_32 (*(volatile uint32_t*)0x0080D276UL) /* POINTER TO AMBIENT AIR PRESSURE RPM FAULT LOG DATA */
#define epf_shutdown_engine_command_from_restart_limitation_a_1_true_0_false (*(volatile uint16_t*)0x0080D27AUL) /* EPF SHUTDOWN ENGINE COMMAND FROM RESTART LIMITA... */
#define epf_shutdown_approaching_command_from_restart_limitat_1_true_0_false (*(volatile uint16_t*)0x0080D27CUL) /* EPF SHUTDOWN APPROACHING COMMAND FROM RESTART L... */
#define indicator_from_engine_protection_that_fuel_derate_1_active_0_inact (*(volatile uint16_t*)0x0080D286UL) /* INDICATOR FROM ENGINE PROTECTION THAT FUEL DERATE */
#define EPESLM (*(volatile uint16_t*)0x0080D288UL) /* Maximum RPM allowed due to exhaust particulate ... */
#define tooth_count_at_which_error_was_found_by_pmm_0_255 (*(volatile uint8_t*)0x0080D292UL) /* TOOTH COUNT AT WHICH ERROR WAS FOUND BY PMM [Ca... */
#define pmm_error_type_signifies_the_type_of_sync_error_found_by_pmma_0_ff (*(volatile uint8_t*)0x0080D293UL) /* PMM_ERROR_TYPE:SIGNIFIES THE TYPE OF SYNC ERROR... */
#define eps_main_in_phase_if_flase_eps_main_lags_backup_true_false (*(volatile uint8_t*)0x0080D296UL) /* EPS_MAIN_IN_PHASE: IF FLASE EPS MAIN LAGS BACKUP */
#define eps_backup_in_phase_if_flase_eps_backup_lags_main_true_false (*(volatile uint8_t*)0x0080D297UL) /* EPS_BACKUP_IN_PHASE: IF FLASE EPS BACKUP LAGS MAIN */
#define eps_positive_out_of_phase_count_teeth_phase_shift_thresho_0_65535 (*(volatile uint16_t*)0x0080D29AUL) /* EPS_POSITIVE_OUT_OF_PHASE_COUNT:TEETH PHASE SHI... */
#define eps_negative_out_of_phase_count_teeth_phase_shift_thresho_0_65535 (*(volatile uint16_t*)0x0080D29CUL) /* EPS_NEGATIVE_OUT_OF_PHASE_COUNT:TEETH PHASE SHI... */
#define dummy_variable_0_65535_d29e (*(volatile uint16_t*)0x0080D29EUL) /* DUMMY VARIABLE */
#define dummy_variable_0_65535_d2a0 (*(volatile uint16_t*)0x0080D2A0UL) /* DUMMY VARIABLE */
#define completion_status_of_data_link_command_invalid_password (*(volatile uint16_t*)0x0080D2AEUL) /* COMPLETION STATUS OF DATA LINK COMMAND */
#define timer_to_record_the_time_of_rpm_deceleration_rate_above_a_thre_0_100 (*(volatile uint16_t*)0x0080D2B0UL) /* TIMER TO RECORD THE TIME OF RPM DECELERATION RA... */
#define current_engine_deceleration_rate_100_100 (*(volatile uint16_t*)0x0080D2B2UL) /* CURRENT ENGINE DECELERATION RATE. */
#define can_transmit_buffer_ptr (*(volatile uint32_t*)0x0080D2B4UL) /* CAN transmit buffer pointer */
#define track_the_time_when_throttle_is_less_than_a_threshold_0_30 (*(volatile uint16_t*)0x0080D2B8UL) /* TRACK THE TIME WHEN THROTTLE IS LESS THAN A THR... */
#define flag_shows_posibility_of_esp_transitioning_between_normal_false_true (*(volatile uint16_t*)0x0080D2BAUL) /* FLAG SHOWS POSIBILITY OF ESP TRANSITIONING BETW... */
#define can_transmit_length (*(volatile uint16_t*)0x0080D2BCUL) /* CAN transmit message length */
#define ci_tooth_count_number_of_eps_teeth_during_ci_pulse_0_24 (*(volatile uint8_t*)0x0080D2BEUL) /* CI_TOOTH_COUNT:NUMBER OF EPS TEETH DURING CI PU... */
#define crank_tooth_count_error_incremented_when_eps_tooth_count_wro_0_65535 (*(volatile uint8_t*)0x0080D2BFUL) /* CRANK_TOOTH_COUNT_ERROR:INCREMENTED WHEN EPS TO... */
#define ci_tooth_count_error_incremented_when_ci_pulse_width_is_wrong_0_255 (*(volatile uint8_t*)0x0080D2C0UL) /* CI_TOOTH_COUNT_ERROR:INCREMENTED WHEN CI PULSE ... */
#define ci_signal_error_incremented_when_ci_pulse_is_missing_0_255 (*(volatile uint8_t*)0x0080D2C1UL) /* CI_SIGNAL_ERROR:INCREMENTED WHEN CI PULSE IS MI... */
#define can_tx_message_type (*(volatile uint16_t*)0x0080D2C2UL) /* CAN transmit message type identifier */
#define dummy_variable_0_65535_d2c4 (*(volatile uint16_t*)0x0080D2C4UL) /* DUMMY VARIABLE */
#define dummy_variable_0_65535_d2c6 (*(volatile uint16_t*)0x0080D2C6UL) /* DUMMY VARIABLE */
#define flag_indicates_ess_sensor_is_not_being_used_0_1 (*(volatile uint8_t*)0x0080D2C8UL) /* FLAG INDICATES ESS SENSOR IS NOT BEING USED */
#define flag_indicating_eps_sensor_not_used_0_1 (*(volatile uint8_t*)0x0080D2C9UL) /* FLAG INDICATING EPS SENSOR NOT USED */
#define enables_input_of_eps_period_data_to_pptb_0_1 (*(volatile uint8_t*)0x0080D2CAUL) /* ENABLES INPUT OF EPS PERIOD DATA TO PPTB */
#define count_of_eps_pulses_since_ess_missing_tooth_0_255 (*(volatile uint8_t*)0x0080D2CBUL) /* COUNT OF EPS PULSES SINCE ESS MISSING TOOTH */
#define eps_pulse_count_since_addtnl_eps_pulse_0_255 (*(volatile uint8_t*)0x0080D2CCUL) /* EPS PULSE COUNT SINCE ADDTNL EPS PULSE */
#define CSSYSSCM (*(volatile uint8_t*)0x0080D2CDUL) /* CalTerm CSSYSSCM: 0-NO SYNC  1-LOST SYNC  2-HAV... */
#define tpu_transmission_active_flag (*(volatile uint8_t*)0x0080D2CEUL) /* TPU transmission active/busy flag (8 refs) */
#define tpu_channel_state_value (*(volatile uint8_t*)0x0080D2D0UL) /* TPU channel state machine current value - acces... */
#define tpu_transmission_byte_counter (*(volatile uint8_t*)0x0080D2D1UL) /* TPU transmission byte index counter (8 refs) */
#define tpu_transmission_state (*(volatile uint8_t*)0x0080D2D3UL) /* TPU transmission state machine */
#define tpu_transmission_state_machine (*(volatile TPU_TRANSMISSION_STATE*)0x0080D2D6UL) /* TPU transmission state (0=init 1=sending 2=comp... */
#define tpu_channel_enable_state (*(volatile uint8_t*)0x0080D2DAUL) /* TPU timer channel enable state - accessed via c... */
#define tpu_diagnostic_retry_counter (*(volatile uint8_t*)0x0080D2DBUL) /* TPU diagnostic protocol retry counter (6 refs) */
#define diagnostic_protocol_init_state (*(volatile uint16_t*)0x0080D2DCUL) /* Diagnostic protocol init state (1 ref) */
#define tracks_progress_of_fan_on_due_to_ac_0_3600 (*(volatile uint16_t*)0x0080D2DEUL) /* TRACKS PROGRESS OF FAN ON DUE TO AC */
#define fss_interface_for_fan_0_0_3 (*(volatile uint16_t*)0x0080D2E2UL) /* FSS INTERFACE FOR FAN. 0 */
#define fan_may_be_turned_on_via_the_tool_for_this_time_0_3600 (*(volatile uint16_t*)0x0080D2E4UL) /* FAN MAY BE TURNED ON VIA THE TOOL FOR THIS TIME */
#define bus_imt_fan_may_be_turned_on_via_the_tool_for_this_time_0_3600 (*(volatile uint16_t*)0x0080D2E6UL) /* BUS IMT FAN MAY BE TURNED ON VIA THE TOOL FOR T... */
#define ac_desired_percent_of_max_fan_1_speed_0_100 (*(volatile uint16_t*)0x0080D2ECUL) /* AC DESIRED PERCENT OF MAX FAN 1 SPEED */
#define coolant_desired_percent_of_max_fan_1_speed_0_100 (*(volatile uint16_t*)0x0080D2EEUL) /* COOLANT DESIRED PERCENT OF MAX FAN 1 SPEED */
#define desired_percent_of_max_fan_1_speed_0_100 (*(volatile uint16_t*)0x0080D2F0UL) /* DESIRED PERCENT OF MAX FAN 1 SPEED */
#define imt_desired_percent_of_max_fan_1_speed_0_100 (*(volatile uint16_t*)0x0080D2F4UL) /* IMT DESIRED PERCENT OF MAX FAN 1 SPEED */
#define percent_prior_to_hysteresis_0_100_d2f6 (*(volatile uint16_t*)0x0080D2F6UL) /* PERCENT PRIOR TO HYSTERESIS */
#define ac_desired_percent_of_max_fan_2_speed_0_100 (*(volatile uint16_t*)0x0080D2FAUL) /* AC DESIRED PERCENT OF MAX FAN 2 SPEED */
#define coolant_desired_percent_of_max_fan_2_speed_0_100 (*(volatile uint16_t*)0x0080D2FCUL) /* COOLANT DESIRED PERCENT OF MAX FAN 2 SPEED */
#define desired_percent_of_max_fan_2_speed_0_100 (*(volatile uint16_t*)0x0080D2FEUL) /* DESIRED PERCENT OF MAX FAN 2 SPEED */
#define imt_desired_percent_of_max_fan_2_speed_0_100 (*(volatile uint16_t*)0x0080D302UL) /* IMT DESIRED PERCENT OF MAX FAN 2 SPEED */
#define minimum_time_fan_will_be_on_following_100_imt_request_0_60 (*(volatile uint16_t*)0x0080D304UL) /* MINIMUM TIME FAN WILL BE ON FOLLOWING 100% IMT ... */
#define percent_prior_to_hysteresis_0_100_d306 (*(volatile uint16_t*)0x0080D306UL) /* PERCENT PRIOR TO HYSTERESIS */
#define how_often_samples_are_taken_for_ac_1_3000 (*(volatile uint16_t*)0x0080D310UL) /* HOW OFTEN SAMPLES ARE TAKEN FOR AC */
#define FC13DR01 (*(volatile uint16_t*)0x0080D312UL) /* CalTerm FC13DR01: SIGNAL 1 FOR 3 SPEED FAN #1 */
#define FC13DR02 (*(volatile uint16_t*)0x0080D314UL) /* CalTerm FC13DR02: SIGNAL 2 FOR 3 SPEED FAN #1 */
#define FC23DR01 (*(volatile uint16_t*)0x0080D316UL) /* CalTerm FC23DR01: SIGNAL 1 FOR 3 SPEED FAN #2 */
#define FC23DR02 (*(volatile uint16_t*)0x0080D318UL) /* CalTerm FC23DR02: SIGNAL 1 FOR 3 SPEED FAN #2 */
#define how_often_samples_are_taken_for_ct_1_3000_d320 (*(volatile uint16_t*)0x0080D320UL) /* HOW OFTEN SAMPLES ARE TAKEN FOR CT */
#define how_often_samples_are_taken_for_imt_1_3000_d328 (*(volatile uint16_t*)0x0080D328UL) /* HOW OFTEN SAMPLES ARE TAKEN FOR IMT */
#define a2d_input_related_to_ac_pressure_255_255 (*(volatile uint16_t*)0x0080D32CUL) /* A2D INPUT RELATED TO AC PRESSURE */
#define desired_engine_fueling_after_derate_without_air_handl_derate_0_100 (*(volatile uint16_t*)0x0080D332UL) /* DESIRED ENGINE FUELING AFTER DERATE WITHOUT AIR... */
#define FSLMDSST (*(volatile uint16_t*)0x0080D334UL) /* CalTerm FSLMDSST: INDICATOR AS TO WHICH ALGORIT... */
#define indicates_origin_of_tqdqta_value_0_10 (*(volatile uint16_t*)0x0080D33AUL) /* INDICATES ORIGIN OF TQDQTA VALUE */
#define maximum_user_fueling_allowed_0_100 (*(volatile uint16_t*)0x0080D342UL) /* MAXIMUM USER FUELING ALLOWED */
#define timing_4DTBTA (*(volatile uint16_t*)0x0080D344UL) /* TIMING ADVANCE VALUE CALCULATED FROM THE 4D TIM... */
#define intermediate_timing_state_used_before_final_timing_selction_0_10 (*(volatile uint16_t*)0x0080D348UL) /* INTERMEDIATE TIMING STATE USED BEFORE FINAL TIM... */
#define fso_state_desired_from_fuel_system_specific_algorithms_1_off_on_off (*(volatile uint16_t*)0x0080D34EUL) /* FSO STATE DESIRED FROM FUEL SYSTEM SPECIFIC ALG... */
#define fss_adjustment_to_compensate_for_delta_between_injected_and_co_0_100 (*(volatile uint16_t*)0x0080D350UL) /* FSS ADJUSTMENT TO COMPENSATE FOR DELTA BETWEEN ... */
#define quantity_of_fuel_to_be_injected_during_next_injection_cycle_0_100 (*(volatile uint16_t*)0x0080D352UL) /* QUANTITY OF FUEL TO BE INJECTED DURING NEXT INJ... */
#define JCFSTLFG (*(volatile uint16_t*)0x0080D358UL) /* CalTerm JCFSTLFG: WHEN ACTIVE, THIS FLAG SETS B... */
#define fueling_value_at_100_throttle_0_100 (*(volatile uint16_t*)0x0080D368UL) /* FUELING VALUE AT 100% THROTTLE. */
#define fueling_provided_if_engine_were_using_low_hp_curve_0_100 (*(volatile uint16_t*)0x0080D36AUL) /* FUELING PROVIDED IF ENGINE WERE USING LOW HP CURVE */
#define full_fueling_value_at_hsg_bef_droop_speed_0_100 (*(volatile uint16_t*)0x0080D36CUL) /* 100% FUELING VALUE AT HSG_BEF_DROOP_SPEED */
#define max_fueling_without_programmable_power_for_esp_tau_0_0_100 (*(volatile uint16_t*)0x0080D370UL) /* MAX FUELING WITHOUT PROGRAMMABLE POWER FOR ESP ... */
#define filtered_gear_ratio_used_by_the_system_may_be_frozen_upo_0_1_15_999 (*(volatile uint16_t*)0x0080D3A0UL) /* FILTERED GEAR RATIO USED BY THE SYSTEM -MAY BE ... */
#define GRCRFFFG (*(volatile uint16_t*)0x0080D3A2UL) /* CalTerm GRCRFFFG: FLAG THAT CAN BE USED TO DISA... */
#define timer_used_to_disable_rsg_when_veh_and_eng_speeds_disagree_0_100 (*(volatile uint16_t*)0x0080D3A4UL) /* TIMER USED TO DISABLE RSG WHEN VEH AND ENG SPEE... */
#define timer_used_to_disable_rsg_when_gear_ratio_changes_0_100 (*(volatile uint16_t*)0x0080D3A6UL) /* TIMER USED TO DISABLE RSG WHEN GEAR RATIO CHANGES */
#define gear_ratio_determined_when_in_gear_and_at_high_load_0_17 (*(volatile uint16_t*)0x0080D3A8UL) /* GEAR RATIO DETERMINED WHEN IN GEAR AND AT HIGH ... */
#define can_rx_buffer_ptr (*(volatile uint32_t*)0x0080D3E2UL) /* CAN receive buffer pointer */
#define diagnostic_tx_buffer_start_ptr (*(volatile uint32_t*)0x0080D3E6UL) /* Diagnostic TX buffer start pointer (points to 0... */
#define diagnostic_rx_buffer_start_ptr (*(volatile uint32_t*)0x0080D3EAUL) /* Diagnostic RX buffer start pointer (points to 0... */
#define diagnostic_buffer_end_address (*(volatile uint32_t*)0x0080D3EEUL) /* Diagnostic buffer end boundary address (0x808cff) */
#define can_buffer_logger_state (*(volatile uint8_t*)0x0080D3F3UL) /* CAN message buffer logger state flag (1 ref) */
#define water_in_fuel_detection_flag (*(volatile uint16_t*)0x0080D3F4UL) /* SPECIAL DIAGNOSTIC MODE FLAG (misleading name) ... */
#define diag_multipacket_transmit_pending (*(volatile uint8_t*)0x0080D404UL) /* Multi-packet diagnostic transmit continuation f... */
#define multi_packet_receive_state (*(volatile uint8_t*)0x0080D405UL) /* Multi-packet receive state machine */
#define can_buffer_write_pending (*(volatile uint8_t*)0x0080D406UL) /* CAN message buffer write pending flag (3 refs) */
#define insite_command_byte (*(volatile uint8_t*)0x0080D407UL) /* INSITE command byte selector (many refs) */
#define insite_data_valid_flag (*(volatile uint8_t*)0x0080D409UL) /* INSITE data valid/processing flag (5 refs) */
#define insite_response_buffer_ptr (*(volatile uint32_t*)0x0080D40CUL) /* INSITE response buffer write pointer (many refs) */
#define insite_response_write_offset (*(volatile uint8_t*)0x0080D40FUL) /* INSITE response buffer write offset (many refs) */
#define insite_response_continuation_ptr (*(volatile uint32_t*)0x0080D410UL) /* INSITE response buffer continuation pointer for... */
#define insite_data_read_ptr (*(volatile uint32_t*)0x0080D414UL) /* INSITE data buffer read pointer (11 refs) */
#define insite_data_buffer_offset (*(volatile uint8_t*)0x0080D417UL) /* INSITE data buffer offset counter (11 refs) */
#define insite_response_buffer_index (*(volatile uint8_t*)0x0080D418UL) /* INSITE response buffer write index */
#define insite_bytes_remaining (*(volatile uint8_t*)0x0080D419UL) /* INSITE bytes remaining to send */
#define insite_response_buffer_length (*(volatile uint8_t*)0x0080D41AUL) /* INSITE response buffer length - accessed via mo... */
#define insite_response_buffer_reserved (*(volatile uint8_t*)0x0080D41BUL) /* INSITE response buffer reserved */
#define insite_parameter_checksum_ptr (*(volatile uint32_t*)0x0080D41CUL) /* INSITE parameter checksum/result pointer - acce... */
#define insite_parameter_table_current_byte (*(volatile uint8_t*)0x0080D420UL) /* INSITE parameter table current byte - accessed ... */
#define insite_parameter_table_reserved (*(volatile uint8_t*)0x0080D421UL) /* INSITE parameter table reserved byte */
#define insite_parameter_checksum_buffer (*(volatile uint16_t*)0x0080D422UL) /* INSITE parameter checksum buffer (insiteParamet... */
#define insite_parameter_table_ptr (*(volatile uint32_t*)0x0080D440UL) /* INSITE parameter table pointer - accessed via m... */
#define multi_packet_tx_state (*(volatile uint8_t*)0x0080D444UL) /* Multi-packet transmission state machine */
#define insite_multi_frame_state (*(volatile uint8_t*)0x0080D445UL) /* Insite multi-frame response state */
#define multi_packet_sequence_counter (*(volatile uint8_t*)0x0080D446UL) /* Multi-packet sequence counter for J1939 */
#define insite_dtc_pid_byte (*(volatile uint8_t*)0x0080D447UL) /* INSITE DTC/PID parameter byte (4 refs) */
#define insite_live_data_parameter_index (*(volatile uint8_t*)0x0080D448UL) /* INSITE live data parameter index - accessed via... */
#define insite_live_data_reserved (*(volatile uint8_t*)0x0080D449UL) /* INSITE live data reserved byte */
#define memory_patch_buffer_base_ptr (*(volatile uint32_t*)0x0080D44AUL) /* Memory patch data buffer base pointer */
#define memory_patch_count (*(volatile uint8_t*)0x0080D44EUL) /* Number of memory patches to apply (max 10) */
#define memory_patch_iteration_counter (*(volatile uint8_t*)0x0080D44FUL) /* Loop counter for memory patch operations */
#define secured_shutdown_request_flag (*(volatile uint16_t*)0x0080D450UL) /* Secured operation shutdown request flag */
#define diagnostic_data_buffer_ptr (*(volatile uint32_t*)0x0080D452UL) /* Diagnostic data buffer pointer */
#define memory_patch_crc_expected (*(volatile uint16_t*)0x0080D456UL) /* Memory patch expected CRC value for validation ... */
#define memory_patch_pending_flag (*(volatile uint16_t*)0x0080D458UL) /* Memory patching system pending flag (3 refs) */
#define diagnostic_iteration_limit_count (*(volatile uint16_t*)0x0080D45AUL) /* Diagnostic iteration limit (initialized to 200) */
#define retarder_override_rpm_value (*(volatile uint16_t*)0x0080D45EUL) /* Alternative RPM value when retarder override ac... */
#define retarder_rpm_override_active (*(volatile uint16_t*)0x0080D460UL) /* Retarder RPM override enable flag (0=off 1=active) */
#define retarder_proportion_calc_workspace (*(volatile uint32_t*)0x0080D462UL) /* Retarder proportional calculation workspace */
#define fuel_statistics_init_flag (*(volatile uint16_t*)0x0080D466UL) /* Fuel statistics tracker init flag (3 refs) */
#define fuel_statistics_status_byte (*(volatile uint8_t*)0x0080D468UL) /* Fuel statistics status byte (3 refs) */
#define fuel_statistics_previous_status (*(volatile uint8_t*)0x0080D469UL) /* Fuel statistics previous status byte (1 ref) */
#define engine_runtime_statistics_accumulator (*(volatile uint32_t*)0x0080D46AUL) /* Engine runtime histogram and statistics accumul... */
#define fuel_statistics_command_value (*(volatile uint16_t*)0x0080D476UL) /* Fuel statistics INSITE command value (6 refs) */
#define fuel_economy_statistics_value (*(volatile uint16_t*)0x0080D478UL) /* Fuel economy data statistics value (7 refs) */
#define fuel_statistics_accumulator (*(volatile uint16_t*)0x0080D47AUL) /* Fuel statistics tracker accumulator (9 refs) */
#define fuel_statistics_secondary_accumulator (*(volatile uint16_t*)0x0080D47CUL) /* Fuel statistics tracker secondary accumulator (... */
#define diagnostic_timing_increment_value (*(volatile uint16_t*)0x0080D480UL) /* Diagnostic timing increment controller value (4... */
#define diagnostic_fuel_arbitration_output (*(volatile uint16_t*)0x0080D482UL) /* Diagnostic fuel arbitration PWM output value (9... */
#define diagnostic_fuel_arbitration_state_d486 (*(volatile uint16_t*)0x0080D486UL) /* Diagnostic fuel arbitration handler state (1 ref) */
#define fuel_demand_limit_selector_state (*(volatile uint16_t*)0x0080D488UL) /* Fuel demand limit selector 4 state (1 ref) */
#define diagnostic_fuel_arbitration_write_flag (*(volatile uint16_t*)0x0080D48AUL) /* Diagnostic fuel arbitration write flag (1 ref) */
#define fault_flag_scanner_state (*(volatile uint16_t*)0x0080D48CUL) /* Fault flag scanner and processor state (7 refs) */
#define insite_pid_dtc_handler_state (*(volatile uint16_t*)0x0080D48EUL) /* INSITE PID DTC handler state (4 refs) */
#define insite_parameter_lookup_state (*(volatile uint16_t*)0x0080D490UL) /* INSITE parameter lookup and PID handler state (... */
#define diagnostic_code_clear_handler_state (*(volatile uint16_t*)0x0080D492UL) /* Diagnostic code clear handler state (13 refs) */
#define shutdown_limit_accumulator (*(volatile uint16_t*)0x0080D494UL) /* Shutdown limit accumulator value (24 refs) */
#define shutdown_minimum_selector_value (*(volatile SHUTDOWN_SELECTOR_SOURCE*)0x0080D496UL) /* Shutdown minimum selector - identifies winning ... */
#define shutdown_minimum_init_value (*(volatile uint16_t*)0x0080D498UL) /* Shutdown minimum selector init value (5 refs) */
#define cached_parameter_value (*(volatile uint16_t*)0x0080D49AUL) /* Cached parameter value for diagnostic responses */
#define diagnostic_status_register (*(volatile DIAGNOSTIC_STATUS*)0x0080D49CUL) /* Diagnostic operation mode state machine */
#define pwm_timer_cycle_advance_state (*(volatile PWM_TIMER_CYCLE_STATE*)0x0080D49EUL) /* PWM timer cycle advance state - accessed via mo... */
#define pwm_temperature_shifted_workspace (*(volatile uint32_t*)0x0080D4A4UL) /* PWM temperature calculation workspace (temp << 16) */
#define pwm_timing_advance_lookup_table ((volatile uint32_t*)0x0080D4A8UL) /* 6-entry PWM timing advance lookup table (24 bytes) */
#define fuel_demand_rpm_based_limit (*(volatile uint16_t*)0x0080D4C0UL) /* Fuel demand limit calculated from RPM in fuelDe... */
#define fuel_demand_limit_snapshot (*(volatile uint16_t*)0x0080D4C2UL) /* Fuel demand limit snapshot before minimum updat... */
#define system_loop_counter (*(volatile uint32_t*)0x0080D4C4UL) /* System main loop iteration counter */
#define system_time_seconds_counter (*(volatile uint16_t*)0x0080D4C6UL) /* System time seconds counter for elapsed time */
#define fuel_arbitrator_oil_pressure_snapshot (*(volatile uint16_t*)0x0080D4CCUL) /* Oil pressure snapshot for fuel arbitration */
#define signal_transmitted_by_slave_to_signify_beginning_of_data_transfer_n_a (*(volatile uint8_t*)0x0080D5ACUL) /* SIGNAL TRANSMITTED BY SLAVE TO SIGNIFY BEGINNIN... */
#define bit_mapped_status_byte_from_secondary_processor_0_255_d5b8 (*(volatile uint8_t*)0x0080D5B8UL) /* BIT MAPPED STATUS BYTE FROM SECONDARY PROCESSOR */
#define bit_mapped_status_byte_from_secondary_processor_0_255_d5b9 (*(volatile uint8_t*)0x0080D5B9UL) /* BIT MAPPED STATUS BYTE FROM SECONDARY PROCESSOR */
#define byte_1_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5BBUL) /* BYTE 1 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_2_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5BCUL) /* BYTE 2 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_3_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5BDUL) /* BYTE 3 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_4_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5BEUL) /* BYTE 4 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_5_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5BFUL) /* BYTE 5 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_6_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C0UL) /* BYTE 6 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_7_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C1UL) /* BYTE 7 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_8_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C2UL) /* BYTE 8 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_9_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C3UL) /* BYTE 9 SENT FROM SECONDARY PROCESSOR TO MAIN PR... */
#define byte_10_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C4UL) /* BYTE 10 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_11_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C5UL) /* BYTE 11 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_12_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C6UL) /* BYTE 12 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_13_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C7UL) /* BYTE 13 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_14_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C8UL) /* BYTE 14 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_15_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5C9UL) /* BYTE 15 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_16_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5CAUL) /* BYTE 16 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_17_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5CBUL) /* BYTE 17 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_18_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5CCUL) /* BYTE 18 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_19_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5CDUL) /* BYTE 19 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_20_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5CEUL) /* BYTE 20 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_21_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5CFUL) /* BYTE 21 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_22_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D0UL) /* BYTE 22 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_23_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D1UL) /* BYTE 23 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_24_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D2UL) /* BYTE 24 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_25_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D3UL) /* BYTE 25 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_26_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D4UL) /* BYTE 26 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_27_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D5UL) /* BYTE 27 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_28_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D6UL) /* BYTE 28 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_29_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D7UL) /* BYTE 29 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_30_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D8UL) /* BYTE 30 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_31_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5D9UL) /* BYTE 31 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define byte_32_sent_from_secondary_processor_to_main_processor_0_255 (*(volatile uint8_t*)0x0080D5DAUL) /* BYTE 32 SENT FROM SECONDARY PROCESSOR TO MAIN P... */
#define bit_mapped_status_byte_from_secondary_processor_0_255_d5dc (*(volatile uint8_t*)0x0080D5DCUL) /* BIT MAPPED STATUS BYTE FROM SECONDARY PROCESSOR */
#define filter_coefficient_3_from_hsg_lead_lag_dynamic_compensator_0_1 (*(volatile uint16_t*)0x0080D60EUL) /* FILTER COEFFICIENT #3 FROM HSG LEAD/LAG DYNAMIC... */
#define application_specified_hsg_engine_speed_error_filter_time_constan_0_1 (*(volatile uint16_t*)0x0080D612UL) /* APPLICATION-SPECIFIED HSG ENGINE SPEED ERROR FI... */
#define defines_hsg_application_specific_gain_set_that_has_been_chosen_0_15 (*(volatile uint16_t*)0x0080D614UL) /* DEFINES HSG APPLICATION-SPECIFIC GAIN SET THAT ... */
#define defines_hsg_gain_set_that_has_been_chosen_0_31 (*(volatile uint16_t*)0x0080D61AUL) /* DEFINES HSG GAIN SET THAT HAS BEEN CHOSEN */
#define hsg_speed_dependant_engine_speed_error_filter_time_constant_0_1 (*(volatile uint16_t*)0x0080D622UL) /* HSG SPEED-DEPENDANT ENGINE SPEED ERROR FILTER T... */
#define hsg_gain_scheduling_output_hsg_engine_speed_error_filter_time_c_0_1 (*(volatile uint16_t*)0x0080D634UL) /* HSG GAIN SCHEDULING OUTPUT; HSG ENGINE SPEED ER... */
#define hsg_adjusted_proportional_gain_0_7_5000 (*(volatile uint16_t*)0x0080D63EUL) /* HSG ADJUSTED PROPORTIONAL GAIN. */
#define hsg_adjusted_derivative_gain_0_5_120 (*(volatile uint16_t*)0x0080D640UL) /* HSG ADJUSTED DERIVATIVE GAIN. */
#define hsg_adjusted_integral_gain_0_6_0000 (*(volatile uint16_t*)0x0080D642UL) /* HSG ADJUSTED INTEGRAL GAIN. */
#define reference_speed_before_droop_calculation_1400_4500 (*(volatile uint16_t*)0x0080D648UL) /* REFERENCE SPEED BEFORE DROOP CALCULATION */
#define rpm_derate_supplied_by_application_group_0_8000 (*(volatile uint16_t*)0x0080D64CUL) /* RPM DERATE SUPPLIED BY APPLICATION GROUP. [CalT... */
#define hsg_base_reference_speed_currently_in_use_esp_may_select_1500_5000 (*(volatile uint16_t*)0x0080D64EUL) /* HSG BASE REFERENCE SPEED CURRENTLY IN USE (ESP ... */
#define point_at_which_the_hsg_droop_slope_line_intersects_the_no_1500_4500 (*(volatile uint16_t*)0x0080D650UL) /* POINT AT WHICH THE HSG DROOP SLOPE LINE INTERSE... */
#define slope_of_line_defining_droop_for_the_hsg_ref_currently_activ_0_55_13 (*(volatile uint16_t*)0x0080D652UL) /* SLOPE OF LINE DEFINING DROOP FOR THE HSG REF CU... */
#define the_actual_hsg_derate_speed_used_in_hsg_droop_calculation_1400_5000 (*(volatile uint16_t*)0x0080D654UL) /* THE ACTUAL HSG DERATE SPEED USED IN HSG DROOP C... */
#define reference_speed_before_droop_sent_hsg_ref_hsg_gain_sched_1400_3000 (*(volatile uint16_t*)0x0080D658UL) /* REFERENCE SPEED BEFORE DROOP SENT HSG REF -> HS... */
#define hsg_isochronous_speed_currently_in_use_1500_3000 (*(volatile uint16_t*)0x0080D65AUL) /* HSG ISOCHRONOUS SPEED CURRENTLY IN USE */
#define indicator_of_which_alg_is_setting_hsisrfae_0_255 (*(volatile uint16_t*)0x0080D65EUL) /* INDICATOR OF WHICH ALG. IS SETTING HSISRFAE */
#define winning_active_isochronous_speed_1500_4500 (*(volatile uint16_t*)0x0080D660UL) /* WINNING ACTIVE ISOCHRONOUS SPEED */
#define winning_active_isochronous_speed_state_0_255 (*(volatile uint16_t*)0x0080D662UL) /* WINNING ACTIVE ISOCHRONOUS SPEED STATE */
#define HSINRFST (*(volatile uint16_t*)0x0080D664UL) /* CalTerm HSINRFST: INDICATES WHICH ALG. CONTROLS... */
#define bit_0_of_0_15_eeprom_parameter_used_to_enable_cylinder_cutout_ca_0_1 (*(volatile uint16_t*)0x0080D700UL) /* BIT 0 OF 0-15.  EEPROM PARAMETER USED TO ENABLE... */
#define eeprom_indicator_used_to_define_which_cylinders_to_cutout_0_1 (*(volatile uint16_t*)0x0080D702UL) /* EEPROM INDICATOR USED TO DEFINE WHICH CYLINDERS... */
#define aps_error_flag_for_throttle_indicating_bad_data_not_logged_true_false (*(volatile uint8_t*)0x0080D70CUL) /* APS ERROR FLAG FOR THROTTLE INDICATING BAD DATA... */
#define ivs_parameter_not_properly_configured_not_logged_as_a_faul_true_false (*(volatile uint8_t*)0x0080D70DUL) /* IVS PARAMETER NOT PROPERLY CONFIGURED. NOT LOGG... */
#define pgn_timeout_error_flag_for_aps_ivs_remote_throttle_not_log_true_false (*(volatile uint8_t*)0x0080D70EUL) /* PGN TIMEOUT ERROR FLAG FOR APS/IVS/REMOTE THROT... */
#define multiplex_value_for_air_conditioner_pressure_switch_on_off (*(volatile uint8_t*)0x0080D70FUL) /* MULTIPLEX VALUE FOR AIR CONDITIONER PRESSURE SW... */
#define multiplex_value_for_throttle_interlock_switch_on_off (*(volatile uint8_t*)0x0080D710UL) /* MULTIPLEX VALUE FOR THROTTLE INTERLOCK SWITCH */
#define multiplex_value_for_auxiliary_shutdown_switch_on_off (*(volatile uint8_t*)0x0080D711UL) /* MULTIPLEX VALUE FOR AUXILIARY SHUTDOWN SWITCH */
#define multiplex_value_for_brake_switch_on_off (*(volatile uint8_t*)0x0080D712UL) /* MULTIPLEX VALUE FOR BRAKE SWITCH */
#define multiplex_value_for_clutch_switch_on_off (*(volatile uint8_t*)0x0080D713UL) /* MULTIPLEX VALUE FOR CLUTCH SWITCH */
#define JCCMTHMU (*(volatile uint8_t*)0x0080D714UL) /* CalTerm JCCMTHMU: MUXED VALUE FOR COMMANDED THR... */
#define multiplex_value_for_cruise_enable_switch_switch_on_off (*(volatile uint8_t*)0x0080D715UL) /* MULTIPLEX VALUE FOR CRUISE ENABLE SWITCH SWITCH */
#define multiplex_value_for_cruise_resume_switch_on_off (*(volatile uint8_t*)0x0080D716UL) /* MULTIPLEX VALUE FOR CRUISE RESUME SWITCH */
#define multiplex_value_for_cruise_set_switch_on_off (*(volatile uint8_t*)0x0080D717UL) /* MULTIPLEX VALUE FOR CRUISE SET SWITCH */
#define multiplex_value_for_decrement_switch_on_off (*(volatile uint8_t*)0x0080D718UL) /* MULTIPLEX VALUE FOR DECREMENT SWITCH */
#define muxed_value_for_the_amount_of_engine_brake_requested_0_100 (*(volatile uint8_t*)0x0080D719UL) /* MUXED VALUE FOR THE AMOUNT OF ENGINE BRAKE REQU... */
#define multiplex_value_for_idle_switch_on_off (*(volatile uint8_t*)0x0080D71AUL) /* MULTIPLEX VALUE FOR IDLE SWITCH */
#define multiplex_value_for_increment_switch_on_off (*(volatile uint8_t*)0x0080D71BUL) /* MULTIPLEX VALUE FOR INCREMENT SWITCH */
#define multiplexed_value_for_requested_fan_speed_0_100 (*(volatile uint8_t*)0x0080D71CUL) /* MULTIPLEXED VALUE FOR REQUESTED % FAN SPEED */
#define multiplex_value_for_pto_on_switch_on_off (*(volatile uint8_t*)0x0080D71DUL) /* MULTIPLEX VALUE FOR PTO ON SWITCH */
#define multiplex_value_for_pto_resume_switch_on_off (*(volatile uint8_t*)0x0080D71EUL) /* MULTIPLEX VALUE FOR PTO RESUME SWITCH */
#define multiplex_value_for_pto_set_switch_on_off (*(volatile uint8_t*)0x0080D71FUL) /* MULTIPLEX VALUE FOR PTO SET SWITCH */
#define muxed_value_for_the_pneumatic_control_pressure_wet_tank_pressur_0_250 (*(volatile uint8_t*)0x0080D720UL) /* MUXED VALUE FOR THE PNEUMATIC CONTROL PRESSURE ... */
#define multiplex_value_for_remote_pto_switch_on_off (*(volatile uint8_t*)0x0080D721UL) /* MULTIPLEX VALUE FOR REMOTE PTO SWITCH */
#define multiplexed_value_for_remote_accelerator_0_100 (*(volatile uint8_t*)0x0080D722UL) /* MULTIPLEXED VALUE FOR REMOTE ACCELERATOR */
#define multiplex_value_for_remote_throttle_switch_on_off (*(volatile uint8_t*)0x0080D723UL) /* MULTIPLEX VALUE FOR REMOTE THROTTLE SWITCH */
#define multiplex_value_for_test_switch_on_off (*(volatile uint8_t*)0x0080D724UL) /* MULTIPLEX VALUE FOR TEST SWITCH */
#define multiplex_value_for_torque_derate_switch_on_off (*(volatile uint8_t*)0x0080D725UL) /* MULTIPLEX VALUE FOR TORQUE DERATE SWITCH */
#define priority_of_client_which_is_currently_overriding_engine_brake_swi_0_ff (*(volatile uint8_t*)0x0080D726UL) /* PRIORITY OF CLIENT WHICH IS CURRENTLY OVERRIDIN... */
#define a_d_priority_for_manual_fan_level_requested_fan_speed_0_ff (*(volatile uint8_t*)0x0080D727UL) /* A/D PRIORITY FOR MANUAL FAN LEVEL (REQUESTED % ... */
#define user_value_for_engine_brake_0_100 (*(volatile uint16_t*)0x0080D728UL) /* USER VALUE FOR ENGINE BRAKE */
#define user_value_for_manual_fan_level_requested_fan_speed_0_100 (*(volatile uint16_t*)0x0080D72AUL) /* USER VALUE FOR MANUAL FAN LEVEL (REQUESTED % FA... */
#define takes_raw_throttle_for_mux_limphome_on_a2d_0_1023 (*(volatile uint16_t*)0x0080D72CUL) /* TAKES RAW THROTTLE FOR MUX LIMPHOME ON A2D */
#define source_0_none_1_trans_2_abs_3_asr_4_unknown_0_4_d9e6 (*(volatile uint16_t*)0x0080D9E6UL) /* 0 = NONE 1 = TRANS 2 = ABS 3 = ASR 4 = UNKNOWN */
#define byte_indicating_retarder_commands_as_received_over_datalink_0_255 (*(volatile uint16_t*)0x0080D9EAUL) /* BYTE INDICATING RETARDER COMMANDS AS RECEIVED O... */
#define retarder_torque_torque_limit_command_in_percent_of_peak_retard_0_255 (*(volatile uint16_t*)0x0080D9F0UL) /* RETARDER TORQUE/TORQUE LIMIT COMMAND IN PERCENT... */
#define jcomm_req_torque_braking_override_or_limit_value_0_125 (*(volatile uint16_t*)0x0080D9F2UL) /* JCOMM REQ. % TORQUE BRAKING (OVERRIDE OR LIMIT ... */
#define j1939_network_address_for_ecm_as_engine_node_0_255 (*(volatile uint16_t*)0x0080DA00UL) /* J1939 NETWORK ADDRESS FOR ECM AS ENGINE NODE */
#define j1939_network_address_for_ecm_as_engine_retarder_node_0_255 (*(volatile uint16_t*)0x0080DA0AUL) /* J1939 NETWORK ADDRESS FOR ECM AS ENGINE RETARDE... */
#define status_from_fault_handler_indicating_obdii_def_of_monit_not_comp_comp (*(volatile uint16_t*)0x0080DA10UL) /* STATUS FROM FAULT HANDLER INDICATING OBDII DEF.... */
#define jcomm_ind_percent_load_ratio_of_actual_engine_torque_to_max_to_0_125 (*(volatile uint16_t*)0x0080DA1AUL) /* JCOMM IND PERCENT LOAD RATIO OF ACTUAL ENGINE T... */
#define jcomm_ind_friction_torque_amount_of_torque_required_by_base_en_0_125 (*(volatile uint16_t*)0x0080DA1CUL) /* JCOMM IND FRICTION TORQUE AMOUNT OF TORQUE REQU... */
#define jcomm_ind_torque_at_idle_available_torque_that_engine_can_prov_0_125 (*(volatile uint16_t*)0x0080DA1EUL) /* JCOMM IND TORQUE AT IDLE AVAILABLE TORQUE THAT ... */
#define jcomm_ind_torque_at_point_2_available_torque_that_engine_can_0_125 (*(volatile uint16_t*)0x0080DA20UL) /* JCOMM IND TORQUE AT POINT 2  AVAILABLE TORQUE T... */
#define jcomm_ind_torque_at_point_3_available_torque_that_engine_can_0_125 (*(volatile uint16_t*)0x0080DA22UL) /* JCOMM IND TORQUE AT POINT 3  AVAILABLE TORQUE T... */
#define jcomm_ind_torque_at_point_4_available_torque_that_engine_can_p_0_125 (*(volatile uint16_t*)0x0080DA24UL) /* JCOMM IND TORQUE AT POINT 4 AVAILABLE TORQUE TH... */
#define jcomm_ind_torque_at_point_5_available_torque_that_engine_can_0_125 (*(volatile uint16_t*)0x0080DA26UL) /* JCOMM IND TORQUE AT POINT 5  AVAILABLE TORQUE T... */
#define JCEVRPP2 (*(volatile uint16_t*)0x0080DA28UL) /* CalTerm JCEVRPP2: JCOMM-DETERMINED RPM AT HSG B... */
#define jcomm_determined_rpm_at_pt_5_for_engine_config_map_0_8031_875 (*(volatile uint16_t*)0x0080DA2AUL) /* JCOMM-DETERMINED RPM AT PT. 5 FOR ENGINE CONFIG... */
#define jcomm_determined_rpm_at_engine_configuration_idle_speed_0_8031_875 (*(volatile uint16_t*)0x0080DA2CUL) /* JCOMM DETERMINED RPM AT ENGINE CONFIGURATION ID... */
#define jcomm_determine_rpm_at_engine_configuration_point_3_0_8031_875_da2e (*(volatile uint16_t*)0x0080DA2EUL) /* JCOMM DETERMINE RPM AT ENGINE CONFIGURATION POI... */
#define jcomm_determine_rpm_at_engine_configuration_point_3_0_8031_875_da30 (*(volatile uint16_t*)0x0080DA30UL) /* JCOMM DETERMINE RPM AT ENGINE CONFIGURATION POI... */
#define determined_peak_engine_fueling_0_100 (*(volatile uint16_t*)0x0080DA32UL) /* DETERMINED PEAK ENGINE FUELING */
#define four_d_fueling_value_used_to_determine_jcomm_drivers_demand_ind_tor_0_100 (*(volatile uint16_t*)0x0080DA36UL) /* 4-D FUELING VALUE USED TO DETERMINE JCOMM_DRIVE... */
#define torque_curve_speed_at_breakpoint_1_lsg_reference_0_5000 (*(volatile uint16_t*)0x0080DA38UL) /* TORQUE CURVE SPEED AT BREAKPOINT 1 (LSG REFEREN... */
#define torque_curve_speed_at_breakpoint_2_hsg_breakpoint_0_5000 (*(volatile uint16_t*)0x0080DA3AUL) /* TORQUE CURVE SPEED AT BREAKPOINT 2 (HSG BREAKPO... */
#define torque_curve_speed_at_breakpoint_3_0_5000 (*(volatile uint16_t*)0x0080DA3CUL) /* TORQUE CURVE SPEED AT BREAKPOINT 3. */
#define torque_curve_speed_at_breakpoint_4_0_5000 (*(volatile uint16_t*)0x0080DA3EUL) /* TORQUE CURVE SPEED AT BREAKPOINT 4. */
#define torque_curve_speed_at_breakpoint_5_0_5000 (*(volatile uint16_t*)0x0080DA40UL) /* TORQUE CURVE SPEED AT BREAKPOINT 5. */
#define torque_curve_fueling_at_idle_speed_breakpoint_0_100 (*(volatile uint16_t*)0x0080DA42UL) /* TORQUE CURVE FUELING AT IDLE SPEED BREAKPOINT. */
#define torque_curve_fueling_at_point_2_speed_breakpoint_0_100 (*(volatile uint16_t*)0x0080DA44UL) /* TORQUE CURVE FUELING AT POINT 2 SPEED BREAKPOINT. */
#define torque_curve_fueling_at_point_3_speed_breakpoint_0_100 (*(volatile uint16_t*)0x0080DA46UL) /* TORQUE CURVE FUELING AT POINT 3 SPEED BREAKPOINT. */
#define torque_curve_fueling_at_point_4_speed_breakpoint_0_100 (*(volatile uint16_t*)0x0080DA48UL) /* TORQUE CURVE FUELING AT POINT 4 SPEED BREAKPOINT. */
#define torque_curve_fueling_at_point_5_speed_breakpoint_0_100 (*(volatile uint16_t*)0x0080DA4AUL) /* TORQUE CURVE FUELING AT POINT 5 SPEED BREAKPOINT. */
#define byte_indicating_engine_commands_as_received_over_datalink_0_255 (*(volatile uint16_t*)0x0080DA4CUL) /* BYTE INDICATING ENGINE COMMANDS AS RECEIVED OVE... */
#define source_0_none_1_trans_2_abs_3_asr_4_unknown_0_4_da4e (*(volatile uint16_t*)0x0080DA4EUL) /* 0 = NONE 1 = TRANS 2 = ABS 3 = ASR 4 = UNKNOWN */
#define JCHII1OD (*(volatile uint16_t*)0x0080DA54UL) /* CalTerm JCHII1OD: JCOMM HIGH IDLE OVERRIDE 0 = ... */
#define jcomm_speed_control_status_1_speed_control_mode_0_n_true_false (*(volatile uint16_t*)0x0080DA60UL) /* JCOMM SPEED CONTROL STATUS 1 = SPEED CONTROL MO... */
#define jcomm_torque_derate_fueling_maximum_allowed_fuel_as_per_link_u_0_100 (*(volatile uint16_t*)0x0080DA62UL) /* JCOMM TORQUE DERATE FUELING MAXIMUM ALLOWED FUE... */
#define jcomm_speed_governor_mode_indicator_of_which_speed_mode_characte_0_3 (*(volatile uint16_t*)0x0080DA66UL) /* JCOMM SPEED GOVERNOR MODE INDICATOR OF WHICH SP... */
#define JCEGNETY (*(volatile uint16_t*)0x0080DA68UL) /* CalTerm JCEGNETY: NETWORK TYPE IN CONTROL OF EN... */
#define JCOGNETY (*(volatile uint16_t*)0x0080DA6AUL) /* CalTerm JCOGNETY: INDICATOR OF WHICH NETWORK SE... */
#define determined_state_of_operation_of_lamp_1_on_off_short (*(volatile uint16_t*)0x0080DA9EUL) /* DETERMINED STATE OF OPERATION OF LAMP 1 */
#define determined_state_of_operation_of_lamp_2_on_off_short (*(volatile uint16_t*)0x0080DAA0UL) /* DETERMINED STATE OF OPERATION OF LAMP 2 */
#define determined_state_of_operation_of_lamp_3_on_off_short (*(volatile uint16_t*)0x0080DAA2UL) /* DETERMINED STATE OF OPERATION OF LAMP 3 */
#define determined_state_of_operation_of_lamp_4_on_off_short (*(volatile uint16_t*)0x0080DAA4UL) /* DETERMINED STATE OF OPERATION OF LAMP 4 */
#define determined_state_of_operation_of_lamp_5_on_off_short (*(volatile uint16_t*)0x0080DAA6UL) /* DETERMINED STATE OF OPERATION OF LAMP 5 */
#define determined_state_of_operation_of_lamp_6_on_off_short (*(volatile uint16_t*)0x0080DAA8UL) /* DETERMINED STATE OF OPERATION OF LAMP 6 */
#define determined_state_of_operation_of_lamp_7_on_off_short (*(volatile uint16_t*)0x0080DAAAUL) /* DETERMINED STATE OF OPERATION OF LAMP 7 */
#define set_when_leading_threshold_has_expired_time_to_change_oil_1_0 (*(volatile uint16_t*)0x0080DAAEUL) /* SET WHEN LEADING THRESHOLD HAS EXPIRED */
#define passes_diagnostic_output_for_stop_lamp_to_j1939_73_true_false (*(volatile uint16_t*)0x0080DAB2UL) /* PASSES DIAGNOSTIC OUTPUT FOR STOP LAMP TO J1939/73 */
#define passes_diagnostic_output_for_warning_lamp_to_j1939_73_true_false (*(volatile uint16_t*)0x0080DAB4UL) /* PASSES DIAGNOSTIC OUTPUT FOR WARNING LAMP TO J1... */
#define passes_diagnostic_output_for_fluids_lamp_to_j1939_73_true_false (*(volatile uint16_t*)0x0080DAB6UL) /* PASSES DIAGNOSTIC OUTPUT FOR FLUIDS LAMP TO J19... */
#define low_oil_pressure_limit_as_calculated_for_present_engine_speed_0_100 (*(volatile uint16_t*)0x0080DABEUL) /* LOW OIL PRESSURE LIMIT AS CALCULATED FOR PRESEN... */
#define very_low_oil_pressure_is_calculated_for_present_engine_speed_0_100 (*(volatile uint16_t*)0x0080DAC0UL) /* VERY LOW OIL PRESSURE IS CALCULATED FOR PRESENT... */
#define allow_aggressive_logic_0_inhibit_aggressive_logic_1_0_1 (*(volatile uint16_t*)0x0080DAC2UL) /* ALLOW_AGGRESSIVE_LOGIC = 0; INHIBIT_AGGRESSIVE_... */
#define identifies_the_current_lsg_pid_gain_set_0_7 (*(volatile uint16_t*)0x0080DACAUL) /* IDENTIFIES THE CURRENT LSG PID GAIN SET */
#define indicator_of_the_lsg_gain_set_currently_being_used_0_9 (*(volatile uint16_t*)0x0080DACCUL) /* INDICATOR OF THE LSG GAIN SET CURRENTLY BEING USED */
#define indicator_of_current_active_override_gain_state_5_9 (*(volatile uint16_t*)0x0080DACEUL) /* INDICATOR OF CURRENT ACTIVE OVERRIDE GAIN STATE */
#define lsg_p_gain_passed_from_fuel_system_specific_algorithm_0_0_4348_dad0 (*(volatile uint16_t*)0x0080DAD0UL) /* LSG P GAIN PASSED FROM FUEL SYSTEM SPECIFIC ALG... */
#define lsg_i_gain_passed_from_fuel_system_specific_algorithm_0_0_217_dad2 (*(volatile uint16_t*)0x0080DAD2UL) /* LSG I GAIN PASSED FROM FUEL SYSTEM SPECIFIC ALG... */
#define lsg_d_gain_passed_from_fuel_system_specific_algorithm_0_0_0144_dad4 (*(volatile uint16_t*)0x0080DAD4UL) /* LSG D GAIN PASSED FROM FUEL SYSTEM SPECIFIC ALG... */
#define lsg_fueling_clamp_max_0_100 (*(volatile uint16_t*)0x0080DAE8UL) /* LSG FUELING CLAMP MAX */
#define lsg_maximum_integrator_fuel_output_0_100 (*(volatile uint16_t*)0x0080DAEAUL) /* LSG MAXIMUM INTEGRATOR FUEL OUTPUT */
#define lsg_integrator_preset_max_0_100 (*(volatile uint16_t*)0x0080DAECUL) /* LSG INTEGRATOR PRESET MAX */
#define lsg_reference_speed_adjusted_with_throttle_position_300_2000 (*(volatile uint16_t*)0x0080DAEEUL) /* LSG REFERENCE SPEED ADJUSTED WITH THROTTLE POSI... */
#define lsg_droop_gain_1_at_integrator_feedback_2_to_2 (*(volatile uint16_t*)0x0080DAF0UL) /* LSG DROOP GAIN 1 AT INTEGRATOR FEEDBACK */
#define lsg_droop_gain_2_at_lsg_fueling_output_2_to_2 (*(volatile uint16_t*)0x0080DAF2UL) /* LSG DROOP GAIN 2 AT LSG FUELING OUTPUT */
#define lsg_adjusted_proportional_gain_0_4348 (*(volatile uint16_t*)0x0080DAF8UL) /* LSG ADJUSTED PROPORTIONAL GAIN. */
#define lsg_adjusted_derivative_gain_0_0159 (*(volatile uint16_t*)0x0080DAFAUL) /* LSG ADJUSTED DERIVATIVE GAIN. */
#define lsg_adjusted_integral_gain_0_0_238 (*(volatile uint16_t*)0x0080DAFCUL) /* LSG ADJUSTED INTEGRAL GAIN. */
#define lsg_pid_speed_derivative_2_fueling_contribution_200_to_200 (*(volatile uint16_t*)0x0080DAFEUL) /* LSG PID SPEED DERIVATIVE 2 FUELING CONTRIBUTION */
#define lsg_pid_speed_proportional_2_fueling_contribution_200_to_200 (*(volatile uint16_t*)0x0080DB00UL) /* LSG PID SPEED PROPORTIONAL 2 FUELING CONTRIBUTION */
#define operator_adjusted_lsg_breakpoint_speed_300_1000 (*(volatile uint16_t*)0x0080DB06UL) /* OPERATOR ADJUSTED LSG BREAKPOINT SPEED */
#define bit_mapped_status_byte_from_main_processor_0_ff_db0e (*(volatile uint8_t*)0x0080DB0EUL) /* BIT MAPPED STATUS BYTE FROM MAIN PROCESSOR. */
#define bit_mapped_status_byte_from_main_processor_0_ff_db0f (*(volatile uint8_t*)0x0080DB0FUL) /* BIT MAPPED STATUS BYTE FROM MAIN PROCESSOR. */
#define lsb_8_of_first_address_offset_to_be_used_by_secondary_storage_0_255 (*(volatile uint8_t*)0x0080DB10UL) /* 8 LSB OF FIRST ADDRESS OFFSET TO BE USED BY SEC... */
#define data_for_the_secondary_processor_to_store_in_memory_0_255 (*(volatile uint8_t*)0x0080DB11UL) /* DATA FOR THE SECONDARY PROCESSOR TO STORE IN ME... */
#define lsb_8_of_second_address_offset_to_be_used_by_secondary_storage_0_255 (*(volatile uint8_t*)0x0080DB12UL) /* 8 LSB OF SECOND ADDRESS OFFSET TO BE USED BY SE... */
#define bit_flag_which_represents_the_spi_transmission_mode_master_fast_slow (*(volatile uint8_t*)0x0080DB13UL) /* BIT FLAG WHICH REPRESENTS THE SPI TRANSMISSION ... */
#define max_torque_at_current_rpm_in_foot_pounds_0_10000 (*(volatile uint16_t*)0x0080DB1AUL) /* MAX TORQUE AT CURRENT RPM IN FOOT-POUNDS */
#define no_load_fueling_curve_value_at_hsg_active_no_load_rpm_0_100 (*(volatile uint16_t*)0x0080DB1EUL) /* NO LOAD FUELING CURVE VALUE AT HSG_ACTIVE_NO_LO... */
#define interval_with_the_highest_weighted_percentage_of_the_threshold_used (*(volatile uint16_t*)0x0080DB42UL) /* INTERVAL WITH THE HIGHEST (WEIGHTED) PERCENTAGE... */
#define percent_of_threshold_used_up_by_other_market_interval_e_g_mi_0_200 (*(volatile uint16_t*)0x0080DB46UL) /* PERCENT OF THRESHOLD USED UP BY OTHER MARKET IN... */
#define reset_flag_used_to_determine_when_other_app_is_requesting_to_upda_n_a (*(volatile uint16_t*)0x0080DB48UL) /* RESET FLAG USED TO DETERMINE WHEN OTHER APP. IS... */
#define actual_amount_of_fuel_consumed_since_the_last_ocm_rese_0_0_9999999_0 (*(volatile uint32_t*)0x0080DB4CUL) /* ACTUAL AMOUNT OF FUEL CONSUMED SINCE THE LAST O... */
#define bit_13_of_0_15_cpu_output_port_1_bit_5_warning_lamp_yellow_none (*(volatile uint16_t*)0x0080DB5CUL) /* BIT 13 OF 0-15.  CPU OUTPUT PORT 1 & BIT: 5 WAR... */
#define percent_load_based_on_low_hp_torque_curve_0_255 (*(volatile uint16_t*)0x0080DB62UL) /* PERCENT LOAD BASED ON LOW HP TORQUE CURVE */
#define phase_lag_calculation_based_on_the_pulse_0_phase_lag_slope_and_0_40 (*(volatile uint16_t*)0x0080DB66UL) /* PHASE LAG CALCULATION BASED ON THE PULSE 0 PHAS... */
#define max_engine_speed_while_throttle_fueling_overrides_pto_fueling_0_4500 (*(volatile uint16_t*)0x0080DC2CUL) /* MAX ENGINE SPEED WHILE THROTTLE FUELING OVERRID... */
#define selected_fueling_state_from_pto_fl_state_and_user_fl_state_1_8 (*(volatile uint16_t*)0x0080DC32UL) /* SELECTED FUELING STATE FROM PTO FL. STATE AND U... */
#define value_which_designates_the_duty_cycle_requested_of_pwm1_0_100 (*(volatile uint16_t*)0x0080DC62UL) /* VALUE WHICH DESIGNATES THE DUTY CYCLE REQUESTED... */
#define value_which_designates_the_duty_cycle_requested_of_pwm2_0_100 (*(volatile uint16_t*)0x0080DC64UL) /* VALUE WHICH DESIGNATES THE DUTY CYCLE REQUESTED... */
#define value_which_designates_the_duty_cycle_requested_for_pwm3_0_100 (*(volatile uint16_t*)0x0080DC66UL) /* VALUE WHICH DESIGNATES THE DUTY CYCLE REQUESTED... */
#define value_which_designates_the_duty_cycle_requested_for_pwm4_0_100 (*(volatile uint16_t*)0x0080DC68UL) /* VALUE WHICH DESIGNATES THE DUTY CYCLE REQUESTED... */
#define value_which_designates_the_duty_cycle_requested_of_pwm5_0_100 (*(volatile uint16_t*)0x0080DC6AUL) /* VALUE WHICH DESIGNATES THE DUTY CYCLE REQUESTED... */
#define constant_used_in_sampled_road_speed_calculation_51428_16000000 (*(volatile uint32_t*)0x0080DC74UL) /* CONSTANT USED IN SAMPLED_ROAD_SPEED CALCULATION */
#define maximum_allowable_vehicle_speed_selected_as_the_rsg_refer_2_255_9961 (*(volatile uint16_t*)0x0080DC82UL) /* MAXIMUM ALLOWABLE VEHICLE SPEED SELECTED AS THE... */
#define filtered_percent_load_output_of_gear_down_0_100 (*(volatile uint16_t*)0x0080DC8EUL) /* FILTERED PERCENT_LOAD OUTPUT OF GEAR-DOWN */
#define j1708_transmit_buffer_0_2_32 (*(volatile uint32_t*)0x0080DC94UL) /* J1708 TRANSMIT BUFFER */
#define j1708_transmit_buffer_2_32_dc98 (*(volatile uint32_t*)0x0080DC98UL) /* J1708 TRANSMIT BUFFER */
#define j1708_transmit_buffer_2_32_dc9c (*(volatile uint32_t*)0x0080DC9CUL) /* J1708 TRANSMIT BUFFER */
#define j1708_transmit_buffer_full_flag_1_true_0_false (*(volatile uint16_t*)0x0080DCA0UL) /* J1708 TRANSMIT BUFFER FULL FLAG */
#define j1708_receive_buffer_pointer_2_32_dca2 (*(volatile uint32_t*)0x0080DCA2UL) /* J1708 RECEIVE BUFFER POINTER */
#define j1708_receive_buffer_pointer_2_32_dca6 (*(volatile uint32_t*)0x0080DCA6UL) /* J1708 RECEIVE BUFFER POINTER */
#define j1708_receive_buffer_pointer_2_32_dcaa (*(volatile uint32_t*)0x0080DCAAUL) /* J1708 RECEIVE BUFFER POINTER */
#define j1708_receive_buffer_full_flag_1_true_0_false (*(volatile uint16_t*)0x0080DCAEUL) /* J1708 RECEIVE BUFFER FULL FLAG */
#define j1708_transmit_buffer_2_32_ddc6 (*(volatile uint32_t*)0x0080DDC6UL) /* J1708 TRANSMIT BUFFER */
#define j1708_receive_buffer_2_32 (*(volatile uint32_t*)0x0080DDCAUL) /* J1708 RECEIVE BUFFER */
#define address_of_scratch_pad_directory_0c000h_0f7efh (*(volatile uint32_t*)0x0080DE28UL) /* ADDRESS OF SCRATCH PAD DIRECTORY */
#define number_of_entries_in_the_scratch_pad_0_10 (*(volatile uint16_t*)0x0080DE2CUL) /* NUMBER OF ENTRIES IN THE SCRATCH PAD */
#define buffer_used_to_store_secure_write_data_until_the_copy_0c000h_0f7efh (*(volatile uint32_t*)0x0080DE32UL) /* BUFFER USED TO STORE SECURE WRITE DATA UNTIL TH... */
#define flag_indicating_tool_has_updated_scratch_pad_crc_0_false_1_tru (*(volatile uint16_t*)0x0080DE38UL) /* FLAG INDICATING TOOL HAS UPDATED SCRATCH_PAD_CRC */
#define length_in_bytes_of_scratch_pad_buffer_0_200 (*(volatile uint16_t*)0x0080DE3AUL) /* LENGTH IN BYTES OF SCRATCH PAD BUFFER */
#define rpm_value_for_tach_if_normal_input_is_overridden_0_4500 (*(volatile uint16_t*)0x0080DE3CUL) /* RPM VALUE FOR TACH IF NORMAL INPUT IS OVERRIDDEN. */
#define DRTKODMD (*(volatile uint16_t*)0x0080DE3EUL) /* CalTerm DRTKODMD: FLAG TO SET TACH TO TACHOMETE... */
#define total_time_offset_moved_to_ti_base_adj_h_none (*(volatile uint32_t*)0x0080DE5CUL) /* TOTAL_TIME_OFFSET MOVED TO TI_BASE_ADJ.H */
#define instantaneous_fuel_rate_formatted_for_j1587_broadcast_pid_18_0_284421 (*(volatile uint16_t*)0x0080DE60UL) /* INSTANTANEOUS FUEL RATE FORMATTED FOR J1587 BRO... */
#define instantaneous_fuel_rate_formatted_for_1939_71_broadcast_0_235769 (*(volatile uint16_t*)0x0080DE62UL) /* INSTANTANEOUS FUEL RATE FORMATTED FOR 1939/71 B... */
#define timing_advance_added_to_base_timing_anytime_afc_is_limiting_fu_0_120 (*(volatile uint16_t*)0x0080DE68UL) /* TIMING ADVANCE ADDED TO BASE TIMING ANYTIME AFC... */
#define test_variable_used_to_snapshot_the_system_interface_variable_s_0_120 (*(volatile uint16_t*)0x0080DE6EUL) /* TEST VARIABLE USED TO SNAPSHOT THE SYSTEM INTER... */
#define timing_advance_limit_as_just_before_modification_by_max_limit_0_120 (*(volatile uint16_t*)0x0080DE70UL) /* TIMING ADVANCE LIMIT AS JUST BEFORE MODIFICATIO... */
#define flags_of_final_timing_increment_states_0_ff (*(volatile uint16_t*)0x0080DE72UL) /* FLAGS OF FINAL TIMING INCREMENT STATES */
#define fault_to_erase_none (*(volatile uint16_t*)0x0080DE78UL) /* FAULT TO ERASE */
#define action_00_no_clear_action_01_clear_inactive_02_clear_active_03_clear_al_0_6 (*(volatile uint16_t*)0x0080DE7AUL) /* 00=NO_CLEAR_ACTION 01=CLEAR_INACTIVE 02=CLEAR_A... */
#define indicator_as_to_which_algorithm_is_controlling_fuel_after_it_has_13_41 (*(volatile uint16_t*)0x0080DECAUL) /* INDICATOR AS TO WHICH ALGORITHM IS CONTROLLING ... */
#define fuel_system_specific_fuel_derate_that_is_input_to_the_core_sys_0_100 (*(volatile uint16_t*)0x0080DECCUL) /* FUEL SYSTEM SPECIFIC FUEL DERATE THAT IS INPUT ... */
#define smallest_derate_fueling_value_among_group_2_ah_derate_algori_0_100 (*(volatile uint16_t*)0x0080DECEUL) /* SMALLEST DERATE FUELING VALUE AMONG GROUP 2 (AH... */
#define FSLMAHST (*(volatile uint16_t*)0x0080DED0UL) /* CalTerm FSLMAHST: INDICATOR AS TO WHICH ALGORIT... */
#define FSDSFLST (*(volatile uint16_t*)0x0080DED4UL) /* CalTerm FSDSFLST: INDICATOR AS TO WHAT ALGORITH... */
#define eps_period_between_vss_interrupts_0_4294967295 (*(volatile uint32_t*)0x0080DEDAUL) /* EPS PERIOD BETWEEN VSS INTERRUPTS */
#define timing_command_just_before_wet_stack_modification_0_120 (*(volatile uint16_t*)0x0080DEE6UL) /* TIMING COMMAND JUST BEFORE WET STACK MODIFICATION */
#define sim_chip_select_option_reg0 (*(volatile uint16_t*)0x0080FFFAUL) /* SIM chip select option register 0 */
#define sim_chip_select_base_reg0 (*(volatile uint16_t*)0x0080FFFCUL) /* SIM chip select base address register 0 */
#define init_checkpoint_address (*(volatile uint16_t*)0x0080FFFEUL) /* Initialization checkpoint address value */
#define serial_port_2_base_register (*(volatile uint32_t*)0x00FFC800UL) /* MC68336 Serial Port 2 (QSM) base register addre... */
#define toucan_control_reg_0 (*(volatile uint8_t*)0x00FFC806UL) /* TouCAN CANCTRL0 - Control Register 0 (CAN module) */
#define toucan_prescaler_div (*(volatile uint8_t*)0x00FFC808UL) /* TouCAN PRESDIV - Prescaler Divide Register */
#define toucan_control_reg_2 (*(volatile uint8_t*)0x00FFC809UL) /* TouCAN CTRL2 - Control Register 2 */
#define toucan_free_timer_high (*(volatile uint8_t*)0x00FFC80AUL) /* TouCAN Free Running Timer high byte */
#define toucan_free_timer_low (*(volatile uint8_t*)0x00FFC80BUL) /* TouCAN Free Running Timer low byte */
#define toucan_mb0_control (*(volatile uint16_t*)0x00FFC810UL) /* TouCAN MB0 - Message Buffer 0 Control/Status */
#define toucan_mb0_timer (*(volatile uint16_t*)0x00FFC812UL) /* TouCAN MB0 - Message Buffer 0 Timer Capture */
#define toucan_mb0_id_low (*(volatile uint16_t*)0x00FFC816UL) /* TouCAN MB0 - Message Buffer 0 ID Low */
#define toucan_mb0_data_7 (*(volatile uint8_t*)0x00FFC81FUL) /* TouCAN MB0 - Message Buffer 0 Data Byte 7 */
#define toucan_mb1_control (*(volatile uint16_t*)0x00FFC820UL) /* TouCAN MB1 - Message Buffer 1 Control/Status */
#define toucan_mb1_timer (*(volatile uint16_t*)0x00FFC822UL) /* TouCAN MB1 - Message Buffer 1 Timer Capture */
#define toucan_mb1_id_low (*(volatile uint16_t*)0x00FFC826UL) /* TouCAN MB1 - Message Buffer 1 ID Low */
#define toucan_mb1_data_7 (*(volatile uint8_t*)0x00FFC82FUL) /* TouCAN MB1 - Message Buffer 1 Data Byte 7 */
#define toucan_mb2_control (*(volatile uint16_t*)0x00FFC830UL) /* TouCAN MB2 - Message Buffer 2 Control/Status */
#define toucan_mb2_timer (*(volatile uint16_t*)0x00FFC832UL) /* TouCAN MB2 - Message Buffer 2 Timer Capture */
#define toucan_mb2_id_low (*(volatile uint16_t*)0x00FFC836UL) /* TouCAN MB2 - Message Buffer 2 ID Low */
#define toucan_mb2_data_7 (*(volatile uint8_t*)0x00FFC83FUL) /* TouCAN MB2 - Message Buffer 2 Data Byte 7 */
#define toucan_mb3_control (*(volatile uint16_t*)0x00FFC840UL) /* TouCAN MB3 - Message Buffer 3 Control/Status */
#define toucan_mb3_timer (*(volatile uint16_t*)0x00FFC842UL) /* TouCAN MB3 - Message Buffer 3 Timer Capture */
#define toucan_mb3_id_low (*(volatile uint16_t*)0x00FFC846UL) /* TouCAN MB3 - Message Buffer 3 ID Low */
#define toucan_mb3_data_7 (*(volatile uint8_t*)0x00FFC84FUL) /* TouCAN MB3 - Message Buffer 3 Data Byte 7 */
#define toucan_mb4_control (*(volatile uint16_t*)0x00FFC850UL) /* TouCAN MB4 - Message Buffer 4 Control/Status */
#define toucan_mb4_timer (*(volatile uint16_t*)0x00FFC852UL) /* TouCAN MB4 - Message Buffer 4 Timer Capture */
#define toucan_mb4_id_low (*(volatile uint16_t*)0x00FFC856UL) /* TouCAN MB4 - Message Buffer 4 ID Low */
#define serial_port_2_rx_data_register (*(volatile uint8_t*)0x00FFC85FUL) /* Serial port 2 receive data register (5 refs) */
#define toucan_mb5_control (*(volatile uint16_t*)0x00FFC860UL) /* TouCAN MB5 - Message Buffer 5 Control/Status */
#define toucan_mb5_timer (*(volatile uint16_t*)0x00FFC862UL) /* TouCAN MB5 - Message Buffer 5 Timer Capture */
#define toucan_mb5_id_low (*(volatile uint16_t*)0x00FFC866UL) /* TouCAN MB5 - Message Buffer 5 ID Low */
#define qsm_config_reg_high (*(volatile uint8_t*)0x00FFD000UL) /* QSM QSMCR high - Configuration Register high byte */
#define qsm_config_reg_low (*(volatile uint8_t*)0x00FFD001UL) /* QSM QSMCR low - Configuration Register low byte */
#define qsm_test_reg_high (*(volatile uint8_t*)0x00FFD002UL) /* QSM QTEST high - Test Register high byte */
#define qsm_test_reg_low (*(volatile uint8_t*)0x00FFD003UL) /* QSM QTEST low - Test Register low byte */
#define SIM_CAN_CONTROL_PORT_1 (*(volatile uint8_t*)0x00FFD004UL) /* SIM CAN control port 1 - hardware I/O for CAN p... */
#define qsm_int_level_reg (*(volatile uint8_t*)0x00FFD005UL) /* QSM QILR - Interrupt Level Register */
#define SIM_CAN_CONTROL_PORT_2 (*(volatile uint8_t*)0x00FFD006UL) /* SIM CAN control port 2 - processed I/O for CAN ... */
#define qsm_int_vector_reg (*(volatile uint8_t*)0x00FFD007UL) /* QSM QIVR - Interrupt Vector Register */
#define qsm_sci_control_0_high (*(volatile uint8_t*)0x00FFD008UL) /* QSM SCCR0 high - SCI Control Register 0 high byte */
#define qsm_sci_control_0_low (*(volatile uint8_t*)0x00FFD009UL) /* QSM SCCR0 low - SCI Control Register 0 low byte */
#define qsm_sci_control_1_high (*(volatile uint8_t*)0x00FFD00AUL) /* QSM SCCR1 high - SCI Control Register 1 high byte */
#define qsm_sci_status_reg (*(volatile uint16_t*)0x00FFD00CUL) /* QSM SCSR - SCI Status Register */
#define qsm_sci_data_reg (*(volatile uint16_t*)0x00FFD00EUL) /* QSM SCDR - SCI Data Register */
#define external_watchdog_service (*(volatile uint8_t*)0x00FFD00FUL) /* External watchdog service register */
#define serial_port_1_base_register (*(volatile uint32_t*)0x00FFD800UL) /* MC68336 Serial Port 1 (QSM) base register addre... */
#define sim_tpu_control_0 (*(volatile uint8_t*)0x00FFD806UL) /* SIM/TPU Control Register 0 */
#define sim_tpu_prescaler (*(volatile uint8_t*)0x00FFD808UL) /* SIM/TPU Prescaler Divide Register */
#define sim_tpu_control_2 (*(volatile uint8_t*)0x00FFD809UL) /* SIM/TPU Control Register 2 */
#define sim_tpu_timer_high (*(volatile uint8_t*)0x00FFD80AUL) /* SIM/TPU Free Running Timer high byte */
#define sim_tpu_timer_low (*(volatile uint8_t*)0x00FFD80BUL) /* SIM/TPU Free Running Timer low byte */
#define can_controller_config_register (*(volatile uint8_t*)0x00FFD810UL) /* Dual CAN controller configuration register (5 r... */
#define sim_tpu_mb0_data_7 (*(volatile uint8_t*)0x00FFD81FUL) /* SIM/TPU Message Buffer 0 Data Byte 7 */
#define sim_tpu_mb1_data_7 (*(volatile uint8_t*)0x00FFD82FUL) /* SIM/TPU Message Buffer 1 Data Byte 7 */
#define sim_tpu_mb2_data_7 (*(volatile uint8_t*)0x00FFD83FUL) /* SIM/TPU Message Buffer 2 Data Byte 7 */
#define sim_tpu_mb3_data_7 (*(volatile uint8_t*)0x00FFD84FUL) /* SIM/TPU Message Buffer 3 Data Byte 7 */
#define serial_port_1_rx_data_register (*(volatile uint8_t*)0x00FFD85FUL) /* Serial port 1 receive data register (5 refs) */
#define EBI_EBIMCR (*(volatile uint16_t*)0x00FFE000UL) /* EBI module configuration register */
#define QADC_QADCMCR (*(volatile uint16_t*)0x00FFF200UL) /* QADC module configuration register */
#define QADC_PORTQA (*(volatile uint16_t*)0x00FFF206UL) /* QADC port QA data register */
#define QADC_PORTQB (*(volatile uint16_t*)0x00FFF208UL) /* QADC port QB data register */
#define QADC_QACR1 (*(volatile uint16_t*)0x00FFF20AUL) /* QADC control register 1 */
#define QADC_QACR2 (*(volatile uint16_t*)0x00FFF20CUL) /* QADC control register 2 */
#define QADC_QSTAT (*(volatile uint16_t*)0x00FFF20EUL) /* QADC status register */
#define QADC_CCW0 (*(volatile uint16_t*)0x00FFF230UL) /* QADC conversion command word 0 */
#define QADC64_QMCR (*(volatile uint16_t*)0x00FFF400UL) /* QADC64 module control register */
#define hardware_timer_register (*(volatile uint32_t*)0x00FFF404UL) /* Hardware timer register for main loop timing sy... */
#define QADC64_QADCTEST (*(volatile uint16_t*)0x00FFF408UL) /* QADC64 test register */
#define QADC64_PORTQA (*(volatile uint16_t*)0x00FFF410UL) /* QADC64 port QA data register */
#define QADC64_QADCMCR (*(volatile uint16_t*)0x00FFF414UL) /* QADC64 module configuration register */
#define QADC64_QACR1 (*(volatile uint16_t*)0x00FFF418UL) /* QADC64 control register 1 */
#define QADC64_QACR2 (*(volatile uint16_t*)0x00FFF41AUL) /* QADC64 control register 2 */
#define QADC64_QSTAT (*(volatile uint16_t*)0x00FFF41CUL) /* QADC64 status register */
#define QADC64_QADCSR (*(volatile uint16_t*)0x00FFF420UL) /* QADC64 status register */
#define QADC64_QADCINT (*(volatile uint16_t*)0x00FFF428UL) /* QADC64 interrupt register */
#define sim_timer_control_register (*(volatile uint32_t*)0x00FFF42AUL) /* SIM timer control register */
#define QADC64_PQAPAR (*(volatile uint16_t*)0x00FFF430UL) /* QADC64 port QA pin assignment register */
#define QADC64_DDRQA (*(volatile uint16_t*)0x00FFF432UL) /* QADC64 port QA data direction register */
#define QADC64_PQBPAR (*(volatile uint16_t*)0x00FFF434UL) /* QADC64 port QB pin assignment register */
#define QADC64_DDRQB (*(volatile uint16_t*)0x00FFF438UL) /* QADC64 port QB data direction register */
#define tpu_pwm_channel_3_output (*(volatile uint32_t*)0x00FFF43AUL) /* TPU PWM channel 3 output register */
#define QADC64_LJSRR (*(volatile uint16_t*)0x00FFF440UL) /* QADC64 left-justified signed result register */
#define tpu_pwm_channel_4_output (*(volatile uint32_t*)0x00FFF442UL) /* TPU PWM channel 4 output register */
#define QADC64_RJURR (*(volatile uint16_t*)0x00FFF448UL) /* QADC64 right-justified unsigned result register */
#define QADC64_CCW0 (*(volatile uint16_t*)0x00FFF450UL) /* QADC64 conversion command word 0 */
#define tpu_channel_priority_select (*(volatile uint16_t*)0x00FFF458UL) /* TPU channel priority select register CPR (18 refs) */
#define tpu_channel_int_select (*(volatile uint16_t*)0x00FFF45AUL) /* TPU channel interrupt select register CISR (2 r... */
#define QADC64_CCW8 (*(volatile uint16_t*)0x00FFF460UL) /* QADC64 conversion command word 8 */
#define sim_mcr (*(volatile uint16_t*)0x00FFFA00UL) /* SIM Module Configuration Register */
#define sim_simtr (*(volatile uint16_t*)0x00FFFA02UL) /* SIM Module Test Register */
#define sim_avr (*(volatile uint16_t*)0x00FFFA04UL) /* SIM Auto Vector Register */
#define sim_rsr_fa06 (*(volatile uint16_t*)0x00FFFA06UL) /* SIM Reset Status Register */
#define sim_syncr (*(volatile uint16_t*)0x00FFFA08UL) /* SIM Clock Synthesizer Control Register */
#define sim_sypcr_fa0a (*(volatile uint16_t*)0x00FFFA0AUL) /* SIM System Protection Control Register */
#define sim_swiv_fa0c (*(volatile uint16_t*)0x00FFFA0CUL) /* SIM Software Interrupt Vector Register */
#define sim_swsr_fa0e (*(volatile uint16_t*)0x00FFFA0EUL) /* SIM Software Service Register */
#define sim_ddir (*(volatile uint16_t*)0x00FFFA10UL) /* SIM Data Direction Register */
#define sim_syncr_param (*(volatile uint8_t*)0x00FFFA11UL) /* SIM Reset Status Register [CalTerm: SIM_SYNCR] */
#define sim_dpar (*(volatile uint16_t*)0x00FFFA12UL) /* SIM Data Polarity Register */
#define sim_ddrd (*(volatile uint16_t*)0x00FFFA14UL) /* SIM Data Direction Register D */
#define sim_simcr_param (*(volatile uint8_t*)0x00FFFA15UL) /* System Protection Control Register [CalTerm: SI... */
#define sim_dpard (*(volatile uint16_t*)0x00FFFA16UL) /* SIM Data Polarity Register D */
#define sim_swiv_fa17 (*(volatile uint8_t*)0x00FFFA17UL) /* Software Interrupt Vector */
#define sim_picr (*(volatile uint16_t*)0x00FFFA18UL) /* SIM Periodic Interrupt Control Register */
#define sim_sypcr_param (*(volatile uint8_t*)0x00FFFA19UL) /* Software Service Register (watchdog) [CalTerm: ... */
#define sim_pitr (*(volatile uint16_t*)0x00FFFA1AUL) /* SIM Periodic Interrupt Timer Register */
#define sim_swsr2 (*(volatile uint16_t*)0x00FFFA1CUL) /* SIM Software Service Register 2 */
#define sim_csbar0 (*(volatile uint16_t*)0x00FFFA20UL) /* SIM Chip Select Base Address Register 0 */
#define REG_SIM_PICR (*(volatile uint16_t*)0x00FFFA22UL) /* MC68336 Periodic Interrupt Control Register */
#define REG_SIM_PITR (*(volatile uint16_t*)0x00FFFA24UL) /* MC68336 Periodic Interrupt Timer Register */
#define sim_csor1 (*(volatile uint16_t*)0x00FFFA26UL) /* SIM Chip Select Option Register 1 */
#define REG_SIM_SWSR (*(volatile uint8_t*)0x00FFFA27UL) /* MC68336 Software Watchdog Service Register */
#define sim_csbar2 (*(volatile uint16_t*)0x00FFFA28UL) /* SIM Chip Select Base Address Register 2 */
#define sim_csor2 (*(volatile uint16_t*)0x00FFFA2AUL) /* SIM Chip Select Option Register 2 */
#define sim_csbar3 (*(volatile uint16_t*)0x00FFFA2CUL) /* SIM Chip Select Base Address Register 3 */
#define sim_csor3 (*(volatile uint16_t*)0x00FFFA2EUL) /* SIM Chip Select Option Register 3 */
#define sim_csbar4 (*(volatile uint16_t*)0x00FFFA30UL) /* SIM Chip Select Base Address Register 4 */
#define sim_csor4 (*(volatile uint16_t*)0x00FFFA32UL) /* SIM Chip Select Option Register 4 */
#define sim_csbar5 (*(volatile uint16_t*)0x00FFFA34UL) /* SIM Chip Select Base Address Register 5 */
#define sim_csor5 (*(volatile uint16_t*)0x00FFFA36UL) /* SIM Chip Select Option Register 5 */
#define sim_csbar6 (*(volatile uint16_t*)0x00FFFA38UL) /* SIM Chip Select Base Address Register 6 */
#define sim_csor6 (*(volatile uint16_t*)0x00FFFA3AUL) /* SIM Chip Select Option Register 6 */
#define sim_csbar7 (*(volatile uint16_t*)0x00FFFA3CUL) /* SIM Chip Select Base Address Register 7 */
#define sim_csor7 (*(volatile uint16_t*)0x00FFFA3EUL) /* SIM Chip Select Option Register 7 */
#define sim_csbar8 (*(volatile uint16_t*)0x00FFFA40UL) /* SIM Chip Select Base Address Register 8 */
#define sim_csor8 (*(volatile uint16_t*)0x00FFFA42UL) /* SIM Chip Select Option Register 8 */
#define sim_csbar9 (*(volatile uint16_t*)0x00FFFA44UL) /* SIM Chip Select Base Address Register 9 */
#define sim_csor9 (*(volatile uint16_t*)0x00FFFA46UL) /* SIM Chip Select Option Register 9 */
#define sim_csbar10 (*(volatile uint16_t*)0x00FFFA48UL) /* SIM Chip Select Base Address Register 10 */
#define sim_csor10 (*(volatile uint16_t*)0x00FFFA4AUL) /* SIM Chip Select Option Register 10 */
#define SIM_CSPDR (*(volatile uint16_t*)0x00FFFA64UL) /* SIM chip select pin data register */
#define SIM_PORTC (*(volatile uint16_t*)0x00FFFA66UL) /* SIM port C data register */
#define SIM_PFPAR (*(volatile uint16_t*)0x00FFFA68UL) /* SIM port F pin assignment register */
#define SIM_PEPAR (*(volatile uint16_t*)0x00FFFA6AUL) /* SIM port E pin assignment register */
#define SIM_PORTF (*(volatile uint16_t*)0x00FFFA6CUL) /* SIM port F data register */
#define SIM_DDRF (*(volatile uint16_t*)0x00FFFA6EUL) /* SIM port F data direction register */
#define SIM_PORTE (*(volatile uint16_t*)0x00FFFA70UL) /* SIM port E data register */
#define SIM_DDRE (*(volatile uint16_t*)0x00FFFA72UL) /* SIM port E data direction register */
#define SIM_CSPAR0 (*(volatile uint16_t*)0x00FFFA74UL) /* SIM chip select pin assignment register 0 */
#define SIM_CSPAR1 (*(volatile uint16_t*)0x00FFFA76UL) /* SIM chip select pin assignment register 1 */
#define qsm_qmcr (*(volatile uint16_t*)0x00FFFB00UL) /* QSM Master Control Register */
#define qsm_qtest (*(volatile uint16_t*)0x00FFFB02UL) /* QSM Test Register */
#define qsm_qilr (*(volatile uint16_t*)0x00FFFB04UL) /* QSM Interrupt Level Register [CalTerm: SRAM_RAM... */
#define qsm_qivr (*(volatile uint16_t*)0x00FFFB06UL) /* QSM Interrupt Vector Register */
#define sccr0 (*(volatile uint16_t*)0x00FFFB08UL) /* SCI Control Register 0 */
#define sccr1 (*(volatile uint16_t*)0x00FFFB0AUL) /* SCI Control Register 1 */
#define scsr (*(volatile uint16_t*)0x00FFFB0CUL) /* SCI Status Register */
#define scdr (*(volatile uint16_t*)0x00FFFB0EUL) /* SCI Data Register */
#define qsm_portqs (*(volatile uint16_t*)0x00FFFB10UL) /* QSM Port QS Data Register */
#define qsm_pqspar (*(volatile uint16_t*)0x00FFFB12UL) /* QSM Port QS Pin Assignment Register */
#define qsm_ddrqs (*(volatile uint16_t*)0x00FFFB14UL) /* QSM Data Direction Register QS */
#define spcr0 (*(volatile uint16_t*)0x00FFFB16UL) /* SPI Control Register 0 */
#define spcr1 (*(volatile uint16_t*)0x00FFFB18UL) /* SPI Control Register 1 */
#define spcr2 (*(volatile uint16_t*)0x00FFFB1AUL) /* SPI Control Register 2 */
#define spcr3 (*(volatile uint16_t*)0x00FFFB1CUL) /* SPI Control Register 3 */
#define spsr (*(volatile uint16_t*)0x00FFFB1EUL) /* SPI Status Register */
#define tpu_tpumcr (*(volatile uint16_t*)0x00FFFC00UL) /* TPU Master Control Register [CalTerm: TPU_TPUMCR] */
#define tpu_tcr (*(volatile uint16_t*)0x00FFFC02UL) /* TPU Test Configuration Register */
#define tpu_dscr (*(volatile uint16_t*)0x00FFFC04UL) /* TPU Development Support Control Register [CalTe... */
#define TPU_TICR_H (*(volatile uint8_t*)0x00FFFC05UL) /* TPU interrupt configuration register high byte */
#define tpu_dssr (*(volatile uint16_t*)0x00FFFC06UL) /* TPU Development Support Status Register */
#define tpu_ticr (*(volatile uint16_t*)0x00FFFC08UL) /* TPU Interrupt Configuration Register [CalTerm: ... */
#define tpu_cier (*(volatile uint16_t*)0x00FFFC0AUL) /* TPU Channel Interrupt Enable Register [CalTerm:... */
#define tpu_cfsr0 (*(volatile uint16_t*)0x00FFFC0CUL) /* TPU Channel Function Select Register 0 [CalTerm... */
#define tpu_cfsr1 (*(volatile uint16_t*)0x00FFFC0EUL) /* TPU Channel Function Select Register 1 [CalTerm... */
#define tpu_cfsr2 (*(volatile uint16_t*)0x00FFFC10UL) /* TPU Channel Function Select Register 2 */
#define tpu_cfsr3 (*(volatile uint16_t*)0x00FFFC12UL) /* TPU Channel Function Select Register 3 */
#define tpu_hsqr0 (*(volatile uint16_t*)0x00FFFC14UL) /* TPU Host Sequence Register 0 */
#define TPU_HSQR1_H (*(volatile uint8_t*)0x00FFFC15UL) /* TPU host sequence register 1 high byte */
#define tpu_hsqr1 (*(volatile uint16_t*)0x00FFFC16UL) /* TPU Host Sequence Register 1 [CalTerm: TPU_HSRR0] */
#define TPU_HSRR0_H (*(volatile uint8_t*)0x00FFFC17UL) /* TPU host service request register 0 high byte */
#define tpu_hssr0 (*(volatile uint16_t*)0x00FFFC18UL) /* TPU Host Service Status Register 0 [CalTerm: TP... */
#define tpu_hssr1 (*(volatile uint16_t*)0x00FFFC1AUL) /* TPU Host Service Status Register 1 [CalTerm: TP... */
#define tpu_cpr0 (*(volatile uint16_t*)0x00FFFC1CUL) /* TPU Channel Priority Register 0 [CalTerm: TPU_C... */
#define tpu_cpr1 (*(volatile uint16_t*)0x00FFFC1EUL) /* TPU Channel Priority Register 1 */
#define TPU_CFSR1 (*(volatile uint8_t*)0x00FFFC1FUL) /* TPU channel function select register 1 */
#define qadc_qadcmcr (*(volatile uint16_t*)0x00FFFD00UL) /* QADC Master Control Register */
#define qadc_qadctest (*(volatile uint16_t*)0x00FFFD02UL) /* QADC Test Register */
#define qadc_qadcilr (*(volatile uint16_t*)0x00FFFD04UL) /* QADC Interrupt Level Register [CalTerm: TPU_PRA... */
#define qadc_qadcivr (*(volatile uint16_t*)0x00FFFD06UL) /* QADC Interrupt Vector Register [CalTerm: TPU_PR... */
#define qadc_portqa (*(volatile uint16_t*)0x00FFFD08UL) /* QADC Port QA Data Register [CalTerm: TPU_PRAM_C... */
#define qadc_portqb (*(volatile uint16_t*)0x00FFFD0AUL) /* QADC Port QB Data Register */
#define qadc_ddrqa (*(volatile uint16_t*)0x00FFFD0CUL) /* QADC Data Direction Register QA */
#define qadc_ddrqb (*(volatile uint16_t*)0x00FFFD0EUL) /* QADC Data Direction Register QB */
#define TPU_PRAM_CH1_0 (*(volatile uint16_t*)0x00FFFD20UL) /* TPU parameter RAM channel 1 offset 0 */
#define TPU_PRAM_CH1_2 (*(volatile uint16_t*)0x00FFFD22UL) /* TPU parameter RAM channel 1 offset 2 */
#define TPU_PRAM_CH1_4 (*(volatile uint16_t*)0x00FFFD24UL) /* TPU parameter RAM channel 1 offset 4 */
#define TPU_PRAM_CH1_6 (*(volatile uint16_t*)0x00FFFD26UL) /* TPU parameter RAM channel 1 offset 6 */
#define TPU_PRAM_CH1_8 (*(volatile uint16_t*)0x00FFFD28UL) /* TPU parameter RAM channel 1 offset 8 */
#define TPU_PRAM_CH1_10 (*(volatile uint16_t*)0x00FFFD2AUL) /* TPU parameter RAM channel 1 offset 10 */
#define TPU_PRAM_CH0_0 (*(volatile uint16_t*)0x00FFFD40UL) /* TPU parameter RAM channel 0 offset 0 */
#define TPU_PRAM_CH0_1 (*(volatile uint8_t*)0x00FFFD41UL) /* TPU parameter RAM channel 0 offset 1 */
#define TPU_PRAM_CH0_2 (*(volatile uint16_t*)0x00FFFD42UL) /* TPU parameter RAM channel 0 offset 2 */
#define TPU_PRAM_CH0_3 (*(volatile uint8_t*)0x00FFFD43UL) /* TPU parameter RAM channel 0 offset 3 */
#define TPU_PRAM_CH0_4 (*(volatile uint16_t*)0x00FFFD44UL) /* TPU parameter RAM channel 0 offset 4 */
#define TPU_PRAM_CH0_5 (*(volatile uint8_t*)0x00FFFD45UL) /* TPU parameter RAM channel 0 offset 5 */
#define can1_canmcr (*(volatile uint16_t*)0x00FFFE00UL) /* CAN 1 Master Control Register [CalTerm: MIOS_MC... */
#define can1_canbtcr (*(volatile uint16_t*)0x00FFFE02UL) /* CAN 1 Bit Timing Configuration Register */
#define can1_cantcr (*(volatile uint16_t*)0x00FFFE04UL) /* CAN 1 Test Control Register */
#define can1_canacr (*(volatile uint16_t*)0x00FFFE06UL) /* CAN 1 Acceptance Control Register */
#define can1_cantaak (*(volatile uint16_t*)0x00FFFE08UL) /* CAN 1 Transmit Acknowledge Register [CalTerm: M... */
#define can1_cantbsel (*(volatile uint16_t*)0x00FFFE0AUL) /* CAN 1 Transmit Buffer Selection Register [CalTe... */
#define can1_canidac (*(volatile uint16_t*)0x00FFFE0CUL) /* CAN 1 Identifier Acceptance Control Register [C... */
#define can1_reserved (*(volatile uint16_t*)0x00FFFE0EUL) /* CAN 1 Reserved Register [CalTerm: MIOS_MPWMSM0_... */
#define can1_canrxerr (*(volatile uint16_t*)0x00FFFE10UL) /* CAN 1 Receive Error Counter Register */
#define can1_cantxerr (*(volatile uint16_t*)0x00FFFE12UL) /* CAN 1 Transmit Error Counter Register [CalTerm:... */
#define can1_canidar0 (*(volatile uint16_t*)0x00FFFE14UL) /* CAN 1 Identifier Acceptance Register 0 [CalTerm... */
#define can1_canidar1 (*(volatile uint16_t*)0x00FFFE16UL) /* CAN 1 Identifier Acceptance Register 1 [CalTerm... */
#define can1_canidar2 (*(volatile uint16_t*)0x00FFFE18UL) /* CAN 1 Identifier Acceptance Register 2 [CalTerm... */
#define can1_canidar3 (*(volatile uint16_t*)0x00FFFE1AUL) /* CAN 1 Identifier Acceptance Register 3 [CalTerm... */
#define can1_canidmr0 (*(volatile uint16_t*)0x00FFFE1CUL) /* CAN 1 Identifier Mask Register 0 [CalTerm: MIOS... */
#define can1_canidmr1 (*(volatile uint16_t*)0x00FFFE1EUL) /* CAN 1 Identifier Mask Register 1 [CalTerm: MIOS... */
#define can1_canidmr2 (*(volatile uint16_t*)0x00FFFE20UL) /* CAN 1 Identifier Mask Register 2 [CalTerm: MIOS... */
#define can1_canidmr3 (*(volatile uint16_t*)0x00FFFE22UL) /* CAN 1 Identifier Mask Register 3 */
#define can2_canmcr (*(volatile uint16_t*)0x00FFFE80UL) /* CAN 2 Master Control Register */
#define can2_canbtcr (*(volatile uint16_t*)0x00FFFE82UL) /* CAN 2 Bit Timing Configuration Register */
#define can2_cantcr (*(volatile uint16_t*)0x00FFFE84UL) /* CAN 2 Test Control Register */
#define can2_canacr (*(volatile uint16_t*)0x00FFFE86UL) /* CAN 2 Acceptance Control Register */
#define can2_cantaak (*(volatile uint16_t*)0x00FFFE88UL) /* CAN 2 Transmit Acknowledge Register */
#define can2_cantbsel (*(volatile uint16_t*)0x00FFFE8AUL) /* CAN 2 Transmit Buffer Selection Register */
#define can2_canidac (*(volatile uint16_t*)0x00FFFE8CUL) /* CAN 2 Identifier Acceptance Control Register */
#define can2_reserved (*(volatile uint16_t*)0x00FFFE8EUL) /* CAN 2 Reserved Register */
#define can2_canrxerr (*(volatile uint16_t*)0x00FFFE90UL) /* CAN 2 Receive Error Counter Register */
#define can2_cantxerr (*(volatile uint16_t*)0x00FFFE92UL) /* CAN 2 Transmit Error Counter Register */
#define can2_canidar0 (*(volatile uint16_t*)0x00FFFE94UL) /* CAN 2 Identifier Acceptance Register 0 */
#define can2_canidar1 (*(volatile uint16_t*)0x00FFFE96UL) /* CAN 2 Identifier Acceptance Register 1 */
#define can2_canidar2 (*(volatile uint16_t*)0x00FFFE98UL) /* CAN 2 Identifier Acceptance Register 2 */
#define can2_canidar3 (*(volatile uint16_t*)0x00FFFE9AUL) /* CAN 2 Identifier Acceptance Register 3 */
#define can2_canidmr0 (*(volatile uint16_t*)0x00FFFE9CUL) /* CAN 2 Identifier Mask Register 0 */
#define can2_canidmr1 (*(volatile uint16_t*)0x00FFFE9EUL) /* CAN 2 Identifier Mask Register 1 */
#define can2_canidmr2 (*(volatile uint16_t*)0x00FFFEA0UL) /* CAN 2 Identifier Mask Register 2 */
#define can2_canidmr3 (*(volatile uint16_t*)0x00FFFEA2UL) /* CAN 2 Identifier Mask Register 3 */
#define QSM_QMCR (*(volatile uint16_t*)0x00FFFF00UL) /* QSM module control register */
#define QSM_QTEST (*(volatile uint16_t*)0x00FFFF02UL) /* QSM test register */
#define QSM_QSMCR (*(volatile uint16_t*)0x00FFFF04UL) /* QSM module configuration register */
#define QSM_QILR (*(volatile uint16_t*)0x00FFFF06UL) /* QSM interrupt level register */
#define QSM_QIVR (*(volatile uint16_t*)0x00FFFF08UL) /* QSM interrupt vector register */
#define QSM_QILR_IVL (*(volatile uint16_t*)0x00FFFF0CUL) /* QSM interrupt level vector register */
#define QSM_PORTQS (*(volatile uint16_t*)0x00FFFF10UL) /* QSM port QS data register */
#define QSM_PQSCTL (*(volatile uint16_t*)0x00FFFF12UL) /* QSM port QS control register */
#define QSM_DDRQS (*(volatile uint16_t*)0x00FFFF16UL) /* QSM port QS data direction register */
#define QSM_PQSPAR (*(volatile uint16_t*)0x00FFFF18UL) /* QSM port QS pin assignment register */
#define QSM_QPAR (*(volatile uint8_t*)0x00FFFF1BUL) /* QSM pin assignment register */
#define QSM_SPCR3 (*(volatile uint16_t*)0x00FFFF20UL) /* QSM SPI control register 3 */
#define QSM_NEWQP (*(volatile uint16_t*)0x00FFFF22UL) /* QSM new queue pointer register */
#define QSM_SPCR1 (*(volatile uint16_t*)0x00FFFF26UL) /* QSM SPI control register 1 */
#define QSM_SPCR2 (*(volatile uint16_t*)0x00FFFF28UL) /* QSM SPI control register 2 */
#define QSM_SPSR (*(volatile uint16_t*)0x00FFFF30UL) /* QSM SPI status register */
#define QSM_SPCR0 (*(volatile uint16_t*)0x00FFFF34UL) /* QSM SPI control register 0 */
#define QSM_SCCR1 (*(volatile uint16_t*)0x00FFFF38UL) /* QSM SCI control register 1 */
#define QSM_SCCR2 (*(volatile uint16_t*)0x00FFFF3AUL) /* QSM SCI control register 2 */
#define IMB_CSBAR0 (*(volatile uint16_t*)0x00FFFFA0UL) /* IMB chip select base address register 0 */
#define IMB_CSOR0 (*(volatile uint16_t*)0x00FFFFA2UL) /* IMB chip select option register 0 */
#define IMB_CSBAR1 (*(volatile uint16_t*)0x00FFFFA4UL) /* IMB chip select base address register 1 */
#define IMB_CSOR1 (*(volatile uint16_t*)0x00FFFFA6UL) /* IMB chip select option register 1 */
#define rpm_timer_capture_value (*(volatile uint32_t*)0x00FFFFA8UL) /* Timer capture value for RPM calculation */
#define IMB_CSBAR2 (*(volatile uint16_t*)0x00FFFFC0UL) /* IMB chip select base address register 2 */
#define IMB_CSBAR3 (*(volatile uint16_t*)0x00FFFFC4UL) /* IMB chip select base address register 3 */
#define IMB_PICR (*(volatile uint16_t*)0x00FFFFD0UL) /* IMB periodic interrupt control register */
#define IMB_PITR (*(volatile uint16_t*)0x00FFFFD2UL) /* IMB periodic interrupt timer register */
#define IMB_CSBAR10 (*(volatile uint16_t*)0x00FFFFFCUL) /* IMB chip select base address register 10 */
#define indicator_as_to_the_calibration_status_of_the_ecm_see_ces15005 (*(volatile uint16_t*)0x01000000UL) /* INDICATOR AS TO THE CALIBRATION STATUS OF THE ECM */
#define ECM_PSWD ((volatile uint8_t*)0x01000002UL) /* [6] CalTerm ECM_PSWD: SECURITY MASTER PASSWORD */
#define checksum_for_flash_parameter_block_1_0_ff (*(volatile uint16_t*)0x01000008UL) /* CHECKSUM FOR FLASH PARAMETER BLOCK  1 */
#define checksum_for_flash_parameter_block_2_0_ff (*(volatile uint16_t*)0x0100000AUL) /* CHECKSUM FOR FLASH PARAMETER BLOCK  2 */
#define memory_offset_ee_romseg_none (*(volatile uint16_t*)0x0100003AUL) /* MEMORY OFFSET + EE_ROMSEG */
#define CAL_DATE ((volatile uint16_t*)0x01000080UL) /* [3] CALIBRATION RELEASE DATE. */
#define indicates_the_versions_of_the_tools_compatible_with_the_ecm_n_a (*(volatile uint16_t*)0x01000090UL) /* INDICATES THE VERSIONS OF THE TOOLS COMPATIBLE ... */
#define service_tool_adjustable_parameters_n_a (*(volatile uint16_t*)0x01000092UL) /* SERVICE TOOL ADJUSTABLE PARAMETERS [CalTerm: AD... */
#define engine_speed_set_point_for_remote_pto_operation_600_2500 (*(volatile uint16_t*)0x0100009CUL) /* ENGINE SPEED SET POINT FOR REMOTE PTO OPERATION */
#define max_range_limit_for_pto_setpoints_600_2500_9e (*(volatile uint16_t*)0x0100009EUL) /* MAX RANGE LIMIT FOR PTO SETPOINTS */
#define offset_used_to_obtain_calculated_pto_proportional_gain_0_0_2 (*(volatile uint16_t*)0x010000A4UL) /* OFFSET USED TO OBTAIN CALCULATED PTO PROPORTION... */
#define slope_used_to_obtain_calculated_pto_proportional_gain_0_0_0_05 (*(volatile uint16_t*)0x010000A6UL) /* SLOPE USED TO OBTAIN CALCULATED PTO PROPORTIONA... */
#define offset_used_to_adjust_droop_in_the_gain_adjust_calculation_of_0_4000 (*(volatile uint16_t*)0x010000ACUL) /* OFFSET USED TO ADJUST DROOP IN THE GAIN ADJUST ... */
#define slope_multiplier_used_to_adjust_droop_in_the_gain_adjust_cal_30_40000 (*(volatile uint32_t*)0x010000AEUL) /* SLOPE MULTIPLIER USED TO ADJUST DROOP IN THE GA... */
#define tool_asg_droop_min_throttle_for_switched_droop_2_adjust_0_00_50_00 (*(volatile uint16_t*)0x010000B6UL) /* TOOL ASG DROOP MIN THROTTLE % FOR SWITCHED DROO... */
#define tool_asg_droop_max_throttle_for_switched_droop_2_adjus_0_00_100_00 (*(volatile uint16_t*)0x010000B8UL) /* TOOL ASG DROOP MAX THROTTLE % FOR SWITCHED DROO... */
#define asdp21gn_param (*(volatile uint16_t*)0x010000BAUL) /* ALTERNATE OFFSET USED TO ADJUST DROOP IN GAIN A... */
#define asdp22gn_param (*(volatile uint32_t*)0x010000BCUL) /* ALTERNATE SLOPE MULTIPLIER USED TO ADJUST DROOP... */
#define asmnrf02_param (*(volatile uint16_t*)0x010000C0UL) /* ALTERNATE ASG REFERENCE SPEED FOR 0% THROTTLE I... */
#define asmxrf02_param (*(volatile uint16_t*)0x010000C2UL) /* ALTERNATE ASG REFERENCE SPEED FOR 100% THROTTLE... */
#define tool_asg_droop_min_throttle_for_switched_droop_3_adjust_0_00_50_00 (*(volatile uint16_t*)0x010000C4UL) /* TOOL ASG DROOP MIN THROTTLE % FOR SWITCHED DROO... */
#define tool_asg_droop_max_throttle_for_switched_droop_3_adjus_0_00_100_00 (*(volatile uint16_t*)0x010000C6UL) /* TOOL ASG DROOP MAX THROTTLE % FOR SWITCHED DROO... */
#define asdp31gn_param (*(volatile uint16_t*)0x010000C8UL) /* ALTERNATE OFFSET USED TO ADJUST DROOP IN GAIN A... */
#define asdp32gn_param (*(volatile uint32_t*)0x010000CAUL) /* ALTERNATE SLOPE MULTIPLIER USED TO ADJUST DROOP... */
#define asmnrf03_param (*(volatile uint16_t*)0x010000CEUL) /* ALTERNATE ASG REFERENCE SPEED FOR 0% THROTTLE I... */
#define asmxrf03_param (*(volatile uint16_t*)0x010000D0UL) /* ALTERNATE ASG REFERENCE SPEED FOR 100% THROTTLE... */
#define blank_spot_0_434_8_d6 (*(volatile uint16_t*)0x010000D6UL) /* BLANK_SPOT */
#define alternate_fueling_intercept_used_in_determining_hsg_droop_re_0_434_8_de (*(volatile uint16_t*)0x010000DEUL) /* ALTERNATE FUELING INTERCEPT USED IN DETERMINING... */
#define alternate_fueling_intercept_used_in_determining_hsg_droop_re_0_434_8_e4 (*(volatile uint16_t*)0x010000E4UL) /* ALTERNATE FUELING INTERCEPT USED IN DETERMINING... */
#define FSTHGVOP (*(volatile uint16_t*)0x010000E6UL) /* CalTerm FSTHGVOP: USER INDICATOR FOR ENABLING A... */
#define tool_previous_ecm_engine_time_for_offset_of_engine_total_0_99999_0 (*(volatile uint32_t*)0x010000E8UL) /* TOOL  PREVIOUS ECM ENGINE TIME FOR OFFSET OF EN... */
#define adbs01_param (*(volatile uint16_t*)0x010000ECUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs02_param (*(volatile uint16_t*)0x010000EEUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs03_param (*(volatile uint16_t*)0x010000F0UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs04_param (*(volatile uint16_t*)0x010000F2UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs05_param (*(volatile uint16_t*)0x010000FAUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs06_param (*(volatile uint16_t*)0x010000FCUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs07_param (*(volatile uint16_t*)0x010000FEUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define pto_max_droop_pto_min_droop_pto_max_droop_rpm_pto_min_dro_0_2 (*(volatile uint16_t*)0x01000100UL) /* (PTO MAX DROOP */
#define pto_resume_speed_display_value_none (*(volatile uint16_t*)0x01000104UL) /* PTO RESUME SPEED DISPLAY VALUE */
#define pto_set_speed_display_value_none (*(volatile uint16_t*)0x01000108UL) /* PTO SET SPEED DISPLAY VALUE */
#define adbs08_param (*(volatile uint16_t*)0x0100010AUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs09_param (*(volatile uint16_t*)0x0100010CUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs10_param (*(volatile uint16_t*)0x0100010EUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs11_param (*(volatile uint16_t*)0x01000110UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs12_param (*(volatile uint16_t*)0x01000112UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs13_param (*(volatile uint16_t*)0x01000114UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs22_param (*(volatile uint16_t*)0x01000116UL) /* BLANK SPOT IN ADJUSTABLE_PARAMETERS.H [CalTerm:... */
#define adbs14_param (*(volatile uint32_t*)0x01000118UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs23_param (*(volatile uint16_t*)0x0100011CUL) /* BLANK SPOT IN ADJUSTABLE_PARAMETERS.H [CalTerm:... */
#define adbs24_param (*(volatile uint16_t*)0x0100011EUL) /* BLANK SPOT IN ADJUSTABLE_PARAMETERS.H [CalTerm:... */
#define adbs15_param (*(volatile uint16_t*)0x01000120UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs16_param (*(volatile uint16_t*)0x01000122UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs17_param (*(volatile uint16_t*)0x01000124UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs18_param (*(volatile uint16_t*)0x01000126UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs19_param (*(volatile uint16_t*)0x01000128UL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs20_param (*(volatile uint16_t*)0x0100012AUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define adbs21_param (*(volatile uint16_t*)0x0100012CUL) /* BLANK SPOT IN THE ADJUSTABLE_PARAMETERS.H FILE ... */
#define lsg_droop_selected_percent_20_20 (*(volatile uint16_t*)0x0100012EUL) /* LSG DROOP SELECTED PERCENT */
#define early_warning_of_ocm_interval_expiring_user_programmable_0_100 (*(volatile uint16_t*)0x01000136UL) /* EARLY WARNING OF OCM INTERVAL EXPIRING (USER PR... */
#define enables_use_of_warning_light_with_engine_in_run_state_true_false (*(volatile uint16_t*)0x01000138UL) /* ENABLES USE OF WARNING LIGHT WITH ENGINE IN RUN... */
#define trimmable_lower_limit_of_hsg_breakpoint_speed_0_5000 (*(volatile uint16_t*)0x0100013AUL) /* TRIMMABLE LOWER LIMIT OF HSG BREAKPOINT SPEED */
#define trimmable_upper_limit_of_hsg_breakpoint_speed_0_5000 (*(volatile uint16_t*)0x0100013CUL) /* TRIMMABLE UPPER LIMIT OF HSG BREAKPOINT SPEED */
#define ADJ_FEAT ((volatile uint8_t*)0x01000140UL) /* FEATURE ACTIVE FLAGS */
#define AENBLFLG ((volatile uint8_t*)0x01000188UL) /* LENGTH OF ALGORITHM_ENABLE_FLAGS */
#define APAFEN (*(volatile uint16_t*)0x0100018AUL) /* BIT B WORD 0. ENABLES ALPHA AFC SUBALGORITHM FO... */
#define APUOAPEN (*(volatile uint16_t*)0x0100018CUL) /* BIT 0 WORD 1. EEPROM INDICATOR SET BY ENGR APPL... */
#define CPAGEN (*(volatile uint16_t*)0x01000190UL) /* BIT 11 OF 0-15.  ENABLES AND DISABLES THE CYLIN... */
#define ADV_OVER (*(volatile uint16_t*)0x01000192UL) /* BIT 8 OF WORD 4.  ENABLE INDICATOR FOR THE ENGI... */
#define algorithm_enable_flags_word_5_bit_3_enable_disable (*(volatile uint16_t*)0x01000194UL) /* ALGORITHM_ENABLE_FLAGS WORD 5 BIT 3 */
#define frequency_throttle_input_sv_override_enable_disable (*(volatile uint16_t*)0x01000196UL) /* FREQUENCY_THROTTLE_INPUT_SV_OVERRIDE [CalTerm: ... */
#define bit_14_of_0_14_enables_shutdown_on_fuel_temperatu_1_enabled_0_disabl (*(volatile uint16_t*)0x0100019AUL) /* BIT 14 OF 0-14 ENABLES SHUTDOWN ON FUEL TEMPERATU */
#define AFENMAN (*(volatile uint16_t*)0x010001A2UL) /* BIT 3 OF 0-15 IN WORD C */
#define bit_f_user_override_enable_flag_for_the_diagnostic_test_enable_disable (*(volatile uint16_t*)0x010001A4UL) /* BIT F USER OVERRIDE ENABLE FLAG FOR THE DIAGNOS... */
#define user_override_enable_flag_for_user_datalogger_switch_enable_disable (*(volatile uint16_t*)0x010001A6UL) /* USER OVERRIDE ENABLE FLAG FOR USER DATALOGGER S... */
#define enable_which_allows_the_client_to_override_wait_to_star_enable_disable (*(volatile uint16_t*)0x010001A8UL) /* ENABLE WHICH ALLOWS THE CLIENT TO OVERRIDE WAIT... */
#define user_override_enable_flag_for_the_pto_set_switch_enable_disable (*(volatile uint16_t*)0x010001AAUL) /* USER OVERRIDE ENABLE FLAG FOR THE PTO SET SWITCH */
#define user_override_enable_flag_for_the_torque_derate_switch_enable_disable (*(volatile uint16_t*)0x010001ACUL) /* USER OVERRIDE ENABLE FLAG FOR THE TORQUE DERATE... */
#define remote_throttle_enable_bit_12_of_0_15_0_1 (*(volatile uint16_t*)0x010001AEUL) /* REMOTE THROTTLE ENABLE BIT 12 OF 0-15 */
#define enable_disable_parameter_for_the_throttle_activated_dia_enable_disable (*(volatile uint16_t*)0x010001B0UL) /* ENABLE/DISABLE PARAMETER FOR THE THROTTLE ACTIV... */
#define throttle_position_sensor_sv_override_raw_enable_enable_disable (*(volatile uint16_t*)0x010001B6UL) /* THROTTLE POSITION SENSOR SV OVERRIDE RAW ENABLE */
#define vehicle_connector_sensors_sv_override_raw_enable_enable_disable (*(volatile uint16_t*)0x010001B8UL) /* VEHICLE CONNECTOR SENSORS SV OVERRIDE RAW ENABLE */
#define a_d_override_for_manual_fan_level_requested_fan_spee_enable_disable (*(volatile uint16_t*)0x010001BCUL) /* A/D OVERRIDE FOR MANUAL FAN LEVEL (REQUESTED % ... */
#define bit_10_of_15_selects_the_temp_interaction_option_for_i_enable_disable (*(volatile uint16_t*)0x010001C0UL) /* BIT 10 OF 15.SELECTS THE TEMP. INTERACTION OPTI... */
#define descriptor_of_the_project_or_fuel_system_n_a (*(volatile uint16_t*)0x010001D0UL) /* DESCRIPTOR OF THE PROJECT OR FUEL SYSTEM. */
#define AUDIT_TR (*(volatile uint16_t*)0x010001D2UL) /* MULTI BYTE SERVICE TOOL CHANGE TRACKING AREA */
#define AUTO_ADJ (*(volatile uint16_t*)0x01000230UL) /* ADJUSTABLE PARAMETERS OF THE AUTOMOTIVE INTERFA... */
#define maximum_allowable_cruise_control_reference_speed_allowed_0_255_9961 (*(volatile uint16_t*)0x01000232UL) /* MAXIMUM ALLOWABLE CRUISE CONTROL REFERENCE SPEE... */
#define maximum_allowable_vehicle_speed_in_top_gear_any_gear_if_0_255_9961 (*(volatile uint16_t*)0x01000234UL) /* MAXIMUM ALLOWABLE VEHICLE SPEED IN TOP GEAR (AN... */
#define ratio_of_trans_to_axle_revs_used_by_tools_low_ratio_if_2_1_0_20_0 (*(volatile uint16_t*)0x01000236UL) /* RATIO OF TRANS. TO AXLE REVS -USED BY TOOLS (LO... */
#define indicates_discrete_t_or_ford_multiplexed_f_cruise_switc_true_false (*(volatile uint16_t*)0x0100023AUL) /* INDICATES DISCRETE(T) OR FORD MULTIPLEXED(F) CR... */
#define ratio_of_trans_to_axle_revs_high_ratio_if_two_spd_rar_1_0_20_0 (*(volatile uint16_t*)0x0100023CUL) /* RATIO OF TRANS. TO AXLE REVS. (HIGH RATIO IF TW... */
#define indicates_whether_a_switch_is_present_for_two_spd_rar_apps_0_1 (*(volatile uint16_t*)0x0100023EUL) /* INDICATES WHETHER A SWITCH IS PRESENT FOR TWO S... */
#define additional_air_pressure_from_apamtrig_which_disables_alpha_alti_0_15 (*(volatile uint16_t*)0x01000244UL) /* ADDITIONAL AIR PRESSURE FROM APAMTRIG WHICH DIS... */
#define APAMTRIG (*(volatile uint16_t*)0x01000246UL) /* AMBIENT AIR PRESSURE WHICH TRIGGERS ALPHA ALTITUDE */
#define size_of_asg_adjustable_parameters_0_100 (*(volatile uint16_t*)0x01000248UL) /* SIZE OF ASG ADJUSTABLE PARAMETERS */
#define flag_to_enable_disable_the_asg_quadratic_proportional_scheme_0_1 (*(volatile uint16_t*)0x0100024AUL) /* FLAG TO ENABLE/DISABLE THE ASG QUADRATIC PROPOR... */
#define flag_to_enable_disable_the_asg_quadratic_integral_scheme_0_1 (*(volatile uint16_t*)0x0100024CUL) /* FLAG TO ENABLE/DISABLE THE ASG QUADRATIC INTEGR... */
#define flag_to_enable_disable_the_asg_quadratic_derivative_scheme_0_1 (*(volatile uint16_t*)0x0100024EUL) /* FLAG TO ENABLE/DISABLE THE ASG QUADRATIC DERIVA... */
#define datalogger_trigger_one_length_0_4 (*(volatile uint8_t*)0x0100025AUL) /* DATALOGGER TRIGGER ONE LENGTH */
#define name_table_name_for_datalogger_trigger_1_0_ffff (*(volatile uint16_t*)0x01000260UL) /* NAME TABLE NAME FOR DATALOGGER TRIGGER 1. */
#define name_table_offset_for_datalogger_trigger_1_0_ffff (*(volatile uint16_t*)0x01000262UL) /* NAME TABLE OFFSET FOR DATALOGGER TRIGGER 1. */
#define trigger_threshold_for_the_datalogger_trigger_one_input_0_ffffffff (*(volatile uint32_t*)0x01000264UL) /* TRIGGER THRESHOLD FOR THE DATALOGGER TRIGGER ON... */
#define datalogger_trigger_two_length_0_4 (*(volatile uint8_t*)0x0100026AUL) /* DATALOGGER TRIGGER TWO LENGTH */
#define name_table_name_for_datalogger_trigger_2_0_ffff (*(volatile uint16_t*)0x01000270UL) /* NAME TABLE NAME FOR DATALOGGER TRIGGER 2. */
#define name_table_offset_for_datalogger_trigger_2_0_ffff (*(volatile uint16_t*)0x01000272UL) /* NAME TABLE OFFSET FOR DATALOGGER TRIGGER 2. */
#define trigger_threshold_for_the_datalogger_trigger_two_input_0_ffffffff (*(volatile uint32_t*)0x01000274UL) /* TRIGGER THRESHOLD FOR THE DATALOGGER TRIGGER TW... */
#define datalogger_trigger_three_length_0_4 (*(volatile uint8_t*)0x0100027AUL) /* DATALOGGER TRIGGER THREE LENGTH */
#define name_table_name_for_datalogger_trigger_3_0_ffff (*(volatile uint16_t*)0x01000280UL) /* NAME TABLE NAME  FOR DATALOGGER TRIGGER 3. */
#define name_table_offset_for_datalogger_trigger_3_0_ffff (*(volatile uint16_t*)0x01000282UL) /* NAME TABLE OFFSET FOR DATALOGGER TRIGGER 3. */
#define trigger_threshold_for_the_datalogger_trigger_three_input_0_ffffffff (*(volatile uint32_t*)0x01000284UL) /* TRIGGER THRESHOLD FOR THE DATALOGGER TRIGGER TH... */
#define datalogger_trigger_four_length_0_4 (*(volatile uint8_t*)0x0100028AUL) /* DATALOGGER TRIGGER FOUR LENGTH */
#define name_table_name_for_datalogger_trigger_4_0_ffff (*(volatile uint16_t*)0x01000290UL) /* NAME TABLE NAME FOR DATALOGGER TRIGGER 4. */
#define name_table_offset_for_datalogger_trigger_4_0_ffff (*(volatile uint16_t*)0x01000292UL) /* NAME TABLE OFFSET FOR DATALOGGER TRIGGER 4. */
#define trigger_threshold_for_the_datalogger_trigger_four_input_0_ffffffff (*(volatile uint32_t*)0x01000294UL) /* TRIGGER THRESHOLD FOR THE DATALOGGER TRIGGER FO... */
#define datalogger_data_one_length_0_10 (*(volatile uint16_t*)0x0100029AUL) /* DATALOGGER DATA ONE LENGTH */
#define name_table_name_for_datalogger_data_parameter_1_0_ffff (*(volatile uint16_t*)0x0100029CUL) /* NAME TABLE NAME FOR DATALOGGER DATA PARAMETER 1 */
#define name_table_offset_for_datalogger_data_parameter_1_0_ffff (*(volatile uint16_t*)0x0100029EUL) /* NAME TABLE OFFSET FOR DATALOGGER DATA PARAMETER 1 */
#define datalogger_data_two_length_0_10 (*(volatile uint16_t*)0x010002A0UL) /* DATALOGGER DATA TWO LENGTH */
#define name_table_name_for_datalogger_data_parameter_2_0_ffff (*(volatile uint16_t*)0x010002A2UL) /* NAME TABLE NAME FOR DATALOGGER DATA PARAMETER 2 */
#define name_table_offset_for_datalogger_data_parameter_2_0_ffff (*(volatile uint16_t*)0x010002A4UL) /* NAME TABLE OFFSET FOR DATALOGGER DATA PARAMETER 2 */
#define datalogger_data_three_length_0_10 (*(volatile uint16_t*)0x010002A6UL) /* DATALOGGER DATA THREE LENGTH */
#define name_table_name_for_datalogger_data_parameter_3_0_ffff (*(volatile uint16_t*)0x010002A8UL) /* NAME TABLE NAME FOR DATALOGGER DATA PARAMETER 3 */
#define name_table_offset_for_datalogger_data_parameter_3_0_ffff (*(volatile uint16_t*)0x010002AAUL) /* NAME TABLE OFFSET FOR DATALOGGER DATA PARAMETER 3 */
#define datalogger_data_four_length_0_10 (*(volatile uint16_t*)0x010002ACUL) /* DATALOGGER DATA FOUR LENGTH */
#define name_table_name_for_datalogger_data_parameter_4_0_ffff (*(volatile uint16_t*)0x010002AEUL) /* NAME TABLE NAME FOR DATALOGGER DATA PARAMETER 4 */
#define name_table_offset_for_datalogger_data_parameter_4_0_ffff (*(volatile uint16_t*)0x010002B0UL) /* NAME TABLE OFFSET FOR DATALOGGER DATA PARAMETER 4 */
#define datalogger_data_five_length_0_10 (*(volatile uint16_t*)0x010002B2UL) /* DATALOGGER DATA FIVE LENGTH */
#define name_table_name_for_datalogger_data_parameter_5_0_ffff (*(volatile uint16_t*)0x010002B4UL) /* NAME TABLE NAME FOR DATALOGGER DATA PARAMETER 5 */
#define name_table_offset_for_datalogger_data_parameter_5_0_ffff (*(volatile uint16_t*)0x010002B6UL) /* NAME TABLE OFFSET FOR DATALOGGER DATA PARAMETER 5 */
#define DAT_PLAT ((volatile uint8_t*)0x010002C0UL) /* [332] CalTerm DAT_PLAT: PART, SERIAL NUMBER AND CODE ... */
#define ESCS (*(volatile uint32_t*)0x01000416UL) /* Conversion factor from hardware time units to RPM */
#define engineering_torque_derate_fueling_override_0_100 (*(volatile uint16_t*)0x01000420UL) /* ENGINEERING TORQUE DERATE FUELING OVERRIDE */
#define fpw_trim_to_adjust_for_mechanical_wear_per_cyl_15_15_424 (*(volatile uint16_t*)0x01000424UL) /* FPW TRIM TO ADJUST FOR MECHANICAL WEAR PER CYL */
#define fpw_trim_to_adjust_for_mechanical_wear_per_cyl_15_15_426 (*(volatile uint16_t*)0x01000426UL) /* FPW TRIM TO ADJUST FOR MECHANICAL WEAR PER CYL */
#define fpw_trim_to_adjust_for_mechanical_wear_per_cyl_15_15_428 (*(volatile uint16_t*)0x01000428UL) /* FPW TRIM TO ADJUST FOR MECHANICAL WEAR PER CYL */
#define fpw_trim_to_adjust_for_mechanical_wear_per_cyl_15_15_42a (*(volatile uint16_t*)0x0100042AUL) /* FPW TRIM TO ADJUST FOR MECHANICAL WEAR PER CYL */
#define fpw_trim_to_adjust_for_mechanical_wear_per_cyl_15_15_42c (*(volatile uint16_t*)0x0100042CUL) /* FPW TRIM TO ADJUST FOR MECHANICAL WEAR PER CYL */
#define fpw_trim_to_adjust_for_mechanical_wear_per_cyl_15_15_42e (*(volatile uint16_t*)0x0100042EUL) /* FPW TRIM TO ADJUST FOR MECHANICAL WEAR PER CYL */
#define incremental_fueling_value_added_to_4_d_fueling_value_8_7_8_7 (*(volatile uint16_t*)0x01000430UL) /* INCREMENTAL FUELING VALUE ADDED TO 4-D FUELING ... */
#define engineering_timing_advance_increment_value_60_60 (*(volatile uint16_t*)0x01000432UL) /* ENGINEERING TIMING ADVANCE INCREMENT VALUE */
#define max_engine_speed_when_no_derate_is_in_effect_hsg_brake_r_1400_4500 (*(volatile uint16_t*)0x01000436UL) /* MAX ENGINE SPEED WHEN NO DERATE IS IN EFFECT. (... */
#define size_of_hsg_adjustable_parameters_0_100 (*(volatile uint16_t*)0x0100043AUL) /* SIZE OF HSG ADJUSTABLE PARAMETERS */
#define default_network_priority_for_cc_vss_message_0_7 (*(volatile uint16_t*)0x01000448UL) /* DEFAULT NETWORK PRIORITY FOR CC / VSS MESSAGE */
#define default_priority_for_diagnostic_message_1_0_7 (*(volatile uint16_t*)0x0100044CUL) /* DEFAULT PRIORITY FOR DIAGNOSTIC MESSAGE 1 */
#define default_priority_for_diagnostic_message_2_0_7 (*(volatile uint16_t*)0x0100044EUL) /* DEFAULT PRIORITY FOR DIAGNOSTIC MESSAGE 2 */
#define default_priority_for_diagnostic_message_4_0_7 (*(volatile uint16_t*)0x01000450UL) /* DEFAULT PRIORITY FOR DIAGNOSTIC MESSAGE 4 */
#define default_priority_for_diagnostic_message_5_0_7 (*(volatile uint16_t*)0x01000452UL) /* DEFAULT PRIORITY FOR DIAGNOSTIC MESSAGE 5 */
#define default_priority_for_diagnostic_message_8_0_7 (*(volatile uint16_t*)0x01000454UL) /* DEFAULT PRIORITY FOR DIAGNOSTIC MESSAGE 8 */
#define default_priority_for_diagnostic_message_10_0_7 (*(volatile uint16_t*)0x01000456UL) /* DEFAULT PRIORITY FOR DIAGNOSTIC MESSAGE 10 */
#define default_network_priority_for_eec1_message_0_7 (*(volatile uint16_t*)0x01000458UL) /* DEFAULT NETWORK PRIORITY FOR EEC1 MESSAGE */
#define default_network_priority_for_eec2_message_0_7 (*(volatile uint16_t*)0x0100045AUL) /* DEFAULT NETWORK PRIORITY FOR EEC2 MESSAGE */
#define default_network_priority_for_eec3_message_0_7 (*(volatile uint16_t*)0x0100045CUL) /* DEFAULT NETWORK PRIORITY FOR EEC3 MESSAGE */
#define default_network_priority_for_engine_configuration_message_0_7 (*(volatile uint16_t*)0x0100045EUL) /* DEFAULT NETWORK PRIORITY FOR ENGINE CONFIGURATI... */
#define default_network_priority_for_engine_fluid_message_0_7 (*(volatile uint16_t*)0x01000460UL) /* DEFAULT NETWORK PRIORITY FOR ENGINE FLUID MESSAGE */
#define default_network_priority_for_erc1_message_0_7 (*(volatile uint16_t*)0x01000464UL) /* DEFAULT NETWORK PRIORITY FOR ERC1 MESSAGE */
#define default_network_priority_for_engine_temperature_message_0_7 (*(volatile uint16_t*)0x01000466UL) /* DEFAULT NETWORK PRIORITY FOR ENGINE TEMPERATURE... */
#define default_network_priority_for_idle_shutdown_message_0_7 (*(volatile uint16_t*)0x0100046EUL) /* DEFAULT NETWORK PRIORITY FOR IDLE SHUTDOWN MESSAGE */
#define default_network_priority_for_nack_message_0_7 (*(volatile uint16_t*)0x01000472UL) /* DEFAULT NETWORK PRIORITY FOR NACK MESSAGE */
#define default_network_priority_for_retarder_configuration_message_0_7 (*(volatile uint16_t*)0x01000476UL) /* DEFAULT NETWORK PRIORITY FOR RETARDER CONFIGURA... */
#define default_network_priority_for_vehicle_distance_message_0_7 (*(volatile uint16_t*)0x01000478UL) /* DEFAULT NETWORK PRIORITY FOR VEHICLE DISTANCE M... */
#define default_network_priority_for_vehicle_electrical_power_message_0_7 (*(volatile uint16_t*)0x0100047AUL) /* DEFAULT NETWORK PRIORITY FOR VEHICLE ELECTRICAL... */
#define default_network_priority_for_vehicle_hours_message_0_7 (*(volatile uint16_t*)0x0100047CUL) /* DEFAULT NETWORK PRIORITY FOR VEHICLE HOURS MESSAGE */
#define JC39BCFG (*(volatile uint16_t*)0x0100047EUL) /* CalTerm JC39BCFG: BIT 2 - 39/71 ENGINE, BIT 3 -... */
#define CKEXESSW (*(volatile uint16_t*)0x01000480UL) /* CRANK EXIT SPEED SWITCH  1 = USE CALIBRATION/0=... */
#define default_network_priority_for_the_engine_hours_message_pgn_fee5_0_7 (*(volatile uint16_t*)0x01000482UL) /* DEFAULT NETWORK PRIORITY FOR THE ENGINE HOURS M... */
#define default_network_priority_for_vehicle_identification_message_0_7 (*(volatile uint16_t*)0x01000484UL) /* DEFAULT NETWORK PRIORITY FOR VEHICLE IDENTIFICA... */
#define default_network_priority_for_engine_brake_controller_1_message_0_7 (*(volatile uint16_t*)0x01000486UL) /* DEFAULT NETWORK PRIORITY FOR ENGINE BRAKE CONTR... */
#define default_network_priority_for_fan_drive_message_0_7 (*(volatile uint16_t*)0x01000488UL) /* DEFAULT NETWORK PRIORITY FOR FAN DRIVE MESSAGE. */
#define default_network_priority_for_water_in_fuel_indicator_message_0_7 (*(volatile uint16_t*)0x0100048AUL) /* DEFAULT NETWORK PRIORITY FOR WATER IN FUEL INDI... */
#define source_address_allowed_for_muxing_requested_fan_speed_parameter_0_ff (*(volatile uint8_t*)0x01000492UL) /* SOURCE ADDRESS ALLOWED FOR MUXING REQUESTED % F... */
#define source_address_allowed_for_muxing_remote_throttle_switch_paramete_0_ff (*(volatile uint8_t*)0x01000493UL) /* SOURCE ADDRESS ALLOWED FOR MUXING REMOTE THROTT... */
#define source_address_allowed_for_muxing_auxiliary_shutdown_switch_param_0_ff (*(volatile uint8_t*)0x01000494UL) /* SOURCE ADDRESS ALLOWED FOR MUXING AUXILIARY SHU... */
#define source_address_allowed_for_muxing_torque_derate_switch_parameter_0_ff (*(volatile uint8_t*)0x01000495UL) /* SOURCE ADDRESS ALLOWED FOR MUXING TORQUE DERATE... */
#define source_address_allowed_for_muxing_accelerator_interlock_switch_pa_0_ff (*(volatile uint8_t*)0x01000496UL) /* SOURCE ADDRESS ALLOWED FOR MUXING ACCELERATOR I... */
#define source_address_allowed_for_muxing_user_requested_engine_brake_par_0_ff (*(volatile uint8_t*)0x01000497UL) /* SOURCE ADDRESS ALLOWED FOR MUXING USER REQUESTE... */
#define source_address_allowed_for_muxing_idle_switch_parameter_0_ff (*(volatile uint8_t*)0x01000498UL) /* SOURCE ADDRESS ALLOWED FOR MUXING IDLE SWITCH P... */
#define source_address_allowed_for_muxing_commmanded_throttle_parameter_0_ff (*(volatile uint8_t*)0x01000499UL) /* SOURCE ADDRESS ALLOWED FOR MUXING COMMMANDED TH... */
#define source_address_allowed_for_muxing_remote_throttle_parameter_0_ff (*(volatile uint8_t*)0x0100049AUL) /* SOURCE ADDRESS ALLOWED FOR MUXING REMOTE THROTT... */
#define source_address_allowed_for_muxing_wet_tank_pressure_parameter_0_ff (*(volatile uint8_t*)0x0100049BUL) /* SOURCE ADDRESS ALLOWED FOR MUXING WET TANK PRES... */
#define source_address_allowed_for_muxing_air_conditioner_pressure_switch_0_ff (*(volatile uint8_t*)0x0100049CUL) /* SOURCE ADDRESS ALLOWED FOR MUXING AIR CONDITION... */
#define source_address_allowed_for_muxing_remote_pto_switch_parameter_0_ff (*(volatile uint8_t*)0x0100049DUL) /* SOURCE ADDRESS ALLOWED FOR MUXING REMOTE PTO SW... */
#define source_address_allowed_for_muxing_pto_on_switch_parameter_0_ff (*(volatile uint8_t*)0x0100049EUL) /* SOURCE ADDRESS ALLOWED FOR MUXING PTO ON SWITCH... */
#define source_address_allowed_for_muxing_pto_resume_switch_parameter_0_ff (*(volatile uint8_t*)0x0100049FUL) /* SOURCE ADDRESS ALLOWED FOR MUXING PTO RESUME SW... */
#define source_address_allowed_for_muxing_pto_set_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A0UL) /* SOURCE ADDRESS ALLOWED FOR MUXING PTO SET SWITC... */
#define source_address_allowed_for_muxing_clutch_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A1UL) /* SOURCE ADDRESS ALLOWED FOR MUXING CLUTCH SWITCH... */
#define source_address_allowed_for_muxing_brake_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A2UL) /* SOURCE ADDRESS ALLOWED FOR MUXING BRAKE SWITCH ... */
#define source_address_allowed_for_muxing_cruise_on_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A3UL) /* SOURCE ADDRESS ALLOWED FOR MUXING CRUISE ON SWI... */
#define source_address_allowed_for_muxing_cruise_resume_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A4UL) /* SOURCE ADDRESS ALLOWED FOR MUXING CRUISE RESUME... */
#define source_address_allowed_for_muxing_cruise_set_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A5UL) /* SOURCE ADDRESS ALLOWED FOR MUXING CRUISE SET SW... */
#define source_address_allowed_for_muxing_increment_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A6UL) /* SOURCE ADDRESS ALLOWED FOR MUXING INCREMENT SWI... */
#define source_address_allowed_for_muxing_decrement_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A7UL) /* SOURCE ADDRESS ALLOWED FOR MUXING DECREMENT SWI... */
#define source_address_allowed_for_muxing_test_switch_parameter_0_ff (*(volatile uint8_t*)0x010004A8UL) /* SOURCE ADDRESS ALLOWED FOR MUXING TEST SWITCH P... */
#define unused_dummy_j1939_switch_created_to_cover_gc2_error_0_255 (*(volatile uint8_t*)0x010004A9UL) /* UNUSED DUMMY J1939 SWITCH CREATED TO COVER GC2 ... */
#define allows_use_of_diagnostic_switch_to_reset_maintenance_features_0_1_4bc (*(volatile uint16_t*)0x010004BCUL) /* ALLOWS USE OF  DIAGNOSTIC SWITCH TO RESET MAINT... */
#define size_of_lsg_adjustable_parameters_0_100 (*(volatile uint16_t*)0x010004BEUL) /* SIZE OF LSG ADJUSTABLE PARAMETERS */
#define OEM_PSWD ((volatile uint8_t*)0x010004C4UL) /* [6] CalTerm OEM_PSWD: SECURITY MASTER PASSWORD FOR ... */
#define blank_spot_replacing_key_off_count_0_65535 (*(volatile uint16_t*)0x010004CAUL) /* BLANK SPOT REPLACING KEY_OFF_COUNT */
#define a_status_indicator_saved_to_eeprom_indicating_a_fail_active_inactive (*(volatile uint16_t*)0x010004D2UL) /* A STATUS INDICATOR SAVED TO EEPROM INDICATING A... */
#define counts_number_of_times_powerdown_block_2_save_has_started_0_65535 (*(volatile uint16_t*)0x010004D4UL) /* COUNTS NUMBER OF TIMES POWERDOWN BLOCK 2 SAVE H... */
#define counts_number_of_times_powerdown_block_2_save_has_completed_0_65535 (*(volatile uint16_t*)0x010004D6UL) /* COUNTS NUMBER OF TIMES POWERDOWN BLOCK 2 SAVE H... */
#define counts_number_of_times_ram_image_storage_has_started_0_65535 (*(volatile uint16_t*)0x010004D8UL) /* COUNTS NUMBER OF TIMES RAM IMAGE STORAGE HAS ST... */
#define counts_number_of_times_ram_image_storage_has_completed_0_65535 (*(volatile uint16_t*)0x010004DAUL) /* COUNTS NUMBER OF TIMES RAM IMAGE STORAGE HAS CO... */
#define flag_stored_in_eeprom_which_indicates_a_flash_write_failure_true_false (*(volatile uint16_t*)0x010004DEUL) /* FLAG STORED IN EEPROM WHICH INDICATES A FLASH W... */
#define cumulative_count_of_non_power_up_resets_none (*(volatile uint16_t*)0x010004E0UL) /* CUMULATIVE COUNT OF NON-POWER UP RESETS */
#define cumulative_count_of_power_cycles_0_65535 (*(volatile uint16_t*)0x010004E2UL) /* CUMULATIVE COUNT OF POWER CYCLES */
#define road_speed_above_which_pto_will_become_disabled_0_255_9961 (*(volatile uint16_t*)0x010004ECUL) /* ROAD SPEED ABOVE WHICH PTO WILL BECOME DISABLED */
#define min_range_limit_for_pto_setpoints_600_2500_4ee (*(volatile uint16_t*)0x010004EEUL) /* MIN RANGE LIMIT FOR PTO SETPOINTS */
#define the_maximum_number_of_toggles_that_the_remote_pto_switch_recognize_1_5 (*(volatile uint16_t*)0x010004F0UL) /* THE MAXIMUM NUMBER OF TOGGLES THAT THE REMOTE P... */
#define the_remote_pto_setspeed_used_when_the_remote_pto_switch_is_togg_0_5000_4f2 (*(volatile uint16_t*)0x010004F2UL) /* THE REMOTE PTO SETSPEED USED WHEN THE REMOTE PT... */
#define the_remote_pto_setspeed_used_when_the_remote_pto_switch_is_togg_0_5000_4f4 (*(volatile uint16_t*)0x010004F4UL) /* THE REMOTE PTO SETSPEED USED WHEN THE REMOTE PT... */
#define the_remote_pto_setspeed_used_when_the_remote_pto_switch_is_togg_0_5000_4f6 (*(volatile uint16_t*)0x010004F6UL) /* THE REMOTE PTO SETSPEED USED WHEN THE REMOTE PT... */
#define the_remote_pto_setspeed_used_when_the_remote_pto_switch_is_togg_0_5000_4f8 (*(volatile uint16_t*)0x010004F8UL) /* THE REMOTE PTO SETSPEED USED WHEN THE REMOTE PT... */
#define pto_target_speed_when_both_set_and_resume_switches_are_active_0_3000 (*(volatile uint16_t*)0x010004FAUL) /* PTO TARGET SPEED WHEN BOTH SET AND RESUME SWITC... */
#define indicates_the_size_of_the_pto_throttle_override_trims_0_ffff (*(volatile uint16_t*)0x010004FEUL) /* INDICATES THE SIZE OF THE PTO_THROTTLE_OVERRIDE... */
#define the_maximum_rpm_that_throttle_can_override_pto_300_4500 (*(volatile uint16_t*)0x01000500UL) /* THE MAXIMUM RPM THAT THROTTLE CAN OVERRIDE PTO */
#define maximum_engine_load_allowed_during_pto_operation_0_47385 (*(volatile uint16_t*)0x01000504UL) /* MAXIMUM ENGINE LOAD ALLOWED DURING PTO OPERATION */
#define customer_chosen_pto_droop_in_units_of_rpm_0_500 (*(volatile uint16_t*)0x01000506UL) /* CUSTOMER CHOSEN PTO DROOP IN UNITS OF RPM */
#define FOOTPRNT (*(volatile uint16_t*)0x01000510UL) /* CalTerm FOOTPRNT: TOOL FOOTPRINT */
#define the_tools_previous_engine_time_adjustment_for_offset_of_total_0_119304 (*(volatile uint32_t*)0x01000514UL) /* THE TOOLS PREVIOUS ENGINE TIME ADJUSTMENT FOR O... */
#define ADJPSWD1 ((volatile uint16_t*)0x0100051CUL) /* [3] SECURITY SECONDARY PASSWORD 1 -- ADJUST PASSWORD */
#define ADJPSWD2 ((volatile uint16_t*)0x01000522UL) /* [3] SECURITY SECONDARY PASSWORD 2 -- RESET PASSWORD */
#define ADJPSWD3 ((volatile uint16_t*)0x01000528UL) /* [3] SECURITY SECONDARY PASSWORD 3 */
#define ADJPSWD4 ((volatile uint16_t*)0x0100052EUL) /* [3] SECURITY SECONDARY PASSWORD 4 */
#define ADJPSWD5 ((volatile uint16_t*)0x01000534UL) /* [3] SECURITY SECONDARY PASSWORD 5 */
#define ADJPSWD6 ((volatile uint16_t*)0x0100053AUL) /* [3] SECURITY SECONDARY PASSWORD 6 */
#define adjustable_parameter_table_size_for_cc_rs_gain_droops_0x0000_0xffff (*(volatile uint16_t*)0x01000542UL) /* ADJUSTABLE PARAMETER TABLE SIZE FOR CC/RS GAIN ... */
#define bottom_droop_width_for_cruise_control_0_10 (*(volatile uint16_t*)0x01000544UL) /* BOTTOM DROOP WIDTH FOR CRUISE CONTROL. [CalTerm... */
#define top_droop_width_for_cruise_control_0_10 (*(volatile uint16_t*)0x01000546UL) /* TOP DROOP WIDTH FOR CRUISE CONTROL. */
#define bottom_droop_width_for_rsg_0_10 (*(volatile uint16_t*)0x01000548UL) /* BOTTOM DROOP WIDTH FOR RSG. */
#define top_droop_width_for_rsg_0_10 (*(volatile uint16_t*)0x0100054AUL) /* TOP DROOP WIDTH FOR RSG. */
#define size_of_cc_engine_brake_adjustable_parameters_n_a (*(volatile uint16_t*)0x0100054EUL) /* SIZE OF CC_ENGINE_BRAKE ADJUSTABLE PARAMETERS */
#define the_point_on_the_speed_axis_where_e_brake_will_be_at_100_bra_1_5_25 (*(volatile uint16_t*)0x01000550UL) /* THE POINT ON THE SPEED AXIS WHERE E-BRAKE WILL ... */
#define the_point_on_the_speed_axis_where_e_brake_will_start_braking_1_5_25 (*(volatile uint16_t*)0x01000552UL) /* THE POINT ON THE SPEED AXIS WHERE E-BRAKE WILL ... */
#define adjustable_parameter_table_size_for_cc_rs_governor_0x0000_0xffff (*(volatile uint16_t*)0x01000554UL) /* ADJUSTABLE PARAMETER TABLE SIZE FOR CC/RS GOVERNOR */
#define CRERESGN (*(volatile uint16_t*)0x01000556UL) /* CalTerm CRERESGN: GAIN USED BY CC/RSG TO ADJUST... */
#define CRADSZ (*(volatile uint16_t*)0x01000558UL) /* SIZE OF CC RSG ROAD SPEED ADJUSTABLE PARAMETERS */
#define CRDPAJRF (*(volatile uint16_t*)0x0100055CUL) /* CalTerm CRDPAJRF: 1=ROAD_SPEED, 0=PREDICTED_VEH... */
#define DRCRRZOP (*(volatile uint16_t*)0x01000560UL) /* CalTerm DRCRRZOP: DRIVER REWARD CC/RS: 0=RSG, 1... */
#define driver_esp_delta_reward_4_20_20 (*(volatile uint16_t*)0x01000568UL) /* DRIVER ESP_DELTA REWARD 4 */
#define maximum_mpg_while_still_getting_drezdc01_and_drrzdc01_0_50 (*(volatile uint16_t*)0x0100056AUL) /* MAXIMUM MPG WHILE STILL GETTING DREZDC01 AND DR... */
#define maximum_mpg_while_still_getting_drezdc02_and_drrzdc02_0_50 (*(volatile uint16_t*)0x0100056CUL) /* MAXIMUM MPG WHILE STILL GETTING DREZDC02 AND DR... */
#define maximum_mpg_while_still_getting_drezdc03_and_drrzdc03_0_50 (*(volatile uint16_t*)0x0100056EUL) /* MAXIMUM MPG WHILE STILL GETTING DREZDC03 AND DR... */
#define driver_rsg_shift_reward_4_20_20 (*(volatile uint16_t*)0x01000576UL) /* DRIVER RSG SHIFT REWARD 4 */
#define maximum_time_at_0mph_while_still_getting_drezdc01_and_drrzdc0_0_100 (*(volatile uint16_t*)0x01000578UL) /* MAXIMUM %TIME AT 0MPH WHILE STILL GETTING DREZD... */
#define maximum_time_at_0mph_while_still_getting_drezdc02_and_drrzdc0_0_100 (*(volatile uint16_t*)0x0100057AUL) /* MAXIMUM %TIME AT 0MPH WHILE STILL GETTING DREZD... */
#define maximum_time_at_0mph_while_still_getting_drezdc03_and_drrzdc0_0_100 (*(volatile uint16_t*)0x0100057CUL) /* MAXIMUM %TIME AT 0MPH WHILE STILL GETTING DREZD... */
#define number_of_bytes_worth_of_engineering_trims_none (*(volatile uint16_t*)0x0100057EUL) /* NUMBER OF BYTES WORTH OF ENGINEERING TRIMS */
#define boundary_above_which_abuse_condition_exists_at_severity_level_0_22_5_580 (*(volatile uint16_t*)0x01000580UL) /* BOUNDARY ABOVE WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_above_which_abuse_condition_exists_at_severity_level_0_22_5_582 (*(volatile uint16_t*)0x01000582UL) /* BOUNDARY ABOVE WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_above_which_abuse_condition_exists_at_severity_level_0_22_5_584 (*(volatile uint16_t*)0x01000584UL) /* BOUNDARY ABOVE WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_below_which_abuse_condition_exists_at_severity_level_1_0_50 (*(volatile uint16_t*)0x01000586UL) /* BOUNDARY BELOW WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_below_which_abuse_condition_exists_at_severity_level_2_0_50 (*(volatile uint16_t*)0x01000588UL) /* BOUNDARY BELOW WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_below_which_abuse_condition_exists_at_severity_level_3_0_50 (*(volatile uint16_t*)0x0100058AUL) /* BOUNDARY BELOW WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_above_which_abuse_condition_exists_at_severity_level_1_0_4500 (*(volatile uint16_t*)0x01000592UL) /* BOUNDARY ABOVE WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_above_which_abuse_condition_exists_at_severity_level_0_4500 (*(volatile uint16_t*)0x01000594UL) /* BOUNDARY ABOVE WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_above_which_abuse_condition_exists_at_severity_level_3_0_4500 (*(volatile uint16_t*)0x01000596UL) /* BOUNDARY ABOVE WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_below_which_abuse_condition_exists_at_severity_level_0_100_59e (*(volatile uint16_t*)0x0100059EUL) /* BOUNDARY BELOW WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_below_which_abuse_condition_exists_at_severity_level_0_100_5a0 (*(volatile uint16_t*)0x010005A0UL) /* BOUNDARY BELOW WHICH ABUSE CONDITION EXISTS AT ... */
#define boundary_below_which_abuse_condition_exists_at_severity_level_0_100_5a2 (*(volatile uint16_t*)0x010005A2UL) /* BOUNDARY BELOW WHICH ABUSE CONDITION EXISTS AT ... */
#define max_brake_level_step_size_permitted_for_the_current_execution_cy_0_100 (*(volatile uint16_t*)0x010005B2UL) /* MAX BRAKE LEVEL STEP SIZE PERMITTED FOR THE CUR... */
#define fan_clutch_1_fan_drive_ratio_0_20_5bc (*(volatile uint16_t*)0x010005BCUL) /* FAN_CLUTCH_1_FAN_DRIVE_RATIO */
#define fan_clutch_1_max_fan_speed_0_4500 (*(volatile uint16_t*)0x010005BEUL) /* FAN_CLUTCH_1_MAX_FAN_SPEED */
#define fan_clutch_1_fan_drive_ratio_0_20_5c2 (*(volatile uint16_t*)0x010005C2UL) /* FAN_CLUTCH_1_FAN_DRIVE_RATIO */
#define fan_clutch_2_max_fan_speed_0_4500 (*(volatile uint16_t*)0x010005C4UL) /* FAN_CLUTCH_2_MAX_FAN_SPEED */
#define signal_1_configuration_for_3_speed_fan_1_0_100_5ca (*(volatile uint16_t*)0x010005CAUL) /* SIGNAL 1 CONFIGURATION FOR 3 SPEED FAN #1 */
#define signal_1_configuration_for_3_speed_fan_1_0_100_5cc (*(volatile uint16_t*)0x010005CCUL) /* SIGNAL 1 CONFIGURATION FOR 3 SPEED FAN #1 */
#define signal_1_configuration_for_3_speed_fan_1_0_100_5ce (*(volatile uint16_t*)0x010005CEUL) /* SIGNAL 1 CONFIGURATION FOR 3 SPEED FAN #1 */
#define signal_2_configuration_for_3_speed_fan_1_0_100_5d0 (*(volatile uint16_t*)0x010005D0UL) /* SIGNAL 2 CONFIGURATION FOR 3 SPEED FAN #1 */
#define signal_2_configuration_for_3_speed_fan_1_0_100_5d2 (*(volatile uint16_t*)0x010005D2UL) /* SIGNAL 2 CONFIGURATION FOR 3 SPEED FAN #1 */
#define signal_2_configuration_for_3_speed_fan_1_0_100_5d4 (*(volatile uint16_t*)0x010005D4UL) /* SIGNAL 2 CONFIGURATION FOR 3 SPEED FAN #1 */
#define signal_1_configuration_for_3_speed_fan_2_0_100_5d6 (*(volatile uint16_t*)0x010005D6UL) /* SIGNAL 1 CONFIGURATION FOR 3 SPEED FAN #2 */
#define signal_1_configuration_for_3_speed_fan_2_0_100_5d8 (*(volatile uint16_t*)0x010005D8UL) /* SIGNAL 1 CONFIGURATION FOR 3 SPEED FAN #2 */
#define signal_1_configuration_for_3_speed_fan_2_0_100_5da (*(volatile uint16_t*)0x010005DAUL) /* SIGNAL 1 CONFIGURATION FOR 3 SPEED FAN #2 */
#define signal_2_configuration_for_3_speed_fan_2_0_100_5dc (*(volatile uint16_t*)0x010005DCUL) /* SIGNAL 2 CONFIGURATION FOR 3 SPEED FAN #2 */
#define signal_2_configuration_for_3_speed_fan_2_0_100_5de (*(volatile uint16_t*)0x010005DEUL) /* SIGNAL 2 CONFIGURATION FOR 3 SPEED FAN #2 */
#define signal_2_configuration_for_3_speed_fan_2_0_100_5e0 (*(volatile uint16_t*)0x010005E0UL) /* SIGNAL 2 CONFIGURATION FOR 3 SPEED FAN #2 */
#define power_train_protection_blank_spot_0_1 (*(volatile uint16_t*)0x010005F2UL) /* POWER TRAIN PROTECTION BLANK SPOT */
#define torque_limit_due_to_driveline_axel_0_310000 (*(volatile uint16_t*)0x010005F6UL) /* TORQUE LIMIT DUE TO DRIVELINE AXEL */
#define torque_limit_due_to_driveline_switch_0_10000 (*(volatile uint16_t*)0x010005F8UL) /* TORQUE LIMIT DUE TO DRIVELINE SWITCH */
#define TCTQLMTB (*(volatile uint16_t*)0x01000604UL) /* CalTerm TCTQLMTB: FOUR TORQUE LIMITS ASSOCIATED... */
#define tool_entered_max_vehicle_speed_at_high_load_in_gear_down_0_255_9961 (*(volatile uint16_t*)0x0100062EUL) /* TOOL ENTERED MAX VEHICLE SPEED AT HIGH LOAD IN ... */
#define tool_entered_max_veh_speed_at_light_load_in_gear_down_0_255_9961 (*(volatile uint16_t*)0x01000630UL) /* TOOL ENTERED MAX VEH SPEED AT LIGHT LOAD IN GEA... */
#define mph_from_gd_light_load_limit_to_next_gear_down_high_load_0_255_9961 (*(volatile uint16_t*)0x01000632UL) /* MPH FROM GD LIGHT LOAD LIMIT TO NEXT GEAR DOWN ... */
#define mph_from_gd_light_load_limit_to_next_gear_down_light_load_0_255_9961 (*(volatile uint16_t*)0x01000634UL) /* MPH FROM GD LIGHT LOAD LIMIT TO NEXT GEAR DOWN ... */
#define the_tools_previous_engine_distance_adjustment_for_offset_of_0_30500000 (*(volatile uint32_t*)0x0100063AUL) /* THE TOOLS PREVIOUS ENGINE DISTANCE ADJUSTMENT F... */
#define indicates_type_of_transmission_1_0 (*(volatile uint16_t*)0x0100063EUL) /* INDICATES TYPE OF TRANSMISSION */
#define percent_fuel_above_which_the_engine_will_be_derated_by_the_z_0_127_5 (*(volatile uint16_t*)0x01000646UL) /* PERCENT FUEL ABOVE WHICH THE ENGINE WILL BE DER... */
#define maximum_allowable_engine_speed_when_vehicle_speed_is_below_1400_4500 (*(volatile uint16_t*)0x01000648UL) /* MAXIMUM ALLOWABLE ENGINE SPEED WHEN VEHICLE SPE... */
#define JC22LMCU (*(volatile uint16_t*)0x01000660UL) /* CalTerm JC22LMCU: J1922 LIMIT ENGINE MODE COUNT... */
#define j1922_limit_engine_occ_time_ecm_time_of_last_j1922_limit_com_0_2_29 (*(volatile uint32_t*)0x01000662UL) /* J1922 LIMIT ENGINE OCC. TIME ECM TIME OF LAST J... */
#define JC22RPCU (*(volatile uint16_t*)0x01000666UL) /* CalTerm JC22RPCU: J1922 SPEED CONTROL MODE COUN... */
#define j1922_speed_control_occ_time_ecm_time_of_last_j1922_control_0_2_29 (*(volatile uint32_t*)0x01000668UL) /* J1922 SPEED CONTROL OCC. TIME ECM TIME OF LAST ... */
#define JC22TQCU (*(volatile uint16_t*)0x0100066CUL) /* CalTerm JC22TQCU: J1922 TORQUE CONTROL MODE COU... */
#define j1922_monitor_occurrence_time_ecm_time_of_last_j1922_control_0_2_29 (*(volatile uint32_t*)0x0100066EUL) /* J1922 MONITOR OCCURRENCE TIME ECM TIME OF LAST ... */
#define j1939_engine_control_status_0_inactive_0_1 (*(volatile uint16_t*)0x01000720UL) /* J1939 ENGINE CONTROL STATUS 0 = INACTIVE */
#define j1939_retarder_control_status_0_inactive_0_1 (*(volatile uint16_t*)0x01000722UL) /* J1939 RETARDER CONTROL STATUS 0 = INACTIVE */
#define source_0_none_1_trans_2_abs_3_asr_4_unknown_0_3_724 (*(volatile uint16_t*)0x01000724UL) /* 0 = NONE 1 = TRANS 2 = ABS 3 = ASR 4 = UNKNOWN */
#define source_0_none_1_trans_2_abs_3_asr_4_unknown_0_3_726 (*(volatile uint16_t*)0x01000726UL) /* 0 = NONE 1 = TRANS 2 = ABS 3 = ASR 4 = UNKNOWN */
#define pointer_into_j1939_history_table_0_65535 (*(volatile uint16_t*)0x01000728UL) /* POINTER INTO J1939_HISTORY_TABLE */
#define timer_to_track_time_elapsed_before_manual_fan_level_is_receiv_0_10 (*(volatile uint16_t*)0x0100072AUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE MANUAL FAN ... */
#define timer_to_track_time_elapsed_before_remote_throttle_switch_is_0_10 (*(volatile uint16_t*)0x0100072CUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE REMOTE THRO... */
#define timer_to_track_time_elapsed_before_auxiliary_shutdown_switch_0_10 (*(volatile uint16_t*)0x0100072EUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE AUXILIARY S... */
#define timer_to_track_time_elapsed_before_torque_derate_switch_is_re_0_10 (*(volatile uint16_t*)0x01000730UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE TORQUE DERA... */
#define timer_to_track_time_elapsed_before_throttle_interlock_switch_0_10 (*(volatile uint16_t*)0x01000732UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE THROTTLE IN... */
#define timer_to_track_time_elapsed_before_eb_switch_level_is_received_0_10 (*(volatile uint16_t*)0x01000734UL) /* TIMER TO TRACK TIME ELAPSED BEFORE EB SWITCH LE... */
#define timer_to_track_time_elapsed_before_idle_switch_is_received_ag_0_10 (*(volatile uint16_t*)0x01000736UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE IDLE SWITCH... */
#define timer_to_track_time_elapsed_before_commanded_throttle_is_rece_0_10 (*(volatile uint16_t*)0x01000738UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE COMMANDED T... */
#define timer_to_track_time_elapsed_before_remote_throttle_is_receive_0_10 (*(volatile uint16_t*)0x0100073AUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE REMOTE THRO... */
#define timer_to_track_time_elapsed_before_wet_tank_pressure_is_recei_0_10 (*(volatile uint16_t*)0x0100073CUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE WET TANK PR... */
#define timer_to_track_time_elapsed_before_ac_pressure_switch_is_rece_0_10 (*(volatile uint16_t*)0x0100073EUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE AC PRESSURE... */
#define timer_to_track_time_elapsed_before_remote_pto_switch_is_recei_0_10 (*(volatile uint16_t*)0x01000740UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE REMOTE PTO ... */
#define timer_to_track_time_elapsed_before_pto_on_switch_is_received_0_10 (*(volatile uint16_t*)0x01000742UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE PTO ON SWIT... */
#define timer_to_track_time_elapsed_before_pto_resume_switch_is_recei_0_10 (*(volatile uint16_t*)0x01000744UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE PTO RESUME ... */
#define timer_to_track_time_elapsed_before_pto_set_switch_is_received_0_10 (*(volatile uint16_t*)0x01000746UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE PTO SET SWI... */
#define timer_to_track_time_elapsed_before_clutch_switch_is_received_0_10 (*(volatile uint16_t*)0x01000748UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE CLUTCH SWIT... */
#define timer_to_track_time_elapsed_before_brake_switch_is_received_a_0_10 (*(volatile uint16_t*)0x0100074AUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE BRAKE SWITC... */
#define timer_to_track_time_elapsed_before_cruise_on_switch_is_receiv_0_10 (*(volatile uint16_t*)0x0100074CUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE CRUISE ON S... */
#define timer_to_track_time_elapsed_before_cruise_resume_switch_is_re_0_10 (*(volatile uint16_t*)0x0100074EUL) /* TIMER TO TRACK TIME  ELAPSED BEFORE CRUISE RESU... */
#define timer_to_track_time_elapsed_before_cruise_set_switch_is_recei_0_10 (*(volatile uint16_t*)0x01000750UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE CRUISE SET ... */
#define timer_to_track_time_elapsed_before_increment_switch_is_receiv_0_10 (*(volatile uint16_t*)0x01000752UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE INCREMENT S... */
#define timer_to_track_time_elapsed_before_decrement_switch_is_receiv_0_10 (*(volatile uint16_t*)0x01000754UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE DECREMENT S... */
#define timer_to_track_time_elapsed_before_test_switch_is_received_ag_0_10 (*(volatile uint16_t*)0x01000756UL) /* TIMER TO TRACK TIME  ELAPSED BEFORE TEST SWITCH... */
#define unused_dummy_j1939_switch_timer_created_to_cover_gc2_error_0_255 (*(volatile uint16_t*)0x01000758UL) /* UNUSED DUMMY J1939 SWITCH TIMER CREATED TO COVE... */
#define J39PDBLK (*(volatile uint16_t*)0x0100075AUL) /* CalTerm J39PDBLK: FLAG TO ACKNOWLEDGE PRESUNUSE... */
#define current_number_of_j1708_j1922_time_outs_since_powerdown_or_0_1000 (*(volatile uint16_t*)0x0100075CUL) /* CURRENT NUMBER OF J1708 (J1922) TIME-OUTS SINCE... */
#define current_number_of_j1939_time_outs_since_powerdown_or_fault_se_0_1000 (*(volatile uint16_t*)0x0100075EUL) /* CURRENT NUMBER OF J1939 TIME-OUTS SINCE POWERDO... */
#define trending_feature_time_stamp_written_to_nvm_when_engine_rebuild_0_2_29 (*(volatile uint32_t*)0x01000EE2UL) /* TRENDING FEATURE TIME STAMP WRITTEN TO NVM WHEN... */
#define limit_for_interval_window_counter_set_to_10_of_trending_interv_0_79 (*(volatile uint16_t*)0x01000EECUL) /* LIMIT FOR INTERVAL WINDOW COUNTER SET TO 10% OF... */
#define elapsed_time_during_trending_interval_window_0_79 (*(volatile uint16_t*)0x01000EEEUL) /* ELAPSED TIME DURING TRENDING INTERVAL WINDOW */
#define counter_incremented_each_time_a_trending_data_set_is_written_t_0_100 (*(volatile uint16_t*)0x01000EF0UL) /* COUNTER INCREMENTED EACH TIME A TRENDING DATA S... */
#define number_of_samples_taken_by_trending_feature_before_rebuild_flag_0_100 (*(volatile uint16_t*)0x01000EF4UL) /* NUMBER OF SAMPLES TAKEN BY TRENDING FEATURE BEF... */
#define timer_that_increments_when_trending_trigger_conditions_are_me_0_3600 (*(volatile uint16_t*)0x01000EF6UL) /* TIMER THAT INCREMENTS WHEN TRENDING TRIGGER CON... */
#define flag_set_when_trending_trigger_conditions_have_been_true_fo_true_false (*(volatile uint16_t*)0x01000EF8UL) /* FLAG SET WHEN TRENDING TRIGGER CONDITIONS HAVE ... */
#define flag_set_when_time_conditions_are_satisfied_for_trendi_active_inactive (*(volatile uint16_t*)0x01000EFAUL) /* FLAG SET WHEN TIME CONDITIONS ARE SATISFIED FOR... */
#define flag_set_to_equal_the_status_of_n_1_trending_interval_wind_true_false (*(volatile uint16_t*)0x01000EFCUL) /* FLAG SET TO EQUAL THE STATUS OF (N-1)TRENDING_I... */
#define trending_interval_s_average_load_factor_since_last_write_to_nv_0_100 (*(volatile uint16_t*)0x01000F06UL) /* TRENDING INTERVAL'S AVERAGE LOAD FACTOR SINCE L... */
#define holds_max_value_of_torque_curve_in_use_when_trending_data_is_w_0_100 (*(volatile uint16_t*)0x01000F08UL) /* HOLDS MAX VALUE OF TORQUE CURVE IN USE WHEN TRE... */
#define average_fuel_consumption_during_a_trending_interval_2_310 (*(volatile uint16_t*)0x01000F0AUL) /* AVERAGE FUEL CONSUMPTION DURING A TRENDING INTE... */
#define snapshot_of_total_fuel_usage_used_in_trending_feature_0_10000000 (*(volatile uint32_t*)0x01000F0CUL) /* SNAPSHOT OF TOTAL_FUEL_USAGE USED IN TRENDING F... */

/* ============================================================ */
/* Function Forward Declarations                                */
/* ============================================================ */

void rpm_rate_limiter(void);
ushort rpm_system_state_controller(void);
void shutdownMinimumSelector17(void);
ushort highRpmFuelControlLimiter(void);
void fuelLimitMinimumSelector(void);
ushort lowRpmFuelProtectionLimiter(void);
void dmaControllerSetup1(void);
void dmaDescriptorSetup1(void);
void dmaDescriptorSetup2(void);
void initFuelSystemOutputDriver(void);
undefined1 messageTypeToChannelMapper(undefined4 param_1);
void diagnosticMessageQueueWrite(undefined4 param_1);
void sensorFaultDebounceMonitor(void);
void initADCChannelConfiguration(void);
ushort diagnostic_fuel_calculation_with_vp44_monitoring(void);
void timingParameterPointerSetup(void);
void shutdownMinimumSelector16(void);
void diagnosticTimingIncrementController(void);
void fuelAdjustmentWithFlagUpdate(void);
undefined4 vp44TimingConditionChecker(void);
ushort fuelTimingModeArbitrationSlowCycle40Coordinator(void);
undefined2 fuelTableBlendResultHandler(void);
uint fuelSourceOilPressureConditionChecker(void);
int fuelSourceMode11CountdownHandler(void);
int fuelModeTransitionCountdownHandler(void);
uint timingProtectionFlagsOrchestrator(void);
ulonglong shutdownProtectionCalculator(void);
void fuelParameterPointerSetup(void);
void shutdownMinimumSelector15(void);
void rpmParameterPointerSetup(void);
void targetRpmRateLimiter(void);
void engine_speed_governor(void);
void diagnosticDataCopyHandler(void);
void diagnosticStatus30Setter(void);
void diagnosticStatus2Initializer(undefined4 param_1);
void diagnosticState2Initializer(void);
void derate_application_controller(void);
void initDerateSystemPointers(void);
void diagnosticValueCalculator(void);
void diagnosticStatus7Initializer(undefined4 param_1);
void diagnosticState7Setter(void);
void diagnosticTablePointerSetup(void);
void tpuTimerInitializer(void);
void emptyStubFunction1(void);
void modeBasedDataDispatcher(undefined4 param_1);
void emptyStubFunction3(void);
void emptyStubFunction2(void);
void boostPressureControlInit(void);
void engineProtectionSystemInit(void);
void initBoostProtectionSystem(void);
void periodicIoAndCanFaultMonitor(void);
uint acceleratorThrottleFaultDetector(void);
void insiteParameterTableIterator(void);
uint diagnosticMessageTransmissionManager(void);
void insiteParameterResponseBuilder(void);
uint diagnosticCodeTableSearch(undefined4 param_1);
void insiteCommandByteDispatcher(void);
void paramSystemModeController(void);
void param_lookup_1(void);
void param_lookup_2(void);
void diagnosticDataBufferSetup(void);
void param_lookup_3(void);
short fuelTableBlendInterpolation(undefined4 param_1);
void fuelParameterBlendCalculator(void);
ushort param_interpolate(undefined4 param_1);
void fuelOffsetCalculator(uint param_1,undefined4 param_2);
void fuelModeSelectionCalculator(void);
void fuelBlendTablePointerSetup(void);
void ioControlBasedFuelCalculator(void);
void throttleTablePointerSetup(void);
uint bufferDecreasingPatternCheck(void);
uint bufferThresholdValidator(void);
undefined2 throttlePositionValidator(undefined4 param_1);
void canBusTimingInit(void);
void sendCanSingleFrame(void); /* decompile failed */
void sendCanMessage(j1939_header_t *msg_header);
void sendJ1939MultiFrameWrapper(void);
short arrayRangeSum(short *param_1,short *param_2);
void memoryPatchCountDecrement(void);
uint rpm_derate_calculation_and_fault_processing(void);
ulonglong derateThresholdMonitorAndFaultController(void);
ushort initDerateSystem(void);
void diagnosticMemoryAddressResolver(void); /* decompile failed */
void kickdownSignalSlowCycle40Coordinator(void);
void timingAccumulatorUpdate(void);
void initAcControlSystem(void);
undefined4 calibrationDataCopyWithChecksum(void);
undefined4 calibrationDataCopySecondary(void);
int eepromCalibrationWritePrimary(void);
int eepromCalibrationWriteSecondary(void);
void validateRedundantSensors(void);
void firmwareDataCopyToWorkingMemory(void);
uint pwmFuelDemandOutputCalculator(void);
undefined1 enableFaultFlagScanner(void);
uint waterInFuelDetectionStateInit(void);
undefined1 waterInFuelFaultClear(void);
undefined1 waterInFuelFaultValidation(void);
undefined1 activateHighRpmShutdownFlag(void);
void eepromWriteWrapper(byte *param_1);
void triggerDiagnosticSystemReset(void);
undefined4 systemResetWithDiagnostic(byte *param_1,undefined4 param_2);
undefined1 requestSecuredShutdown(void);
undefined4 canMessageBufferLogger(void);
void systemFunction8xMaximum(void);
undefined4 crc16Calculate(byte *param_1,undefined4 param_2);
undefined4 memoryPatchCrcCalculate(void);
ushort coldStartFuelControlSlowCycle40Coordinator(void);
void timingAccumulatorClampedUpdate(void);
void initAncSpeedLimitAndAltitudeDerate(void);
void circularBufferWriteWithStatus(void);
uint vp44_communication_state_machine(undefined4 param_1);
void initVp44BufferAddresses(void);
uint engineRunTimeHistogramAccumulator(void);
void initHourMeterConversionData(void);
void writeHourMeterConversionData(void);
undefined4 canBusConfigTypeSelector(undefined4 param_1);
void speedDifferenceInterpolator(undefined4 param_1);
void speedBasedParameterLookup(void);
void multiSpeedParameterInterpolation(void);
void fuelDemandPercentageCalculator(void);
void initIntakeManifoldTemperatureLimits(void);
void diagnosticCodeDebounceHandler(undefined4 param_1);
void phase2_sensor_data_processor(void);
void diagnosticQueueIterator(void);
short oldestDiagnosticTimestampSearch(undefined4 param_1);
void diagnosticCodeRegistrar(undefined4 param_1);
void diagnosticCodeClearHandler(void);
void diagnosticCodeMaskedClear(void);
void diagnosticStateMachineProcessor(void);
void faultFlagScannerAndProcessor(void);
void insitePidDtcHandler(undefined4 param_1);
void initHourMeterSystem(void);
ushort vp44_status_data_collector(void);
void ioControlAndCanPinSwitching(void);
void initVP44StatusMonitoring(void);
void initCANBus(void);
void emptyStubFunction4(void);
void diagnosticCommandDispatcher(void);
int safeDivideWithClamp(uint param_1,int param_2);
uint clampedDivisionCalculator(uint param_1,uint param_2,int param_3);
uint param_address_calc(uint param_1,undefined4 param_2);
uint limitedDivisionCalculator(uint param_1,uint param_2,undefined4 param_3);
void multiPacketTransmitHandler(void);
void multiPacketReceiveHandler(void);
uint circularBufferEmptyCheck(void);
uint parameterCircularBufferWrite(int param_1,undefined1 *param_2,undefined4 param_3);
void circularBufferWrite(void); /* decompile failed */
void emptyPlaceholderFunction(void);
void tpuTransmissionTrigger(void);
uint engine_fault_monitoring_and_rpm_calculation(void);
void engineRpmSourceInit(void);
void canControllerConfigInit(void);
void canRpmModeConfigInit(void);
void rpmBasedFuelLimitCalculator(void);
void fuelTimingModeBlendCalculator(void);
void rpmBasedFuelTimingInterpolation(void);
uint frictionalLoadInterpolationCalculator(void);
void rpmSourceSelectorForFrictionalLoad(void);
uint frictionalLoadTorqueInterpolator(void);
void peakTorqueFuelCorrection(void);
void engineModeTransitionStateUpdater(void);
void engineModeTransitionHandler(void);
void shutdownProtectionSlowCycle40Coordinator(void);
void frictionalLoadTorqueManagementSlowCycle40Coordinator(void);
void engineOperatingModeStateTrackingSlowCycle40Coordinator(void);
void frictionalLoadTorqueTransitionHandler(void);
void initLoadTrendingSystem(void);
void engineOperatingModeStateMachine(void);
void engineOperatingModeInit(void);
ushort engineProtectionMultiStateSlowCycle40Coordinator(void);
(int param_1,int param_2,ushort *param_3,undefined4 param_4);
undefined4 protectionPercentageCalculator(undefined4 param_1,undefined4 param_2);
void engineProtectionSystemInit(void);
uint protectionConditionEvaluator(ushort *param_1,undefined4 *param_2,undefined4 param_3);
void protectionState0FaultDurationCounter(void);
uint diagnosticProtectionEvaluator(void);
uint diagnosticProtectionProcessor(ushort *param_1,undefined4 *param_2,int param_3);
ushort protectionState1DiagnosticValidator(void);
void protectionUpdateHandler(void); /* decompile failed */
void protectionState3aPrimaryCoordinator(void);
void protectionThresholdPointerInit(void);
void protectionStateUpdater(int param_1,int param_2,undefined4 param_3);
ushort protectionState4EmergencyHandler(void);
uint protectionCalculationHelper(undefined4 param_1,uint param_2);
uint protectionStateProcessor(undefined4 param_1);
undefined8 protectionStateValidator(undefined4 param_1);
void protectionState3bRpmMonitor(void);
void shutdownMinimumSelector29(void);
void protectionState2ThresholdCalculator(void);
void initShutdownLimitVariables(void);
void can1TimerBufferInit(void);
void delayWithWatchdogServiceWrapper(void);
void emptyStubFunction5(void);
undefined8 rpmTimerInterruptHandler(void);
void can1TimerBufferInitAlt(void);
void can1MessageTransmitInit(void);
void emptyStubFunction6(void);
undefined8 rpmTimerInterruptHandlerAlt(void);
void rpmTimingDeltaComparator(void);
uint rpmTimingDeltaComparatorWithReturn(void);
void can1TimerBufferInitDivided(void);
void can1MessageTransmitInit2(void);
void emptyStubFunction7(void);
undefined8 rpmTimerInterruptHandler2(void);
uint can1TimerBufferInitConditional(void);
void delayWithWatchdogServiceWrapper2(void);
void emptyStubFunction8(void);
undefined8 rpmTimerInterruptHandler3(void);
int throttleTimeAccumulatorProcessor(int param_1,undefined4 param_2);
ushort fuelTimingOilPressureModeController(void);
void initOilPressureModeSystem(void);
ushort oilPressureModeParameterPointerConfig(void);
void dutyCycleMonitorCanInit(void);
undefined8 dutyCycleMonitorIsrHandler(void);
uint dutyCycleMonitorAltCanInit(void);
undefined8 dutyCycleMonitorAltIsrHandler(void);
void dutyCycleMonitorBufferInit(void);
void phase2_slot_0_handler(void);
void phase2_slot_1_handler(void);
void phase2_slot_5_handler(void);
undefined8 timerAccumulatorWithWatchdog(void);
undefined8 phase2_slot_7_handler(void);
undefined8 phase2_slot_8_handler(void);
void ioControlAndCanPinSwitchingWrapper(void);
void evenPhaseSchedulerTaskSet(void);
void oddPhaseSchedulerTaskSet(void);
void vp44_engine_management_system(void);
void engine_control_cycle(void);
void engineDiagnosticSystemCoordinator(void);
void slowCycle4Coordinator(void);
void empty_debug_hook(void);
void engineParameterAndBoostControlWrapper(void);
void auxiliarySystemControlWrapper(void);
void slowCycle8Coordinator(void);
void boostPressureControlCoordinator(void);
void boost_pressure_control_wrapper(void);
void emptySlowCycle8Placeholder(void);
void emptySlowCycle8PlaceholderCase7(void);
void rpm_control_system(void);
void rpmBasedFuelLimiterCoordinator(void);
void secondaryMonitoringWrapper(void);
void slowCycle10Coordinator(void);
void diagnosticMonitoringCoordinator(void);
void epsSignalMonitoringCoordinator(void);
void ioControlSlowCycle10Coordinator(void);
ulonglong shutdownProtectionSlowCycle10Coordinator(void);
void diagnosticCommunicationSlowCycle10Coordinator(void);
void diagnosticDataTransmissionSlowCycle10Coordinator(void);
void vp44ControlSystemCoordinator(void);
void vp44ExtendedFaultDetectionCoordinator(void);
void advancedEngineProtectionCoordinator(void);
void slowCycle20Coordinator(void);
void fuelTimingCoordinator(void);
void slowCycle20ExtendedCoordinator(void);
void fuelCalculationSlowCycle20Coordinator(void);
void sensorStatusHistorySlowCycle20Coordinator(void);
void fuelSmokeLimiterSlowCycle20Coordinator(void);
void camSyncDiagnosticProcessingSlowCycle20Coordinator(void);
ulonglong derateProtectionSlowCycle20Coordinator(void);
void vp44ProtectionSlowCycle20Coordinator(void);
void vp44FsoFaultDetectionSlowCycle20Coordinator(void);
void vp44DiagnosticFaultMonitoringSlowCycle20Coordinator(void);
void vp44FsoFaultMonitoringSlowCycle20Coordinator(void);
void emptySlowCycle20PlaceholderCase15(void);
void dzgTimingAndPressureSlowCycle10Coordinator(void);
void engineModeBasedOutputControlSlowCycle20Coordinator(void);
void vp44DiagnosticControlSlowCycle20Coordinator(void);
void diagnosticStatisticsSlowCycle20Coordinator(void);
undefined8 main_loop(void);
void scheduler_init(void);
void mainLoopTaskSchedulerInit(void);
void schedulerPerformanceMonitor(void);
void schedulerWaitLoop(void);
uint circularBufferPush(uint *param_1,undefined4 param_2);
uint circularBufferPop(uint *param_1,undefined1 *param_2);
void circularBufferInit(undefined4 *param_1,undefined4 param_2,uint param_3);
ushort fuelDemandModeSelector(void);
undefined4 flashEraseWithWatchdog(void);
void flashEraseFromRam(dword param_1);
undefined4 flashProgramWordWithWatchdog(void);
void flashProgramFromRam(int param_1,dword param_2,uint param_3);
void diagnosticStatusDefaultSetter(void);
void diagnostic_parameter_handler(void);
void fuelDemandTableBlendCalculator(void);
void initFuelDemandCalculationSystem(void);
void fuelDemandProportionalCalculationSlowCycle40Coordinator(void);
void emptySlowCycle20PlaceholderCase16(void);
void emptyInit2(void);
ushort canPinVp44StatusController(void);
void fuel_timing_calculation_with_fault_checking(void);
void fuelLimitParameterPointerSetup(void);
void shutdownMinimumSelector19(void);
void fuel_delivery_controller(void);
void fuelRpmDeviationCalculator(void);
void fuelDeliverySystemInit(void);
void fuel_limit_arbitrator(void);
void fuelArbitratorInit(void);
void derateChangeDetector(void);
ushort highRpmEngineProtectionStateMachine(void);
void initFuelArbitratorThreshold3(void);
void vp44ControlStructureInit(void);
void diagnosticBufferPointerInit(void);
void initFuelArbitratorThreshold5(void);
short activeParamReadFunction(void);
void fuelTimingModeInit(void);
void serialNodeAddressChecker(undefined4 param_1);
void serialNodeAddressForwarder(undefined4 param_1);
void canFrameDataCopy(void); /* decompile failed */
undefined8 serialPort1IsrHandler(void);
void canMessageInterruptHandlerSetup(void);
void emptyStubWrapper1(void);
void modeBasedDataDispatcherWrapper(undefined4 param_1);
undefined8 serialPort2IsrHandler(void);
void serialCommunicationIsrRegister(void);
void tpuTimerChannelEnable(void);
undefined8 epsPositionSensorIsrHandler(void);
void tpuChannelIsrRegister(void);
uint serialTransmitHandler(void);
void serialReceiveBufferProcessor(uint param_1);
undefined8 interruptCounter1Increment(void);
undefined8 interruptCounter2Increment(void);
void initVectorTable(void);
undefined1 bitPatternToIndexConverter(void);
uint insiteMultiFrameResponseBuilder(undefined4 param_1);
void insiteMultiFrameContinuation(void);
void insiteLiveDataHandler(void);
void responseBufferSpaceCheck(void);
void responseBufferFinalize(void);
void diagnosticMemoryWriteHandler(undefined4 param_1);
void diagnosticMemoryReadHandler(undefined4 param_1);
void diagnosticMessage45Builder(void);
void diagnosticMessage46Builder(void);
uint fuelArbitratorControlService(void);
void extendedDiagnosticService4C(void);
uint extendedDiagnosticService4F(void);
void extendedDiagnosticService51(void);
void diagnosticMessage53Builder(void);
void diagnosticMessage54Builder(void);
uint j1939TimeoutDataClearHandler(void);
uint j1939MessageTypeCounter(undefined4 param_1);
void canMessageFilterInit(void);
void timerSchedulerSetup(void); /* decompile failed */
ushort phase3_periodic_task_scheduler(void);
void emptyPlaceholderInit(void);
uint j1939TorqueControlModeParser(int param_1,undefined4 param_2);
void j1939TorqueControlModeClear(int param_1);
void j1939TorqueControlModeSet(int param_1);
void systemFunction4xParameterizedAlt(void);
void coreSystemControlFunction(void); /* decompile failed */
uint timerBasedTaskScheduler(void);
ushort phase3_retarder_condition_monitor(void);
uint memoryOperationDispatcher(int param_1,undefined1 *param_2,uint param_3);
void j1939MemoryDataCopyResolver(void); /* decompile failed */
void j1939DataCopyWrapper(int param_1);
void j1939DataCopyWrapper2Byte(int param_1);
void j1939DataCopyWrapper2ByteAlt(int param_1);
void j1939DataCopyWrapperExtended(int param_1);
void memoryOperationFromMessage(int param_1);
void memoryOperationFromMessageExtended(int param_1);
void systemFunction6xParameterized(void);
uint addressLookupFunction(undefined4 param_1);
undefined4 diagnosticServiceSecurityValidator(int param_1);
void diagnosticGroupPositionBufferStore(undefined4 param_1);
void diagnosticGroupSnapshotCapture(undefined4 param_1);
uint memoryRegisterController(void);
undefined4 byteSwap32(undefined4 *param_1);
undefined2 byteSwap16(undefined2 *param_1);
uint ioControlBitMapper(void);
undefined4 canDiagnosticResponseSender(undefined1 *param_1);
void systemFunction1xCaller(void);
undefined4 diagMemoryReadResponseBuilder(byte *param_1,undefined1 *param_2,uint param_3);
void diagMemoryReadWithOffsetBuilder(void); /* decompile failed */
void diagMemoryReadService43Handler(int param_1);
void diagMemoryReadService46Handler(int param_1);
void diagMemoryReadService48Handler(int param_1);
void diagMemoryReadService4aHandler(byte *param_1);
void diagMemoryReadService4cHandler(byte *param_1);
void systemFunction5xCaller(void);
void sendJ1939MultiFrame(uint *param_1);
void diagnosticParamRequestHandler(can_std_rx_desc_t *rx_msg);
void messageErrorHandler(undefined4 param_1);
void vp44CanFrameBuilder(undefined4 param_1);
undefined1 vp44MessageTransmitter(undefined4 param_1,undefined2 param_2);
void vp44FuelTempHandler(can_std_rx_desc_t *rx_msg);
void vp44MultiFrameResponseHandler(int param_1);
void diagnosticStatusRequestHandler(can_std_rx_desc_t *rx_msg);
void diagnosticErrorHandler(can_std_rx_desc_t *rx_msg);
void vp44CanMessageDispatcher(can_std_rx_desc_t *rx_msg);
void diagnosticParamRequestHandlerWrapper(void);
void vp44FuelTempHandlerWrapper(void);
void diagnosticStatusRequestHandlerWrapper(void);
void diagnosticErrorHandlerWrapper(void);
void unknownMessageHandler(uint param_1);
void diagnosticMessageProcessor(void);
void vp44ResponseTimeoutHandler(void);
void messageQueueDispatcher(void);
undefined4 multiPacketBufferAllocator(undefined4 param_1);
void vp44DiagnosticBufferPointersInit(void);
void fuelArbitratorResetHandler(void);
void fuelArbitratorVariablesReset(void);
uint systemStatusProcessor(void);
uint diagnosticMessageValidator(undefined4 param_1,undefined4 param_2);
uint ioControlTimeoutTableLookup(undefined4 param_1);
void ioControlEntryAdd(undefined4 param_1,undefined4 param_2);
void ioControlTimeoutEntryAdd(undefined4 param_1);
void phase3_countdown_timer_manager(void);
void diagnosticStateInitializer(undefined4 param_1);
void ioControlEntryRemove(undefined4 param_1);
uint ioControlRegisterBitMapper(void);
uint ioControlStateMachineWithDelay(void);
void ioControlPinSwitchingWrapper(void);
void initIoControlRegister(void);
void initTimerCounterDefaults(void);
void ioControlMaskStateMachine(void);
uint ioControlToggleCycle(void);
undefined1 ioControlLampStateMachine(void);
uint ioControlDigitDisplaySequencer(undefined4 param_1);
byte activeFaultCodeIteratorForward(undefined4 param_1);
byte activeFaultCodeIteratorBackward(undefined4 param_1);
uint faultCodeDisplayController(void);
void activeFaultLampStateMachine(void);
void faultLampBlinkPatternGenerator(void);
void waitToStartLampBlinkPattern(void);
void periodicLampFlashController(void);
void epsSignalQualityValidator(void);
void camSyncDiagnosticProcessor(void);
void epsDiagnosticModeChecker(undefined4 param_1);
void epsDiagnosticSnapshotCapture(void);
void epsDiagnosticVariablesInit(void);
void epsTimingCalculationSlowCycle40Coordinator(void);
void initLookupTablePointers1(void);
void governorFuelModeBlendCalculator(void);
void governorFuelPidController(void);
void governorPidFuelCalculator(void);
void intakeTemperatureTablesInit(void);
uint epsAccelerationMonitor(void);
void epsRpmTrackingInit(void);
void epsControlModeReset(void);
uint epsOverrideChecker(undefined4 param_1);
void epsControlModeSelector(void);
void epsInitializationWrapper(void);
void epsControlModeInit(void);
void epsDiagnosticModeHandler(void);
void epsCounterReset(void);
void fuelTimingOffsetCalculator(void);
ushort initVP44StatusFlags(void);
int epsRpmTargetModeChecker(void);
void engineModeTimingAdjuster(void);
void timingOffsetCalculatorWrapper(void);
void qadcDataCollectionStateMachine(void);
undefined8 tpuQadcInterruptHandler(void);
void emptyStubWrapper2(void);
void initTPU(void);
void memcpy(undefined1 *param_1,undefined1 *param_2,undefined4 param_3);
void dualTableFuelInterpolationCalculator(void);
void initRpmLookupTables(void);
void crankStateVariablesReset(void);
void crankFuelAndTimingBufferStore(void);
uint crankFuelCalculationAndProtection(void);
void initParameterScalingSystem(void);
void pwmOutputInit(void);
void fuelSmokeLimiterCalculator(void);
void insiteActiveFaultListBuilder(void);
void insiteFaultDetailBuilder(void);
void insiteEcuIdResponseBuilder(void);
void insiteCapacityResponseBuilder(void);
void insiteVersionInfoBuilder(void);
void hourMeterEventLogger(void);
void mainSystemInitialization(void);
void phase4InitSequence(void);
void dualCanControllerInit(void);
void canTransmissionScheduler(void);
void mainCanTransmissionLoop(void);
void vp44StatusInitAndWait(void);
void vp44CommunicationTestAndInit(void);
short huffmanTreeBuilder(int param_1);
void huffmanDecompress(int param_1,undefined4 param_2);
void huffmanDecompressMain(void);
void busyWaitDelayLoop(undefined4 param_1);
byte portPinTestSequence1(void);
void waitForPortPinStable(void);
byte portPinTestSequence2(void);
undefined4 tpuAndQadcVerification(void);
void hardwareInitAndStartup(void);
void ramClearWithWatchdog(void);
void flashBootloaderProgrammer(void);
void dataBufferCopy(undefined1 *param_1,undefined4 param_2);
uint diagnosticResponseBuilder(undefined4 param_1);
void main(void);
word initDiagnosticProtocol(void);
void systemControl64(void);
void systemControl74(void);
void systemControl75(void);
void memoryPatchBufferInit(void);
uint memoryPatchingSystem(void);
void advanced_oil_pressure_protection_system(void);
void fuelDemandProportionalCalculator(void);
void fuelDemandScaleFactorCalculator(void);
void oil_pressure_protection_controller(void);
void rpmSnapshotCapture(void);
void fuelDemandTablePointerInit(void);
uint oil_pressure_shutdown_controller(void);
void initOilPressureMonitoring(void);
uint initMIOS14Timers(void);
void hardwareTimerFlagsInit(void);
uint oilPressureRpmFaultMonitor(void);
uint waterInFuelDiagnosticHandler(void);
void ioOutputFlagMappingSlowCycle40Coordinator(void);
void initQADC(void);
void clearWorkingMemory(void);
void canMemoryPointerTableInit(void);
void canMessageMemorySyncController(void);
char insiteParameterParser(void);
undefined2 parameterLookupForInsite(void);
void coreSystemFunction(void); /* decompile failed */
void diagnosticServiceDispatcher(byte *param_1);
void systemControlFunction1(void);
void diagnosticResponseHandler2(int param_1);
void canTransmissionTrigger(void);
void diagnosticServiceByteHandler(int param_1);
void systemControlFunction2(void);
void fuelArbitratorMessageHandler(int param_1);
void systemControlFunction3(void);
void torqueControlModeHandler(int param_1);
void canTransmissionController(void); /* decompile failed */
void diagnosticServiceDispatcherByPgn(int param_1);
void diagnosticDataDump(void);
uint retarderModeThresholdCalculator(undefined4 param_1);
short retarderPercentageScaler(undefined4 param_1);
void retarderControlModeHandler(int param_1);
void retarderModeThresholdsSetup(void);
void torqueControlAddressDispatcher(int param_1);
void systemControlFunction4(void);
undefined1 systemSecurityCheckStub_AlwaysPasses(void);
void diagnosticTableEntryRemover(undefined4 param_1);
void diagnosticTableEntryClear(undefined4 param_1);
void diagnosticTableSnapshotCapture(undefined4 param_1);
void initSensorDataArrays(void);
undefined8 tpuChannelStateMachine(void);
void engineSpeedIsrRegister(void);
void engineRpmHardwareTimerSetup(void);
void can1ControllerInit(void);
undefined8 emptyStubFunction9(void);
void emptyInitPlaceholder(void);
undefined4 engineStatisticsAccumulator(uint *param_1,uint *param_2);
void runTimeCountersUpdate(void);
void runTimeCountersUpdateAlt(void);
byte fuelDemandFaultCounterIncrement(void);
void rpmHistogramAndAveragingStatistics(void);
ushort fuelStatisticsTracker(void);
ushort protectionFlagAccumulator(void);
void initDiagnosticSystemState(void);
void initInternalRamAndCAN1(void);
uint diagnosticSessionValidator(undefined4 param_1);
void diagnosticCanResponseSender(int param_1,undefined4 param_2);
void canBufferSetup1(void);
void ambientConditionsDataBuilder(void);
void ambientConditionsPGN_65269_Builder(void);
void ambientConditionsDataBuilder(void);
void j1939MessageSetup_PGN_65265(void);
void engineSerialNumberDataBuilder(void);
void engineSerialNumberPGN_65259_Builder(void);
byte * diagnosticMultiPacketResponseBuilder(byte *param_1,undefined4 param_2);
byte activeDtcListBuilder(void);
void engineCoolantPGN_65226_Builder(void);
byte previousDtcListBuilder(void);
void diagnosticDM2PGN_65227_Builder(void);
byte buildCanMessage(void);
void diagnosticDM4PGN_65229_Builder(void);
void diagnosticDM5DataBuilder(void);
void diagnosticDM5PGN_65230_Builder(void);
void diagnosticByteResponseSender(undefined4 param_1);
void diagnosticDM8PGN_65232_Builder(void);
void diagnosticDM11PGN_65234_Builder(void);
void buildPgn61444_ProprietarySpeed(void);
void vp44Command0x100Builder(void);
void buildProprietaryLoadStatusMessage(void);
void cumminsProprietaryDM_983_Builder(void);
void configParamCanBuilder(void);
void secondaryParamPGN_65247_Builder(void);
byte fuelParameterCanMessageBuilder(void);
void extendedDiagPGN_65251_Builder(void);
void engineFluidLevelDataBuilder(void);
void engineFluidLevelPGN_65263_Builder(void);
void engineFluidLevelDataBuilder(void);
void engineTemperaturePGN_65262_Builder(void);
void torqueControlDataBuilder(void);
void cumminsProprietaryTSC_PGN_15728640_Builder(void);
void intakeExhaustConditionsDataBuilder(void);
void intakeExhaustConditionsPGN_65257_Builder(void);
void fuelEconomyDataBuilder(void);
void fuelEconomyPGN_65266_Builder(void);
void ioControlDataBuilder(void);
void ioControlPGN_65244_Builder(void);
void engineHoursPGN_65252_Builder(void);
void intakeManifoldDataBuilder(void);
void intakeManifoldPGN_65526_Builder(void);
void cruiseControlPGN_65264_Builder(void);
byte retarderConfigDataBuilder(void);
void retarderConfigPGN_65249_Builder(void);
void vehicleDistanceDataBuilder(void);
void vehicleDistancePGN_65248_Builder(void);
void retarderDataBuilder(void);
void electronicBrakePGN_65527_Builder(void);
void vehicleHoursDataBuilder(void);
void vehicleHoursPGN_65255_Builder(void);
void incrementCounters(void);
void initLoopCounter(void);
void setDiagnosticSourceFromFuelArbitrator(void);
void setDiagnosticSourceFromEngineFlags(void);
void engine_protection_coordinator(void);
void initMultiSystemParameters(void);
undefined4 addressRangeValidator(uint param_1,uint param_2);
void pwmTimerMode0Init(void);
void pwmTimerMode0Reset(void);
void pwmTimerMode1ChannelSetup(void);
void pwmTimerMode1Update(void);
void pwmTimerModeDispatcher(void);
undefined8 pwmTimerCycleAdvance(void);
void delayWithWatchdogService(undefined4 param_1);
void watchdogServiceLoop(undefined4 param_1);
void engineDataTrendingSlowCycle40Coordinator(void);
void trendingDataTableLookup(void);
void fuelDemandBasedParameterCalculator(void);
void fuelDemandLimitMinimumUpdater(void);
ushort vp44_rpm_derate_monitor(void);
void diagnostic_protection_coordinator(void);
void initDiagnosticModeSystem(void);
uint fuelTimingTransitionStateMachine(void);
void initProtectionTablePointer(void);
ushort diagnosticFlagResetHandler(void);
ushort fuelTempControlFlagChecker(void);
void diagnosticModeFuelAdjustmentCalculator(undefined4 param_1);
void update_engine_protection_thresholds(void);
undefined4 engineProtectionTimeoutCalculator(undefined4 param_1);
void engineProtectionScaledValueCalculator(void); /* decompile failed */
void protectionThresholdDivider(void); /* decompile failed */
void engine_protection_init(void);
undefined4 diagnosticFuelGainCalculator(void);
void boost_pressure_control_and_diagnostics(void);
void diagnosticMode10FuelController(void);
void diagnosticParameterPointersInit(void);
ushort vp44DiagnosticModeStateMachine(void);
void vp44ControlVariablesReset(void);
void boostPressureFeedbackController(void);
ushort minimumOfTwoValues(undefined4 param_1);
void fuelLimitDecreaseWithFloor(undefined4 param_1);
void fuelLimitIncreaseWithCeiling(undefined4 param_1);
void boostPressureProtectionStateMachine(void);
ushort fuelLimitEngineStateCapture(void);
void fuelLimitRestoreFromCapture(void);
void diagnosticRpmBasedFuelLimitCalculator(void);
void diagnosticFuelLimitInterpolator(void);
uint engineStateFuelLimitInterpolator(void);
void fuelTempProtectionLimitCalculator(void);
void fuelArbitratorVariablesInit(void);
ushort shutdownLimitSelector(void);
void shutdownMinimumSelector21(void);
void crankDataBufferStore(void);
uint crankAndProtectionStateMonitor(void);
void calibrationDataValidatorInit(void);
void engineParameterControllerWithTimer(void);
void derateTablePointerInit(void);
uint boostPressureTargetCalculator(void);
void boostPressureControlStateInit(void);
undefined4 accumulatorWithOverflowCarry(uint *param_1,uint *param_2);
void fuelDemandStatisticsAccumulator(void);
void boostPressureStatisticsAccumulator(void);
void fuelLimitExceedanceStatisticsAccumulator(void);
void rpmHistogramAndProtectionStatisticsAccumulator(void);
ushort clutchOperatingStatisticsTracker(void);
void statisticsTrackingFlagsReset(void);
undefined8 timerCaptureAverageCalculator(void);
void timerCaptureHardwareInit(void);
void vp44FaultThresholdTablesInit(void);
void vp44FaultProtectionController(void);
void oilPressureTablePointersInit(void);
ushort oilPressureFuelArbitrationMonitor(void);
void protectionLimitValueInit(void);
void fuelDemandLimitSelector4(void);
void fuelDemandUpdateOrchestrator(void);
void diagnosticModeFuelArbitrationHandler(void);
void shutdownMinimumSelector28(void);
void shutdownMinimumSelector20(void);
void shutdownMinimumSelectorOrchestrator(void);
void masterSubsystemInit(void);
void dualTableLookupSum(void);
void interpolationTableSetup(void);
void vp44ExtendedProcessingRouter(void);
void vp44StateVariablesInit(void);
void vp44StateProcessor(void);
short vp44StateDebounceFilter(void);
undefined2 vp44StateToControlModeMapper(void);
undefined4 vp44OperatingConditionChecker(void);
undefined4 vp44FuelControlConditionChecker(void);
VP44_DIAG_MODE vp44State2TransitionHandler(void);
undefined4 vp44State1TransitionHandler(void);
uint vp44State3Or4TransitionChecker(void);
undefined2 vp44StateOutputSelector(void);
uint vp44FaultStateCodeMapper(void);
void diagnosticFuelOverrideHandler(void);
void vp44TimingStateInit(void);
void vp44InjectionTimingSlowCycle40Coordinator(void);
void vp44TimingValuesInit(void);
ushort engineModeOutputControlInit(void);
uint engineModeOutputControlStateMachine(void);
void outputControlState1Handler(void);
void outputControlState2Handler(void);
void outputControlState3Handler(void);
void outputControlState4Handler(void);
void outputControlStateToModeMapper(void);
uint outputControlStateMachineSelector(void);
void outputControlTimingGenerator(void);
void outputControlState5FaultHandler(void);
ushort sensorFaultBasedRpmSourceSelector(void);
ushort faultBasedOutputStateCalculator(void);
void outputControlFlagsInit(void);
void engineModeBasedIoController(void);
void fuelDemandTablePointersInit(void);
uint rpmLoadParameterLookup(void);
ushort fuelDemandLimitSelector11(void);
uint simTimerControlInit(void);
uint rpmDerateCalculationController(void);
ushort vp44DiagnosticSensorThresholdMonitor(void);
ushort vp44FaultRegisterBit2Monitor(void);
void fuelDemandConditionFlagBuilder(void);
ushort fuelDemandFaultFlagUpdater(uint param_1);
ushort fuelDemandLimitSource2Selector(void);
void fuelDemandLimitSource3Selector(void);
void fuelDemandLimitSource4Selector(void);
void fuelDemandOverrideStateSelector(void);
ushort fuelDemandLimitOrchestrator(void);
void fuelPressureSyncStateMachine(void);
void vp44InjectionSystemStateController(void);
void fuelDemandState24Override(void);
void fuelDemandControllerInit(void);
ushort fuelTemperatureLimitingPrimary(void);
word fuelTemperatureLimitingSecondary(void);
void ioControlSourceRegisterManager(uint param_1);
void ioControlRegistersInit(void);
uint fuelTemperatureProtectionSlowCycle40Coordinator(void);
void vp44SensorStatusMonitor(void);
void vp44DiagnosticStateInit(void);
void vp44ControlFlagsInit(void);
ushort vp44SensorDiagnosticControl(void);
void dzgTimingStateVariablesInit(void);
uint dzgTimingAndPressureControlStateMachine(void);
void sensorHistoryTablePointerInit(void);
void timeDeltaCalculator(void);
uint oilPressureRpmLimitTargetSelector(void);
void sensorStatusHistoryTracker(void);
void initOilPressureProtectionPointers(void);
void vp44FaultProtectionSystemInit(void);
void vp44TimingRangeValidation(void);
ushort vp44CanMessage100Parser(int param_1);
void vp44CanMessage100ResponseBuilder(void);
void vp44CanMessage200Parser(int param_1);
void vp44CanMessage200ResponseBuilder(void);
void vp44CanMessage300Parser(int param_1);
void baseTimingTableLookup(void);
void liftPumpFuelDeliveryController(void);
void derateThresholdIoController(void);
void vp44FsoFaultDetectionMonitor(void);
void vp44FsoCircuitFaultDetection(void);
void vp44FsoCircuitFaultDetectionBit1(void);
void vp44FsoFaultRangeMonitor(void);
void vp44TimingFaultMonitor(void);
void vp44FsoFaultDetectionAndProtectionController(void);
void vp44FsoFaultBit0Monitor(void);
void vp44FsoFaultBit15Monitor(void);
void vp44FsoMultiBitFaultMonitor(void);
void vp44FsoStuckHighFaultDetector(void);
void vp44FsoStuckLowFaultDetector(void);
void vp44FsoFaultConditionDetector(void);
void vp44Message300FaultFlagProcessor(void);
void multiParameterMinimumSelector(void);
void systemStatusMonitor(void);
byte liftPumpCommStatusMonitor(void);
void vp44FsoFaultEnableController(void);
ushort vp44RpmBasedFaultDetector(void);
void vp44FaultBit5Reset(void);
short lookupTableInterpolation(table_interp_args_t *args);
void exponentialMovingAverage(void); /* decompile failed */
void signedLinearInterpolation(void); /* decompile failed */
void coreTableInterpolation(void); /* decompile failed */
void unsignedLinearInterpolation(void); /* decompile failed */
undefined4 proportionalCalculation(uint param_1,uint param_2,uint param_3);
undefined4 rpmFuelCalculation(int param_1,int param_2,int param_3);
undefined8 tableInterpolationLookup(short *param_1);

/* ============================================================ */
/* Function Implementations                                     */
/* ============================================================ */

/*
 * Function: rpm_rate_limiter @ 0x0000a16a
 */

void rpm_rate_limiter(void)

{
  rpm_delta_value = current_engine_rpm_raw - previous_engine_rpm;
  previous_engine_rpm = current_engine_rpm_raw;
  rpm_rate_limited_value = exponentialMovingAverage();
  if ((short)rpm_rate_limited_value < (short)rpm_rate_limits_t_008062f8.minimum) {
    rpm_rate_limited_value = rpm_rate_limits_t_008062f8.minimum;
    dma_control_flags1 = (short)rpm_rate_limits_t_008062f8.minimum * 0x10000 + 0x80000000;
  }
  else if ((short)rpm_rate_limits_t_008062f8.maximum < (short)rpm_rate_limited_value) {
    rpm_rate_limited_value = rpm_rate_limits_t_008062f8.maximum;
    dma_control_flags1 = (short)rpm_rate_limits_t_008062f8.maximum * 0x10000 + 0x80000000;
  }
  rpm_rate_secondary_calc = exponentialMovingAverage();
  return;
}



/*
 * Function: rpm_system_state_controller @ 0x0000a204
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort rpm_system_state_controller(void)

{
  ushort uVar1;
  
  uVar1 = diagnostic_system_flags_1 & 0x1000;
  if ((diagnostic_system_flags_1 & 0x1000) != 0) {
    if ((short)rpm_threshold_lower < (short)rpm_rate_limited_value) {
      rpm_threshold_exceeded_flag = 1;
      rpm_control_timer_1 = rpm_timer_reload_value_1;
    }
    else if (rpm_control_timer_1 == 0) {
      rpm_threshold_exceeded_flag = 0;
    }
    else {
      rpm_control_timer_1 = rpm_control_timer_1 - 1;
    }
    if ((((_request_to_strobe_set_0_then_set_1_fso_driver_0_1 == 0) ||
         (rpm_threshold_exceeded_flag != 0)) || (current_engine_rpm_raw < rpm_threshold_upper)) ||
       (((short)rpm_threshold_lower < (short)rpm_rate_limited_value ||
        ((short)rpm_rate_secondary_calc < (short)rpm_secondary_threshold)))) {
      if (rpm_control_override_flag == 0) {
        if (rpm_control_timer_2 == 0) {
          rpm_system_mode_flag = 0;
        }
        else {
          rpm_control_timer_2 = rpm_control_timer_2 - 1;
        }
      }
      else {
        rpm_system_mode_flag = 1;
        rpm_control_timer_2 = can_memory_table_start._2_2_;
      }
    }
    else {
      rpm_system_mode_flag = 1;
      rpm_control_timer_2 = can_memory_table_start._2_2_;
    }
    if (rpm_system_mode_flag == 1) {
      rpm_state_lookup_input = current_engine_rpm_raw;
      fuel_limit_shutdown = lookupTableInterpolation((table_interp_args_t *)&dma_descriptor_base1);
      return fuel_limit_shutdown;
    }
    uVar1 = fuel_limit_shutdown;
    if (fuel_limit_shutdown < max_number_of_shutdowns_before_restart_is_not_allowed_0_255) {
      uVar1 = rpm_state_controller_param + fuel_limit_shutdown;
      fuel_limit_shutdown = uVar1;
      if (max_number_of_shutdowns_before_restart_is_not_allowed_0_255 < uVar1) {
        fuel_limit_shutdown = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
      }
    }
  }
  return uVar1;
}



/*
 * Function: shutdownMinimumSelector17 @ 0x0000a30c
 */

void shutdownMinimumSelector17(void)

{
  if (fuel_limit_shutdown < shutdown_limit_accumulator) {
    shutdown_limit_accumulator = fuel_limit_shutdown;
    shutdown_minimum_selector_value = FUEL_LIMIT_SHUTDOWN;
  }
  return;
}



/*
 * Function: highRpmFuelControlLimiter @ 0x0000a32a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort highRpmFuelControlLimiter(void)

{
  word wVar1;
  
  wVar1 = diagnostic_system_flags_1 & 0x2000;
  if ((diagnostic_system_flags_1 & 0x2000) != 0) {
    if ((short)high_rpm_threshold_calibration_t_00806300.rate_threshold <
        (short)rpm_rate_limited_value) {
      none_none = 1;
      high_rpm_threshold_countdown =
           high_rpm_threshold_calibration_t_00806300.threshold_timer_reload;
    }
    else if (high_rpm_threshold_countdown == 0) {
      none_none = 0;
    }
    else {
      high_rpm_threshold_countdown = high_rpm_threshold_countdown - 1;
    }
    wVar1 = rpm_rate_limited_value;
    if ((((_request_to_strobe_set_0_then_set_1_fso_driver_0_1 == 0) || (none_none != 0)) ||
        (wVar1 = throttle_position_raw,
        throttle_position_raw <= high_rpm_calibration_t_008062ea.high_rpm_upper_threshold)) ||
       ((wVar1 = rpm_rate_limited_value,
        (short)high_rpm_threshold_calibration_t_00806300.rate_threshold <
        (short)rpm_rate_limited_value ||
        (wVar1 = rpm_rate_secondary_calc,
        (short)rpm_rate_secondary_calc <
        (short)high_rpm_calibration_t_008062ea.high_rpm_secondary_threshold)))) {
      if (rpm_control_override_flag == 0) {
        if (rpm_control_timer_previous == 0) {
          high_rpm_fuel_accumulator = 0;
        }
        else {
          rpm_control_timer_previous = rpm_control_timer_previous - 1;
        }
      }
      else {
        high_rpm_fuel_accumulator = 1;
        rpm_control_timer_previous = high_rpm_calibration_t_008062ea.high_rpm_timer_reload;
      }
    }
    else {
      high_rpm_fuel_accumulator = 1;
      rpm_control_timer_previous = high_rpm_calibration_t_008062ea.high_rpm_timer_reload;
    }
    if (high_rpm_fuel_accumulator == 1) {
      high_rpm_lookup_input = current_engine_rpm_raw;
      high_rpm_fuel_limit = lookupTableInterpolation((table_interp_args_t *)&dma_descriptor_base2);
      return high_rpm_fuel_limit;
    }
    if (high_rpm_fuel_limit < 0x400) {
      high_rpm_fuel_limit =
           high_rpm_calibration_t_008062ea.high_rpm_fuel_ramp_increment + high_rpm_fuel_limit;
      wVar1 = high_rpm_calibration_t_008062ea.high_rpm_fuel_ramp_increment;
      if (0x400 < high_rpm_fuel_limit) {
        high_rpm_fuel_limit = 0x400;
      }
    }
  }
  return wVar1;
}



/*
 * Function: fuelLimitMinimumSelector @ 0x0000a428
 */

void fuelLimitMinimumSelector(void)

{
  fuel_demand_before_limiting = fuel_limit_minimum_value;
  if (high_rpm_fuel_limit < fuel_limit_minimum_value) {
    fuel_limit_minimum_value = high_rpm_fuel_limit;
    fuel_demand_source_id = HIGH_RPM_FUEL_LIMIT;
  }
  return;
}



/*
 * Function: lowRpmFuelProtectionLimiter @ 0x0000a44c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort lowRpmFuelProtectionLimiter(void)

{
  word wVar1;
  ushort uVar2;
  
  uVar2 = diagnostic_system_flags_1 & 0x4000;
  if ((diagnostic_system_flags_1 & 0x4000) != 0) {
    if ((short)low_rpm_calibration_t_008062de.low_rpm_rate_threshold < (short)rpm_rate_limited_value
       ) {
      rpm_rate_limit_active_flag = 1;
      rpm_rate_limit_countdown = rpm_rate_limits_t_008062f8.threshold_timer_reload;
    }
    else if (rpm_rate_limit_countdown == 0) {
      rpm_rate_limit_active_flag = 0;
    }
    else {
      rpm_rate_limit_countdown = rpm_rate_limit_countdown - 1;
    }
    wVar1 = rpm_rate_limited_value;
    if ((((_request_to_strobe_set_0_then_set_1_fso_driver_0_1 == 0) ||
         (rpm_rate_limit_active_flag != 0)) ||
        (wVar1 = current_engine_rpm_raw,
        low_rpm_calibration_t_008062de.low_rpm_upper_threshold < current_engine_rpm_raw)) ||
       ((wVar1 = rpm_rate_limited_value,
        (short)low_rpm_calibration_t_008062de.low_rpm_rate_threshold < (short)rpm_rate_limited_value
        || (wVar1 = rpm_rate_secondary_calc,
           (short)rpm_rate_secondary_calc <
           (short)low_rpm_calibration_t_008062de.low_rpm_secondary_threshold)))) {
      if (rpm_control_override_flag == 0) {
        if (rpm_control_timer_delta == 0) {
          low_rpm_fuel_accumulator = 0;
        }
        else {
          rpm_control_timer_delta = rpm_control_timer_delta - 1;
        }
      }
      else {
        low_rpm_fuel_accumulator = 1;
        rpm_control_timer_delta = low_rpm_calibration_t_008062de.low_rpm_timer_reload;
      }
    }
    else {
      low_rpm_fuel_accumulator = 1;
      rpm_control_timer_delta = low_rpm_calibration_t_008062de.low_rpm_timer_reload;
    }
    if (low_rpm_fuel_accumulator != 0) {
      fuel_arbitrator_threshold_3 = low_rpm_calibration_t_008062de.low_rpm_fuel_limit;
      return wVar1;
    }
    uVar2 = fuel_arbitrator_threshold_3;
    if (fuel_arbitrator_threshold_3 < oil_pressure_precrank_status) {
      uVar2 = low_rpm_calibration_t_008062de.low_rpm_fuel_ramp_increment +
              fuel_arbitrator_threshold_3;
      fuel_arbitrator_threshold_3 = uVar2;
      if (oil_pressure_precrank_status < uVar2) {
        fuel_arbitrator_threshold_3 = oil_pressure_precrank_status;
      }
    }
  }
  return uVar2;
}



/*
 * Function: dmaControllerSetup1 @ 0x0000a53e
 */

void dmaControllerSetup1(void)

{
                    /* Constant: DMA_CONTROLLER_SETUP = 0x80000000 */
  dma_control_flags1 = 0x80000000;
                    /* Constant: DMA_DESC_ADDR_1 = 0x8062F4 */
  dma_descriptor_ptr1 = 0x8062f4;
  dma_control_flags2 = 0x80000000;
                    /* Constant: DMA_DESC_ADDR_2 = 0x8062F6 */
  dma_descriptor_ptr2 = (dword)&dma_desc_dest_addr1;
  previous_engine_rpm = 0;
  return;
}



/*
 * Function: dmaDescriptorSetup1 @ 0x0000a56e
 */

void dmaDescriptorSetup1(void)

{
  dma_descriptor_base1 = 2;
                    /* Constant: DMA_SOURCE_ADDR_1 = 0x806304 */
  dma_desc1_source_ptr = (dword)&dma_desc_source_addr2;
                    /* Constant: DMA_DEST_ADDR_1 = 0x806318 */
  dma_desc1_dest_ptr = (dword)&dma_desc_dest_addr2;
  fuel_limit_shutdown = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
  return;
}



/*
 * Function: dmaDescriptorSetup2 @ 0x0000a598
 */

void dmaDescriptorSetup2(void)

{
  dma_descriptor_base2 = 2;
                    /* Constant: DMA_SOURCE_ADDR_2 = 0x80632C */
  dma_desc2_source_ptr = (dword)&dma_desc_source_addr3;
                    /* Constant: DMA_DEST_ADDR_2 = 0x806340 */
  dma_desc2_dest_ptr = (dword)&dma_desc_dest_addr3;
  high_rpm_fuel_limit = 0x400;
  return;
}



/*
 * Function: initFuelSystemOutputDriver @ 0x0000a5c0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initFuelSystemOutputDriver(void)

{
  _request_to_strobe_set_0_then_set_1_fso_driver_0_1 = 1;
  fuel_arbitrator_threshold_3 = oil_pressure_precrank_status;
  return;
}



/*
 * Function: messageTypeToChannelMapper @ 0x0000a5e2
 */

undefined1 messageTypeToChannelMapper(undefined4 param_1)

{
  byte bVar1;
  
  bVar1 = (byte)((uint)param_1 >> 0x10);
  if (0x40 < bVar1) {
    if (bVar1 < 0x4f) {
      return *(undefined1 *)((short)(param_1._0_2_ & 0xff) + 0xa593);
    }
    return 1;
  }
  if ((bVar1 != 4) && (bVar1 != 5)) {
    return 1;
  }
  return 3;
}



/*
 * Function: diagnosticMessageQueueWrite @ 0x0000a626
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticMessageQueueWrite(undefined4 param_1)

{
  char cVar1;
  int iVar2;
  undefined1 uVar3;
  undefined4 local_8;
  
  if ((int)can_transmit_buffer_ptr < _can_transmit_length) {
    iVar2 = (_can_transmit_length - can_transmit_buffer_ptr) + -2;
  }
  else {
    iVar2 = (_can_transmit_length - can_transmit_buffer_ptr) + 0xfe;
  }
  if (iVar2 < 3) {
    io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
  }
  else {
    local_8._3_1_ = (char)can_transmit_buffer_ptr;
    cVar1 = (char)local_8;
    local_8._0_3_ = (undefined3)(can_transmit_buffer_ptr >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
    if (param_1._0_2_ == 0) {
      uVar3 = 100;
    }
    else if (param_1._0_2_ == 1) {
      uVar3 = 0x74;
      diagnostic_queue_message_type = param_1._0_2_;
    }
    else {
      uVar3 = 0x75;
      if (param_1._0_2_ < 0x12) {
        diagnostic_queue_message_type = param_1._0_2_;
      }
      else {
        diagnostic_queue_message_type = *(word *)((short)param_1._0_2_ * 2 + 0xa5f6);
      }
    }
    *local_8 = 6;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar1 + '\x02');
    *local_8 = uVar3;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar1 + '\x03');
    *(undefined1 *)can_transmit_buffer_ptr = 2;
    can_transmit_buffer_ptr = (dword)local_8;
    *local_8 = 0;
    tpuTransmissionTrigger();
  }
  return;
}



/*
 * Function: sensorFaultDebounceMonitor @ 0x0000a6fa
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void sensorFaultDebounceMonitor(void)

{
  bool bVar1;
  short sVar2;
  undefined2 uVar3;
  ushort uVar4;
  short sVar5;
  word wVar6;
  int iVar7;
  byte *pbVar8;
  byte *pbVar9;
  word *args;
  
  sVar5 = 0;
  pbVar8 = &request_to_strobe_set_0_then_set_1_cold_start_aid_1_driver_0_1;
  iVar7 = 0x8068ea;
  uVar4 = 1;
  pbVar9 = &sensor_fault_debounce_counter_base;
  args = &adc_channel_config_buffer;
  wVar6 = _engine_control_flags_register;
  do {
    if ((byte *)0x809407 < pbVar8) {
      return;
    }
    if (*(char *)(iVar7 + 0x17) == '\0') {
      pbVar8[0xf] = 0;
    }
    else if (pbVar8[0xf] < *(byte *)(iVar7 + 0x17)) {
      pbVar8[0xf] = pbVar8[0xf] + 1;
    }
    else {
      pbVar8[0xf] = 1;
      if ((uVar4 & wVar6) == 0) {
        *(undefined2 *)(pbVar8 + 0x10) =
             *(undefined2 *)((uint)*(ushort *)(iVar7 + 0x10) * 2 + 0xfff2b0);
        if (*(ushort *)(iVar7 + 0xc) < *(ushort *)(pbVar8 + 0x10)) {
          if ((((uint)(&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)] &
               1 << (*(byte *)(iVar7 + 0x15) & 0xf)) == 0) ||
             (((uint)(&fault_flags_enabled_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)] &
              1 << (*(byte *)(iVar7 + 0x15) & 0xf)) == 0)) {
            bVar1 = false;
          }
          else {
            bVar1 = true;
          }
          if (bVar1) goto LAB_0000a864;
          *(short *)(pbVar8 + 0xc) = *(short *)(iVar7 + 8) + *(short *)(pbVar8 + 0xc);
          if (*(short *)(iVar7 + 10) <= *(short *)(pbVar8 + 0xc)) {
            *(undefined2 *)(pbVar8 + 0xc) = *(undefined2 *)(iVar7 + 10);
            pbVar8[0xe] = 1;
            (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)] =
                 1 << (*(byte *)(iVar7 + 0x14) & 0xf) |
                 (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)];
            (&fault_flags_history_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)] =
                 1 << (*(byte *)(iVar7 + 0x14) & 0xf) |
                 (&fault_flags_history_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)];
          }
        }
        else {
LAB_0000a864:
          if (*(ushort *)(pbVar8 + 0x10) < *(ushort *)(iVar7 + 0xe)) {
            if ((((uint)(&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)]
                 & 1 << (*(byte *)(iVar7 + 0x14) & 0xf)) == 0) ||
               (((uint)(&fault_flags_enabled_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)]
                & 1 << (*(byte *)(iVar7 + 0x14) & 0xf)) == 0)) {
              bVar1 = false;
            }
            else {
              bVar1 = true;
            }
            if (!bVar1) {
              *(short *)(pbVar8 + 0xc) = *(short *)(iVar7 + 8) + *(short *)(pbVar8 + 0xc);
              if (*(short *)(iVar7 + 10) <= *(short *)(pbVar8 + 0xc)) {
                *(undefined2 *)(pbVar8 + 0xc) = *(undefined2 *)(iVar7 + 10);
                pbVar8[0xe] = 1;
                (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)] =
                     1 << (*(byte *)(iVar7 + 0x15) & 0xf) |
                     (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)];
                (&fault_flags_history_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)] =
                     1 << (*(byte *)(iVar7 + 0x15) & 0xf) |
                     (&fault_flags_history_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)];
              }
              goto LAB_0000a964;
            }
          }
          *(short *)(pbVar8 + 0xc) = *(short *)(pbVar8 + 0xc) - *(short *)(iVar7 + 6);
          if (*(short *)(pbVar8 + 0xc) < 0) {
            pbVar8[0xc] = 0;
            pbVar8[0xd] = 0;
          }
        }
LAB_0000a964:
        if (*(short *)(pbVar8 + 0xc) <= *(short *)(iVar7 + 4)) {
          pbVar8[0xe] = 0;
          if (((uint)(&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)] &
              1 << (*(byte *)(iVar7 + 0x14) & 0xf)) != 0) {
            if (((uint)(&fault_flags_history_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)]
                & 1 << (*(byte *)(iVar7 + 0x14) & 0xf)) == 0) {
              (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)] =
                   ~(1 << (*(byte *)(iVar7 + 0x14) & 0xf)) &
                   (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x14) >> 4)];
            }
          }
          if (((uint)(&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)] &
              1 << (*(byte *)(iVar7 + 0x15) & 0xf)) != 0) {
            if (((uint)(&fault_flags_history_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)]
                & 1 << (*(byte *)(iVar7 + 0x15) & 0xf)) == 0) {
              (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)] =
                   ~(1 << (*(byte *)(iVar7 + 0x15) & 0xf)) &
                   (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x15) >> 4)];
            }
          }
        }
        if (pbVar8[0xe] == 0) {
          ((table_interp_args_t *)args)->input_value = *(word *)(pbVar8 + 0x10);
          sVar2 = lookupTableInterpolation((table_interp_args_t *)args);
          *(short *)(pbVar8 + 10) = sVar2;
          if (*(char *)(iVar7 + 0x13) != '\0') {
            if (*(short *)(pbVar8 + 10) == 4) {
              if (*pbVar9 == 4) {
                (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x16) >> 4)] =
                     1 << (*(byte *)(iVar7 + 0x16) & 0xf) |
                     (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x16) >> 4)];
                (&fault_flags_history_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x16) >> 4)] =
                     1 << (*(byte *)(iVar7 + 0x16) & 0xf) |
                     (&fault_flags_history_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x16) >> 4)];
              }
              else {
                *pbVar9 = *pbVar9 + 1;
              }
            }
            else if (*pbVar9 == 0) {
              if (((uint)(&fault_flags_active_base)
                         [(short)((int)(uint)*(byte *)(iVar7 + 0x16) >> 4)] &
                  1 << (*(byte *)(iVar7 + 0x16) & 0xf)) != 0) {
                if (((uint)(&fault_flags_history_base)
                           [(short)((int)(uint)*(byte *)(iVar7 + 0x16) >> 4)] &
                    1 << (*(byte *)(iVar7 + 0x16) & 0xf)) == 0) {
                  (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x16) >> 4)] =
                       ~(1 << (*(byte *)(iVar7 + 0x16) & 0xf)) &
                       (&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar7 + 0x16) >> 4)];
                }
              }
            }
            else {
              *pbVar9 = *pbVar9 - 1;
            }
          }
          uVar3 = coreTableInterpolation();
          *(undefined2 *)(pbVar8 + 8) = uVar3;
        }
        else {
          *(undefined2 *)(pbVar8 + 8) = *(undefined2 *)(iVar7 + 2);
        }
      }
      else {
        *(word *)(pbVar8 + 8) = (&sensor_fault_debounce_limit)[sVar5];
      }
    }
    pbVar8 = pbVar8 + 0x16;
    iVar7 = iVar7 + 0x18;
    args = (word *)((int)args + 0xc);
    pbVar9 = pbVar9 + 1;
    sVar5 = sVar5 + 1;
    if (sVar5 == 0x10) {
      uVar4 = 1;
      wVar6 = fuel_temp_control_flags;
    }
    else {
      uVar4 = uVar4 * 2;
    }
  } while( true );
}



/*
 * Function: initADCChannelConfiguration @ 0x0000ac1c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initADCChannelConfiguration(void)

{
  bool bVar1;
  byte *pbVar2;
  int iVar3;
  
  adc_coolant_temp_fault_clear_ptr = (dword)&a_d_fault_clear_counts_for_coolant_temperature_0_32767;
  adc_oil_pressure_filter_ptr = (dword)&a_d_digital_filter_constant_for_oil_pressure_0_1;
  adc_channel_config_buffer = 2;
  adc_sampled_throttle_fault_clear_ptr = (dword)&a_d_fault_clear_counts_for_sampled_throttle_0_32767
  ;
  adc_throttle_fault_set_ptr = (dword)&a_d_fault_increment_0_32767;
  _adc_throttle_fault_increment_ptr = 2;
  adc_channel_3_mux_ptr = (dword)&channel_mux_setting_0_255;
  adc_ambient_air_pressure_filter_ptr =
       (dword)&a_d_digital_filter_constant_for_ambient_air_pressure_0_1;
  adc_channel_3_config_value = 2;
  adc_channel_4_mux_ptr = (dword)&channel_mux_setting_0_255;
  adc_battery_voltage_error_limit_ptr = (dword)&a_d_high_error_limit_for_battery_voltage_0_1023;
  adc_channel_4_config_value = 2;
  adc_channel_5_error_limit_ptr = (dword)&a_d_high_error_limit_0_1023;
  adc_channel_5_filter_ptr = (dword)&a_d_digital_filter_constant_0_1;
  adc_channel_5_config_value = 2;
  adc_channel_6_fault_set_ptr = (dword)&a_d_fault_set_0_32767;
  adc_channel_6_filter_ptr = (dword)&a_d_digital_filter_constant_0_1;
  adc_channel_6_config_value = 2;
  adc_channel_7_filter_ptr = (dword)&a_d_digital_filter_constant_0_1;
  adc_throttle_error_number_ptr =
       (dword)&error_number_storage_for_throttle_position_sv_high_error_0_255;
  adc_channel_7_config_value = 2;
  adc_water_in_fuel_fault_set_ptr = (dword)&water_in_fuel_a_d_fault_set_0_32767;
  adc_water_in_fuel_fault_clear_ptr = (dword)&water_in_fuel_a_d_fault_clear_counts_0_32767;
  adc_channel_8_config_value = 2;
  adc_water_in_fuel_tristate_ptr = (dword)&water_in_fuel_tri_state_error_none;
  adc_water_in_fuel_channel_addr_ptr = (dword)&water_in_fuel_channel_address_none;
  adc_channel_9_config_value = 2;
  adc_channel_10_fault_set_ptr = (dword)&a_d_fault_set_0_32767;
  adc_channel_10_fault_clear_ptr = (dword)&a_d_fault_clear_counts_0_32767;
  adc_channel_10_config_value = 2;
  adc_channel_11_fault_decrement_ptr = (dword)&a_d_fault_decrement_0_32767;
  adc_egr_feedback_channel_addr_ptr = (dword)&egr_current_feedback_channel_address_none;
  adc_channel_11_config_value = 2;
  adc_channel_12_fault_ptr = (dword)&ADHBSVFD;
  adc_programming_pulse_error_ptr =
       (dword)&error_number_storage_for_programming_pulse_sv_high_error_0_255;
  adc_channel_12_config_value = 2;
  adc_channel_13_default_ptr = (dword)&global_default_value;
  adc_channel_13_fault_ptr = (dword)&ADHBSVCA;
  adc_channel_13_config_value = 2;
  adc_channel_14_mux_ptr = (dword)&channel_mux_setting_0_255;
  adc_channel_14_error_limit_ptr = (dword)&a_d_high_error_limit_0_1023;
  adc_channel_14_config_value = 2;
  adc_channel_15_table_ptr_2 = (dword)&linearization_table_ch15_y_axis;
  adc_channel_15_table_ptr_1 = (dword)&linearization_table_ch15_x_axis;
  adc_channel_15_config_value = 2;
  adc_channel_16_table_ptr_2 = (dword)&linearization_table_ch16_y_axis;
  adc_channel_16_table_ptr_1 = (dword)&linearization_table_ch16_x_axis;
  adc_channel_16_config_value = 2;
  adc_channel_17_table_ptr_2 = (dword)&linearization_table_ch17_y_axis;
  adc_channel_17_table_ptr_1 = (dword)&linearization_table_ch17_x_axis;
  adc_channel_17_config_value = 2;
  adc_channel_18_table_ptr_2 = (dword)&linearization_table_ch18_y_axis;
  adc_channel_18_table_ptr_1 = (dword)&linearization_table_ch18_x_axis;
  adc_channel_18_config_value = 2;
  adc_channel_19_table_ptr_2 = (dword)&linearization_table_ch19_y_axis;
  adc_channel_19_table_ptr_1 = (dword)&linearization_table_ch19_x_axis;
  adc_channel_19_config_value = 2;
  adc_channel_20_table_ptr_2 = (dword)&linearization_table_ch20_y_axis;
  adc_channel_20_table_ptr_1 = (dword)&linearization_table_ch20_x_axis;
  adc_channel_20_config_value = 2;
  adc_channel_21_table_ptr_2 = (dword)&linearization_table_ch21_y_axis;
  adc_channel_21_table_ptr_1 = (dword)&linearization_table_ch21_x_axis;
  adc_channel_21_config_value = 2;
  adc_channel_22_table_ptr_2 = (dword)&linearization_table_ch22_y_axis;
  adc_channel_22_table_ptr_1 = (dword)&linearization_table_ch22_x_axis;
  adc_channel_22_config_value = 2;
  adc_channel_23_table_ptr_2 = (dword)&linearization_table_ch23_y_axis;
  adc_channel_23_table_ptr_1 = (dword)&linearization_table_ch23_x_axis;
  adc_channel_23_config_value = 2;
  adc_channel_24_table_ptr_2 = (dword)&linearization_table_ch24_y_axis;
  adc_channel_24_table_ptr_1 = (dword)&linearization_table_ch24_x_axis;
  adc_channel_24_config_value = 2;
  adc_channel_25_table_ptr_2 = (dword)&linearization_table_ch25_y_axis;
  adc_channel_25_table_ptr_1 = (dword)&linearization_table_ch25_x_axis;
  adc_channel_25_config_value = 2;
  pbVar2 = &request_to_strobe_set_0_then_set_1_cold_start_aid_1_driver_0_1;
  iVar3 = 0x8068ea;
  do {
    if ((byte *)0x809407 < pbVar2) {
      sensorFaultDebounceMonitor();
      for (pbVar2 = &request_to_strobe_set_0_then_set_1_cold_start_aid_1_driver_0_1;
          pbVar2 < (byte *)0x809408; pbVar2 = pbVar2 + 0x16) {
        *(uint *)(pbVar2 + 4) = (uint)*(ushort *)(pbVar2 + 10) << 0x10;
        *(undefined2 *)(pbVar2 + 8) = *(undefined2 *)(pbVar2 + 10);
        pbVar2[0xf] = 0;
      }
      return;
    }
    pbVar2[4] = 0;
    pbVar2[5] = 0;
    pbVar2[6] = 0;
    pbVar2[7] = 0;
    *(int *)pbVar2 = iVar3;
    pbVar2[0xf] = *(byte *)(iVar3 + 0x17);
    if ((((uint)(&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar3 + 0x15) >> 4)] &
         1 << (*(byte *)(iVar3 + 0x15) & 0xf)) == 0) ||
       (((uint)(&fault_flags_enabled_base)[(short)((int)(uint)*(byte *)(iVar3 + 0x15) >> 4)] &
        1 << (*(byte *)(iVar3 + 0x15) & 0xf)) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (bVar1) {
LAB_0000af4c:
      *(undefined2 *)(pbVar2 + 0xc) = *(undefined2 *)(iVar3 + 10);
      pbVar2[0xe] = 1;
    }
    else {
      if ((((uint)(&fault_flags_active_base)[(short)((int)(uint)*(byte *)(iVar3 + 0x14) >> 4)] &
           1 << (*(byte *)(iVar3 + 0x14) & 0xf)) == 0) ||
         (((uint)(&fault_flags_enabled_base)[(short)((int)(uint)*(byte *)(iVar3 + 0x14) >> 4)] &
          1 << (*(byte *)(iVar3 + 0x14) & 0xf)) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (bVar1) goto LAB_0000af4c;
    }
    pbVar2 = pbVar2 + 0x16;
    iVar3 = iVar3 + 0x18;
  } while( true );
}



/*
 * Function: diagnostic_fuel_calculation_with_vp44_monitoring @ 0x0000afa0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort diagnostic_fuel_calculation_with_vp44_monitoring(void)

{
  ushort uVar1;
  ushort uVar2;
  undefined8 uVar3;
  
  if ((vp44_status_flags_2 & 8) == 0) {
    _diagnostic_rpm_input = current_engine_rpm;
    _diagnostic_secondary_input = diagnostic_sensor_reading;
    uVar3 = tableInterpolationLookup((short *)&diagnostic_fuel_table_base);
    _diagnostic_mode_buffer = (short)((ulonglong)uVar3 >> 0x20);
  }
  else {
    _diagnostic_mode_buffer = _vp44_override_fuel_value;
  }
  uVar2 = vp44_flag_register_1 & 0x4000;
  if (((((vp44_flag_register_1 & 0x4000) == 0) ||
       (((engine_fault_status_register_1 & 2) != 0 &&
        (uVar2 = engine_fault_confirmation_register & 2, uVar2 != 0)))) ||
      (((engine_fault_status_register_1 & 1) != 0 &&
       (uVar2 = engine_fault_confirmation_register & 1, uVar2 != 0)))) ||
     (((engine_fault_status_register_1 & 0x10) != 0 &&
      (uVar2 = engine_fault_confirmation_register & 0x10, uVar2 != 0)))) {
    uVar1 = 0;
  }
  else {
    _diagnostic_correction_input = throttle_position_raw;
    uVar1 = lookupTableInterpolation((table_interp_args_t *)&diagnostic_correction_table_base);
    uVar2 = uVar1;
  }
  _diagnostic_mode_buffer = uVar1 + _diagnostic_mode_buffer;
  return uVar2;
}



/*
 * Function: timingParameterPointerSetup @ 0x0000b05c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void timingParameterPointerSetup(void)

{
  timing_table_1_ptr = 0x806e34;
  _diagnostic_fuel_table_base = 2;
  timing_table_2_ptr = 0x806e20;
  timing_table_2_base = 2;
  timing_table_3_ptr = 0x806e5a;
  _diagnostic_correction_input = throttle_position_raw;
  timing_table_4_ptr = 0x808862;
  timing_table_5_ptr = 0x808876;
  _diagnostic_correction_table_base = 2;
  return;
}



/*
 * Function: shutdownMinimumSelector16 @ 0x0000b0b0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void shutdownMinimumSelector16(void)

{
  if (_diagnostic_mode_buffer < shutdown_limit_accumulator) {
    shutdown_limit_accumulator = _diagnostic_mode_buffer;
    shutdown_minimum_selector_value = DIAGNOSTIC_MODE_BUFFER;
  }
  return;
}



/*
 * Function: diagnosticTimingIncrementController @ 0x0000b0ce
 */

void diagnosticTimingIncrementController(void)

{
  if (vp44_engine_state != 0x10) {
    diagnostic_timing_increment_value = 0;
    diagnostic_timing_increment_state = 0;
    return;
  }
  diagnostic_timing_increment_value =
       calibratible_timing_increment_that_is_added_to_base_timing_any_0_120;
  timing_protection_counter_1 = 1;
  diagnostic_timing_increment_state = 4;
  return;
}



/*
 * Function: fuelAdjustmentWithFlagUpdate @ 0x0000b0fe
 */

void fuelAdjustmentWithFlagUpdate(void)

{
  if ((short)(diagnostic_timing_increment_value + fuel_limit_minimum_value) < 0) {
    fuel_limit_minimum_value = 0;
  }
  else {
    fuel_limit_minimum_value = diagnostic_timing_increment_value + fuel_limit_minimum_value;
  }
  fuel_adjustment_active_flag =
       diagnostic_timing_increment_state | fuel_adjustment_active_flag & 0xfffb;
  return;
}



/*
 * Function: vp44TimingConditionChecker @ 0x0000b130
 */

undefined4 vp44TimingConditionChecker(void)

{
  undefined2 uVar1;
  uint uVar2;
  
  uVar2 = 0;
  if (((vp44_status_flags_1 & 0x8000) == 0) ||
     (uVar2 = (uint)vp44_timing_condition_value + (uint)insite_diagnostic_lower_bound,
     uVar2 < insite_diagnostic_reading)) {
    uVar1 = (undefined2)(uVar2 >> 0x10);
    vp44_status_threshold_flag = 0;
  }
  else {
    uVar1 = 0;
    if (((vp44_status_flags_1 & 0x8000) != 0) &&
       (uVar1 = 0, insite_diagnostic_reading < insite_diagnostic_lower_bound)) {
      vp44_status_threshold_flag = 1;
    }
  }
  return CONCAT22(uVar1,vp44_status_threshold_flag);
}



/*
 * Function: fuelTimingModeArbitrationSlowCycle40Coordinator @ 0x0000b18c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort fuelTimingModeArbitrationSlowCycle40Coordinator(void)

{
  undefined4 uVar1;
  
  if (((engine_operating_mode == ENGINE_IDLE) || (engine_operating_mode == LOW_RPM_RUNNING)) ||
     (engine_operating_mode == TRANSITIONAL_MODE_6)) {
    fuel_source_mode_11_state = 1;
    fuel_source_mode_11_timer = fuel_source_mode_11_timeout_value;
    fuel_mode_transition_state = 1;
    fuel_mode_transition_timer = fuel_mode_transition_timeout_value;
    timing_blend_state = 0;
    _timing_blend_accumulator = 0;
    timing_protection_blend_ramp = 0;
  }
  else {
    timingProtectionFlagsOrchestrator();
  }
  if (fuel_timing_mode_arbitration_param_1 == 0) {
    if ((fuel_demand_control_flags & 1) == 0) {
      uVar1 = vp44TimingConditionChecker();
      if ((short)uVar1 == 0) {
        if (((vp44_status_flags_1 & 0x4000) == 0) || (protection_mode_state != 1)) {
          timing_mode_source_selector = BLEND_RAMP_DEFAULT;
          fuel_timing_mode_blend_factor_965a = timing_protection_blend_ramp;
        }
        else {
          timing_mode_source_selector = ARBITRATION_2;
          fuel_timing_mode_blend_factor_965a = fuel_timing_mode_arbitration_2;
        }
      }
      else {
        timing_mode_source_selector = ARBITRATION_1;
        fuel_timing_mode_blend_factor_965a = fuel_timing_mode_arbitration_1;
      }
    }
    else {
      timing_mode_source_selector = ARBITRATION_VALUE;
      fuel_timing_mode_blend_factor_965a = fuel_timing_mode_arb_value;
    }
  }
  else {
    timing_mode_source_selector = PARAM_OVERRIDE;
    fuel_timing_mode_blend_factor_965a = fuel_timing_mode_arbitration_param_2;
  }
  if (0x4000 < fuel_timing_mode_blend_factor_965a) {
    fuel_timing_mode_blend_factor_965a = 0x4000;
  }
  if ((vp44_status_flags_2 & 0x10) == 0) {
    fuel_timing_mode_selector = fuel_timing_mode_blend_factor_965a;
  }
  return vp44_status_flags_2 & 0x10;
}



/*
 * Function: fuelTableBlendResultHandler @ 0x0000b27e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined2 fuelTableBlendResultHandler(void)

{
  if ((timing_protection_counter_2 == 1) && (timing_blend_threshold < timing_blend_state)) {
    timing_blend_state = timing_blend_threshold;
    _timing_blend_accumulator = (uint)timing_blend_threshold << 0x10;
  }
  timing_blend_state = coreTableInterpolation();
  if (timing_blend_state <= timing_blend_threshold) {
    return 0;
  }
  if (unnamed_data_6fb4 < timing_blend_state) {
    return 1;
  }
  return timing_fuel_blend_result;
}



/*
 * Function: fuelSourceOilPressureConditionChecker @ 0x0000b2ee
 */

uint fuelSourceOilPressureConditionChecker(void)

{
  uint in_D0;
  
  if (((vp44_engine_state != 10) && (protection_system_enable_flag != 1)) &&
     (oil_pressure_protection_enabled != 1)) {
    return in_D0 & 0xffff0000;
  }
  return 1;
}



/*
 * Function: fuelSourceMode11CountdownHandler @ 0x0000b314
 */

int fuelSourceMode11CountdownHandler(void)

{
  ushort uVar1;
  undefined4 in_D0;
  
  uVar1 = (ushort)((uint)in_D0 >> 0x10);
  if (vp44_engine_state == 0xb) {
    fuel_source_mode_11_timer = fuel_source_mode_11_timeout_value;
    fuel_source_mode_11_state = 1;
    return (uint)uVar1 << 0x10;
  }
  if ((fuel_source_mode_11_state == 1) && (fuel_source_mode_11_timer != 0)) {
    fuel_source_mode_11_timer = fuel_source_mode_11_timer - 1;
    return (uint)uVar1 << 0x10;
  }
  fuel_source_mode_11_state = 0;
  return 1;
}



/*
 * Function: fuelModeTransitionCountdownHandler @ 0x0000b35c
 */

int fuelModeTransitionCountdownHandler(void)

{
  ushort uVar1;
  undefined4 in_D0;
  
  uVar1 = (ushort)((uint)in_D0 >> 0x10);
  if ((timing_protection_counter_1 == 1) || (timing_protection_counter_2 == 1)) {
    fuel_mode_transition_timer = fuel_mode_transition_timeout_value;
    fuel_mode_transition_state = 1;
    return (uint)uVar1 << 0x10;
  }
  if ((fuel_mode_transition_state == 1) && (fuel_mode_transition_timer != 0)) {
    fuel_mode_transition_timer = fuel_mode_transition_timer - 1;
    return (uint)uVar1 << 0x10;
  }
  fuel_mode_transition_state = 0;
  return 1;
}



/*
 * Function: timingProtectionFlagsOrchestrator @ 0x0000b3ae
 */

uint timingProtectionFlagsOrchestrator(void)

{
  int iVar1;
  ushort uVar3;
  uint uVar2;
  
  uVar3 = 0;
  if ((vp44_status_flags_1 & 0x400) != 0) {
    iVar1 = fuelSourceMode11CountdownHandler();
    uVar3 = (ushort)iVar1;
    timing_mode_11_result = uVar3;
  }
  if ((vp44_status_flags_1 & 0x800) != 0) {
    iVar1 = fuelModeTransitionCountdownHandler();
    timing_transition_result = (word)iVar1;
    uVar3 = timing_transition_result | uVar3;
  }
  if ((vp44_status_flags_1 & 0x1000) != 0) {
    timing_fuel_blend_result = fuelTableBlendResultHandler();
    uVar3 = timing_fuel_blend_result | uVar3;
  }
  uVar2 = vp44_status_flags_1 & 0xffff2000;
  if ((vp44_status_flags_1 & 0x2000) != 0) {
    uVar2 = fuelSourceOilPressureConditionChecker();
    timing_oil_pressure_result = (word)uVar2;
    uVar3 = timing_oil_pressure_result | uVar3;
  }
  if (uVar3 == 0) {
    timing_protection_blend_ramp = 0;
  }
  else if (timing_protection_blend_ramp != 0x4000) {
    if (timing_protection_blend_ramp < timing_protection_blend_increment) {
      timing_protection_blend_ramp = timing_protection_flags_param + timing_protection_blend_ramp;
      uVar2 = (uint)timing_protection_blend_base + (uint)timing_protection_blend_increment;
      if (uVar2 < timing_protection_blend_ramp) {
        timing_protection_blend_ramp =
             timing_protection_blend_base + timing_protection_blend_increment;
        uVar2 = CONCAT22((short)(uVar2 >> 0x10),timing_protection_blend_ramp);
      }
    }
    else {
      uVar2 = CONCAT22((short)(uVar2 >> 0x10),timing_protection_blend_base);
      timing_protection_blend_ramp = timing_protection_blend_base + timing_protection_blend_ramp;
    }
  }
  if (0x4000 < timing_protection_blend_ramp) {
    timing_protection_blend_ramp = 0x4000;
  }
  timing_protection_counter_1 = 0;
  timing_protection_counter_2 = 0;
  return uVar2;
}



/*
 * Function: shutdownProtectionCalculator @ 0x0000b47e
 */

ulonglong shutdownProtectionCalculator(void)

{
  undefined2 uVar1;
  undefined4 in_D0;
  undefined4 uVar2;
  undefined4 in_D1;
  ulonglong uVar3;
  
  uVar1 = (undefined2)((uint)in_D0 >> 0x10);
  if (((fuel_demand_control_flags & 0x20) == 0) || (engine_operating_mode != HIGH_RPM_RUNNING)) {
    shutdown_protection_fuel_limit = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
    return CONCAT44(CONCAT22(uVar1,fuel_demand_control_flags),in_D1) & 0xffff0020ffffffff;
  }
  if ((((fault_status_flags_2 & 4) == 0) || ((accelerator_pedal_position & 4) == 0)) &&
     (((fault_status_flags_2 & 8) == 0 || ((accelerator_pedal_position & 8) == 0)))) {
    shutdown_protection_rpm_input = current_engine_rpm;
    shutdown_protection_diag_input = insite_diagnostic_reading;
    uVar3 = tableInterpolationLookup((short *)&fuel_parameter_pointer_3);
    shutdown_protection_fuel_limit = (word)(uVar3 >> 0x20);
    return uVar3;
  }
  uVar2 = CONCAT22(uVar1,current_engine_rpm);
  if (shutdown_protection_param_1 < current_engine_rpm) {
    shutdown_protection_fuel_limit = shutdown_protection_param_2;
    return CONCAT44(uVar2,in_D1);
  }
  shutdown_protection_fuel_limit = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
  return CONCAT44(uVar2,in_D1);
}



/*
 * Function: fuelParameterPointerSetup @ 0x0000b528
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelParameterPointerSetup(void)

{
  fuel_parameter_pointer_3._0_2_ = 2;
  ram0x00800076 = 0x806fba;
  fuel_parameter_pointer_2._0_2_ = 2;
  ram0x0080007e = 0x806fe0;
  fuel_parameter_pointer_1 = 0x806fea;
  return;
}



/*
 * Function: shutdownMinimumSelector15 @ 0x0000b556
 */

void shutdownMinimumSelector15(void)

{
  if (shutdown_protection_fuel_limit < shutdown_limit_accumulator) {
    shutdown_limit_accumulator = shutdown_protection_fuel_limit;
    shutdown_minimum_selector_value = SHUTDOWN_PROTECTION_LIMIT;
  }
  return;
}



/*
 * Function: rpmParameterPointerSetup @ 0x0000b574
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void rpmParameterPointerSetup(void)

{
  rpm_interpolation_lookup_arg = 2;
  rpm_parameter_pointer = 0x807886;
  _target_rpm_rate_limiter_reserved_9e = 0x807892;
  return;
}



/*
 * Function: targetRpmRateLimiter @ 0x0000b594
 */

void targetRpmRateLimiter(void)

{
  if (diagnostic_status_previous == 7) {
    target_rpm_rate_limiter_previous = target_rpm_rate_limiter_state;
  }
  else {
    target_rpm_rate_limiter_previous = target_engine_rpm;
  }
  target_rpm_rate_limiter_state = diagnostic_target_rpm_setpoint - target_rpm_rate_limiter_previous;
  if ((int)(short)target_rpm_rate_limiter_state < (int)-(uint)target_rpm_rate_limit) {
    target_rpm_rate_limiter_state = (word)-(uint)target_rpm_rate_limit;
  }
  if ((int)(uint)target_rpm_rate_limit < (int)(short)target_rpm_rate_limiter_state) {
    target_rpm_rate_limiter_state = target_rpm_rate_limit;
  }
  target_rpm_rate_limiter_state = target_rpm_rate_limiter_previous + target_rpm_rate_limiter_state;
  if ((int)((int)(short)target_rpm_rate_limiter_state - (uint)target_engine_rpm) < 0) {
    target_rpm_rate_limiter_output = -(target_rpm_rate_limiter_state - target_engine_rpm);
  }
  else {
    target_rpm_rate_limiter_output = target_rpm_rate_limiter_state - target_engine_rpm;
  }
  governor_interpolation_factor =
       lookupTableInterpolation((table_interp_args_t *)&rpm_interpolation_lookup_arg);
  target_engine_rpm =
       (word)((int)((uint)target_engine_rpm * (uint)governor_interpolation_factor +
                   (uint)diagnostic_target_rpm_setpoint *
                   (0x4000 - (uint)governor_interpolation_factor)) >> 0xe);
  return;
}



/*
 * Function: engine_speed_governor @ 0x0000b656
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engine_speed_governor(void)

{
  int iVar1;
  int rpm_error_integral;
  int iVar2;
  ushort pid_output_previous;
  int fuel_command_scaled;
  ushort rpm_error_previous;
  ushort derivative_term_previous;
  ushort rpm_error_clamped;
  
  dualTableLookupSum();
  if ((((diagnostic_status_register == DIAGNOSTIC_MODE_7) ||
       (diagnostic_status_register == DERATE_CONDITION_3)) ||
      (diagnostic_status_register == DERATE_CONDITION_2)) ||
     (diagnostic_status_register == DERATE_CONDITION_30)) {
    rpm_error_previous = governor_rpm_error;
    if (diagnostic_status_register != diagnostic_status_previous) {
      rpm_error_integral =
           (uint)governor_blend_factor_2 *
           ((int)_governor_speed_setpoint[3] + (int)_governor_speed_setpoint[2]);
      if (rpm_error_integral == 0) {
        target_engine_rpm = current_engine_rpm;
      }
      else {
        iVar2 = (int)(((uint)current_fuel_demand_value - (uint)governor_reference_fuel) *
                      (0x400 - (uint)governor_blend_factor_1) * 0x80) / rpm_error_integral;
        if (iVar2 < 0x30d4) {
          if (iVar2 < -0x30d3) {
            iVar2 = -32000;
          }
          else {
            iVar2 = (iVar2 << 8) / 100;
          }
        }
        else {
          iVar2 = 32000;
        }
        iVar2 = (uint)current_engine_rpm + iVar2;
        if (iVar2 < 0x10000) {
          if (iVar2 < 0) {
            target_engine_rpm = 0;
          }
          else {
            target_engine_rpm = (word)iVar2;
          }
        }
        else {
          target_engine_rpm = 0xffff;
        }
      }
      target_rpm_scaled = (uint)target_engine_rpm << 0x10;
      iVar2 = (uint)target_engine_rpm - (uint)current_engine_rpm;
      if (iVar2 < 32000) {
        if (iVar2 < -31999) {
          rpm_error_previous = 0x8300;
        }
        else {
          rpm_error_clamped = (ushort)iVar2;
          rpm_error_previous = rpm_error_clamped;
        }
      }
      else {
        rpm_error_previous = 32000;
      }
    }
    if (diagnostic_status_register == DIAGNOSTIC_MODE_7) {
      targetRpmRateLimiter();
    }
    else {
      target_engine_rpm = coreTableInterpolation();
      governor_interpolation_factor = (word)((int)(uint)*_governor_interpolation_input_1 >> 2);
    }
    iVar2 = (uint)target_engine_rpm - (uint)current_engine_rpm;
    if (iVar2 < 32000) {
      if (iVar2 < -31999) {
        governor_rpm_error = 0x8300;
      }
      else {
        rpm_error_clamped = (ushort)iVar2;
        governor_rpm_error = rpm_error_clamped;
      }
    }
    else {
      governor_rpm_error = 32000;
    }
    if (governor_mode_state == 1) {
      governor_mode_changed_flag = 1;
      _governor_pid_integral = (uint)governor_mode_init_integral << 0x10;
      _governor_proportional_state = governor_mode_init_rpm_ref;
      _governor_fuel_output_state = governor_reference_fuel;
      rpm_error_previous = governor_mode_init_error_prev;
      derivative_term_previous = governor_mode_init_deriv_prev;
      governor_fuel_command_delta = governor_mode_init_fuel_delta;
      fuel_command_scaled._2_2_ = governor_mode_init_output_prev;
    }
    else if ((_governor_derivative_state == current_fuel_demand_value) &&
            (diagnostic_status_register == diagnostic_status_previous)) {
      governor_mode_changed_flag = 0;
      derivative_term_previous = governor_pid_derivative_term_9d08;
      fuel_command_scaled._2_2_ = governor_pid_combined_output;
    }
    else {
      governor_mode_changed_flag = 1;
      if (governor_fuel_blend_limit_upper == governor_fuel_blend_limit_lower) {
        _governor_pid_integral = 0;
        fuel_command_scaled._2_2_ = 0;
      }
      else if (governor_reference_fuel < current_fuel_demand_value) {
        _governor_pid_integral =
             rpmFuelCalculation((uint)current_fuel_demand_value - (uint)governor_reference_fuel,
                                0x100 - (short)IHPHTMZA,
                                (int)(short)governor_fuel_blend_limit_upper -
                                (int)(short)governor_fuel_blend_limit_lower);
        if (0x1700 < _governor_pid_integral) {
          _governor_pid_integral = 0x1700;
        }
        fuel_command_scaled._2_2_ = (word)_governor_pid_integral;
        _governor_pid_integral = _governor_pid_integral << 0x10;
      }
      else {
        iVar2 = rpmFuelCalculation((uint)governor_reference_fuel - (uint)current_fuel_demand_value,
                                   0x100 - (short)IHPHTMZA,
                                   (int)(short)governor_fuel_blend_limit_upper -
                                   (int)(short)governor_fuel_blend_limit_lower);
        if (0x1700 < iVar2) {
          iVar2 = 0x1700;
        }
        _governor_pid_integral = (uint)(ushort)-(short)iVar2 << 0x10;
        fuel_command_scaled._2_2_ = -(short)iVar2;
      }
      _governor_proportional_state = current_engine_rpm;
      derivative_term_previous = 0;
      governor_fuel_command_delta = current_fuel_demand_value - governor_reference_fuel;
      _governor_fuel_output_state = governor_reference_fuel;
    }
    iVar2 = (uint)current_engine_rpm - (int)(short)_governor_proportional_state;
    if (iVar2 < 8000) {
      if (iVar2 < -7999) {
        governor_rpm_change_rate = 0xe0c0;
      }
      else {
        rpm_error_clamped = (ushort)iVar2;
        governor_rpm_change_rate = rpm_error_clamped;
      }
    }
    else {
      governor_rpm_change_rate = 8000;
    }
    _governor_proportional_state = current_engine_rpm;
    governor_rpm_error_delta = governor_rpm_error - rpm_error_previous;
    if ((short)governor_rpm_error_delta < 32000) {
      if ((short)governor_rpm_error_delta < -31999) {
        governor_rpm_error_delta = 0x8300;
      }
    }
    else {
      governor_rpm_error_delta = 32000;
    }
    governor_pid_proportional_accum =
         ((int)(short)rpm_error_previous *
          ((int)_governor_speed_setpoint[3] + (int)_governor_speed_setpoint[2]) +
         (int)(short)governor_rpm_error_delta *
         ((int)_governor_speed_setpoint[2] + (int)*_governor_speed_setpoint)) -
         (int)(short)governor_rpm_change_rate * (int)_governor_speed_setpoint[1] >> 9;
    if ((int)governor_pid_proportional_accum < 0xe6000) {
      if ((int)governor_pid_proportional_accum < -0xe5fff) {
        governor_pid_proportional_accum = 0xfff1a000;
      }
    }
    else {
      governor_pid_proportional_accum = 0xe6000;
    }
    rpm_error_clamped =
         (ushort)((int)(short)governor_rpm_error_delta * (int)_governor_speed_setpoint[4] -
                  (int)(short)governor_rpm_change_rate * (int)_governor_speed_setpoint[5] >> 0xd);
    if ((short)rpm_error_clamped < (short)governor_derivative_deadband) {
      if (-(int)(short)governor_derivative_deadband < (int)(short)rpm_error_clamped) {
        governor_derivative_filtered = 0;
      }
      else {
        governor_derivative_filtered = governor_derivative_deadband + rpm_error_clamped;
        if ((int)(short)governor_derivative_filtered <= -(int)(short)_IHPHSDXA) {
          governor_derivative_filtered = (word)-(int)(short)_IHPHSDXA;
        }
      }
    }
    else {
      governor_derivative_filtered = rpm_error_clamped - governor_derivative_deadband;
      if ((short)_IHPHSDXA <= (short)governor_derivative_filtered) {
        governor_derivative_filtered = _IHPHSDXA;
      }
    }
    rpm_error_clamped =
         (short)((int)(short)derivative_term_previous * (int)(short)governor_derivative_filter_coeff
                >> 10) +
         (short)((int)((uint)governor_blend_factor_2 * (int)(short)governor_derivative_filtered) >>
                10);
    if ((short)rpm_error_clamped < 0x1700) {
      if ((short)rpm_error_clamped < -0x16ff) {
        governor_pid_derivative_term_9d08 = 0xe900;
      }
      else {
        governor_pid_derivative_term_9d08 = rpm_error_clamped;
      }
    }
    else {
      governor_pid_derivative_term_9d08 = 0x1700;
    }
    _governor_pid_integral =
         (int)(short)derivative_term_previous * (governor_blend_factor_1 - 0x400) * 0x10 +
         ((int)((uint)governor_blend_factor_1 * (_governor_pid_integral >> 9)) >> 3) +
         ((int)(governor_pid_proportional_accum * governor_blend_factor_2) >> 1);
    if (_governor_pid_integral < -0x5c00000) {
      _governor_pid_integral = -0x17000000;
    }
    else if (_governor_pid_integral < 0x5c00000) {
      _governor_pid_integral = _governor_pid_integral * 4;
    }
    else {
      _governor_pid_integral = 0x17000000;
    }
    governor_pid_intermediate = _governor_pid_integral;
    governor_pid_combined_output = governor_pid_derivative_term_9d08 + _governor_pid_integral;
    if ((short)governor_pid_combined_output < -0x16ff) {
      governor_pid_combined_output = 0xe900;
    }
    else if (0x1700 < (short)governor_pid_combined_output) {
      governor_pid_combined_output = 0x1700;
    }
    iVar2 = (int)(short)governor_fuel_command_delta * (int)_governor_speed_setpoint[8] +
            ((int)(short)governor_pid_combined_output * (int)_governor_speed_setpoint[6] -
            (int)(short)fuel_command_scaled._2_2_ * (int)_governor_speed_setpoint[7]);
    iVar1 = iVar2 >> 8;
    if (iVar1 < -0x16ff) {
      governor_fuel_command_delta = 0xe900;
    }
    else if (iVar1 < 0x1700) {
      rpm_error_clamped = (ushort)((uint)iVar2 >> 8);
      governor_fuel_command_delta = rpm_error_clamped;
    }
    else {
      governor_fuel_command_delta = 0x1700;
    }
    _governor_fuel_output_state =
         (ushort)((int)((uint)_governor_fuel_output_state * (uint)governor_interpolation_factor +
                       (uint)governor_reference_fuel *
                       (0x4000 - (uint)governor_interpolation_factor)) >> 0xe);
    if (0x1700 < _governor_fuel_output_state) {
      _governor_fuel_output_state = 0x1700;
    }
    _governor_derivative_state = _governor_fuel_output_state + governor_fuel_command_delta;
    if ((short)_governor_derivative_state < (short)governor_output_upper_limit) {
      governor_output_clamped = _governor_derivative_state;
      if ((short)_governor_derivative_state <= (short)governor_output_lower_limit) {
        governor_output_clamped = governor_output_lower_limit;
      }
    }
    else {
      governor_output_clamped = governor_output_upper_limit;
    }
    cached_parameter_value = governor_output_clamped;
  }
  diagnostic_status_previous = diagnostic_status_register;
  return;
}



/*
 * Function: diagnosticDataCopyHandler @ 0x0000bdd4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticDataCopyHandler(void)

{
  if ((diag_governor_copy_enable_flag != 0) && (_derate_status_flag == 0)) {
    _derate_status_flag = 0x1e;
    diagnostic_target_rpm_setpoint = diag_governor_target_rpm_source;
    governor_blend_factor_1 = diag_governor_blend_factor_1;
    governor_blend_factor_2 = diag_governor_blend_factor_2;
    _governor_speed_setpoint = 0x809ce6;
    _governor_interpolation_input_1 = 0x809cd2;
    governor_mode_init_error_prev = diag_governor_error_prev_source;
    governor_mode_init_integral = diag_governor_integral_source;
    governor_mode_init_rpm_ref = diag_governor_rpm_ref_source;
    governor_mode_init_deriv_prev = diag_governor_deriv_prev_source;
    governor_mode_init_output_prev = diagnostic_data_copy_source;
    governor_mode_init_fuel_delta = diagnostic_data_copy_dest;
    governor_mode_state = diag_governor_mode_state_source;
    governor_output_upper_limit = diag_governor_output_upper_limit;
    governor_output_lower_limit = diag_governor_output_lower_limit;
  }
  return;
}



/*
 * Function: diagnosticStatus30Setter @ 0x0000be7c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticStatus30Setter(void)

{
  if ((diagnostic_status_register == NORMAL_OPERATION) && (_derate_status_flag == 0x1e)) {
    diagnostic_status_register = DERATE_CONDITION_30;
  }
  return;
}



/*
 * Function: diagnosticStatus2Initializer @ 0x0000be96
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticStatus2Initializer(undefined4 param_1)

{
  if ((diagnostic_status_register == NORMAL_OPERATION) && (_derate_status_flag == 2)) {
    diagnostic_status_register = DERATE_CONDITION_2;
    _governor_speed_setpoint =
         (uint)(ushort)fuel_arbitrator_diag_t_0080cff8._26_2_ * 0x12 + 0x8078fc;
    if (param_1._0_2_ != 2) {
      governor_mode_state = 0;
      governor_blend_factor_1 = 0x400;
      governor_blend_factor_2 = 0x400;
      governor_output_lower_limit = diag_mode_2_output_lower_limit;
      governor_output_upper_limit = diag_mode_2_output_upper_limit;
      _governor_interpolation_input_1 = 0x8078f6;
    }
  }
  return;
}



/*
 * Function: diagnosticState2Initializer @ 0x0000bf0a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticState2Initializer(void)

{
  if ((_derate_status_flag == 0) && (fuel_arbitrator_diag_t_0080cff8.rpm_target == 1)) {
    _derate_status_flag = 2;
    diagnostic_target_rpm_setpoint = fuel_arbitrator_diag_t_0080cff8.state_pointer._1_2_;
  }
  return;
}



/*
 * Function: derate_application_controller @ 0x0000bf2e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void derate_application_controller(void)

{
  _derate_base_value = derate_base_calibration_value;
  _derate_min_limit = *_derate_min_limit_ptr;
  _derate_max_limit = *_derate_max_limit_ptr;
  _calculated_derate_output =
       _derate_min_limit +
       (short)(((uint)active_derate_value * ((uint)_derate_max_limit - (uint)_derate_min_limit)) /
              400);
  _derate_status_flag = 0;
  diagnosticDataCopyHandler();
  diagnosticState2Initializer();
  diagnosticState7Setter();
  return;
}



/*
 * Function: initDerateSystemPointers @ 0x0000bf9c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initDerateSystemPointers(void)

{
  _derate_min_limit_ptr = 0x8036b6;
  _derate_max_limit_ptr = 0x8036b8;
  _derate_base_value = derate_base_calibration_value;
  return;
}



/*
 * Function: diagnosticValueCalculator @ 0x0000bfbc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticValueCalculator(void)

{
  uint uVar1;
  
  if (_derate_base_value == 1) {
    diag_mode_1_target_rpm_arg = diagnostic_target_rpm_setpoint;
    diag_interpolation_result =
         lookupTableInterpolation((table_interp_args_t *)&diagnostic_table_pointer_2);
  }
  else if (_derate_base_value == 0) {
    diag_mode_0_target_rpm_arg = diagnostic_target_rpm_setpoint;
    diag_interpolation_result =
         lookupTableInterpolation((table_interp_args_t *)&diagnostic_table_pointer_4);
  }
  uVar1 = (uint)(ushort)(diag_blend_factor_offset + diag_blend_factor_base) *
          (uint)diag_interpolation_result;
  if (uVar1 < 0x2655879) {
    diag_governor_blend_result_1 =
         (word)((0x2655879 - uVar1 >> 1) / (uVar1 + 0x2655879 >> 0xb & 0xffff));
  }
  else {
    diag_governor_blend_result_1 = 0;
  }
  diag_governor_blend_result_2 = (word)((int)(diag_governor_blend_result_1 + 0x400) >> 1);
  governor_blend_factor_1 = diag_governor_blend_result_1;
  governor_blend_factor_2 = diag_governor_blend_result_2;
  return;
}



/*
 * Function: diagnosticStatus7Initializer @ 0x0000c084
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticStatus7Initializer(undefined4 param_1)

{
  if ((diagnostic_status_register == NORMAL_OPERATION) && (diagnostic_mode_7_enable_flag == 1)) {
    diagnostic_status_register = DIAGNOSTIC_MODE_7;
    diagnosticValueCalculator();
    if ((param_1._0_2_ != 7) && (param_1._0_2_ != 3)) {
      _governor_speed_setpoint = 0x8078a4;
      governor_mode_state = 0;
      governor_output_lower_limit = diag_mode_7_output_lower_limit;
      governor_output_upper_limit = diag_mode_7_output_upper_limit;
      _governor_interpolation_input_1 = 0x80789e;
    }
  }
  return;
}



/*
 * Function: diagnosticState7Setter @ 0x0000c0e6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticState7Setter(void)

{
  if (_derate_status_flag == 0) {
    diagnostic_target_rpm_setpoint = _calculated_derate_output;
    _derate_status_flag = 7;
  }
  return;
}



/*
 * Function: diagnosticTablePointerSetup @ 0x0000c100
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticTablePointerSetup(void)

{
  diagnostic_table_pointer_4 = 2;
  diagnostic_table_5_ptr = 0x8078b6;
  _diagnostic_table_pointer_3 = 0x8078c6;
  diagnostic_table_pointer_2 = 2;
  diagnostic_table_6_ptr = 0x8078d6;
  _diagnostic_table_pointer_1 = 0x8078e6;
  _derate_base_value = 0;
  return;
}



/*
 * Function: tpuTimerInitializer @ 0x0000c144
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void tpuTimerInitializer(void)

{
  _tpu_timer_channel_config = &serial_port_2_base_register;
  serial_port_1_isr_state = 6;
  toucan_mb0_timer = 0x2240;
  toucan_mb0_id_low._0_1_ = 0x80;
  toucan_mb0_control = 0x9955;
  toucan_mb1_timer = 0x2000;
  toucan_mb1_id_low._0_1_ = 0x88;
  toucan_mb1_control = 0x5559;
  toucan_mb2_timer = 0xa240;
  toucan_mb2_id_low._0_1_ = 0x80;
  toucan_mb2_control = 0x9955;
  toucan_mb3_timer = 0xa000;
  toucan_mb3_id_low._0_1_ = 0x88;
  toucan_mb3_control = 0x5559;
  toucan_mb4_timer = 0xe240;
  toucan_mb4_id_low._0_1_ = 0x80;
  toucan_mb4_control = 0x9955;
  toucan_mb5_timer = 0xe000;
  toucan_mb5_id_low._0_1_ = 0x88;
  toucan_mb5_control = 0x5559;
  serial_port_2_base_register._0_1_ = serial_port_2_base_register._0_1_ | 10;
  return;
}



/*
 * Function: emptyStubFunction1 @ 0x0000c1f0
 */

void emptyStubFunction1(void)

{
  return;
}



/*
 * Function: modeBasedDataDispatcher @ 0x0000c1f2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void modeBasedDataDispatcher(undefined4 param_1)

{
  char cVar1;
  
  cVar1 = (char)((uint)param_1 >> 0x10);
  if (cVar1 == '\x01') {
    vp44TimingRangeValidation();
    vp44CanMessage100Parser(_tpu_timer_channel_config + 0x10);
    return;
  }
  if (cVar1 == '\x03') {
    vp44CanMessage200Parser(_tpu_timer_channel_config + 0x30);
    return;
  }
  if (cVar1 == '\x05') {
    vp44CanMessage200ResponseBuilder();
    vp44CanMessage300Parser(_tpu_timer_channel_config + 0x50);
  }
  return;
}



/*
 * Function: emptyStubFunction3 @ 0x0000c260
 */

void emptyStubFunction3(void)

{
  return;
}



/*
 * Function: emptyStubFunction2 @ 0x0000c262
 */

void emptyStubFunction2(void)

{
  return;
}



/*
 * Function: boostPressureControlInit @ 0x0000c264
 */

void boostPressureControlInit(void)

{
  fuelLimitEngineStateCapture();
  writeHourMeterConversionData();
  return;
}



/*
 * Function: engineProtectionSystemInit @ 0x0000c272
 */

void engineProtectionSystemInit(void)

{
  engine_protection_init();
  diagnosticParameterPointersInit();
  vp44ControlVariablesReset();
  fuelTempControlFlagChecker();
  fuelLimitRestoreFromCapture();
  calibrationDataValidatorInit();
  fuelArbitratorVariablesInit();
  derateTablePointerInit();
  boostPressureControlStateInit();
  statisticsTrackingFlagsReset();
  timerCaptureHardwareInit();
  oilPressureTablePointersInit();
  protectionLimitValueInit();
  initProtectionTablePointer();
  rpmParameterPointerSetup();
  interpolationTableSetup();
  vp44StateVariablesInit();
  vp44TimingValuesInit();
  sensorFaultBasedRpmSourceSelector();
  engineModeOutputControlInit();
  fuelDemandTablePointersInit();
  simTimerControlInit();
  vp44TimingStateInit();
  outputControlFlagsInit();
  vp44FaultProtectionSystemInit();
  governor_rpm_error_value = governor_rpm_error_init_value;
  fuelDemandControllerInit();
  ioControlRegistersInit();
  vp44ControlFlagsInit();
  dzgTimingStateVariablesInit();
  sensorHistoryTablePointerInit();
  vp44DiagnosticStateInit();
  initHourMeterConversionData();
  return;
}



/*
 * Function: initBoostProtectionSystem @ 0x0000c33e
 */

void initBoostProtectionSystem(void)

{
  protection_system_enable_flag = 0;
  target_boost_pressure_base = 0;
  throttle_position_value = 0;
  throttle_position_filtered = 0;
  fuel_temp_protection_threshold_flag = 0;
  fuel_arbitrator_threshold_4 = oil_pressure_precrank_status;
  return;
}



/*
 * Function: periodicIoAndCanFaultMonitor @ 0x0000c368
 */

void periodicIoAndCanFaultMonitor(void)

{
  io_can_fault_monitor_state = io_can_fault_monitor_state + 1;
  if (4 < io_can_fault_monitor_state) {
    io_can_fault_monitor_state = 0;
  }
  if (io_can_fault_monitor_state == 1) {
    if (((io_control_state_delay & 0x80) != 0) == ((can_pin_switching_control_flags & 0x20) != 0)) {
      if (((io_fault_status_reg_2 & 0x80) != 0) && ((io_fault_latch_reg_2 & 0x80) == 0)) {
        io_fault_status_reg_2 = io_fault_status_reg_2 & 0xff7f;
        can_pin_fault_persistence_counter = 0;
      }
    }
    else if (can_pin_fault_persistence_counter < fault_persistence_threshold) {
      can_pin_fault_persistence_counter = can_pin_fault_persistence_counter + 1;
    }
    else {
      io_fault_status_reg_2 = io_fault_status_reg_2 | 0x80;
      io_fault_latch_reg_2 = io_fault_latch_reg_2 | 0x80;
    }
    if (((vp44_io_can_fault_state & 0x80) != 0) == ((io_control_flags & 0x80) != 0)) {
      if (((io_fault_status_reg_2 & 0x40) != 0) && ((io_fault_latch_reg_2 & 0x40) == 0)) {
        io_fault_status_reg_2 = io_fault_status_reg_2 & 0xffbf;
        io_control_fault_persistence_counter_1 = 0;
      }
    }
    else if (io_control_fault_persistence_counter_1 < fault_persistence_threshold) {
      io_control_fault_persistence_counter_1 = io_control_fault_persistence_counter_1 + 1;
    }
    else {
      io_fault_status_reg_2 = io_fault_status_reg_2 | 0x40;
      io_fault_latch_reg_2 = io_fault_latch_reg_2 | 0x40;
    }
    if (((vp44_io_can_fault_state & 1) != 0) == ((io_control_flags & 1) != 0)) {
      if (((io_fault_status_reg_2 & 0x20) != 0) && ((io_fault_latch_reg_2 & 0x20) == 0)) {
        io_fault_status_reg_2 = io_fault_status_reg_2 & 0xffdf;
        io_control_fault_persistence_counter_2 = 0;
      }
    }
    else if (io_control_fault_persistence_counter_2 < fault_persistence_threshold) {
      io_control_fault_persistence_counter_2 = io_control_fault_persistence_counter_2 + 1;
    }
    else {
      io_fault_status_reg_2 = io_fault_status_reg_2 | 0x20;
      io_fault_latch_reg_2 = io_fault_latch_reg_2 | 0x20;
    }
    if (((vp44_io_can_fault_state & 2) != 0) == ((io_control_flags & 2) != 0)) {
      if (((engine_fault_register_a & 0x4000) != 0) && ((engine_fault_register_c & 0x4000) == 0)) {
        engine_fault_register_a = engine_fault_register_a & 0xbfff;
        can_fault_monitor_counter = 0;
      }
    }
    else if (can_fault_monitor_counter < fault_persistence_threshold) {
      can_fault_monitor_counter = can_fault_monitor_counter + 1;
    }
    else {
      engine_fault_register_a = engine_fault_register_a | 0x4000;
      engine_fault_register_c = engine_fault_register_c | 0x4000;
    }
    if (((vp44_io_can_fault_state & 4) != 0) == ((io_control_flags & 4) != 0)) {
      if ((engine_fault_register_a & 0x8000) != 0) {
        if ((engine_fault_register_c & 0x8000) == 0) {
          engine_fault_register_a = engine_fault_register_a & 0x7fff;
          io_control_fault_persistence_counter_4 = 0;
        }
      }
    }
    else if (io_control_fault_persistence_counter_4 < fault_persistence_threshold) {
      io_control_fault_persistence_counter_4 = io_control_fault_persistence_counter_4 + 1;
    }
    else {
      engine_fault_register_a = engine_fault_register_a | 0x8000;
      engine_fault_register_c = engine_fault_register_c | 0x8000;
    }
    if (((vp44_io_can_fault_state & 0x20) != 0) == ((io_control_flags & 0x20) != 0)) {
      if (((io_fault_status_reg_4 & 0x2000) != 0) && ((io_fault_latch_reg_4 & 0x2000) == 0)) {
        io_fault_status_reg_4 = io_fault_status_reg_4 & 0xdfff;
        io_control_fault_persistence_counter_5 = 0;
      }
    }
    else if (io_control_fault_persistence_counter_5 < fault_persistence_threshold) {
      io_control_fault_persistence_counter_5 = io_control_fault_persistence_counter_5 + 1;
    }
    else {
      io_fault_status_reg_4 = io_fault_status_reg_4 | 0x2000;
      io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x2000;
    }
    if (((vp44_io_can_fault_state & 0x10) != 0) == ((io_control_flags & 0x10) != 0)) {
      if (((io_fault_status_reg_2 & 0x100) != 0) && ((io_fault_latch_reg_2 & 0x100) == 0)) {
        io_fault_status_reg_2 = io_fault_status_reg_2 & 0xfeff;
        io_control_fault_persistence_counter_6 = 0;
      }
    }
    else if (io_control_fault_persistence_counter_6 < fault_persistence_threshold) {
      io_control_fault_persistence_counter_6 = io_control_fault_persistence_counter_6 + 1;
    }
    else {
      io_fault_status_reg_2 = io_fault_status_reg_2 | 0x100;
      io_fault_latch_reg_2 = io_fault_latch_reg_2 | 0x100;
    }
    if (((vp44_io_can_fault_state & 0x40) != 0) == ((io_control_flags & 0x40) != 0)) {
      if (((io_fault_status_reg_3 & 0x4000) != 0) && ((io_fault_latch_reg_3 & 0x4000) == 0)) {
        io_fault_status_reg_3 = io_fault_status_reg_3 & 0xbfff;
        accelerator_throttle_fault_counter = 0;
      }
    }
    else if (accelerator_throttle_fault_counter < fault_persistence_threshold) {
      accelerator_throttle_fault_counter = accelerator_throttle_fault_counter + 1;
    }
    else {
      io_fault_status_reg_3 = io_fault_status_reg_3 | 0x4000;
      io_fault_latch_reg_3 = io_fault_latch_reg_3 | 0x4000;
    }
    if (((vp44_io_can_fault_state & 8) != 0) != ((io_control_flags & 8) != 0)) {
      if (io_control_fault_persistence_counter_7 < fault_persistence_threshold) {
        io_control_fault_persistence_counter_7 = io_control_fault_persistence_counter_7 + 1;
        return;
      }
      io_fault_status_reg_3 = io_fault_status_reg_3 | 0x800;
      io_fault_latch_reg_3 = io_fault_latch_reg_3 | 0x800;
      return;
    }
    if (((io_fault_status_reg_3 & 0x800) != 0) && ((io_fault_latch_reg_3 & 0x800) == 0)) {
      io_fault_status_reg_3 = io_fault_status_reg_3 & 0xf7ff;
      io_control_fault_persistence_counter_7 = 0;
    }
  }
  return;
}



/*
 * Function: acceleratorThrottleFaultDetector @ 0x0000c8c2
 */

uint acceleratorThrottleFaultDetector(void)

{
  undefined2 uVar1;
  uint in_D0;
  uint uVar2;
  
  if (engine_operating_mode == HIGH_RPM_RUNNING) {
    if (((fault_status_flags_2 & 0x400) == 0) || ((accelerator_pedal_position & 0x400) == 0)) {
      in_D0 = 0;
    }
    else {
      in_D0 = 1;
    }
    if (in_D0 == 0) {
      if (((fault_status_flags_2 & 0x200) == 0) || ((accelerator_pedal_position & 0x200) == 0)) {
        in_D0 = 0;
      }
      else {
        in_D0 = 1;
      }
      if ((in_D0 == 0) &&
         (in_D0 = (uint)BSTATBZA + (uint)governor_rpm_error_value, current_engine_rpm_raw <= in_D0))
      {
        uVar1 = (undefined2)(in_D0 >> 0x10);
        in_D0 = CONCAT22(uVar1,asthrfes_calc_input);
        if (asthrfes_calc_input <= accel_throttle_fault_upper_threshold) {
          if (accel_throttle_fault_delay_counter < accel_throttle_fault_delay_threshold) {
            accel_throttle_fault_delay_counter = accel_throttle_fault_delay_counter + 1;
          }
          if (accel_throttle_fault_delay_counter == accel_throttle_fault_delay_threshold) {
            if (accel_throttle_diag_reading_threshold < diagnostic_sensor_reading) {
              if (accelerator_throttle_fault_state < accel_throttle_fault_count_threshold) {
                accelerator_throttle_fault_state = accelerator_throttle_fault_state + 1;
              }
            }
            else if (accelerator_throttle_fault_state != 0) {
              accelerator_throttle_fault_state = accelerator_throttle_fault_state - 1;
            }
          }
          if (accelerator_throttle_fault_state == accel_throttle_fault_count_threshold) {
            fault_status_flags_2 = fault_status_flags_2 | 0x2000;
            fault_status_flags_8_previous = fault_status_flags_8_previous | 0x2000;
          }
          if (accelerator_throttle_fault_state != 0) {
            return CONCAT22(uVar1,accelerator_throttle_fault_state);
          }
          if ((fault_status_flags_2 & 0x2000) == 0) {
            return CONCAT22(uVar1,fault_status_flags_2) & 0xffff2000;
          }
          uVar2 = CONCAT22(uVar1,fault_status_flags_8_previous) & 0xffff2000;
          if ((fault_status_flags_8_previous & 0x2000) != 0) {
            return uVar2;
          }
          fault_status_flags_2 = fault_status_flags_2 & 0xdfff;
          return uVar2;
        }
      }
    }
  }
  accelerator_throttle_fault_state = 0;
  accel_throttle_fault_delay_counter = 0;
  return in_D0;
}



/*
 * Function: insiteParameterTableIterator @ 0x0000c9f0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteParameterTableIterator(void)

{
  short sVar1;
  byte bVar2;
  byte bVar3;
  
  insite_parameter_table_ptr = (dword)&insite_parameter_table_start;
  insite_parameter_checksum_ptr = (dword)&insite_parameter_checksum_buffer;
  insite_response_continuation_ptr = can_transmit_buffer_ptr;
  _insite_response_buffer_ptr = can_transmit_buffer_ptr;
  insite_data_valid_flag = 0;
  insite_response_buffer_index = 0;
  insite_command_byte = insite_parameter_table_start;
  for (bVar2 = 0; (insite_command_byte != 0 && (bVar2 < 0x1e)); bVar2 = bVar2 + 1) {
    if (insite_parameter_table_current_byte == *(byte *)insite_parameter_checksum_ptr) {
      *(char *)insite_parameter_checksum_ptr =
           *(char *)(insite_parameter_table_ptr + 1) + *(char *)insite_parameter_checksum_ptr;
      bVar3 = '\x01' << (insite_command_byte & 7);
      sVar1 = (short)((int)(uint)insite_command_byte >> 3);
      if (((bVar3 & *(byte *)((int)&
                                   maximum_time_between_tailshaft_pulses_allowed_before_vehicle_0_04_40
                             + (int)sVar1)) != 0) && ((bVar3 & *(byte *)(sVar1 + 0x8055fe)) == 0)) {
        insiteParameterResponseBuilder();
      }
    }
    insite_parameter_table_ptr = insite_parameter_table_ptr + 3;
    insite_command_byte = *(byte *)insite_parameter_table_ptr;
    insite_parameter_checksum_ptr = insite_parameter_checksum_ptr + 1;
  }
  responseBufferFinalize();
  return;
}



/*
 * Function: diagnosticMessageTransmissionManager @ 0x0000caa8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint diagnosticMessageTransmissionManager(void)

{
  byte bVar1;
  byte bVar2;
  undefined2 uVar3;
  undefined2 extraout_D0u;
  undefined4 in_D0;
  uint uVar4;
  
  uVar3 = (undefined2)((uint)in_D0 >> 0x10);
  if (((_diagnostic_service_enable_flags & 4) != 0) && ((diagnostic_command_state & 2) != 0)) {
    diagnosticMessage45Builder();
    bVar1 = diagnostic_message_alternation_counter + 1;
    bVar2 = diagnostic_message_alternation_counter & 1;
    uVar3 = 0;
    diagnostic_message_alternation_counter = bVar1;
    if (bVar2 == 0) {
      diagnosticMessage53Builder();
      uVar3 = extraout_D0u;
    }
  }
  uVar4 = CONCAT22(uVar3,_diagnostic_service_enable_flags) & 0xffff0002;
  if ((_diagnostic_service_enable_flags & 2) != 0) {
    main_loop_iteration_counter = main_loop_iteration_counter + 1;
    uVar4 = main_loop_iteration_counter & 1;
    if (((main_loop_iteration_counter & 1) == 0) &&
       (uVar4 = diagnostic_command_state & 1, (diagnostic_command_state & 1) != 0)) {
      uVar4 = insiteParameterTableIterator();
      insite_parameter_table_current_byte = insite_parameter_table_current_byte + 1;
    }
  }
  return uVar4;
}



/*
 * Function: insiteParameterResponseBuilder @ 0x0000cb1e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteParameterResponseBuilder(void)

{
  undefined2 uVar1;
  
  if (insite_response_buffer_index == 0) {
    _insite_response_buffer_ptr =
         (undefined1 *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = 0x80;
    _insite_response_buffer_ptr =
         (undefined1 *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    insite_response_buffer_index = 1;
    responseBufferSpaceCheck();
    if (insite_bytes_remaining == 0) {
      io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
      io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
      return;
    }
  }
  uVar1 = parameterLookupForInsite();
  insite_response_buffer_length = (byte)uVar1;
  if (insite_response_buffer_length == 0) {
    return;
  }
  if (insite_response_buffer_length <= insite_bytes_remaining) {
    insiteCommandByteDispatcher();
    return;
  }
  if (1 < insite_response_buffer_index) {
    responseBufferFinalize();
    insite_response_continuation_ptr = (dword)_insite_response_buffer_ptr;
    responseBufferSpaceCheck();
    if (insite_bytes_remaining < 4) {
      insite_bytes_remaining = 0;
      insite_response_buffer_index = 0;
      io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
      io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
      return;
    }
    _insite_response_buffer_ptr =
         (undefined1 *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = 0x80;
    _insite_response_buffer_ptr =
         (undefined1 *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    insite_response_buffer_index = 1;
  }
  if ((insite_response_buffer_length < 0x14) &&
     (insite_bytes_remaining < insite_response_buffer_length)) {
    io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
    return;
  }
  insiteCommandByteDispatcher();
  return;
}



/*
 * Function: diagnosticCodeTableSearch @ 0x0000cc34
 */

uint diagnosticCodeTableSearch(undefined4 param_1)

{
  uint in_D0;
  byte bVar1;
  
  bVar1 = 1;
  while( true ) {
    if (diagnostic_pending_code_count < bVar1) {
      return in_D0 & 0xffffff00;
    }
    in_D0 = 0;
    if ((byte)((uint)param_1 >> 0x10) == (&diagnostic_pending_code_count)[(short)(ushort)bVar1])
    break;
    bVar1 = bVar1 + 1;
  }
  return 1;
}



/*
 * Function: insiteCommandByteDispatcher @ 0x0000cc64
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteCommandByteDispatcher(void)

{
  dword dVar1;
  uint uVar2;
  undefined2 uVar3;
  undefined2 uVar4;
  undefined4 unaff_D2;
  byte bVar5;
  char cVar6;
  undefined2 uVar7;
  undefined4 local_a;
  undefined2 local_6;
  
  dVar1 = insite_command_base_value;
  uVar7 = (undefined2)((uint)unaff_D2 >> 0x10);
  if (insite_command_byte < 0x80) {
    if (insite_command_byte < 0x59) {
      if (insite_command_byte < 0x54) {
        if (insite_command_byte == 2) {
          bVar5 = 0;
          uVar2 = diagnosticCodeTableSearch((uint)CONCAT12(insite_dtc_search_code_9,uVar7));
          if ((char)uVar2 == '\0') {
            uVar2 = diagnosticCodeTableSearch
                              (CONCAT22((short)CONCAT31((int3)(uVar2 >> 8),insite_dtc_search_code_8)
                                        ,uVar7));
            if ((char)uVar2 == '\0') {
              uVar2 = diagnosticCodeTableSearch
                                (CONCAT22((short)CONCAT31((int3)(uVar2 >> 8),
                                                          insite_dtc_search_code_7),uVar7));
              if ((char)uVar2 != '\0') {
                bVar5 = 0x20;
              }
            }
            else {
              bVar5 = 0x20;
            }
          }
          else {
            bVar5 = 0x20;
          }
          uVar3 = (undefined2)CONCAT31((int3)(uVar2 >> 8),insite_dtc_search_code_1);
          uVar2 = diagnosticCodeTableSearch(CONCAT22(uVar3,uVar7));
          if ((char)uVar2 != '\0') {
            bVar5 = bVar5 | 0x10;
          }
          uVar4 = (undefined2)CONCAT31((int3)(uVar2 >> 8),insite_dtc_search_code_3);
          uVar2 = diagnosticCodeTableSearch(CONCAT22(uVar4,uVar3));
          if ((char)uVar2 != '\0') {
            bVar5 = bVar5 | 8;
          }
          uVar3 = (undefined2)CONCAT31((int3)(uVar2 >> 8),insite_dtc_search_code_4);
          uVar2 = diagnosticCodeTableSearch(CONCAT22(uVar3,uVar4));
          if ((char)uVar2 != '\0') {
            bVar5 = bVar5 | 4;
          }
          uVar2 = diagnosticCodeTableSearch
                            (CONCAT22((short)CONCAT31((int3)(uVar2 >> 8),insite_dtc_search_code_5),
                                      uVar3));
          if ((char)uVar2 == '\0') {
            uVar2 = diagnosticCodeTableSearch
                              (CONCAT22((short)CONCAT31((int3)(uVar2 >> 8),insite_dtc_search_code_6)
                                        ,uVar7));
            if ((char)uVar2 != '\0') {
              bVar5 = bVar5 | 2;
            }
          }
          else {
            bVar5 = bVar5 | 2;
          }
          uVar2 = diagnosticCodeTableSearch
                            (CONCAT22((short)CONCAT31((int3)(uVar2 >> 8),insite_dtc_search_code_2),
                                      uVar7));
          if ((char)uVar2 != '\0') {
            bVar5 = bVar5 | 1;
          }
        }
        else if (insite_command_byte == 3) {
          bVar5 = (derate_status_byte & 0x80) != 0;
          if ((derate_status_byte & 0x40) != 0) {
            bVar5 = bVar5 | 2;
          }
          if ((derate_status_byte & 0x20) != 0) {
            bVar5 = bVar5 | 4;
          }
        }
        else if (insite_command_byte == 0x47) {
          bVar5 = 0;
          if ((high_rpm_protection_timer != 0) &&
             (high_rpm_protection_timer < high_rpm_protection_initial_timer)) {
            bVar5 = 0x80;
          }
          if ((diagnostic_system_flags_1 & 2) != 0) {
            bVar5 = bVar5 | 8;
          }
          if ((high_rpm_protection_fault_flag != 0) && ((diagnostic_system_flags_1 & 4) != 0)) {
            bVar5 = bVar5 | 4;
          }
          if ((high_rpm_shutdown_active_flag != 0) && (high_rpm_protection_timer == 0)) {
            bVar5 = bVar5 | 2;
          }
          if (high_rpm_protection_warning_flag != 0) {
            bVar5 = bVar5 | 1;
          }
        }
        else if (insite_command_byte == 0x4a) {
          bVar5 = (byte)((int)(uint)boost_pressure_target_pointer >> 7);
        }
        else {
          if (insite_command_byte != 0x53) {
            return;
          }
          if (diagnostic_fuel_control_mode == 10) {
            bVar5 = 0x80;
          }
          else {
            bVar5 = 0;
          }
        }
        *_insite_response_buffer_ptr = insite_command_byte;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        *_insite_response_buffer_ptr = bVar5;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      }
      else {
        switch(insite_command_byte) {
        case 0x54:
          bVar5 = (byte)((int)(uint)throttle_position_value >> 7);
          break;
        case 0x55:
          bVar5 = 0;
          if (protection_system_enable_flag != 0) {
            bVar5 = 0x80;
          }
          if ((derate_status_byte & 4) != 0) {
            bVar5 = bVar5 | 0x40;
          }
          if ((derate_status_byte & 8) != 0) {
            bVar5 = bVar5 | 0x20;
          }
          if ((sensor_status_register & 2) != 0) {
            bVar5 = bVar5 | 0x10;
          }
          if ((sensor_status_register & 1) != 0) {
            bVar5 = bVar5 | 8;
          }
          if ((sensor_status_register & 8) != 0) {
            bVar5 = bVar5 | 4;
          }
          if ((sensor_status_register & 4) != 0) {
            bVar5 = bVar5 | 2;
          }
          if ((sensor_status_register & 0x10) != 0) {
            bVar5 = bVar5 | 1;
          }
          break;
        case 0x56:
          bVar5 = (byte)((int)(uint)target_boost_pressure_base >> 7);
          break;
        case 0x57:
          bVar5 = (byte)((int)(uint)fuel_timing_transition_limit >> 7);
          break;
        case 0x58:
          bVar5 = (byte)((int)(uint)insite_fuel_timing_display >> 7);
          break;
        default:
          goto switchD_0000ce84_default;
        }
        *_insite_response_buffer_ptr = insite_command_byte;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        *_insite_response_buffer_ptr = bVar5;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      }
    }
    else if (insite_command_byte < 0x69) {
      if (insite_command_byte == 0x59) {
        local_6._1_1_ = 0;
        if (oil_pressure_protection_enabled != 0) {
          local_6._1_1_ = 0x80;
        }
        if ((derate_status_byte & 4) != 0) {
          local_6._1_1_ = (byte)local_6 | 0x40;
        }
        if ((derate_status_byte & 8) != 0) {
          local_6._1_1_ = (byte)local_6 | 0x20;
        }
        if ((sensor_status_register & 2) != 0) {
          local_6._1_1_ = (byte)local_6 | 0x10;
        }
        if ((sensor_status_register & 1) != 0) {
          local_6._1_1_ = (byte)local_6 | 8;
        }
        if ((sensor_status_register & 8) != 0) {
          local_6._1_1_ = (byte)local_6 | 4;
        }
        if ((sensor_status_register & 4) != 0) {
          local_6._1_1_ = (byte)local_6 | 2;
        }
        if ((sensor_status_register & 0x10) != 0) {
          local_6._1_1_ = (byte)local_6 | 1;
        }
      }
      else if (insite_command_byte == 0x5b) {
        local_6._1_1_ = (byte)(((uint)active_derate_value * 0xfa) / 400);
      }
      else if (insite_command_byte == 0x5c) {
        local_6._1_1_ = (byte)((int)(uint)asthrfes_calc_input >> 7);
      }
      else if (insite_command_byte == 100) {
        local_6._1_1_ = (byte)((int)(uint)insite_parameter_display_value >> 6);
      }
      else {
        if (insite_command_byte != 0x66) {
          return;
        }
        if ((ushort)((int)(uint)diagnostic_sensor_reading >> 4) < 0xff) {
          local_6._1_1_ = (byte)((int)(uint)diagnostic_sensor_reading >> 4);
        }
        else {
          local_6._1_1_ = 0xff;
        }
      }
      *_insite_response_buffer_ptr = insite_command_byte;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      *_insite_response_buffer_ptr = (byte)local_6;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    }
    else {
      if (insite_command_byte == 0x69) {
        if (intake_manifold_temp_raw < 0x1900) {
          cVar6 = '\0';
        }
        else {
          cVar6 = (char)((int)(intake_manifold_temp_raw - 0x1900) >> 7);
        }
      }
      else if (insite_command_byte == 0x6c) {
        cVar6 = (char)((int)(uint)insite_diagnostic_reading >> 3);
      }
      else if (insite_command_byte == 0x6e) {
        if (throttle_position_raw < 0x1900) {
          cVar6 = '\0';
        }
        else {
          cVar6 = (char)((int)(throttle_position_raw - 0x1900) >> 7);
        }
      }
      else {
        if (insite_command_byte != 0x79) {
          return;
        }
        if (retarder_mode_threshold_value_37d4 == 0) {
          cVar6 = '\0';
        }
        else {
          cVar6 = (io_control_flags & 1) != 0;
          if ((output_control_status_byte & 1) != 0) {
            cVar6 = cVar6 + '\x02';
          }
          if (retarder_mode_threshold_value_37d4 == 1) {
            switch(cVar6) {
            case '\0':
              cVar6 = '\0';
              break;
            case '\x01':
              cVar6 = -0x7f;
              break;
            case '\x02':
              cVar6 = -0x7c;
              break;
            case '\x03':
              cVar6 = -0x78;
            }
          }
          else {
            switch(cVar6) {
            case '\0':
              cVar6 = '\0';
              break;
            case '\x01':
            case '\x02':
              cVar6 = -0x7e;
              break;
            case '\x03':
              cVar6 = -0x78;
            }
          }
        }
      }
      *_insite_response_buffer_ptr = insite_command_byte;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      *_insite_response_buffer_ptr = cVar6;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    }
  }
  else if (insite_command_byte < 0xc1) {
    if (insite_command_byte < 0xb9) {
      if ((insite_command_byte != 0x9c) && (insite_command_byte != 0x9d)) {
        if (insite_command_byte == 0xa6) {
          local_6 = CONCAT11(insite_ecu_command_selector_high,insite_ecu_command_selector_low);
        }
        else if (insite_command_byte == 0xa8) {
          local_6 = (short)((int)(uint)retarder_input_value >> 1) + retarder_input_value * 2;
        }
        else if (insite_command_byte != 0xaf) {
          if (insite_command_byte == 0xb6) {
            local_6 = (word)clutch_operating_stats_output;
          }
          else if (insite_command_byte == 0xb7) {
            local_6 = fuel_statistics_command_value;
          }
          else {
            if (insite_command_byte != 0xb8) {
              return;
            }
            local_6 = fuel_economy_statistics_output;
          }
        }
      }
      *_insite_response_buffer_ptr = insite_command_byte;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      *_insite_response_buffer_ptr = (byte)local_6;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      *_insite_response_buffer_ptr = local_6._0_1_;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    }
    else {
      switch(insite_command_byte) {
      case 0xb9:
        local_6 = clutch_transitions_per_distance;
        break;
      default:
        goto switchD_0000ce84_default;
      case 0xbb:
        local_6 = (word)((int)(uint)pointer_to_oil_pressure_rpm_limit_threshold_0_2_32 >> 1);
        break;
      case 0xbc:
        local_6 = (word)((int)(uint)governor_rpm_error_value >> 1);
        break;
      case 0xbd:
        local_6 = (word)((int)(uint)
                              _user_inversion_bit_mask_for_the_ac_high_pressure_swit_invert_no_invert
                        >> 1);
        break;
      case 0xbe:
        local_6 = (word)((int)(uint)current_engine_rpm_raw >> 1);
      }
      *_insite_response_buffer_ptr = insite_command_byte;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      *_insite_response_buffer_ptr = (byte)local_6;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      *_insite_response_buffer_ptr = local_6._0_1_;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    }
  }
  else if (insite_command_byte < 0xf4) {
    if (insite_command_byte == 0xc1) {
      insiteActiveFaultListBuilder();
      return;
    }
    if (insite_command_byte == 0xc2) {
      insiteFaultDetailBuilder();
      return;
    }
    if (insite_command_byte == 0xc4) {
      *_insite_response_buffer_ptr = 0xc4;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      if (((insite_live_data_parameter_index & 0xc0) == 0x80) ||
         ((insite_live_data_parameter_index & 0xc0) == 0x40)) {
        *_insite_response_buffer_ptr = 2;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      }
      else if ((insite_live_data_parameter_index & 0xc0) == 0) {
        if (insite_parameter_lookup_state == 0) {
          *_insite_response_buffer_ptr = 0;
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          goto LAB_0000d55a;
        }
        *_insite_response_buffer_ptr = 5;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      }
      *_insite_response_buffer_ptr = insite_dtc_pid_byte;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      *_insite_response_buffer_ptr = insite_live_data_parameter_index;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      if (((insite_live_data_parameter_index & 0xc0) == 0) && (insite_parameter_lookup_state != 0))
      {
        bVar5 = 1;
        do {
          *_insite_response_buffer_ptr = (char)(insite_parameter_lookup_state / 100) + 0x30;
          insite_parameter_lookup_state = (insite_parameter_lookup_state % 100) * 10;
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          bVar5 = bVar5 + 1;
        } while (bVar5 < 4);
      }
    }
    else {
      if (insite_command_byte == 0xea) {
        insiteEcuIdResponseBuilder();
        return;
      }
      if (insite_command_byte == 0xeb) {
        uVar2 = insite_runtime_hours_accumulator / 0x708;
        *_insite_response_buffer_ptr = 0xeb;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        *_insite_response_buffer_ptr = 4;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        local_a._3_1_ = (undefined1)uVar2;
        *_insite_response_buffer_ptr = (undefined1)local_a;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        local_a._2_1_ = (undefined1)(uVar2 >> 8);
        *_insite_response_buffer_ptr = local_a._2_1_;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        local_a._1_1_ = (undefined1)(uVar2 >> 0x10);
        *_insite_response_buffer_ptr = local_a._1_1_;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        *_insite_response_buffer_ptr = 0;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      }
      else {
        if (insite_command_byte != 0xec) {
          if (insite_command_byte == 0xed) {
            insiteCapacityResponseBuilder();
            return;
          }
          if (insite_command_byte != 0xf3) {
            return;
          }
          insiteVersionInfoBuilder();
          return;
        }
        *_insite_response_buffer_ptr = 0xec;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        *_insite_response_buffer_ptr = 4;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        local_a._3_1_ = (undefined1)dVar1;
        *_insite_response_buffer_ptr = (undefined1)local_a;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        local_a._2_1_ = (undefined1)(dVar1 >> 8);
        *_insite_response_buffer_ptr = local_a._2_1_;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        local_a._1_1_ = (undefined1)(dVar1 >> 0x10);
        *_insite_response_buffer_ptr = local_a._1_1_;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        local_a._0_1_ = (undefined1)(dVar1 >> 0x18);
        *_insite_response_buffer_ptr = local_a._0_1_;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      }
    }
  }
  else {
    switch(insite_command_byte) {
    case 0xf4:
      local_a = proportionalCalculation(vehicle_distance_clutch_value,10,0x40);
      break;
    case 0xf5:
      local_a = proportionalCalculation(vehicle_distance_statistics_value,10,0x40);
      break;
    default:
      goto switchD_0000ce84_default;
    case 0xf7:
      local_a = vehicle_hours_statistics_value / 0x708;
      break;
    case 0xf8:
      local_a = insite_idle_hours_accumulator / 0x708;
      break;
    case 0xfa:
      local_a = insite_fuel_statistics_output;
    }
    *_insite_response_buffer_ptr = insite_command_byte;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = 4;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = (undefined1)local_a;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = local_a._2_1_;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = local_a._1_1_;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = local_a._0_1_;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
  }
LAB_0000d55a:
  insite_response_buffer_index = insite_response_buffer_length + insite_response_buffer_index;
  insite_bytes_remaining = insite_bytes_remaining - insite_response_buffer_length;
switchD_0000ce84_default:
  return;
}



/*
 * Function: paramSystemModeController @ 0x0000d57c
 */

void paramSystemModeController(void)

{
  uint uVar1;
  undefined4 unaff_D2;
  undefined2 uVar2;
  
  uVar2 = (undefined2)((uint)unaff_D2 >> 0x10);
  if ((diagnostic_fuel_control_mode == 2) || (diagnostic_fuel_control_mode == 1)) {
    param_system_mode_state = activeParamReadFunction();
  }
  else if ((diagnostic_fuel_control_mode == 0xb) || (diagnostic_fuel_control_mode == 0xc)) {
    if (diagnostic_status_register == DEFAULT_DIAGNOSTIC) {
      param_system_mode_state = cached_parameter_value;
    }
    else {
      param_system_mode_state = activeParamReadFunction();
    }
  }
  else {
    param_system_mode_state = diagnostic_rpm_threshold_status;
  }
  if ((short)(param_scale_factor - param_ref_base) < 1) {
    param_table_aux = 0;
    return;
  }
  if ((short)(param_system_mode_state - param_ref_base) < 1) {
    param_table_aux = 0;
    return;
  }
  uVar1 = param_address_calc((short)(param_system_mode_state - param_ref_base) * 0x6400,
                             CONCAT22(param_scale_factor - param_ref_base,uVar2));
  param_table_aux = (word)uVar1;
  if (32000 < param_table_aux) {
    param_table_aux = 32000;
  }
  return;
}



/*
 * Function: param_lookup_1 @ 0x0000d632
 */

void param_lookup_1(void)

{
  uint uVar1;
  undefined4 unaff_D2;
  
  if ((short)(param_scale_factor - param_ref_base) < 1) {
    param_table_main = 0;
    return;
  }
  if ((short)(current_fuel_demand_value - param_ref_base) < 1) {
    param_table_main = 0;
    return;
  }
  uVar1 = param_address_calc((short)(current_fuel_demand_value - param_ref_base) * 0x6400,
                             CONCAT22(param_scale_factor - param_ref_base,
                                      (short)((uint)unaff_D2 >> 0x10)));
  param_table_main = (word)uVar1;
  if (32000 < param_table_main) {
    param_table_main = 32000;
  }
  return;
}



/*
 * Function: param_lookup_2 @ 0x0000d69c
 */

void param_lookup_2(void)

{
  short sVar1;
  uint uVar2;
  undefined4 unaff_D2;
  uint uVar3;
  undefined8 uVar4;
  undefined2 uVar5;
  
  uVar5 = (undefined2)((uint)unaff_D2 >> 0x10);
  uVar3 = (uint)current_fuel_demand_value;
  uVar2 = (uint)param_ref_base;
  if ((int)(uVar3 - uVar2) < 1) {
    param_table_ctrl = 0;
    return;
  }
  param_lookup_rpm_input = current_engine_rpm;
  uVar4 = tableInterpolationLookup((short *)&diagnostic_param_lookup_value);
  sVar1 = (short)((ulonglong)uVar4 >> 0x20) - param_ref_base;
  if (sVar1 < 1) {
    param_table_ctrl = 0;
    return;
  }
  uVar2 = param_address_calc((uVar3 - uVar2) * 0x6400,CONCAT22(sVar1,uVar5));
  param_table_ctrl = (word)uVar2;
  if (32000 < param_table_ctrl) {
    param_table_ctrl = 32000;
  }
  return;
}



/*
 * Function: diagnosticDataBufferSetup @ 0x0000d71a
 */

void diagnosticDataBufferSetup(void)

{
  param_lookup_rpm_input = current_engine_rpm;
  diagnostic_param_lookup_value = 2;
  diagnostic_data_table_1_ptr = 0x807f42;
  diagnostic_data_table_limit = 400;
  diagnostic_data_table_1_base = 2;
  diagnostic_data_table_2_ptr = 0x807f68;
  diagnostic_data_intake_temp_ptr =
       (dword)&lower_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293;
  return;
}



/*
 * Function: param_lookup_3 @ 0x0000d756
 */

void param_lookup_3(void)

{
  uint uVar1;
  undefined4 unaff_D2;
  
  if ((int)((uint)fsmxthfl_calc_input - (uint)param_ref_base) < 1) {
    param_table_ext = 0;
    return;
  }
  if ((short)(param_scale_factor - param_ref_base) < 1) {
    param_table_ext = 0;
    return;
  }
  uVar1 = param_address_calc(((uint)fsmxthfl_calc_input - (uint)param_ref_base) * 0x6400,
                             CONCAT22(param_scale_factor - param_ref_base,
                                      (short)((uint)unaff_D2 >> 0x10)));
  param_table_ext = (word)uVar1;
  if (32000 < param_table_ext) {
    param_table_ext = 32000;
  }
  return;
}



/*
 * Function: fuelTableBlendInterpolation @ 0x0000d7c0
 */

short fuelTableBlendInterpolation(undefined4 param_1)

{
  ushort unaff_D2w;
  ushort unaff_D3w;
  undefined8 uVar1;
  
  if (fuel_timing_mode_selector != 0) {
    fuel_blend_lookup_input = param_1._0_2_;
    uVar1 = tableInterpolationLookup((short *)&fuel_blend_table_1_base);
    unaff_D2w = (ushort)((ulonglong)uVar1 >> 0x20);
  }
  if (fuel_timing_mode_selector < 0x4000) {
    fuel_blend_lookup_input_2 = param_1._0_2_;
    uVar1 = tableInterpolationLookup((short *)&fuel_blend_table_3_base);
    unaff_D3w = (ushort)((ulonglong)uVar1 >> 0x20);
  }
  if (fuel_timing_mode_selector == 0x4000) {
    return fuel_timing_base_offset + unaff_D2w;
  }
  if (fuel_timing_mode_selector == 0) {
    return fuel_timing_base_offset + unaff_D3w;
  }
  return fuel_timing_base_offset +
         (short)((uint)fuel_timing_mode_selector * (uint)unaff_D2w >> 0xe) +
         (short)((uint)unaff_D3w * (0x4000 - (uint)fuel_timing_mode_selector) >> 0xe);
}



/*
 * Function: fuelParameterBlendCalculator @ 0x0000d85e
 */

void fuelParameterBlendCalculator(void)

{
  undefined4 unaff_A2;
  word wVar1;
  word wVar2;
  
  wVar2 = governor_rpm_error_value;
  fuel_mode_blend_state =
       fuelTableBlendInterpolation
                 (CONCAT22(governor_rpm_error_value,(short)((uint)unaff_A2 >> 0x10)));
  wVar1 = fuel_offset_blend_value;
  fuel_mode_blend_result = fuelTableBlendInterpolation(CONCAT22(fuel_offset_blend_value,wVar2));
  wVar2 = fuel_table_blend_param_1;
  fuel_parameter_blend_value = fuelTableBlendInterpolation(CONCAT22(fuel_table_blend_param_1,wVar1))
  ;
  wVar1 = fuel_table_blend_param_2;
  fuel_parameter_blend_state = fuelTableBlendInterpolation(CONCAT22(fuel_table_blend_param_2,wVar2))
  ;
  fuel_mode_selection_state =
       fuelTableBlendInterpolation(CONCAT22(fuel_mode_selection_offset,wVar1));
  return;
}



/*
 * Function: param_interpolate @ 0x0000d8b4
 */

ushort param_interpolate(undefined4 param_1)

{
  ushort uVar1;
  
  if ((short)(param_1._0_2_ - param_ref_base) < 1) {
    uVar1 = 0;
  }
  else if ((short)(param_scale_factor - param_ref_base) < 1) {
    uVar1 = 0;
  }
  else {
    uVar1 = (ushort)((uint)((short)(param_1._0_2_ - param_ref_base) * 0x6400) /
                    (uint)(int)(short)(param_scale_factor - param_ref_base));
    if (32000 < uVar1) {
      uVar1 = 32000;
    }
  }
  return uVar1;
}



/*
 * Function: fuelOffsetCalculator @ 0x0000d90a
 */

void fuelOffsetCalculator(uint param_1,undefined4 param_2)

{
  if ((fuel_limit_comparison_low != 0) && (fuel_limit_comparison_high != 0)) {
    fuel_offset_blend_value =
         arbitrated_fuel_limit +
         ((short)(((uint)fuel_limit_comparison_high *
                  ((uint)fuel_limit_comparison_low - (param_1 & 0xffff))) / 0x1111) -
         fuel_limit_offset_value);
    if (param_2._1_1_ == '\x01') {
      fuel_mode_selection_offset = fuel_offset_blend_value;
      return;
    }
    fuel_mode_selection_offset = fuel_mode_base_offset;
    return;
  }
  fuel_offset_blend_value = arbitrated_fuel_limit;
  fuel_mode_selection_offset = param_1._0_2_;
  return;
}



/*
 * Function: fuelModeSelectionCalculator @ 0x0000d984
 */

void fuelModeSelectionCalculator(void)

{
  undefined4 unaff_D2;
  char cVar1;
  word wVar2;
  word wVar3;
  ushort uVar4;
  
  uVar4 = (ushort)((uint)unaff_D2 >> 0x10);
  if ((((arbitrator_active_limit_priority == 2) || (arbitrator_active_limit_priority == 4)) ||
      (arbitrator_active_limit_priority == 5)) || (arbitrator_active_limit_priority == 1)) {
    cVar1 = '\x02';
  }
  else {
    cVar1 = '\0';
  }
  if (((shutdown_minimum_selector_value == 0x12) ||
      (shutdown_minimum_selector_value == SHUTDOWN_PROTECTION_LIMIT)) ||
     ((shutdown_minimum_selector_value == DIAGNOSTIC_MODE_BUFFER &&
      ((((fault_status_flags_2 & 0x200) != 0 && ((accelerator_pedal_position & 0x200) != 0)) ||
       (((fault_status_flags_2 & 0x400) != 0 && ((accelerator_pedal_position & 0x400) != 0)))))))) {
    cVar1 = cVar1 + '\x04';
    fuel_mode_blend_state = fuel_mode_blend_table_1;
    fuel_parameter_blend_value = fuel_mode_blend_table_2;
    fuel_parameter_blend_state = fuel_mode_state_table_1;
  }
  if (fuel_timing_mode_selector == 0x4000) {
    cVar1 = cVar1 + '\x01';
  }
  switch(cVar1) {
  case '\0':
  case '\x01':
    fuel_offset_blend_value = fuel_limit_offset_value;
    fuel_mode_selection_offset = fuel_mode_base_offset;
    fuelParameterBlendCalculator();
    break;
  case '\x02':
  case '\x03':
    fuel_offset_blend_value = arbitrated_fuel_limit;
    if (fuel_mode_base_offset < arbitrated_fuel_limit) {
      fuel_mode_selection_offset = fuel_mode_base_offset;
    }
    else {
      fuel_mode_selection_offset = arbitrated_fuel_limit;
    }
    fuelParameterBlendCalculator();
    break;
  case '\x04':
    fuel_offset_blend_value = fuel_mode_override_table_1;
    fuel_mode_selection_offset = fuel_mode_base_offset;
    fuel_mode_blend_result = fuel_mode_override_table_2;
    fuel_mode_selection_state = fuel_mode_state_table_2;
    break;
  case '\x05':
    fuel_offset_blend_value = fuel_mode_timing_override_1;
    fuel_mode_selection_offset = fuel_mode_base_offset;
    fuel_mode_blend_result = fuel_mode_timing_override_2;
    fuel_mode_selection_state = fuel_mode_state_table_2;
    break;
  case '\x06':
    if (arbitrated_fuel_limit < fuel_mode_arbitrated_threshold_1) {
      fuelOffsetCalculator
                (CONCAT22(arbitrated_fuel_limit,fuel_mode_state_table_1),CONCAT22(1,uVar4));
      fuel_mode_blend_result = fuel_mode_state_table_1;
      fuel_mode_selection_state = fuel_mode_state_table_1;
    }
    else {
      fuelOffsetCalculator(CONCAT22(fuel_mode_base_offset,fuel_mode_state_table_2),(uint)uVar4);
      fuel_mode_blend_result = fuel_mode_state_table_2;
      fuel_mode_selection_state = fuel_mode_state_table_2;
    }
    break;
  case '\a':
    if (arbitrated_fuel_limit < fuel_mode_arbitrated_threshold_2) {
      fuelOffsetCalculator
                (CONCAT22(arbitrated_fuel_limit,fuel_mode_state_table_1),CONCAT22(1,uVar4));
      fuel_mode_blend_result = fuel_mode_state_table_1;
      fuel_mode_selection_state = fuel_mode_state_table_1;
    }
    else {
      fuelOffsetCalculator(CONCAT22(fuel_mode_base_offset,fuel_mode_state_table_2),(uint)uVar4);
      fuel_mode_blend_result = fuel_mode_state_table_2;
      fuel_mode_selection_state = fuel_mode_state_table_2;
    }
  }
  wVar3 = fuel_mode_blend_state;
  param_table_calc = param_interpolate(CONCAT22(fuel_mode_blend_state,uVar4));
  wVar2 = fuel_mode_blend_result;
  calculated_2 = param_interpolate(CONCAT22(fuel_mode_blend_result,wVar3));
  wVar3 = fuel_parameter_blend_value;
  calculated_3 = param_interpolate(CONCAT22(fuel_parameter_blend_value,wVar2));
  wVar2 = fuel_parameter_blend_state;
  calculated_4 = param_interpolate(CONCAT22(fuel_parameter_blend_state,wVar3));
  result_buffer = param_interpolate(CONCAT22(fuel_mode_selection_state,wVar2));
  return;
}



/*
 * Function: fuelBlendTablePointerSetup @ 0x0000dbc2
 */

void fuelBlendTablePointerSetup(void)

{
  fuel_blend_table_1_base = 2;
  fuel_blend_table_1_ptr = 0x807f42;
  fuel_blend_table_1_limit = 400;
  fuel_blend_table_2_base = 2;
  fuel_blend_table_2_ptr = 0x807f68;
  fuel_blend_intake_temp_ptr =
       (dword)&lower_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293;
  fuel_blend_table_3_base = 2;
  fuel_blend_table_3_ptr = 0x808002;
  fuel_blend_table_3_limit = 400;
  fuel_blend_table_4_base = 2;
  fuel_blend_table_4_ptr = 0x808028;
  fuel_blend_table_5_ptr = 0x808032;
  return;
}



/*
 * Function: ioControlBasedFuelCalculator @ 0x0000dc28
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void ioControlBasedFuelCalculator(void)

{
  short sVar1;
  short sVar2;
  ushort uVar3;
  
  if ((io_control_flags & 1) == 0) {
    sVar1 = 2;
  }
  else {
    sVar1 = 0;
  }
  if ((output_control_status_byte & 1) == 0) {
    uVar3 = sVar1 + 2;
  }
  else {
    uVar3 = sVar1 + 1;
  }
  if (uVar3 < 2) {
    retarder_scaled_percentage_output = 0;
    return;
  }
  if (retarder_mode_threshold_value_37d4 == 2) {
    retarder_mode_lookup_table_pointer = 0x80797a;
    retarder_lookup_table_pointer = 0x80797a;
    _io_control_fuel_calculator_ptr = (word *)0x80798e;
    if (uVar3 == 2) {
      retarder_lookup_table_ptr = 0x807984;
    }
    else if (uVar3 == 3) {
      retarder_lookup_table_ptr = 0x807984;
    }
    else if (uVar3 == 4) {
      retarder_lookup_table_ptr = 0x80798e;
    }
  }
  else {
    retarder_mode_lookup_table_pointer = 0x807952;
    retarder_lookup_table_pointer = 0x807952;
    _io_control_fuel_calculator_ptr = &ADO2TPAI;
    if (uVar3 == 2) {
      retarder_lookup_table_ptr = 0x807966;
    }
    else if (uVar3 == 3) {
      retarder_lookup_table_ptr = 0x80795c;
    }
    else if (uVar3 == 4) {
      retarder_lookup_table_ptr = (dword)&ADO2TPAI;
    }
  }
  io_control_fuel_rpm_input = current_engine_rpm;
  sVar1 = lookupTableInterpolation((table_interp_args_t *)&io_control_fuel_table_1_lookup_arg);
  if (0 < sVar1) {
    io_control_fuel_table_param = *(word *)(retarder_lookup_table_pointer + 8);
    sVar2 = lookupTableInterpolation((table_interp_args_t *)&io_control_fuel_table_2_lookup_arg);
    if (0 < sVar2) {
      retarder_scaled_percentage_output = (word)((uint)(sVar1 * 0x6400) / (uint)(int)sVar2);
      if (32000 < retarder_scaled_percentage_output) {
        retarder_scaled_percentage_output = 32000;
      }
      return;
    }
    retarder_scaled_percentage_output = 0;
    return;
  }
  retarder_scaled_percentage_output = 0;
  return;
}



/*
 * Function: throttleTablePointerSetup @ 0x0000dd72
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void throttleTablePointerSetup(void)

{
  io_control_fuel_table_1_lookup_arg = 2;
  retarder_mode_lookup_table_pointer = 0x807952;
  retarder_lookup_table_ptr = (dword)&ADO2TPAI;
  io_control_fuel_table_2_lookup_arg = 2;
  retarder_lookup_table_pointer = 0x807952;
  _io_control_fuel_calculator_ptr = &ADO2TPAI;
  return;
}



/*
 * Function: bufferDecreasingPatternCheck @ 0x0000ddb4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint bufferDecreasingPatternCheck(void)

{
  uint uVar1;
  uint *puVar2;
  uint *puVar3;
  uint local_18 [5];
  
  uVar1 = 0;
  puVar3 = _throttle_buffer_validation_value;
  for (puVar2 = local_18; puVar2 < &stack0xfffffffc; puVar2 = puVar2 + 1) {
    if (puVar2 == local_18) {
      *puVar2 = _throttle_position_validator_state >> 2;
    }
    else {
      *puVar2 = *puVar3 >> 2;
      puVar3 = puVar3 + -1;
    }
    if (puVar3 < _throttle_buffer_decreasing_value) {
      puVar3 = _throttle_position_validation_buffer;
    }
    uVar1 = *puVar3 >> 2;
    *puVar2 = *puVar2 - uVar1;
  }
  if (((((int)local_18[4] < 1) || (uVar1 = local_18[3], (int)local_18[2] <= (int)local_18[3])) ||
      (-1 < (int)local_18[2])) ||
     (((uVar1 = local_18[2], (int)local_18[1] <= (int)local_18[2] ||
       (uVar1 = local_18[0] + throttle_buffer_offset_adjust, (int)local_18[1] <= (int)uVar1)) ||
      (uVar1 = (uint)(short)throttle_buffer_min_delta, (int)uVar1 <= (int)local_18[0])))) {
    uVar1 = uVar1 & 0xffff0000;
  }
  else {
    uVar1 = 1;
  }
  return uVar1;
}



/*
 * Function: bufferThresholdValidator @ 0x0000de50
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint bufferThresholdValidator(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  
  if (_throttle_buffer_validation_value == _throttle_buffer_decreasing_value) {
    uVar3 = *_throttle_position_validation_buffer >> 2;
    uVar2 = _throttle_position_validation_buffer[-1] >> 2;
  }
  else if (_throttle_buffer_decreasing_value + 1 == _throttle_buffer_validation_value) {
    uVar3 = *_throttle_buffer_decreasing_value >> 2;
    uVar2 = *_throttle_position_validation_buffer >> 2;
  }
  else {
    uVar3 = _throttle_buffer_validation_value[-1] >> 2;
    uVar2 = _throttle_buffer_validation_value[-2] >> 2;
  }
  iVar4 = _throttle_buffer_high_threshold;
  if (throttle_position_raw < throttle_buffer_threshold_low) {
    iVar4 = _throttle_buffer_low_threshold;
  }
  uVar1 = uVar2 * throttle_buffer_scale_factor >> 8;
  if (((uVar1 <= _throttle_position_validator_state >> 2) ||
      (uVar1 = uVar3 - uVar2, iVar4 <= (int)uVar1)) && (iVar4 <= (int)uVar3)) {
    return uVar1 & 0xffff0000;
  }
  return 1;
}



/*
 * Function: throttlePositionValidator @ 0x0000def4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined2 throttlePositionValidator(undefined4 param_1)

{
  word wVar1;
  uint uVar2;
  word wVar3;
  char cVar4;
  
  cVar4 = (char)((uint)param_1 >> 0x10);
  if (throttle_validator_enable_flag == 0) {
    wVar3 = 0;
  }
  else {
    if (cVar4 == '\0') {
      _throttle_position_validator_state = _rpm_timer_interrupt_capture;
      if (_throttle_position_buffer_ptr == &rpm_filter_buffer_start) {
        _throttle_buffer_validation_value = (dword *)rpm_filter_buffer_end;
      }
      else {
        _throttle_buffer_validation_value = _throttle_position_buffer_ptr + -1;
      }
      _throttle_buffer_decreasing_value = &rpm_filter_buffer_start;
      _throttle_position_validation_buffer = rpm_filter_buffer_end;
      uVar2 = _throttle_position_raw_value;
    }
    else {
      _throttle_position_validator_state = _duty_cycle_timing_capture_value;
      if ((dword *)duty_cycle_buffer_current_ptr == &duty_cycle_monitor_buffer_start) {
        _throttle_buffer_validation_value = (dword *)duty_cycle_buffer_end_ptr;
      }
      else {
        _throttle_buffer_validation_value = (dword *)(duty_cycle_buffer_current_ptr - 4);
      }
      _throttle_buffer_decreasing_value = &duty_cycle_monitor_buffer_start;
      _throttle_position_validation_buffer = duty_cycle_buffer_end_ptr;
      uVar2 = _throttle_validation_state;
    }
    if (time_to_delay_before_setting_a_new_throttle_min_0_25500 < current_engine_fuel_demand) {
      if (_throttle_position_validator_state < uVar2) {
        wVar3 = 1;
      }
      else {
        wVar3 = 0;
      }
    }
    else if (_throttle_position_validator_state < uVar2) {
      uVar2 = bufferThresholdValidator();
      wVar3 = (word)uVar2;
    }
    else if ((throttle_position_raw < throttle_position_low_threshold) &&
            (current_engine_fuel_demand <= throttle_position_high_threshold)) {
      uVar2 = bufferDecreasingPatternCheck();
      wVar3 = (word)uVar2;
    }
    else {
      wVar3 = 0;
    }
    if (cVar4 == '\0') {
      _throttle_position_raw_value =
           _throttle_position_validator_state * throttle_scaling_factor >> 8;
    }
    else {
      _throttle_validation_state = _throttle_position_validator_state * throttle_scaling_factor >> 8
      ;
    }
  }
  wVar1 = wVar3;
  if (cVar4 == '\0') {
    throttle_validation_result_1 = wVar3;
    wVar1 = throttle_validation_result_2;
  }
  throttle_validation_result_2 = wVar1;
  return wVar3;
}



/*
 * Function: canBusTimingInit @ 0x0000e02c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void canBusTimingInit(void)

{
  _throttle_position_raw_value =
       _throttle_position_validator_state * (uint)throttle_scaling_factor >> 8;
  _throttle_validation_state =
       _throttle_position_validator_state * (uint)throttle_scaling_factor >> 8;
  return;
}



/*
 * Function: sendCanSingleFrame @ 0x0000e052
 */
/* ERROR: Failed to decompile */
void sendCanSingleFrame(void) {
    /* Decompilation failed */
}


/*
 * Function: sendCanMessage @ 0x0000e180
 */

void sendCanMessage(j1939_header_t *msg_header)

{
  if (msg_header->length < 9) {
    sendCanSingleFrame(msg_header->id);
    return;
  }
  sendJ1939MultiFrame(&msg_header->id);
  return;
}



/*
 * Function: sendJ1939MultiFrameWrapper @ 0x0000e1aa
 */

void sendJ1939MultiFrameWrapper(void)

{
  uint *unaff_A2;
  
  sendJ1939MultiFrame(unaff_A2);
  return;
}



/*
 * Function: arrayRangeSum @ 0x0000e1b8
 */

short arrayRangeSum(short *param_1,short *param_2)

{
  short sVar1;
  
  sVar1 = 0;
  for (; param_1 <= param_2; param_1 = param_1 + 1) {
    sVar1 = *param_1 + sVar1;
  }
  return sVar1;
}



/*
 * Function: memoryPatchCountDecrement @ 0x0000e1ce
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void memoryPatchCountDecrement(void)

{
  if (_memory_patch_count != 0) {
    _memory_patch_count = _memory_patch_count + -1;
    can_rx_buffer_ptr =
         can_rx_buffer_ptr - *(ushort *)((short)(_memory_patch_count * 3) * 2 + 0x80d3aa);
  }
  return;
}



/*
 * Function: rpm_derate_calculation_and_fault_processing @ 0x0000e200
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint rpm_derate_calculation_and_fault_processing(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = _engine_control_flags_register & 0x400;
  if ((_engine_control_flags_register & 0x400) == 0) {
    if (_derate_mode_selector == 0) {
      current_derate_target = normal_derate_reference;
      uVar3 = 0x41;
      uVar2 = 0x42;
    }
    else {
      current_derate_target = override_derate_reference;
      uVar3 = 0;
      uVar2 = 0;
    }
    uVar1 = (uint)current_derate_target;
    if (derate_threshold_base < current_derate_target) {
      uVar1 = (((uint)current_derate_target - (uint)derate_threshold_base) * 400) /
              (uint)_derate_scaling_factor;
      calculated_derate_amount = (word)uVar1;
    }
    else {
      calculated_derate_amount = 0;
    }
    if (rpm_derate_timer == 0) {
      if ((derate_status_flag == 0) && (_derate_override_flag == 0)) {
        if (((((((uint)(&fault_flags_active_base)[(short)((int)uVar3 >> 4)] & 1 << (uVar3 & 0xf)) ==
                0) || (uVar1 = (uint)(&fault_flags_enabled_base)[(int)uVar3 >> 4],
                      (uVar1 & 1 << (uVar3 & 0xf)) == 0)) &&
             ((((uint)(&fault_flags_active_base)[(short)((int)uVar2 >> 4)] & 1 << (uVar2 & 0xf)) ==
               0 || (uVar1 = (uint)(&fault_flags_enabled_base)[(int)uVar2 >> 4],
                    (uVar1 & 1 << (uVar2 & 0xf)) == 0)))) &&
            (((engine_fault_register_a & 0x20) == 0 ||
             (uVar1 = engine_fault_register_b & 0xffff0020, (engine_fault_register_b & 0x20) == 0)))
            ) && ((((engine_fault_register_a & 8) == 0 ||
                   (uVar1 = engine_fault_register_b & 0xffff0008, (engine_fault_register_b & 8) == 0
                   )) && (uVar1 = (uint)current_derate_target,
                         derate_threshold_base < current_derate_target)))) {
          active_derate_value = calculated_derate_amount;
        }
        else {
          active_derate_value = 0;
        }
        _derate_timer_status = 0;
      }
      else {
        if (((engine_fault_register_a & 0x20) != 0) && ((engine_fault_register_c & 0x20) == 0)) {
          engine_fault_register_a = engine_fault_register_a & 0xffdf;
        }
        if (((engine_fault_register_a & 8) != 0) && ((engine_fault_register_c & 8) == 0)) {
          engine_fault_register_a = engine_fault_register_a & 0xfff7;
        }
        if (((engine_fault_register_a & 0x10) != 0) && ((engine_fault_register_c & 0x10) == 0)) {
          engine_fault_register_a = engine_fault_register_a & 0xffef;
        }
        uVar1 = CONCAT22((short)(uVar1 >> 0x10),current_derate_target);
        if (the_transmission_pwm_scaling_from_load_to_duty_cycle_2_2 < current_derate_target) {
          uVar1 = (((uint)current_derate_target -
                   (uint)the_transmission_pwm_scaling_from_load_to_duty_cycle_2_2) * 400) /
                  (uint)_derate_scaling_factor;
          calculated_derate_amount = (word)uVar1;
        }
        else {
          calculated_derate_amount = 0;
        }
        derate_threshold_exceeded =
             (word)(the_transmission_pwm_scaling_from_load_to_duty_cycle_2_2 < current_derate_target
                   );
        active_derate_value = calculated_derate_amount;
        _derate_timer_status = 0;
      }
    }
    else {
      active_derate_value = rpm_derate_status;
      _derate_timer_status = rpm_derate_timer;
      rpm_derate_timer = 0;
    }
  }
  else {
    active_derate_value = normal_derate_reference;
  }
  if (400 < calculated_derate_amount) {
    calculated_derate_amount = 400;
  }
  if (400 < active_derate_value) {
    active_derate_value = 400;
  }
  return uVar1;
}



/*
 * Function: derateThresholdMonitorAndFaultController @ 0x0000e478
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ulonglong derateThresholdMonitorAndFaultController(void)

{
  ushort uVar1;
  undefined2 uVar2;
  short sVar4;
  short sVar5;
  uint uVar3;
  byte bVar6;
  uint in_D1;
  uint uVar7;
  word wVar8;
  uint uVar9;
  
  uVar7 = _engine_control_flags_register & 0x400;
  if ((((_engine_control_flags_register & 0x400) != 0) || (derate_status_flag != 0)) ||
     (_derate_override_flag != 0)) {
LAB_0000eac6:
    return CONCAT44(uVar7,in_D1);
  }
  if (_derate_mode_selector == 0) {
    current_derate_target = normal_derate_reference;
    uVar7 = 0x41;
    uVar9 = 0x42;
  }
  else {
    current_derate_target = override_derate_reference;
    uVar7 = 0;
    uVar9 = 0;
  }
  sVar4 = (short)((int)uVar7 >> 4);
  sVar5 = (short)((int)uVar9 >> 4);
  if (((((uint)(&fault_flags_active_base)[sVar4] & 1 << (uVar7 & 0xf)) == 0) ||
      (((uint)(&fault_flags_enabled_base)[sVar4] & 1 << (uVar7 & 0xf)) == 0)) &&
     ((((uint)(&fault_flags_active_base)[sVar5] & 1 << (uVar9 & 0xf)) == 0 ||
      (((uint)(&fault_flags_enabled_base)[sVar5] & 1 << (uVar9 & 0xf)) == 0)))) {
    if ((derate_mode_selector == 0) && (current_derate_target < derate_threshold_state_counter)) {
      derate_threshold_state_counter = current_derate_target;
    }
    if (derate_mode_selector == 1) {
      if ((current_derate_target < derate_threshold_state_counter) &&
         (derate_threshold_monitor_state == 0)) {
        derate_threshold_monitor_state = derate_monitor_timer_init;
        derate_target_snapshot = current_derate_target;
      }
      if (derate_threshold_monitor_state != 0) {
        if ((uint)derate_hysteresis_offset + (uint)derate_target_snapshot <
            (uint)current_derate_target) {
          derate_threshold_monitor_state = derate_threshold_monitor_state + 1;
          if (derate_threshold_monitor_state == derate_monitor_timer_init) {
            derate_target_snapshot = derate_threshold_state_counter;
            derate_threshold_monitor_state = 0;
          }
        }
        else {
          derate_threshold_monitor_state = derate_threshold_monitor_state - 1;
          if (derate_threshold_monitor_state == 0) {
            derate_threshold_state_counter = derate_target_snapshot;
          }
        }
      }
    }
  }
  else {
    derate_threshold_state_counter = derate_threshold_calibration + 1;
  }
  derate_upper_limit =
       derate_upper_offset +
       (derate_threshold_base - the_transmission_pwm_bias_from_load_to_duty_cycle_100_100);
  derate_lower_limit =
       derate_lower_offset +
       (derate_threshold_base - the_transmission_pwm_bias_from_load_to_duty_cycle_100_100);
  if ((((vp44_communication_status & 0x80) == 0) || ((derate_status_byte & 1) != 0)) &&
     (((vp44_communication_status & 0x80) != 0 || ((derate_status_byte & 1) == 0)))) {
    if ((vp44_communication_status & 0x80) == 0) {
      if (derate_upper_limit < current_derate_target) {
        derate_threshold_monitor_value = 5;
      }
      else if (current_derate_target < derate_lower_limit) {
        derate_threshold_monitor_value = 6;
      }
      else {
        derate_threshold_monitor_value = 7;
      }
    }
    else if ((derate_upper_limit < current_derate_target) ||
            (current_derate_target < derate_lower_limit)) {
      derate_threshold_monitor_value = 4;
    }
    else {
      derate_threshold_monitor_value = 7;
    }
  }
  else if ((vp44_communication_status & 0x80) == 0) {
    if (current_derate_target < derate_threshold_base) {
      if (current_derate_target < derate_lower_limit) {
        derate_threshold_monitor_value = 3;
      }
      else {
        derate_threshold_monitor_value = 8;
      }
    }
    else {
      derate_threshold_monitor_value = 1;
    }
  }
  else if (derate_threshold_base < current_derate_target) {
    if (derate_upper_limit < current_derate_target) {
      derate_threshold_monitor_value = 2;
    }
    else {
      derate_threshold_monitor_value = 9;
    }
  }
  else {
    derate_threshold_monitor_value = 0;
  }
  if ((((derate_threshold_monitor_value == 1) || (derate_threshold_monitor_value == 3)) ||
      (derate_threshold_monitor_value == 5)) || (derate_threshold_monitor_value == 9)) {
    derate_threshold_exceeded = 1;
  }
  else {
    derate_threshold_exceeded = 0;
  }
  if (((uint)(&fault_flags_active_base)[sVar4] & 1 << (uVar7 & 0xf)) != 0) {
    uVar3 = (uint)(&fault_flags_enabled_base)[sVar4];
    uVar7 = uVar3 & 1 << (uVar7 & 0xf);
    if (uVar7 != 0) goto LAB_0000e7d2;
  }
  if (((uint)(&fault_flags_active_base)[sVar5] & 1 << (uVar9 & 0xf)) != 0) {
    uVar3 = (uint)(&fault_flags_enabled_base)[sVar5];
    uVar7 = uVar3 & 1 << (uVar9 & 0xf);
    if (uVar7 != 0) {
LAB_0000e7d2:
      derate_fault_controller_value = 0;
      return CONCAT44(uVar3,uVar7);
    }
  }
  if (derate_fault_controller_value == 0) {
    if ((((vp44_communication_status & 0x80) != 0) && ((derate_status_byte & 1) == 0)) &&
       ((uint)current_derate_target <=
        (uint)the_transmission_pwm_bias_from_load_to_duty_cycle_100_100 +
        (uint)derate_threshold_state_counter)) {
      derate_fault_controller_value = 1;
    }
  }
  else if (derate_fault_controller_value == 1) {
    if ((derate_threshold_monitor_value == 1) &&
       ((uint)the_transmission_pwm_signal_dutycycle_minimum_value_high_time_0_100 +
        (uint)derate_threshold_state_counter < (uint)current_derate_target)) {
      derate_fault_controller_value = 2;
    }
  }
  else if (((derate_fault_controller_value == 2) && ((vp44_communication_status & 0x80) != 0)) &&
          (((derate_status_byte & 1) == 0 &&
           ((uint)current_derate_target <=
            (uint)the_transmission_pwm_bias_from_load_to_duty_cycle_100_100 +
            (uint)derate_threshold_state_counter)))) {
    derate_fault_controller_value = 3;
  }
  if (derate_fault_controller_value == 3) {
    if (derate_threshold_monitor_state == 0) {
      derate_threshold_base =
           the_transmission_pwm_bias_from_load_to_duty_cycle_100_100 +
           derate_threshold_state_counter;
    }
    if (((engine_fault_register_a & 0x20) != 0) && ((engine_fault_register_c & 0x20) == 0)) {
      engine_fault_register_a = engine_fault_register_a & 0xffdf;
    }
    if (((engine_fault_register_a & 8) != 0) && ((engine_fault_register_c & 8) == 0)) {
      engine_fault_register_a = engine_fault_register_a & 0xfff7;
    }
    if (((engine_fault_register_a & 0x10) != 0) && ((engine_fault_register_c & 0x10) == 0)) {
      engine_fault_register_a = engine_fault_register_a & 0xffef;
    }
  }
  if ((derate_threshold_base < the_transmission_pwm_bias_from_load_to_duty_cycle_100_100) ||
     (uVar7 = (uint)derate_threshold_calibration +
              (uint)the_transmission_pwm_bias_from_load_to_duty_cycle_100_100,
     uVar7 < derate_threshold_base)) {
    uVar7 = (uint)derate_threshold_calibration +
            (uint)the_transmission_pwm_bias_from_load_to_duty_cycle_100_100;
    in_D1 = (uint)derate_threshold_base;
    if ((in_D1 <= uVar7) ||
       (uVar7 = CONCAT22((short)(uVar7 >> 0x10),throttle_position_value),
       throttle_position_value <=
       the_transmission_pwm_signal_dutycycle_maximum_value_high_time_0_100)) {
      derate_fault_counter_1 = 0;
      derate_fault_counter_2 = 0;
      derate_fault_counter_3 = 0;
      goto LAB_0000eac6;
    }
  }
  uVar9 = (uint)derate_threshold_base;
  uVar1 = (ushort)(uVar7 >> 0x10);
  uVar7 = CONCAT22(uVar1,normal_derate_reference);
  wVar8 = the_load_point_at_which_the_kick_down_signal_activates_0_127;
  if (derate_threshold_base <= normal_derate_reference) {
    wVar8 = derate_fault_counter_threshold_alt;
  }
  if (derate_threshold_monitor_value == 4) {
    if (derate_fault_counter_1 < wVar8) {
      derate_fault_counter_1 = derate_fault_counter_1 + 1;
    }
    else {
      engine_fault_register_a = engine_fault_register_a | 8;
      engine_fault_register_c = engine_fault_register_c | 8;
      derate_fault_controller_value = 0;
    }
  }
  else {
    derate_fault_counter_1 = 0;
  }
  if ((derate_threshold_monitor_value == 6) || (derate_threshold_monitor_value == 5)) {
    if (derate_fault_counter_2 < wVar8) {
      derate_fault_counter_2 = derate_fault_counter_2 + 1;
    }
    else {
      engine_fault_register_a = engine_fault_register_a | 0x10;
      engine_fault_register_c = engine_fault_register_c | 0x10;
      derate_fault_controller_value = 0;
    }
  }
  else {
    derate_fault_counter_2 = 0;
  }
  if (((derate_threshold_monitor_value == 2) || (derate_threshold_monitor_value == 3)) &&
     ((uVar7 = (uint)uVar1 << 0x10, (engine_fault_register_a & 0x10) == 0 ||
      (uVar7 = CONCAT22(uVar1,engine_fault_register_b) & 0xffff0010,
      (engine_fault_register_b & 0x10) == 0)))) {
    uVar2 = (undefined2)(uVar7 >> 0x10);
    uVar7 = CONCAT22(uVar2,engine_fault_register_a) & 0xffff0008;
    if (((engine_fault_register_a & 8) == 0) ||
       (uVar7 = CONCAT22(uVar2,engine_fault_register_b) & 0xffff0008,
       (engine_fault_register_b & 8) == 0)) {
      if (derate_fault_counter_3 < wVar8) {
        derate_fault_counter_3 = derate_fault_counter_3 + 1;
        return CONCAT44(uVar7,uVar9);
      }
      engine_fault_register_a = engine_fault_register_a | 0x20;
      engine_fault_register_c = engine_fault_register_c | 0x20;
      derate_fault_controller_value = 0;
      bVar6 = -((vp44_communication_status & 0x80) != 0);
      _derate_vp44_status_flag = bVar6 & 1;
      return (ulonglong)CONCAT14(bVar6,uVar9) & 0x1ffffffff;
    }
  }
  derate_fault_counter_3 = 0;
  return CONCAT44(uVar7,uVar9);
}



/*
 * Function: initDerateSystem @ 0x0000eacc
 */

ushort initDerateSystem(void)

{
  derate_threshold_state_counter = derate_threshold_calibration + 4;
  if ((fuel_demand_control_flags & 4) != 0) {
    derate_status_flag = 1;
  }
  return fuel_demand_control_flags & 4;
}



/*
 * Function: diagnosticMemoryAddressResolver @ 0x0000eaf0
 */
/* ERROR: Failed to decompile */
void diagnosticMemoryAddressResolver(void) {
    /* Decompilation failed */
}


/*
 * Function: kickdownSignalSlowCycle40Coordinator @ 0x0000eb5a
 */

void kickdownSignalSlowCycle40Coordinator(void)

{
  if ((vp44_engine_state != 0xb) &&
     (the_load_point_at_which_the_kick_down_signal_de_activates_0_127 < current_fuel_demand_value))
  {
    timing_table_lookup_result = 0;
    timing_accumulator_flag_mask = 0;
    return;
  }
  kickdown_throttle_input = throttle_position_raw;
  timing_table_lookup_result =
       lookupTableInterpolation((table_interp_args_t *)&ac_control_table_size);
  timing_accumulator_flag_mask = 2;
  return;
}



/*
 * Function: timingAccumulatorUpdate @ 0x0000ebb0
 */

void timingAccumulatorUpdate(void)

{
  fuel_limit_minimum_value = timing_table_lookup_result + fuel_limit_minimum_value;
  fuel_adjustment_active_flag = timing_accumulator_flag_mask | fuel_adjustment_active_flag & 0xfffd;
  return;
}



/*
 * Function: initAcControlSystem @ 0x0000ebd2
 */

void initAcControlSystem(void)

{
  ac_control_kickdown_ptr = (dword)&engine_speed_at_0_fuel_which_activates_kick_down_signal_0_8000;
  ac_control_accel_threshold_ptr = (dword)&accel_threshold_to_disable_a_c_1200_1200;
  ac_control_table_size = 2;
  return;
}



/*
 * Function: calibrationDataCopyWithChecksum @ 0x0000ebf2
 */

undefined4 calibrationDataCopyWithChecksum(void)

{
  ushort extraout_D0u;
  word wVar1;
  dword *pdVar2;
  word *pwVar3;
  dword *pdVar4;
  
  wVar1 = arrayRangeSum((short *)&DAT_00004000,(short *)&calibration_checksum_end_marker);
  if ((wVar1 != calibration_checksum_expected_1) && (calibration_checksum_end_marker != 0xa1a1)) {
    return 1;
  }
  pdVar4 = (dword *)&DAT_00004000;
  for (pdVar2 = &flash_program_block_1_buffer; pdVar2 < (dword *)0x80488c; pdVar2 = pdVar2 + 1) {
    *pdVar2 = *pdVar4;
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    pdVar4 = pdVar4 + 1;
  }
  pdVar4 = &eeprom_insite_data_base_address;
  for (pwVar3 = &flash_program_block_2_buffer; pwVar3 < &calibration_data_copy_status;
      pwVar3 = (word *)((int)pwVar3 + 4)) {
    *(dword *)pwVar3 = *pdVar4;
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    pdVar4 = pdVar4 + 1;
  }
  calibration_checksum_workspace._0_2_ = 1;
  return (uint)extraout_D0u << 0x10;
}



/*
 * Function: calibrationDataCopySecondary @ 0x0000eca4
 */

undefined4 calibrationDataCopySecondary(void)

{
  ushort extraout_D0u;
  word wVar1;
  dword *pdVar2;
  word *pwVar3;
  dword *pdVar4;
  
  wVar1 = arrayRangeSum((short *)&eeprom_secondary_base_address,(short *)0x7e42);
  if (wVar1 != calibration_checksum_expected_2) {
    return 1;
  }
  pdVar4 = &eeprom_secondary_base_address;
  for (pdVar2 = &flash_program_block_1_buffer; pdVar2 < (dword *)0x80488c; pdVar2 = pdVar2 + 1) {
    *pdVar2 = *pdVar4;
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    pdVar4 = pdVar4 + 1;
  }
  pdVar4 = &firmware_vector_table_base;
  for (pwVar3 = &flash_program_block_2_buffer; pwVar3 < &calibration_data_copy_status;
      pwVar3 = (word *)((int)pwVar3 + 4)) {
    *(dword *)pwVar3 = *pdVar4;
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    pdVar4 = pdVar4 + 1;
  }
  calibration_checksum_workspace._0_2_ = 2;
  return (uint)extraout_D0u << 0x10;
}



/*
 * Function: eepromCalibrationWritePrimary @ 0x0000ed52
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

int eepromCalibrationWritePrimary(void)

{
  ushort extraout_D0u;
  int iVar1;
  short sVar2;
  undefined4 unaff_D2;
  char in_XF;
  char in_NF;
  char in_ZF;
  char in_VF;
  byte in_CF;
  char cVar3;
  ushort uVar4;
  ushort uVar5;
  undefined2 uVar6;
  word local_6;
  
  uVar6 = (undefined2)((uint)unaff_D2 >> 0x10);
  uVar4 = (ushort)(byte)(in_XF << 4 | in_NF << 3 | in_ZF << 2 | in_VF << 1 | in_CF);
  if ((eeprom_calibration_check_value_2 + _eeprom_calibration_write_state & 1) == 0) {
    local_6 = _eeprom_calibration_write_state + 1;
  }
  else {
    local_6 = _eeprom_calibration_write_state + 2;
  }
  parameterCircularBufferWrite(0x80367a,(undefined1 *)&local_6,CONCAT22(2,uVar4));
  uVar5 = 0;
  while ((uVar5 < 5000 && (_eeprom_calibration_write_state != local_6))) {
    emptyPlaceholderFunction();
    delayWithWatchdogService(CONCAT22(500,uVar4));
    uVar5 = uVar5 + 1;
  }
  iVar1 = flashEraseFromRam(0x4000);
  if (iVar1 == 0) {
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    sVar2 = flashProgramFromRam(0x4000,&flash_program_block_1_buffer,CONCAT22(10,uVar6));
    if (sVar2 == 1) {
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
      sVar2 = flashProgramFromRam(0x4400,&flash_program_block_2_buffer,CONCAT22(0x1a42,uVar6));
      cVar3 = sVar2 == 0;
      if (sVar2 == 1) {
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        local_6 = arrayRangeSum((short *)&DAT_00004000,(short *)&calibration_checksum_end_marker);
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        uVar5 = (ushort)(byte)(cVar3 << 4 | 8);
        parameterCircularBufferWrite(0x803500,(undefined1 *)&local_6,CONCAT22(2,uVar5));
        uVar4 = 0;
        while ((uVar4 < 5000 && (calibration_checksum_expected_1 != local_6))) {
          emptyPlaceholderFunction();
          delayWithWatchdogService(CONCAT22(500,uVar5));
          uVar4 = uVar4 + 1;
        }
        parameterCircularBufferWrite(0x80367c,&eeprom_calibration_write_state,CONCAT22(2,uVar5));
        uVar4 = 0;
        while ((uVar4 < 5000 &&
               (eeprom_calibration_check_value_1 != _eeprom_calibration_write_state))) {
          emptyPlaceholderFunction();
          delayWithWatchdogService(CONCAT22(500,uVar5));
          uVar4 = uVar4 + 1;
        }
        calibration_checksum_workspace._0_2_ = 1;
        canMemoryPointerTableInit();
        iVar1 = (uint)extraout_D0u << 0x10;
      }
      else {
        iVar1 = 1;
      }
    }
    else {
      iVar1 = 1;
    }
  }
  else {
    iVar1 = 1;
  }
  return iVar1;
}



/*
 * Function: eepromCalibrationWriteSecondary @ 0x0000ef80
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

int eepromCalibrationWriteSecondary(void)

{
  ushort extraout_D0u;
  int iVar1;
  short sVar2;
  undefined4 unaff_D2;
  char in_XF;
  char in_NF;
  char in_ZF;
  char in_VF;
  byte in_CF;
  char cVar3;
  ushort uVar4;
  ushort uVar5;
  undefined2 uVar6;
  word local_6;
  
  uVar6 = (undefined2)((uint)unaff_D2 >> 0x10);
  uVar4 = (ushort)(byte)(in_XF << 4 | in_NF << 3 | in_ZF << 2 | in_VF << 1 | in_CF);
  if ((eeprom_calibration_check_value_2 + _eeprom_calibration_write_state & 1) == 0) {
    local_6 = _eeprom_calibration_write_state + 2;
  }
  else {
    local_6 = _eeprom_calibration_write_state + 1;
  }
  parameterCircularBufferWrite(0x803682,(undefined1 *)&local_6,CONCAT22(2,uVar4));
  uVar5 = 0;
  while ((uVar5 < 5000 && (eeprom_calibration_check_value_2 != local_6))) {
    emptyPlaceholderFunction();
    delayWithWatchdogService(CONCAT22(500,uVar4));
    uVar5 = uVar5 + 1;
  }
  iVar1 = flashEraseFromRam(0x6000);
  if (iVar1 == 0) {
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    sVar2 = flashProgramFromRam(0x6000,&flash_program_block_1_buffer,CONCAT22(10,uVar6));
    if (sVar2 == 1) {
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
      sVar2 = flashProgramFromRam(0x6400,&flash_program_block_2_buffer,CONCAT22(0x1a42,uVar6));
      cVar3 = sVar2 == 0;
      if (sVar2 == 1) {
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        local_6 = arrayRangeSum((short *)&eeprom_secondary_base_address,(short *)0x7e42);
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        uVar5 = (ushort)(byte)(cVar3 << 4 | 8);
        parameterCircularBufferWrite(0x803502,(undefined1 *)&local_6,CONCAT22(2,uVar5));
        uVar4 = 0;
        while ((uVar4 < 5000 && (calibration_checksum_expected_2 != local_6))) {
          emptyPlaceholderFunction();
          delayWithWatchdogService(CONCAT22(500,uVar5));
          uVar4 = uVar4 + 1;
        }
        parameterCircularBufferWrite
                  (0x803684,(undefined1 *)&eeprom_calibration_check_value_2,CONCAT22(2,uVar5));
        uVar4 = 0;
        while ((uVar4 < 5000 &&
               (eeprom_calibration_check_value_3 != eeprom_calibration_check_value_2))) {
          emptyPlaceholderFunction();
          delayWithWatchdogService(CONCAT22(500,uVar5));
          uVar4 = uVar4 + 1;
        }
        calibration_checksum_workspace._0_2_ = 2;
        canMemoryPointerTableInit();
        iVar1 = (uint)extraout_D0u << 0x10;
      }
      else {
        iVar1 = 1;
      }
    }
    else {
      iVar1 = 1;
    }
  }
  else {
    iVar1 = 1;
  }
  return iVar1;
}



/*
 * Function: validateRedundantSensors @ 0x0000f1ae
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void validateRedundantSensors(void)

{
  undefined4 uVar1;
  ushort uVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  ushort uVar8;
  
  calibration_checksum_workspace._0_2_ = 0;
  fault_flags_active_base = fault_flags_active_base & 0xefff;
  if (calibration_checksum_end_marker == 0xa1a1) {
    calibrationDataCopyWithChecksum();
    calibration_data_copy_status = 0;
  }
  else if ((_eeprom_calibration_write_state != eeprom_calibration_check_value_1) ||
          (eeprom_calibration_check_value_2 != eeprom_calibration_check_value_3)) {
    if (_eeprom_calibration_write_state != eeprom_calibration_check_value_1) {
      if (eeprom_calibration_check_value_2 != eeprom_calibration_check_value_3) {
        fault_flags_active_base = fault_flags_active_base | 0x1000;
        fault_flags_history_base = fault_flags_history_base | 0x1000;
      }
      else {
        uVar1 = calibrationDataCopySecondary();
        if ((short)uVar1 != 0) {
          fault_flags_active_base = fault_flags_active_base | 0x1000;
          fault_flags_history_base = fault_flags_history_base | 0x1000;
        }
      }
    }
    else {
      uVar1 = calibrationDataCopyWithChecksum();
      if ((short)uVar1 != 0) {
        fault_flags_active_base = fault_flags_active_base | 0x1000;
        fault_flags_history_base = fault_flags_history_base | 0x1000;
      }
    }
  }
  else if ((eeprom_calibration_check_value_2 + _eeprom_calibration_write_state & 1) == 0) {
    uVar1 = calibrationDataCopySecondary();
    if ((short)uVar1 != 0) {
      uVar1 = calibrationDataCopyWithChecksum();
      if ((short)uVar1 != 0) {
        fault_flags_active_base = fault_flags_active_base | 0x1000;
        fault_flags_history_base = fault_flags_history_base | 0x1000;
      }
    }
  }
  else {
    uVar1 = calibrationDataCopyWithChecksum();
    if ((short)uVar1 != 0) {
      uVar1 = calibrationDataCopySecondary();
      if ((short)uVar1 != 0) {
        fault_flags_active_base = fault_flags_active_base | 0x1000;
        fault_flags_history_base = fault_flags_history_base | 0x1000;
      }
    }
  }
  bVar6 = vp44_comm_test_flag < vp44_comm_test_sensor_value;
  bVar3 = (short)(vp44_comm_test_flag - vp44_comm_test_sensor_value) < 0;
  if (vp44_comm_test_flag == vp44_comm_test_sensor_value) {
    uVar8 = (ushort)(byte)(bVar6 << 4 | bVar3 << 3 | 4U |
                           SBORROW2(vp44_comm_test_flag,vp44_comm_test_sensor_value) << 1 | bVar6);
    redundant_sensor_validation_index = 0;
    parameterCircularBufferWrite
              (0x80368a,(undefined1 *)&redundant_sensor_validation_index,CONCAT22(2,uVar8));
    uVar2 = 0;
    while ((uVar2 < 5000 && (redundant_sensor_param_1 != redundant_sensor_validation_index))) {
      emptyPlaceholderFunction();
      delayWithWatchdogService(CONCAT22(500,uVar8));
      uVar2 = uVar2 + 1;
    }
    redundant_sensor_validation_index = redundant_sensor_param_3 + 1;
    parameterCircularBufferWrite
              (0x80368e,(undefined1 *)&redundant_sensor_validation_index,CONCAT22(2,uVar8));
    uVar2 = 0;
    while ((uVar2 < 5000 && (redundant_sensor_param_3 != redundant_sensor_validation_index))) {
      emptyPlaceholderFunction();
      delayWithWatchdogService(CONCAT22(500,uVar8));
      uVar2 = uVar2 + 1;
    }
    bVar3 = (uVar8 & 0x10) != 0;
    bVar6 = (uVar8 & 8) != 0;
    bVar4 = (uVar8 & 4) != 0;
    bVar5 = (uVar8 & 2) != 0;
    bVar7 = (uVar8 & 1) != 0;
    fault_flags_active_base = fault_flags_active_base & 0xf7ff;
  }
  else {
    uVar8 = (ushort)(byte)(bVar6 << 4 | bVar3 << 3 |
                           SBORROW2(vp44_comm_test_flag,vp44_comm_test_sensor_value) << 1 | bVar6);
    redundant_sensor_validation_index = redundant_sensor_param_1 + 1;
    parameterCircularBufferWrite
              (0x80368a,(undefined1 *)&redundant_sensor_validation_index,CONCAT22(2,uVar8));
    uVar2 = 0;
    while ((uVar2 < 5000 && (redundant_sensor_param_1 != redundant_sensor_validation_index))) {
      emptyPlaceholderFunction();
      delayWithWatchdogService(CONCAT22(500,uVar8));
      uVar2 = uVar2 + 1;
    }
    redundant_sensor_validation_index = redundant_sensor_param_2 + 1;
    parameterCircularBufferWrite
              (0x80368c,(undefined1 *)&redundant_sensor_validation_index,CONCAT22(2,uVar8));
    uVar2 = 0;
    while ((uVar2 < 5000 && (redundant_sensor_param_2 != redundant_sensor_validation_index))) {
      emptyPlaceholderFunction();
      delayWithWatchdogService(CONCAT22(500,uVar8));
      uVar2 = uVar2 + 1;
    }
    bVar5 = SBORROW2(redundant_sensor_param_1,redundant_sensor_compare_threshold);
    bVar6 = (short)(redundant_sensor_param_1 - redundant_sensor_compare_threshold) < 0;
    bVar4 = redundant_sensor_param_1 == redundant_sensor_compare_threshold;
    if (redundant_sensor_param_1 < redundant_sensor_compare_threshold) {
      fault_flags_active_base = fault_flags_active_base & 0xf7ff;
      bVar3 = true;
      bVar7 = true;
    }
    else {
      fault_flags_active_base = fault_flags_active_base | 0x800;
      fault_flags_history_base = fault_flags_history_base | 0x800;
      bVar3 = false;
      bVar7 = false;
    }
  }
  uVar8 = (ushort)(byte)(bVar3 << 4 | bVar6 << 3 | bVar4 << 2 | bVar5 << 1 | bVar7);
  redundant_sensor_validation_index = redundant_sensor_param_2 + redundant_sensor_param_3;
  parameterCircularBufferWrite
            (0x803686,(undefined1 *)&redundant_sensor_validation_index,CONCAT22(2,uVar8));
  uVar2 = 0;
  while ((uVar2 < 5000 && (vp44_comm_test_flag != redundant_sensor_validation_index))) {
    emptyPlaceholderFunction();
    delayWithWatchdogService(CONCAT22(500,uVar8));
    uVar2 = uVar2 + 1;
  }
  return;
}



/*
 * Function: firmwareDataCopyToWorkingMemory @ 0x0000f4ea
 */

void firmwareDataCopyToWorkingMemory(void)

{
  dword *pdVar1;
  dword *pdVar2;
  
  pdVar1 = (dword *)&firmware_data_source;
  for (pdVar2 = &can_memory_table_start; pdVar2 < (dword *)0x808ab2; pdVar2 = pdVar2 + 1) {
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    *pdVar2 = *pdVar1;
    pdVar1 = pdVar1 + 1;
  }
  return;
}



/*
 * Function: pwmFuelDemandOutputCalculator @ 0x0000f524
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint pwmFuelDemandOutputCalculator(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = ((uint)current_fuel_demand_value * 0x6400) / 0x1700;
  delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535 = (word)uVar1;
  uVar2 = ((uint)diagnostic_fuel_arbitration_output * 0x6400) / 0x1700;
  time_since_rpm_crossed_oil_pres_start_mon_rpm_0_65535 = (word)uVar2;
  uVar3 = uVar2 & 0xffff0000;
  if ((dtc_active_fault_count & 1) == 0) {
    sim_timer_control_register = sim_timer_control_register & 0xffff0000;
  }
  else {
    uVar3 = ((((uint)pwm_output_scaling_factor * (uVar1 & 0xffff)) / 0x6400 & 0xffff) * 8000) / 1000
            & 0xffff | ((uint)pwm_output_scaling_factor * 8000) / 1000 << 0x10;
    sim_timer_control_register = uVar3;
  }
  uVar3 = uVar3 & 0xffff0000;
  if ((dtc_active_fault_count & 2) == 0) {
    _QADC64_DDRQA = _QADC64_DDRQA & 0xffff0000;
  }
  else {
    uVar3 = ((((uint)pwm_output_2_scaling_factor * (uVar2 & 0xffff)) / 0x6400 & 0xffff) * 8000) /
            1000 & 0xffff | ((uint)pwm_output_2_scaling_factor * 8000) / 1000 << 0x10;
    _QADC64_DDRQA = uVar3;
  }
  if (5 < amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535) {
    uVar3 = uVar3 & 0xffff0000;
    if ((dtc_active_fault_count & 4) == 0) {
      tpu_pwm_channel_3_output = tpu_pwm_channel_3_output & 0xffff0000;
    }
    else {
      uVar3 = ((((uint)pwm_output_3_scaling_factor *
                (uint)errors_allowed_timer_running_flag_for_oil_pres_0_1) / 0x6400 & 0xffff) * 8000)
              / 1000 & 0xffff | ((uint)pwm_output_3_scaling_factor * 8000) / 1000 << 0x10;
      tpu_pwm_channel_3_output = uVar3;
    }
  }
  if (5 < amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535) {
    uVar3 = uVar3 & 0xffff0000;
    if ((dtc_active_fault_count & 8) == 0) {
      tpu_pwm_channel_4_output = tpu_pwm_channel_4_output & 0xffff0000;
    }
    else {
      uVar3 = ((((uint)pwm_output_4_scaling_factor *
                (uint)pointer_to_oil_pressure_fuel_fault_log_data_0_2_32) / 0x6400 & 0xffff) * 8000)
              / 1000 & 0xffff | ((uint)pwm_output_4_scaling_factor * 8000) / 1000 << 0x10;
      tpu_pwm_channel_4_output = uVar3;
    }
  }
  if (((dtc_active_fault_count & 0x10) != 0) && (oil_pressure_rpm_fault_delay != 0)) {
    if (0x63ff < oil_pressure_rpm_fault_delay) {
      uVar3 = ((uint)PTGNQPTB * 8000) / 1000;
      QADC64_QADCMCR = -(short)uVar3 - 1;
      _QADC64_QACR2 = 0x7fff8000;
      return uVar3;
    }
    QADC64_QADCMCR = -(short)(((uint)PTGNQPTB * 8000) / 1000) - 1;
    _QADC64_QACR2 =
         (QADC64_QADCMCR & 0x7fff) +
         (((((uint)PTGNQPTB * (uint)oil_pressure_rpm_fault_delay) / 0x6400 & 0xffff) * 8000) / 1000
         & 0xffff) | 0x7fff0000;
    return _QADC64_QACR2;
  }
  _QADC64_QACR2 = 0x7fff;
  return CONCAT22((short)(uVar3 >> 0x10),dtc_active_fault_count) & 0xffff0010;
}



/*
 * Function: enableFaultFlagScanner @ 0x0000f86a
 */

undefined1 enableFaultFlagScanner(void)

{
  fault_flag_scanner_state = fault_flag_scanner_state | 1;
  return 0;
}



/*
 * Function: waterInFuelDetectionStateInit @ 0x0000f876
 */

uint waterInFuelDetectionStateInit(void)

{
  uint in_D0;
  
  if (water_in_fuel_detection_flag == 1) {
    water_in_fuel_detection_flag = 0;
    amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 = 1;
    calibration_checksum_workspace._2_2_ = 0xeeee;
    return in_D0 & 0xffffff00;
  }
  return 4;
}



/*
 * Function: waterInFuelFaultClear @ 0x0000f89c
 */

undefined1 waterInFuelFaultClear(void)

{
  amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 = 0;
  water_in_fuel_detection_flag = 1;
  calibration_checksum_workspace._2_2_ = 0xaaaa;
  return 0;
}



/*
 * Function: waterInFuelFaultValidation @ 0x0000f8b6
 */

undefined1 waterInFuelFaultValidation(void)

{
  amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 = 1;
  if (calibration_checksum_workspace._2_2_ == -0x5556) {
    calibration_checksum_workspace._2_2_ = -0x1112;
    water_in_fuel_detection_flag = 0;
  }
  return 0;
}



/*
 * Function: activateHighRpmShutdownFlag @ 0x0000f8d8
 */

undefined1 activateHighRpmShutdownFlag(void)

{
  high_rpm_shutdown_active_flag = 1;
  return 0;
}



/*
 * Function: eepromWriteWrapper @ 0x0000f8e4
 */

void eepromWriteWrapper(byte *param_1)

{
  ushort in_stack_00000000;
  
  systemResetWithDiagnostic(param_1,(uint)in_stack_00000000);
  return;
}



/*
 * Function: triggerDiagnosticSystemReset @ 0x0000f8f6
 */

void triggerDiagnosticSystemReset(void)

{
  undefined2 in_stack_00000000;
  
  systemResetWithDiagnostic((byte *)0x0,CONCAT22(1,in_stack_00000000));
  return;
}



/*
 * Function: systemResetWithDiagnostic @ 0x0000f906
 */

/* WARNING: This function may have set the stack pointer */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 systemResetWithDiagnostic(byte *param_1,undefined4 param_2)

{
  uint uVar1;
  undefined4 uVar2;
  undefined4 unaff_A2;
  ushort uVar3;
  int local_8;
  
  uVar3 = (ushort)((uint)unaff_A2 >> 0x10);
  if (engine_operating_mode == ENGINE_IDLE) {
    while (uVar1 = circularBufferEmptyCheck(), (char)uVar1 == '\0') {
      emptyPlaceholderFunction();
      watchdogServiceLoop(CONCAT22(500,uVar3));
    }
    local_8 = _loopCounter;
    parameterCircularBufferWrite(0x80352c,(undefined1 *)&local_8,CONCAT22(4,uVar3));
    if (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 == 0) {
      watchdogServiceLoop(CONCAT22(0xfa,uVar3));
    }
    else {
      while (_loop_counter_reference != local_8) {
        emptyPlaceholderFunction();
        watchdogServiceLoop(CONCAT22(500,uVar3));
      }
    }
    if (param_2._1_1_ == '\0') {
      diagnosticMultiPacketResponseBuilder(param_1,(uint)uVar3);
    }
    else {
      diagnosticMessageQueueWrite((uint)uVar3);
    }
    watchdogServiceLoop(CONCAT22(50000,uVar3));
    sim_data_direction_control = sim_data_direction_control & 0xef;
    ioControlAndCanPinSwitching();
    _sim_chip_select_base_reg0 = 0xf9d2;
    uVar2 = (*_DAT_00000008)();
    uVar2 = CONCAT31((int3)((uint)uVar2 >> 8),0xff);
  }
  else {
    uVar2 = 7;
  }
  return uVar2;
}



/*
 * Function: requestSecuredShutdown @ 0x0000f9e4
 */

undefined1 requestSecuredShutdown(void)

{
  secured_shutdown_request_flag = 1;
  return 0;
}



/*
 * Function: canMessageBufferLogger @ 0x0000f9f0
 */

undefined4 canMessageBufferLogger(void)

{
  undefined4 uVar1;
  
  if (system_logging_state == 1) {
    return 7;
  }
  uVar1 = circularBufferWrite();
  if ((char)uVar1 == '\x01') {
    can_buffer_logger_state = 0;
    return 0xb;
  }
  can_buffer_write_pending = 1;
  points_to_engine_sync_fuel_pressure_fuel_minimun_threshold_0_2_32 = 0;
  return CONCAT31((int3)((uint)uVar1 >> 8),0xff);
}



/*
 * Function: systemFunction8xMaximum @ 0x0000fa40
 */

void systemFunction8xMaximum(void)

{
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  return;
}



/*
 * Function: crc16Calculate @ 0x0000fcb0
 */

undefined4 crc16Calculate(byte *param_1,undefined4 param_2)

{
  ushort uVar1;
  undefined4 unaff_D3;
  undefined4 uVar2;
  
  uVar1 = 0;
  uVar2 = CONCAT22((short)((uint)unaff_D3 >> 0x10),param_2._0_2_);
  while ((char)uVar2 != '\0') {
    uVar1 = (&crc16_lookup_table)[(short)((uVar1 ^ *param_1) & 0xff)] ^ uVar1 >> 8;
    param_1 = (byte *)CONCAT31(param_1._0_3_,(char)param_1 + '\x01');
    uVar2 = CONCAT31((int3)((uint)uVar2 >> 8),(char)uVar2 + -1);
  }
  return CONCAT22((short)((uint)uVar2 >> 0x10),uVar1);
}



/*
 * Function: memoryPatchCrcCalculate @ 0x0000fd02
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 memoryPatchCrcCalculate(void)

{
  byte bVar2;
  ushort uVar1;
  uint unaff_D3;
  uint uVar3;
  word *pwVar4;
  int iVar5;
  
  uVar3 = unaff_D3 & 0xffffff00;
  pwVar4 = &tracks_progress_of_fan_on_due_to_ac_0_3600;
  iVar5 = 0x80d3aa;
  for (bVar2 = 0; bVar2 < _memory_patch_count; bVar2 = bVar2 + 1) {
    uVar3 = CONCAT31((int3)(uVar3 >> 8),*(char *)(iVar5 + 1) + (char)uVar3);
    iVar5 = iVar5 + 6;
  }
  uVar1 = 0;
  while ((char)uVar3 != '\0') {
    uVar1 = (&crc16_lookup_table)[(short)((uVar1 ^ *(byte *)pwVar4) & 0xff)] ^ uVar1 >> 8;
    pwVar4 = (word *)((int)pwVar4 + 1);
    uVar3 = CONCAT31((int3)(uVar3 >> 8),(char)uVar3 + -1);
  }
  return CONCAT22((short)(uVar3 >> 0x10),uVar1);
}



/*
 * Function: coldStartFuelControlSlowCycle40Coordinator @ 0x0000fd68
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort coldStartFuelControlSlowCycle40Coordinator(void)

{
  short sVar1;
  bool bVar2;
  ushort uVar4;
  ushort uVar5;
  uint uVar3;
  word wVar6;
  word unaff_D2w;
  ushort uVar7;
  int iVar8;
  undefined8 uVar9;
  undefined8 uVar10;
  uint uVar11;
  
  wVar6 = diagnostic_system_flags_1 & 0x800;
  if (((((diagnostic_system_flags_1 & 0x800) == 0) ||
       (wVar6 = fuel_timing_mode_blend_factor_965a,
       fuel_timing_mode_blend_factor_965a < value_used_to_detect_sync_pulse_0_100)) ||
      (wVar6 = current_fuel_demand_value, current_fuel_demand_value < used_in_cranking_mode_0_4000))
     || ((wVar6 = current_engine_rpm, current_engine_rpm <= cold_start_rpm_threshold_high ||
         (replaced_old_crank_timer_count2_0 <= current_engine_rpm)))) {
    cold_start_fuel_control_result = 0;
    oil_pressure_protection_snapshot = 0;
    _cold_start_fuel_control_mode = 0;
    return wVar6;
  }
  cold_start_rpm_snapshot = current_engine_rpm;
  cold_start_rpm_snapshot_3 = current_engine_rpm;
  cold_start_rpm_snapshot_2 = current_engine_rpm;
  cold_start_rpm_snapshot_1 = current_engine_rpm;
  cold_start_fuel_demand_snapshot = current_fuel_demand_value;
  if (cold_start_fuel_control_enable_flag != 0 || temp_below_which_cold_crank_can_run_50_293 != 0) {
    if (((fault_status_flags_2 & 0x200) == 0) || ((accelerator_pedal_position & 0x200) == 0)) {
      bVar2 = false;
    }
    else {
      bVar2 = true;
    }
    if (!bVar2) {
      if (((fault_status_flags_2 & 0x400) == 0) || ((accelerator_pedal_position & 0x400) == 0)) {
        bVar2 = false;
      }
      else {
        bVar2 = true;
      }
      if (!bVar2) {
        if (((fault_status_flags_2 & 4) == 0) || ((accelerator_pedal_position & 4) == 0)) {
          bVar2 = false;
        }
        else {
          bVar2 = true;
        }
        if (bVar2) {
LAB_0000fe82:
          if (cold_start_fuel_control_enable_flag == 0) goto LAB_0000fff4;
        }
        else {
          if (((fault_status_flags_2 & 8) == 0) || ((accelerator_pedal_position & 8) == 0)) {
            bVar2 = false;
          }
          else {
            bVar2 = true;
          }
          if (bVar2) goto LAB_0000fe82;
        }
        if (cold_start_fuel_control_enable_flag == 0) {
          cold_start_sensor_reading_sum = insite_diagnostic_reading + diagnostic_sensor_reading;
        }
        else {
          cold_start_sensor_reading_sum = diagnostic_sensor_reading;
        }
        cold_start_sensor_sum_saved = cold_start_sensor_reading_sum;
        uVar4 = lookupTableInterpolation((table_interp_args_t *)&anc_altitude_table_1_size);
        uVar9 = tableInterpolationLookup((short *)&anc_disable_duration_table_size);
        uVar10 = tableInterpolationLookup((short *)&anc_speed_limit_table_1_size);
        uVar5 = (ushort)((ulonglong)uVar10 >> 0x20);
        uVar3 = proportionalCalculation
                          ((uint)cold_start_sensor_reading_sum,
                           (uint)(ushort)((ulonglong)uVar9 >> 0x20),0x400);
        if (uVar3 < 0xbb81) {
          cold_start_fuel_control_state = (word)uVar3;
        }
        else {
          cold_start_fuel_control_state = 48000;
        }
        wVar6 = cold_start_fuel_control_state;
        if (0 < (short)cold_start_fuel_limit_value) {
          uVar11 = 0x100;
          uVar3 = proportionalCalculation
                            ((int)(short)cold_start_fuel_limit_value * (uint)uVar4,0x100,0x4444);
          uVar3 = proportionalCalculation
                            ((uint)cold_start_fuel_control_state,(uVar3 & 0xffff) + 0x100,uVar11);
        }
        if (uVar3 < 0xbb81) {
          cold_start_fuel_control_state = (word)uVar3;
        }
        else {
          cold_start_fuel_control_state = 48000;
        }
        if (cold_start_fuel_control_state < uVar5) {
          iVar8 = 0x7fffffff;
          uVar7 = uVar5 - cold_start_fuel_control_state;
        }
        else {
          uVar7 = cold_start_fuel_control_state - uVar5;
          iVar8 = -0x80000000;
        }
        if (temp_below_which_cold_crank_can_run_50_293 < uVar7) {
          if ((wVar6 != 0) && (uVar4 != 0)) {
            iVar8 = rpmFuelCalculation((int)(short)(uVar5 - cold_start_fuel_control_state),0x4444,
                                       (uint)uVar4 * (uint)wVar6);
          }
          _cold_start_fuel_control_mode = 1;
          if (iVar8 < 0xab) {
            if (iVar8 < -0xaa) {
              unaff_D2w = 0xff56;
            }
            else {
              unaff_D2w = (word)iVar8;
            }
          }
          else {
            unaff_D2w = 0xaa;
          }
        }
        else {
          unaff_D2w = 0;
          _cold_start_fuel_control_mode = 1;
        }
      }
    }
  }
LAB_0000fff4:
  if (cold_start_fuel_control_enable_flag != 0 || temp_below_which_cold_crank_can_run_50_293 != 0) {
    if (((fault_status_flags_2 & 0x200) == 0) || ((accelerator_pedal_position & 0x200) == 0)) {
      bVar2 = false;
    }
    else {
      bVar2 = true;
    }
    if (!bVar2) {
      if (((fault_status_flags_2 & 0x400) == 0) || ((accelerator_pedal_position & 0x400) == 0)) {
        bVar2 = false;
      }
      else {
        bVar2 = true;
      }
      if (!bVar2) {
        if (((fault_status_flags_2 & 4) == 0) || ((accelerator_pedal_position & 4) == 0)) {
          bVar2 = false;
        }
        else {
          bVar2 = true;
        }
        if ((!bVar2) || (cold_start_fuel_control_enable_flag != 0)) {
          if (((fault_status_flags_2 & 8) == 0) || ((accelerator_pedal_position & 8) == 0)) {
            bVar2 = false;
          }
          else {
            bVar2 = true;
          }
          if ((!bVar2) || (cold_start_fuel_control_enable_flag != 0)) goto LAB_000101fa;
        }
      }
    }
  }
  if (((fault_flags_active_base & 0x2000) == 0) || ((fault_flags_enabled_base & 0x2000) == 0)) {
    bVar2 = false;
  }
  else {
    bVar2 = true;
  }
  if (!bVar2) {
    if (((fault_flags_active_base & 0x4000) == 0) || ((fault_flags_enabled_base & 0x4000) == 0)) {
      bVar2 = false;
    }
    else {
      bVar2 = true;
    }
    if (!bVar2) {
      if (the_value_above_set_speed_where_e_brakes_will_turn_off_regard_0_5_10 == 0) {
        if (time_constant_compared_with_prior_pulse_time_in_final_cold_sy_400_0 <
            time_constant_compared_with_prior_pulse_slope_in_final_cold_0_4000) {
          uVar3 = 0x7fffffff;
        }
        else {
          uVar3 = 0x80000000;
        }
      }
      else {
        iVar8 = rpmFuelCalculation(((uint)current_engine_rpm * (uint)current_fuel_demand_value) /
                                   0x1266 & 0xffff,
                                   (uint)
                                   time_constant_compared_with_prior_pulse_slope_in_final_cold_0_4000
                                   - (uint)
                                     time_constant_compared_with_prior_pulse_time_in_final_cold_sy_400_0
                                   ,(uint)
                                    the_value_above_set_speed_where_e_brakes_will_turn_off_regard_0_5_10
                                  );
        uVar3 = (uint)time_constant_compared_with_prior_pulse_time_in_final_cold_sy_400_0 + iVar8;
      }
      if ((int)uVar3 < 0x7f81) {
        if ((int)uVar3 < 0xa00) {
          uVar3 = 0xa00;
        }
      }
      else {
        uVar3 = 0x7f80;
      }
      rpm_delta_for_timing = (word)uVar3;
      if ((uint)engine_speed_limit_below_which_the_cold_crank_sync_determina_0_8000 +
          (uint)intake_manifold_temp_raw < (uVar3 & 0xffff)) {
        sVar1 = intake_manifold_temp_raw - rpm_delta_for_timing;
        uVar4 = lookupTableInterpolation((table_interp_args_t *)&anc_altitude_table_3_size);
        iVar8 = rpmFuelCalculation((uint)uVar4,(int)sVar1,0x7800);
        if (iVar8 < 0xab) {
          if (iVar8 < -0xaa) {
            unaff_D2w = 0xff56;
          }
          else {
            unaff_D2w = (word)iVar8;
          }
        }
        else {
          unaff_D2w = 0xaa;
        }
        _cold_start_fuel_control_mode = 2;
      }
      else {
        unaff_D2w = 0;
        _cold_start_fuel_control_mode = 2;
      }
    }
  }
LAB_000101fa:
  if ((short)unaff_D2w < (short)used_in_cranking_mode_0_4000) {
    oil_pressure_protection_snapshot = used_in_cranking_mode_0_4000;
  }
  else if (((short)unaff_D2w < 1) ||
          ((current_engine_rpm < replaced_old_crank_timer_count1_0 &&
           (value_used_to_detect_sync_pulse_0_100 < current_engine_rpm)))) {
    oil_pressure_protection_snapshot = unaff_D2w;
    if ((int)(uint)number_of_sync_errors_above_which_crank_fueling_will_be_inhib_0_200 <
        (int)(short)unaff_D2w) {
      oil_pressure_protection_snapshot =
           number_of_sync_errors_above_which_crank_fueling_will_be_inhib_0_200;
    }
  }
  else {
    oil_pressure_protection_snapshot = 0;
  }
  if (temp_below_which_cold_crank_can_run_50_293 != 0) {
    if (((fault_status_flags_2 & 0x200) == 0) || ((accelerator_pedal_position & 0x200) == 0)) {
      bVar2 = false;
    }
    else {
      bVar2 = true;
    }
    if (!bVar2) {
      if (((fault_status_flags_2 & 0x400) == 0) || ((accelerator_pedal_position & 0x400) == 0)) {
        bVar2 = false;
      }
      else {
        bVar2 = true;
      }
      if (!bVar2) {
        if (((fault_status_flags_2 & 4) == 0) || ((accelerator_pedal_position & 4) == 0)) {
          bVar2 = false;
        }
        else {
          bVar2 = true;
        }
        if ((!bVar2) || (cold_start_fuel_control_enable_flag != 0)) {
          if (((fault_status_flags_2 & 8) == 0) || ((accelerator_pedal_position & 8) == 0)) {
            uVar4 = 0;
          }
          else {
            uVar4 = 1;
          }
          if (uVar4 == 0) {
            cold_start_fuel_control_result = 8;
            return 0;
          }
          if (cold_start_fuel_control_enable_flag != 0) {
            cold_start_fuel_control_result = 8;
            return uVar4;
          }
        }
      }
    }
  }
  if (((fault_flags_active_base & 0x2000) == 0) || ((fault_flags_enabled_base & 0x2000) == 0)) {
    uVar4 = 0;
  }
  else {
    uVar4 = 1;
  }
  if (uVar4 == 0) {
    if (((fault_flags_active_base & 0x4000) == 0) || ((fault_flags_enabled_base & 0x4000) == 0)) {
      uVar4 = 0;
    }
    else {
      uVar4 = 1;
    }
    if (uVar4 == 0) {
      cold_start_fuel_control_result = 8;
      return 0;
    }
  }
  oil_pressure_protection_snapshot = 0;
  _cold_start_fuel_control_mode = 0;
  cold_start_fuel_control_result = 0;
  return uVar4;
}



/*
 * Function: timingAccumulatorClampedUpdate @ 0x00010366
 */

void timingAccumulatorClampedUpdate(void)

{
  cold_start_fuel_limit_value = fuel_limit_minimum_value;
  if ((short)(oil_pressure_protection_snapshot + fuel_limit_minimum_value) < 0) {
    fuel_limit_minimum_value = 0;
  }
  else {
    fuel_limit_minimum_value = oil_pressure_protection_snapshot + fuel_limit_minimum_value;
  }
  fuel_adjustment_active_flag =
       cold_start_fuel_control_result | fuel_adjustment_active_flag & 0xfff7;
  return;
}



/*
 * Function: initAncSpeedLimitAndAltitudeDerate @ 0x000103a2
 */

void initAncSpeedLimitAndAltitudeDerate(void)

{
  cold_start_rpm_snapshot_2 = current_engine_rpm;
  anc_duty_cycle_ptr = (dword)&duty_cycle_conversion_factor_for_cool_temp_gauge_hot_state_0_9;
  anc_min_active_time_ptr =
       (dword)&minimum_amount_of_time_which_the_anc_speed_limit_will_be_active_0_20;
  anc_altitude_table_1_size = 2;
  cold_start_rpm_snapshot_3 = current_engine_rpm;
  anc_disable_duration_ptr =
       (dword)&duration_anc_speed_limit_will_be_disabled_after_a_bare_engine_a_0_20;
  anc_disable_duration_table_size = 2;
  cold_start_sensor_sum_saved = cold_start_sensor_reading_sum;
  anc_altitude_table_1_ptr = 0x807a66;
  anc_altitude_table_1_base = 2;
  anc_altitude_table_2_ptr = 0x807a6e;
  cold_start_rpm_snapshot = current_engine_rpm;
  anc_default_fueling_ptr =
       (dword)&default_fueling_to_be_used_by_altitude_derate_if_ambient_air_p_0_100;
  anc_altitude_table_3_ptr = 0x807ad8;
  anc_altitude_table_3_size = 2;
  cold_start_rpm_snapshot_1 = current_engine_rpm;
  anc_speed_limit_table_1_ptr = 0x807af4;
  anc_speed_limit_table_1_size = 2;
  cold_start_fuel_demand_snapshot = current_fuel_demand_value;
  anc_speed_limit_table_2_ptr = 0x807b10;
  anc_speed_limit_table_2_base = 2;
  anc_speed_limit_table_3_ptr = 0x807b20;
  return;
}



/*
 * Function: circularBufferWriteWithStatus @ 0x00010466
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void circularBufferWriteWithStatus(void)

{
  int *piVar1;
  
  piVar1 = (int *)&vp44_buffer_start;
  do {
    while( true ) {
      if ((*piVar1 == 0) || (&vp44_buffer_start + (uint)vp44_buffer_count * 4 <= piVar1)) {
        return;
      }
      if (_vp44_transmission_index != 0) break;
      *_vp44_current_read_address = *(undefined1 *)*piVar1;
      piVar1 = piVar1 + 1;
      _vp44_transmission_index = 1;
    }
    _vp44_current_read_address = _vp44_current_read_address + 1;
    if (_vp44_end_address < _vp44_current_read_address) {
      _vp44_current_read_address = _vp44_base_address;
    }
    *_vp44_current_read_address = *(undefined1 *)*piVar1;
    piVar1 = piVar1 + 1;
    if ((_vp44_current_read_address == _vp44_current_write_address) &&
       (_vp44_current_write_address = _vp44_current_write_address + 1,
       _vp44_end_address < _vp44_current_write_address)) {
      _vp44_current_write_address = _vp44_base_address;
    }
  } while (_vp44_current_read_address != _vp44_transmission_address);
  _vp44_state_machine_index = 3;
  return;
}



/*
 * Function: vp44_communication_state_machine @ 0x00010504
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint vp44_communication_state_machine(undefined4 param_1)

{
  int iVar1;
  undefined2 uVar2;
  undefined4 in_D0;
  uint uVar3;
  uint uVar4;
  int *piVar5;
  
  piVar5 = (int *)&vp44_buffer_start;
  uVar2 = (undefined2)((uint)in_D0 >> 0x10);
  uVar4 = CONCAT22(uVar2,vp44_status_flags_1) & 0xffff0100;
  if ((vp44_status_flags_1 & 0x100) != 0) {
    uVar4 = CONCAT22(uVar2,_vp44_command_id);
    if ((_vp44_command_id == param_1._0_2_) && (_vp44_buffer_start != 0)) {
      if (_vp44_init_flag == 0) {
        if (1 < _vp44_buffer_size) {
          _vp44_init_flag = 1;
        }
        if ((_vp44_state_machine_index == 3) && (_vp44_comm_mode == 0)) {
          _vp44_state_machine_index = 0;
        }
        uVar4 = _vp44_state_machine_index;
        if (_vp44_state_machine_index < 4) {
          uVar4 = CONCAT22((short)(_vp44_state_machine_index >> 0x10),
                           (&switchD_00010596::switchdataD_0001059a)[_vp44_state_machine_index]);
          switch(_vp44_state_machine_index) {
          case 0:
            _vp44_transmission_active = 1;
            for (; (*piVar5 != 0 && (piVar5 < (int *)0x804c68)); piVar5 = piVar5 + 1) {
              vp44_buffer_count = vp44_buffer_count + 1;
            }
            iVar1 = _vp44_base_address - 0x2000U % (uint)vp44_buffer_count;
            _vp44_end_address = iVar1 + 0x1fff;
            uVar3 = 0x2000 / vp44_buffer_count;
            vp44_block_size = (word)uVar3;
            vp44_total_data_size = vp44_block_size * vp44_buffer_count;
            _vp44_current_read_address = _vp44_base_address;
            _vp44_current_write_address = _vp44_base_address;
            _vp44_transmission_index = 0;
            if (_vp44_comm_mode == 0) {
              _vp44_state_machine_index = 1;
              _vp44_transmission_address = iVar1 + 0x2000;
              uVar4 = circularBufferWriteWithStatus();
            }
            else {
              if (2 < _vp44_comm_state) {
                _vp44_comm_state = 0;
              }
              uVar4 = (uint)_vp44_comm_state;
              if (_vp44_comm_state == 0) {
                uVar4 = 3;
                _vp44_state_machine_index = 3;
              }
              else if (_vp44_comm_state == 1) {
                _vp44_state_machine_index = 2;
                _vp44_transmission_address =
                     (_vp44_base_address + ((int)uVar3 >> 1) * (uint)vp44_buffer_count) - 1;
                uVar4 = circularBufferWriteWithStatus();
              }
              else if (_vp44_comm_state == 2) {
                _vp44_state_machine_index = 2;
                _vp44_transmission_address = _vp44_end_address;
                uVar4 = circularBufferWriteWithStatus();
              }
            }
            break;
          case 1:
            if (_vp44_comm_mode == 0) {
              uVar4 = circularBufferWriteWithStatus();
            }
            else {
              if (2 < _vp44_comm_state) {
                _vp44_comm_state = 0;
              }
              uVar4 = (uint)_vp44_comm_state;
              if (_vp44_comm_state == 0) {
                uVar4 = 3;
                _vp44_state_machine_index = 3;
              }
              else if (_vp44_comm_state == 1) {
                _vp44_state_machine_index = 2;
                vp44_next_read_address = _vp44_current_read_address + 1;
                if (_vp44_end_address < vp44_next_read_address) {
                  vp44_next_read_address = _vp44_base_address;
                }
                _vp44_transmission_address =
                     _vp44_current_read_address +
                     ((int)(uint)vp44_block_size >> 1) * (uint)vp44_buffer_count;
                if (_vp44_end_address < _vp44_transmission_address) {
                  _vp44_transmission_address = _vp44_transmission_address - vp44_total_data_size;
                }
                uVar4 = circularBufferWriteWithStatus();
              }
              else if (_vp44_comm_state == 2) {
                _vp44_state_machine_index = 2;
                _vp44_transmission_address = _vp44_end_address;
                _vp44_current_read_address = _vp44_base_address;
                _vp44_current_write_address = _vp44_base_address;
                _vp44_transmission_index = 0;
                uVar4 = circularBufferWriteWithStatus();
              }
            }
            break;
          case 2:
            uVar4 = circularBufferWriteWithStatus();
            break;
          case 3:
            vp44_buffer_count = 0;
            _vp44_transmission_active = 0;
          }
        }
      }
      else {
        _vp44_init_flag = _vp44_init_flag + 1;
        uVar4 = CONCAT22(uVar2,_vp44_init_flag);
        if (_vp44_buffer_size <= _vp44_init_flag) {
          _vp44_init_flag = 0;
        }
      }
    }
  }
  return uVar4;
}



/*
 * Function: initVp44BufferAddresses @ 0x0001078e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initVp44BufferAddresses(void)

{
  _vp44_base_address = 0x809d8c;
  _can1_timer_buffer_init_value = &vp44_buffer_start;
  return;
}



/*
 * Function: engineRunTimeHistogramAccumulator @ 0x000107a4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint engineRunTimeHistogramAccumulator(void)

{
  int *piVar1;
  bool bVar2;
  undefined4 in_D0;
  dword dVar3;
  uint uVar4;
  byte bVar5;
  char cVar6;
  char cVar7;
  word *pwVar8;
  undefined8 uVar9;
  
  dVar3 = CONCAT22((short)((uint)in_D0 >> 0x10),engine_operating_mode_flags) & 0xffff0001;
  if (((engine_operating_mode_flags & 1) != 0) && (engine_operating_mode != ENGINE_IDLE)) {
    if (engine_runtime_total_counter == 0) {
      engine_run_counter_snapshot_0 = _engineRunCounter;
    }
    if ((hour_meter_conversion_data == 0) &&
       ((engine_runtime_histogram_counter == 0 ||
        (hour_meter_conversion_state <= engine_runtime_histogram_counter)))) {
      engine_run_counter_snapshot_1 = _engineRunCounter;
    }
    else if ((engine_runtime_histogram_counter == 0) &&
            (hour_meter_conversion_state <= hour_meter_conversion_data)) {
      engine_run_counter_snapshot_2 = _engineRunCounter;
    }
    if ((current_engine_rpm < engine_rpm_histogram_upper_threshold) &&
       (engine_rpm_histogram_lower_threshold <= current_engine_rpm)) {
      engine_runtime_histogram_accumulator = calculated_fuel_timing_value;
    }
    else {
      if (current_engine_rpm < engine_rpm_histogram_upper_threshold) {
        engine_rpm_histogram_threshold_select = engine_rpm_histogram_lower_threshold;
      }
      else {
        engine_rpm_histogram_threshold_select = engine_rpm_histogram_upper_threshold;
      }
      rpm_histogram_threshold_saved = engine_rpm_histogram_threshold_select;
      if (fuel_timing_mode_blend_factor_965a == 0x4000) {
        uVar9 = tableInterpolationLookup((short *)&engine_runtime_histogram_config_type_a);
        engine_runtime_histogram_accumulator = (word)((ulonglong)uVar9 >> 0x20);
      }
      else if (fuel_timing_mode_blend_factor_965a == 0) {
        uVar9 = tableInterpolationLookup((short *)&hour_meter_table_3_size);
        engine_runtime_histogram_accumulator = (word)((ulonglong)uVar9 >> 0x20);
      }
      else {
        uVar9 = tableInterpolationLookup((short *)&engine_runtime_histogram_config_type_a);
        hour_meter_tick_divider = (word)((ulonglong)uVar9 >> 0x20);
        uVar9 = tableInterpolationLookup((short *)&hour_meter_table_3_size);
        engine_runtime_histogram_interpolation_b = (word)((ulonglong)uVar9 >> 0x20);
        engine_runtime_histogram_accumulator =
             (short)((uint)fuel_timing_mode_blend_factor_965a * (uint)hour_meter_tick_divider >> 0xe
                    ) +
             (short)((uint)engine_runtime_histogram_interpolation_b *
                     (0x4000 - (uint)fuel_timing_mode_blend_factor_965a) >> 0xe);
      }
    }
    if (engine_runtime_histogram_accumulator == fsmxthfl_calc_input) {
      engine_runtime_histogram_delta = (dword)runtime_histogram_offset_value;
    }
    else {
      engine_runtime_histogram_delta =
           (int)(((uint)current_fuel_demand_value - (uint)fsmxthfl_calc_input) * 10000) /
           (int)((uint)engine_runtime_histogram_accumulator - (uint)fsmxthfl_calc_input);
    }
    if ((int)engine_runtime_histogram_delta < 0) {
      engine_runtime_histogram_value = 0;
      if (current_engine_rpm < engine_rpm_histogram_upper_threshold) {
        engine_runtime_histogram_index = 0x31;
      }
      else {
        engine_runtime_histogram_index = 0x32;
      }
    }
    else {
      engine_runtime_histogram_value = engine_runtime_histogram_delta._2_2_;
      cVar7 = '\b';
      cVar6 = '\x06';
      bVar2 = false;
      bVar5 = 1;
      pwVar8 = &hysteresis_added_to_postheat_stage_rpm_transitions_0_4500;
      while ((bVar5 < 9 && (!bVar2))) {
        if (current_engine_rpm <= *pwVar8) {
          bVar2 = true;
          if (bVar5 == 1) {
            cVar7 = '\x01';
          }
          else {
            cVar7 = bVar5 - 1;
          }
        }
        bVar5 = bVar5 + 1;
        pwVar8 = pwVar8 + 1;
      }
      bVar2 = false;
      bVar5 = 1;
      pwVar8 = &runtime_histogram_base_value;
      while ((bVar5 < 7 && (!bVar2))) {
        if (engine_runtime_histogram_delta._2_2_ <= *pwVar8) {
          bVar2 = true;
          if (bVar5 == 1) {
            cVar6 = '\x01';
          }
          else {
            cVar6 = bVar5 - 1;
          }
        }
        bVar5 = bVar5 + 1;
        pwVar8 = pwVar8 + 1;
      }
      engine_runtime_histogram_index = cVar7 + ('\x06' - cVar6) * '\b';
    }
    if (engine_runtime_total_counter < 3600000000) {
      piVar1 = (int *)((short)(ushort)engine_runtime_histogram_index * 4 + 0x804aee);
      *piVar1 = *piVar1 + 1;
      engine_runtime_total_counter = engine_runtime_total_counter + 1;
    }
    dVar3 = hour_meter_conversion_data;
    if ((hour_meter_conversion_data < hour_meter_conversion_state) &&
       (hour_meter_conversion_data != 0)) {
      engine_runtime_histogram_mode = INCREMENT;
    }
    else if ((hour_meter_conversion_data == 0) &&
            ((engine_runtime_histogram_counter == 0 ||
             (dVar3 = engine_runtime_histogram_counter,
             hour_meter_conversion_state <= engine_runtime_histogram_counter)))) {
      engine_runtime_histogram_mode = INCREMENT;
    }
    else if (engine_runtime_histogram_counter < hour_meter_conversion_state) {
      engine_runtime_histogram_mode = DECREMENT;
      dVar3 = engine_runtime_histogram_counter;
    }
    else {
      engine_runtime_histogram_mode = HISTOGRAM_IDLE;
      dVar3 = engine_runtime_histogram_counter;
    }
    if (engine_runtime_histogram_mode == INCREMENT) {
      uVar4 = (uint)engine_runtime_histogram_index;
      *(int *)(&engine_runtime_histogram_index + (short)(ushort)engine_runtime_histogram_index * 4)
           = *(int *)(&engine_runtime_histogram_index +
                     (short)(ushort)engine_runtime_histogram_index * 4) + 1;
      hour_meter_conversion_data = hour_meter_conversion_data + 1;
      return uVar4;
    }
    if (engine_runtime_histogram_mode == DECREMENT) {
      dVar3 = (dword)engine_runtime_histogram_index;
      piVar1 = (int *)((short)(ushort)engine_runtime_histogram_index * 4 + 0x809be4);
      *piVar1 = *piVar1 + 1;
      engine_runtime_histogram_counter = engine_runtime_histogram_counter + 1;
    }
  }
  return dVar3;
}



/*
 * Function: initHourMeterConversionData @ 0x00010ad8
 */

void initHourMeterConversionData(void)

{
  byte bVar1;
  dword *pdVar2;
  dword *pdVar3;
  
  rpm_histogram_threshold_saved = engine_rpm_histogram_lower_threshold;
  hour_meter_table_1_ptr = 0x807f42;
  engine_runtime_histogram_config_type_a = 2;
  hour_meter_table_1_limit = 400;
  hour_meter_table_2_ptr = 0x807f68;
  hour_meter_table_2_base = 2;
  hour_meter_intake_temp_ptr =
       (dword)&lower_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293;
  engine_rpm_histogram_threshold_select = engine_rpm_histogram_lower_threshold;
  hour_meter_table_3_ptr = 0x808002;
  hour_meter_table_3_size = 2;
  hour_meter_table_3_limit = 400;
  hour_meter_table_4_ptr = 0x808028;
  hour_meter_table_4_base = 2;
  hour_meter_table_5_ptr = 0x808032;
  hour_meter_conversion_state = (uint)hour_meter_multiplier * 36000;
  hour_meter_tick_counter = hour_meter_multiplier * 0x3c;
  hour_meter_conversion_data = hour_meter_conversion_state;
  if (hour_meter_stored_ticks < hour_meter_tick_counter) {
    hour_meter_conversion_data = ((uint)hour_meter_stored_ticks * 36000) / 0x3c;
  }
  engine_runtime_histogram_counter = hour_meter_conversion_state;
  if (histogram_stored_ticks < hour_meter_tick_counter) {
    engine_runtime_histogram_counter = ((uint)histogram_stored_ticks * 36000) / 0x3c;
  }
  hour_meter_conversion_init_value_1 = runtime_histogram_array_1 * 2;
  hour_meter_conversion_init_value_2 = runtime_histogram_array_2 * 2;
  bVar1 = 1;
  pdVar2 = &hour_meter_conversion_data_1;
  pdVar3 = &hour_meter_conversion_data_2;
  do {
    *pdVar2 = ((uint)(&runtime_histogram_array_1)[(short)(ushort)bVar1] * 36000) / 0x3c;
    *pdVar3 = ((uint)(&runtime_histogram_array_2)[(short)(ushort)bVar1] * 36000) / 0x3c;
    bVar1 = bVar1 + 1;
    pdVar2 = pdVar2 + 1;
    pdVar3 = pdVar3 + 1;
  } while (bVar1 < 0x33);
  return;
}



/*
 * Function: writeHourMeterConversionData @ 0x00010c98
 */

void writeHourMeterConversionData(void)

{
  byte bVar1;
  dword *pdVar2;
  dword *pdVar3;
  
  if (hour_meter_conversion_data < hour_meter_conversion_state) {
    hour_meter_stored_ticks =
         (word)((uint)(&hour_meter_conversion_base + hour_meter_conversion_data * 0xf) / 36000);
  }
  else {
    hour_meter_stored_ticks = hour_meter_tick_counter;
  }
  if (engine_runtime_histogram_counter < hour_meter_conversion_state) {
    histogram_stored_ticks =
         (word)((uint)(&hour_meter_conversion_base + engine_runtime_histogram_counter * 0xf) / 36000
               );
  }
  else {
    histogram_stored_ticks = hour_meter_tick_counter;
  }
  bVar1 = 1;
  pdVar2 = &hour_meter_conversion_data_1;
  pdVar3 = &hour_meter_conversion_data_2;
  do {
    (&runtime_histogram_array_1)[(short)(ushort)bVar1] =
         (word)((uint)(&hour_meter_conversion_base + *pdVar2 * 0xf) / 36000);
    (&runtime_histogram_array_2)[(short)(ushort)bVar1] =
         (word)((uint)(&hour_meter_conversion_base + *pdVar3 * 0xf) / 36000);
    bVar1 = bVar1 + 1;
    pdVar2 = pdVar2 + 1;
    pdVar3 = pdVar3 + 1;
  } while (bVar1 < 0x33);
  return;
}



/*
 * Function: canBusConfigTypeSelector @ 0x00010d78
 */

undefined4 canBusConfigTypeSelector(undefined4 param_1)

{
  char cVar1;
  
  cVar1 = (char)((uint)param_1 >> 0x10);
  if (cVar1 == (char)the_can_bus_configuration_register_0_255) {
    return 1;
  }
  if (cVar1 == (char)the_can_bit_timing_0_register_0_255) {
    return 2;
  }
  if (cVar1 == (char)the_can_bit_timing_1_register_0_255) {
    return 3;
  }
  return 4;
}



/*
 * Function: speedDifferenceInterpolator @ 0x00010da4
 */

void speedDifferenceInterpolator(undefined4 param_1)

{
  undefined8 uVar1;
  undefined2 uVar2;
  
  speed_diff_interp_input = param_1._0_2_;
  uVar2 = 0x80;
  uVar1 = tableInterpolationLookup((short *)&manifold_temp_table_1_type);
  safeDivideWithClamp((short)((short)((ulonglong)uVar1 >> 0x20) -
                             (speed_difference_interpolation_result + param_1._2_2_)) * 0x6400,
                      CONCAT22(the_maximum_speed_a_customer_may_program_to_correspond_with_s_1_5_15
                               - boost_pressure_protection_state_bda0,uVar2));
  return;
}



/*
 * Function: speedBasedParameterLookup @ 0x00010e02
 */

void speedBasedParameterLookup(void)

{
  speed_based_parameter_lookup_result = governor_rpm_error_value;
  manifold_temp_lookup_result_1 =
       lookupTableInterpolation((table_interp_args_t *)&manifold_temp_table_2_type);
  speed_based_parameter_lookup_result = speed_lookup_parameter_value;
  manifold_temp_lookup_result_2 =
       lookupTableInterpolation((table_interp_args_t *)&manifold_temp_table_2_type);
  speed_based_parameter_lookup_result = CRACSWAC;
  boost_pressure_protection_state_bda0 =
       lookupTableInterpolation((table_interp_args_t *)&manifold_temp_table_2_type);
  speed_based_parameter_lookup_result = CRCNDTRF;
  DPFLPSWD = lookupTableInterpolation((table_interp_args_t *)&manifold_temp_table_2_type);
  speed_based_parameter_lookup_result =
       the_minimum_speed_a_customer_may_program_to_correspond_with_s_1_5_15;
  manifold_temp_lookup_result =
       lookupTableInterpolation((table_interp_args_t *)&manifold_temp_table_2_type);
  return;
}



/*
 * Function: multiSpeedParameterInterpolation @ 0x00010e70
 */

void multiSpeedParameterInterpolation(void)

{
  multi_speed_throttle_input = throttle_position_raw;
  speed_difference_interpolation_result =
       lookupTableInterpolation((table_interp_args_t *)&manifold_temp_table_3_type);
  speedBasedParameterLookup();
  speed_difference_interp_result_3 =
       speedDifferenceInterpolator(CONCAT22(governor_rpm_error_value,manifold_temp_lookup_result_1))
  ;
  speed_difference_interp_result_4 =
       speedDifferenceInterpolator
                 (CONCAT22(the_minimum_speed_a_customer_may_program_to_correspond_with_s_1_5_15,
                           manifold_temp_lookup_result));
  manifold_temp_calculated =
       speedDifferenceInterpolator
                 (CONCAT22(speed_lookup_parameter_value,manifold_temp_lookup_result_2));
  speed_difference_interp_result_1 =
       speedDifferenceInterpolator(CONCAT22(CRACSWAC,boost_pressure_protection_state_bda0));
  speed_difference_interp_result_2 = speedDifferenceInterpolator(CONCAT22(CRCNDTRF,DPFLPSWD));
  return;
}



/*
 * Function: fuelDemandPercentageCalculator @ 0x00010f08
 */

void fuelDemandPercentageCalculator(void)

{
  int iVar1;
  undefined2 uVar2;
  
  fuel_demand_percentage_current = fsmxthfl_calc_input;
  speed_based_parameter_lookup_result = CRACSWAC;
  uVar2 = 0x80;
  boost_pressure_protection_state_bda0 =
       lookupTableInterpolation((table_interp_args_t *)&manifold_temp_table_2_type);
  iVar1 = safeDivideWithClamp(((int)(short)current_fuel_demand_value -
                              (int)(short)fuel_demand_percentage_current) * 0x6400,
                              CONCAT22(the_maximum_speed_a_customer_may_program_to_correspond_with_s_1_5_15
                                       - boost_pressure_protection_state_bda0,uVar2));
  fuel_demand_percentage = (word)iVar1;
  return;
}



/*
 * Function: initIntakeManifoldTemperatureLimits @ 0x00010f76
 */

void initIntakeManifoldTemperatureLimits(void)

{
  manifold_temp_table_1_type = 2;
  manifold_temp_table_1_x_ptr = 0x807f42;
  manifold_temp_table_1_count = 400;
  manifold_temp_table_1_y_type = 2;
  manifold_temp_table_1_y_ptr = 0x807f68;
  manifold_temp_table_1_z_ptr =
       (dword)&lower_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293;
  manifold_temp_table_3_type = 2;
  manifold_temp_table_3_x_ptr = 0x808862;
  manifold_temp_table_3_z_ptr = 0x808876;
  manifold_temp_table_2_type = 2;
  manifold_temp_table_2_x_ptr = 0x80883a;
  manifold_temp_table_2_z_ptr = 0x80884e;
  speedBasedParameterLookup();
  return;
}



/*
 * Function: diagnosticCodeDebounceHandler @ 0x00010fee
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticCodeDebounceHandler(undefined4 param_1)

{
  int iVar1;
  short sVar2;
  undefined4 unaff_D2;
  byte bVar3;
  
  bVar3 = (byte)((uint)param_1 >> 0x10);
  if ((((*(byte *)((short)((param_1._0_2_ & 0xff) * 5) * 2 + 0x804fcc) & 1) == 0) &&
      (*(char *)((int)&diagnostic_sensor_data_ptr + (uint)bVar3 * 6 + 1) != '\0')) &&
     ((&diagnostic_pid_dtc_index)[(short)((param_1._0_2_ & 0xff) * 5) * 2] != 0)) {
    iVar1 = (int)(short)((ushort)*(byte *)((int)&diagnostic_sensor_data_ptr + (uint)bVar3 * 6 + 1)
                        << 3);
    if (((*(int *)(&ivs_switch_status_when_throttle_validation_process_error_true_false +
                  (short)((param_1._0_2_ & 0xff) * 5)) == 0) &&
        (*(uint *)(iVar1 + 0x806354) <=
         (uint)(_loopCounter - *(int *)((short)((param_1._0_2_ & 0xff) * 5) * 2 + 0x804fc4)))) ||
       ((*(int *)(&ivs_switch_status_when_throttle_validation_process_error_true_false +
                 (short)((param_1._0_2_ & 0xff) * 5)) != 0 &&
        (*(uint *)(iVar1 + 0x806358) <=
         (uint)(_loopCounter -
               *(int *)(&ivs_switch_status_when_throttle_validation_process_error_true_false +
                       (short)((param_1._0_2_ & 0xff) * 5))))))) {
      sVar2 = (param_1._0_2_ & 0xff) * 10;
      *(int *)((int)&ivs_switch_status_when_throttle_validation_process_error_true_false +
              (int)sVar2) = _loopCounter;
      if ((&diagnostic_pid_dtc_index)[sVar2] != 0) {
        (&diagnostic_pid_dtc_index)[sVar2] = (&diagnostic_pid_dtc_index)[sVar2] - 1;
      }
      if ((&diagnostic_pid_dtc_index)[sVar2] == 0) {
        diagnosticTableEntryClear
                  (CONCAT22(param_1._0_2_,(short)((uint)unaff_D2 >> 0x10)) & 0xffffff);
        if ((*(char *)((int)&diagnostic_sensor_data_ptr + (uint)bVar3 * 6) != '\0') &&
           ((*(ushort *)(&dtc_fault_table_base + (uint)bVar3 * 6) & 0x40) == 0)) {
          insite_fault_detail_index = insite_fault_detail_index - 1;
        }
        diagnostic_active_code_count = diagnostic_active_code_count - 1;
        diagnostic_code_status_count = diagnostic_code_status_count - 1;
        (&diagnostic_active_code_count)[_diagnostic_queue_index] =
             (&diagnostic_active_code_count)[(short)diagnostic_queue_iterator_index];
        iVar1 = (int)(short)diagnostic_queue_iterator_index;
        diagnostic_queue_iterator_index = diagnostic_queue_iterator_index - 1;
        (&diagnostic_code_status_count)[_diagnostic_queue_index] =
             (&diagnostic_code_status_count)[iVar1];
        _diagnostic_queue_index = _diagnostic_queue_index + -1;
      }
    }
  }
  return;
}



/*
 * Function: phase2_sensor_data_processor @ 0x00011060
 */

void phase2_sensor_data_processor(void)

{
  int iVar1;
  short sVar2;
  short in_D0w;
  byte unaff_D2b;
  int unaff_A3;
  short *unaff_A4;
  int *unaff_A5;
  undefined2 in_stack_00000000;
  
  if (((*(int *)(&ivs_switch_status_when_throttle_validation_process_error_true_false +
                (short)((ushort)unaff_D2b * 5)) == 0) &&
      (*(uint *)(in_D0w + 0x806354) <=
       (uint)(*unaff_A5 - *(int *)((short)((ushort)unaff_D2b * 5) * 2 + 0x804fc4)))) ||
     ((*(int *)(&ivs_switch_status_when_throttle_validation_process_error_true_false +
               (short)((ushort)unaff_D2b * 5)) != 0 &&
      (*(uint *)(in_D0w + 0x806358) <=
       (uint)(*unaff_A5 -
             *(int *)(&ivs_switch_status_when_throttle_validation_process_error_true_false +
                     (short)((ushort)unaff_D2b * 5))))))) {
    sVar2 = (ushort)unaff_D2b * 10;
    *(int *)((int)&ivs_switch_status_when_throttle_validation_process_error_true_false + (int)sVar2)
         = *unaff_A5;
    if ((&diagnostic_pid_dtc_index)[sVar2] != 0) {
      (&diagnostic_pid_dtc_index)[sVar2] = (&diagnostic_pid_dtc_index)[sVar2] - 1;
    }
    if ((&diagnostic_pid_dtc_index)[sVar2] == 0) {
      diagnosticTableEntryClear((uint)CONCAT12(unaff_D2b,in_stack_00000000));
      if ((*(char *)(unaff_A3 + 4 + (uint)unaff_D2b * 6) != '\0') &&
         ((*(ushort *)(unaff_A3 + 2 + (uint)unaff_D2b * 6) & 0x40) == 0)) {
        insite_fault_detail_index = insite_fault_detail_index - 1;
      }
      diagnostic_active_code_count = diagnostic_active_code_count - 1;
      diagnostic_code_status_count = diagnostic_code_status_count - 1;
      (&diagnostic_active_code_count)[*unaff_A4] =
           (&diagnostic_active_code_count)[(short)diagnostic_queue_iterator_index];
      iVar1 = (int)(short)diagnostic_queue_iterator_index;
      diagnostic_queue_iterator_index = diagnostic_queue_iterator_index - 1;
      (&diagnostic_code_status_count)[*unaff_A4] = (&diagnostic_code_status_count)[iVar1];
      *unaff_A4 = *unaff_A4 + -1;
    }
  }
  return;
}



/*
 * Function: diagnosticQueueIterator @ 0x000111a2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticQueueIterator(void)

{
  ushort uVar1;
  uint uVar2;
  uint unaff_D2;
  
  uVar2 = unaff_D2 >> 0x10;
  uVar1 = _diagnostic_queue_index + 1;
  if (diagnostic_queue_iterator_index < uVar1) {
    _diagnostic_queue_index = 0;
  }
  else {
    unaff_D2 = (uint)(&diagnostic_active_code_count)[(short)uVar1];
    _diagnostic_queue_index = uVar1;
  }
  diagnosticCodeDebounceHandler(CONCAT22(CONCAT11((char)(uVar1 >> 8),(char)unaff_D2),(short)uVar2));
  return;
}



/*
 * Function: oldestDiagnosticTimestampSearch @ 0x000111de
 */

short oldestDiagnosticTimestampSearch(undefined4 param_1)

{
  short sVar1;
  short sVar2;
  short sVar3;
  uint uVar4;
  short sVar5;
  
  uVar4 = 0xffffffff;
  sVar5 = -1;
  sVar2 = 0;
  sVar3 = 0;
  do {
    sVar1 = *(short *)((int)&dtc_timestamp_array + (int)sVar3) * 10;
    if ((*(byte *)(sVar1 + 0x804fcc) == param_1._0_2_) && (*(uint *)(sVar1 + 0x804fc4) < uVar4)) {
      uVar4 = *(uint *)(sVar1 + 0x804fc4);
      sVar5 = sVar2;
    }
    sVar3 = sVar3 + 0x30;
    sVar2 = sVar2 + 1;
  } while (sVar2 < 0x14);
  return sVar5;
}



/*
 * Function: diagnosticCodeRegistrar @ 0x0001124a
 */

void diagnosticCodeRegistrar(undefined4 param_1)

{
  ushort uVar1;
  undefined4 unaff_D2;
  short sVar2;
  short sVar3;
  undefined2 uVar4;
  
  uVar4 = (undefined2)((uint)unaff_D2 >> 0x10);
  sVar2 = 0;
  sVar3 = 0;
  do {
    if (param_1._0_2_ == *(short *)((int)&dtc_timestamp_array + (int)sVar3)) {
      diagnosticTableSnapshotCapture(CONCAT22(sVar2,param_1._0_2_));
      return;
    }
    sVar3 = sVar3 + 0x30;
    sVar2 = sVar2 + 1;
  } while (sVar2 < 0x14);
  sVar2 = 0;
  sVar3 = 0;
  do {
    if (*(short *)((int)&dtc_timestamp_array + (int)sVar3) == 0x7d) {
      diagnosticTableSnapshotCapture(CONCAT22(sVar2,param_1._0_2_));
      return;
    }
    sVar3 = sVar3 + 0x30;
    sVar2 = sVar2 + 1;
  } while (sVar2 < 0x14);
  uVar1 = oldestDiagnosticTimestampSearch(CONCAT22(2,uVar4));
  if (uVar1 < 0x14) {
    sVar2 = *(short *)(&dtc_timestamp_array + (short)(uVar1 * 6) * 2);
    diagnosticTableSnapshotCapture(CONCAT22(uVar1,param_1._0_2_));
    *(undefined1 *)((short)(sVar2 * 5) * 2 + 0x804fcc) = 0;
    return;
  }
  uVar1 = oldestDiagnosticTimestampSearch(CONCAT22(3,uVar4));
  if (uVar1 < 0x14) {
    sVar2 = *(short *)(&dtc_timestamp_array + (short)(uVar1 * 6) * 2);
    diagnosticTableSnapshotCapture(CONCAT22(uVar1,param_1._0_2_));
    *(undefined1 *)((short)(sVar2 * 5) * 2 + 0x804fcc) = 1;
  }
  return;
}



/*
 * Function: diagnosticCodeClearHandler @ 0x0001133c
 */

void diagnosticCodeClearHandler(void)

{
  int iVar1;
  bool bVar2;
  undefined4 unaff_D2;
  byte bVar3;
  undefined2 uVar4;
  
  uVar4 = (undefined2)((uint)unaff_D2 >> 0x10);
  if ((diagnostic_code_clear_handler_state != 0) && (diagnostic_code_clear_handler_state < 0x7d)) {
    bVar2 = false;
    bVar3 = 0;
    while (!bVar2) {
      bVar3 = bVar3 + 1;
      if ((uint)diagnostic_active_code_count == bVar3 - 1) {
        bVar2 = true;
      }
      else if ((&diagnostic_active_code_count)[(short)(ushort)bVar3] ==
               diagnostic_code_clear_handler_state) {
        if ((*(char *)((int)&diagnostic_sensor_data_ptr +
                      (uint)diagnostic_code_clear_handler_state * 6) != '\0') &&
           ((*(ushort *)(&dtc_fault_table_base + (uint)diagnostic_code_clear_handler_state * 6) &
            0x40) == 0)) {
          insite_fault_detail_index = insite_fault_detail_index - 1;
        }
        bVar2 = true;
        diagnostic_active_code_count = diagnostic_active_code_count - 1;
        diagnostic_code_status_count = diagnostic_code_status_count - 1;
        (&diagnostic_active_code_count)[(short)(ushort)bVar3] =
             (&diagnostic_active_code_count)[(short)diagnostic_queue_iterator_index];
        iVar1 = (int)(short)diagnostic_queue_iterator_index;
        diagnostic_queue_iterator_index = diagnostic_queue_iterator_index - 1;
        (&diagnostic_code_status_count)[(short)(ushort)bVar3] =
             (&diagnostic_code_status_count)[iVar1];
        diagnosticTableEntryClear(CONCAT22(diagnostic_code_clear_handler_state,uVar4));
      }
    }
    diagnostic_code_clear_handler_state = 0;
    return;
  }
  if (diagnostic_code_clear_handler_state == 0) {
    for (bVar3 = 1; bVar3 <= diagnostic_active_code_count; bVar3 = bVar3 + 1) {
      diagnosticTableEntryClear
                ((uint)CONCAT12((&diagnostic_active_code_count)[(short)(ushort)bVar3],uVar4));
    }
    diagnostic_active_code_count = 0;
    diagnostic_code_status_count = 0;
    diagnostic_queue_iterator_index = 0;
    insite_fault_detail_index = 0;
    diagnostic_code_clear_handler_state = 0;
  }
  return;
}



/*
 * Function: diagnosticCodeMaskedClear @ 0x0001147c
 */

void diagnosticCodeMaskedClear(void)

{
  int iVar1;
  undefined4 unaff_D2;
  byte bVar2;
  undefined2 uVar3;
  
  uVar3 = (undefined2)((uint)unaff_D2 >> 0x10);
  if ((insite_pid_dtc_handler_state & 0xc0) == 0x40) {
    for (bVar2 = 1; bVar2 <= diagnostic_active_code_count; bVar2 = bVar2 + 1) {
      iVar1 = (int)(short)((ushort)(&diagnostic_active_code_count)[(short)(ushort)bVar2] * 6);
      if ((*(byte *)((int)&diagnostic_sensor_data_ptr + iVar1) ==
           diagnostic_code_clear_handler_state) &&
         (((int)(uint)*(ushort *)(&dtc_fault_table_base + iVar1) >> 7 & 0x3fU) ==
          (insite_pid_dtc_handler_state & 0x3f))) {
        diagnosticTableEntryClear
                  ((uint)CONCAT12((&diagnostic_active_code_count)[(short)(ushort)bVar2],uVar3));
        (&diagnostic_active_code_count)[(short)(ushort)bVar2] =
             (&diagnostic_active_code_count)[(short)diagnostic_queue_iterator_index];
        iVar1 = (int)(short)diagnostic_queue_iterator_index;
        diagnostic_queue_iterator_index = diagnostic_queue_iterator_index - 1;
        (&diagnostic_code_status_count)[(short)(ushort)bVar2] =
             (&diagnostic_code_status_count)[iVar1];
        diagnostic_active_code_count = diagnostic_active_code_count - 1;
        diagnostic_code_status_count = diagnostic_code_status_count - 1;
        bVar2 = bVar2 - 1;
      }
    }
    diagnostic_code_clear_handler_state = 0;
    return;
  }
  for (bVar2 = 1; bVar2 <= diagnostic_active_code_count; bVar2 = bVar2 + 1) {
    diagnosticTableEntryClear
              ((uint)CONCAT12((&diagnostic_active_code_count)[(short)(ushort)bVar2],uVar3));
  }
  diagnostic_active_code_count = 0;
  diagnostic_code_status_count = 0;
  diagnostic_queue_iterator_index = 0;
  insite_fault_detail_index = 0;
  diagnostic_code_clear_handler_state = 0;
  return;
}



/*
 * Function: diagnosticStateMachineProcessor @ 0x000115b2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticStateMachineProcessor(void)

{
  int iVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  bool bVar5;
  undefined4 unaff_D2;
  byte bVar6;
  ushort uVar7;
  ushort uVar8;
  undefined2 uVar9;
  
  uVar9 = (undefined2)((uint)unaff_D2 >> 0x10);
  uVar2 = (&fault_flags_active_base)[(short)diagnostic_fault_group_index];
  uVar3 = (&fault_flags_history_base)[(short)diagnostic_fault_group_index];
  (&fault_flags_history_base)[(short)diagnostic_fault_group_index] = 0;
  uVar7 = 1;
  uVar8 = 0;
  do {
    if ((uVar7 & (uVar3 | uVar2)) == 0) {
      if (((((uVar7 & (&diagnostic_fault_group_bitmask_array)[(short)diagnostic_fault_group_index])
             != 0) &&
           (uVar4 = *(ushort *)((short)(uVar8 + diagnostic_fault_group_index * 0x10) * 2 + 0x806374)
           , uVar4 < 0x7d)) &&
          ((uVar7 & (&fault_flags_enabled_base)[(short)diagnostic_fault_group_index]) != 0)) &&
         ((*(char *)((short)uVar4 + 0x804f46) != '\0' &&
          (*(char *)((short)uVar4 + 0x804f46) = *(char *)((short)uVar4 + 0x804f46) + -1,
          *(char *)((short)uVar4 + 0x804f46) == '\0')))) {
        *(undefined1 *)((short)(uVar4 * 5) * 2 + 0x804fcc) = 2;
        *(undefined4 *)((short)(uVar4 * 5) * 2 + 0x804fc4) = _loopCounter;
        bVar5 = false;
        bVar6 = 0;
        while (!bVar5) {
          bVar6 = bVar6 + 1;
          if ((uint)diagnostic_pending_code_count == bVar6 - 1) {
            bVar5 = true;
          }
          else if ((&diagnostic_pending_code_count)[(short)(ushort)bVar6] == uVar4) {
            bVar5 = true;
            if ((*(char *)((int)&diagnostic_sensor_data_ptr + (uint)uVar4 * 6) != '\0') &&
               ((*(ushort *)(&dtc_fault_table_base + (uint)uVar4 * 6) & 0x40) == 0)) {
              insite_fault_detail_state = insite_fault_detail_state - 1;
              circularBufferPush(&
                                 time_key_switch_is_on_and_ecm_is_running_boot_or_application_0_2_29
                                 ,CONCAT22(uVar4,uVar9) & 0xffffff);
            }
            diagnostic_pending_code_count = diagnostic_pending_code_count - 1;
            diagnostic_pending_list_count = diagnostic_pending_list_count - 1;
            (&diagnostic_pending_code_count)[(short)(ushort)bVar6] =
                 (&diagnostic_pending_code_count)[(short)diagnostic_state_machine_index];
            iVar1 = (int)(short)diagnostic_state_machine_index;
            diagnostic_state_machine_index = diagnostic_state_machine_index - 1;
            (&diagnostic_pending_list_count)[(short)(ushort)bVar6] =
                 (&diagnostic_pending_list_count)[iVar1];
          }
        }
        if (diagnostic_active_code_count != 0x1f) {
          diagnostic_active_code_count = diagnostic_active_code_count + 1;
          diagnostic_code_status_count = diagnostic_code_status_count + 1;
          diagnostic_queue_iterator_index = diagnostic_queue_iterator_index + 1;
          (&diagnostic_active_code_count)[(short)diagnostic_queue_iterator_index] = (byte)uVar4;
          (&diagnostic_code_status_count)[(short)diagnostic_queue_iterator_index] =
               (&diagnostic_fault_parameter_array)[(uint)uVar4 * 3];
          if ((*(char *)((int)&diagnostic_sensor_data_ptr + (uint)uVar4 * 6) != '\0') &&
             ((*(ushort *)(&dtc_fault_table_base + (uint)uVar4 * 6) & 0x40) == 0)) {
            insite_fault_detail_index = insite_fault_detail_index + 1;
          }
        }
        diagnostic_active_fault_counter = diagnostic_active_fault_counter - 1;
      }
    }
    else {
      uVar4 = *(ushort *)((short)(uVar8 + diagnostic_fault_group_index * 0x10) * 2 + 0x806374);
      if ((((uVar4 < 0x7d) &&
           ((uVar7 & (&diagnostic_fault_group_bitmask_array)[(short)diagnostic_fault_group_index])
            == 0)) && (diagnostic_pending_code_count != 0x1f)) &&
         ((uVar7 & (&fault_flags_enabled_base)[(short)diagnostic_fault_group_index]) != 0)) {
        if ((&diagnostic_pid_dtc_index)[(short)(uVar4 * 5) * 2] != 0xff) {
          (&diagnostic_pid_dtc_index)[(short)(uVar4 * 5) * 2] =
               (&diagnostic_pid_dtc_index)[(short)(uVar4 * 5) * 2] + 1;
        }
        if (*(char *)((short)uVar4 + 0x804f46) == '\0') {
          diagnosticCodeRegistrar(CONCAT22(uVar4,uVar9));
          *(undefined1 *)((short)(uVar4 * 5) * 2 + 0x804fcc) = 3;
          *(undefined4 *)((short)(uVar4 * 5) * 2 + 0x804fc4) = _loopCounter;
          (&ivs_switch_status_when_throttle_validation_process_error_true_false + (short)(uVar4 * 5)
          )[0] = 0;
          (&ivs_switch_status_when_throttle_validation_process_error_true_false + (short)(uVar4 * 5)
          )[1] = 0;
          bVar5 = false;
          bVar6 = 0;
          while (!bVar5) {
            bVar6 = bVar6 + 1;
            if ((uint)diagnostic_active_code_count == bVar6 - 1) {
              bVar5 = true;
            }
            else if ((&diagnostic_active_code_count)[(short)(ushort)bVar6] == uVar4) {
              bVar5 = true;
              if ((*(char *)((int)&diagnostic_sensor_data_ptr + (uint)uVar4 * 6) != '\0') &&
                 ((*(ushort *)(&dtc_fault_table_base + (uint)uVar4 * 6) & 0x40) == 0)) {
                insite_fault_detail_index = insite_fault_detail_index - 1;
              }
              diagnostic_active_code_count = diagnostic_active_code_count - 1;
              diagnostic_code_status_count = diagnostic_code_status_count - 1;
              (&diagnostic_active_code_count)[(short)(ushort)bVar6] =
                   (&diagnostic_active_code_count)[(short)diagnostic_queue_iterator_index];
              iVar1 = (int)(short)diagnostic_queue_iterator_index;
              diagnostic_queue_iterator_index = diagnostic_queue_iterator_index - 1;
              (&diagnostic_code_status_count)[(short)(ushort)bVar6] =
                   (&diagnostic_code_status_count)[iVar1];
            }
          }
          diagnostic_pending_code_count = diagnostic_pending_code_count + 1;
          diagnostic_pending_list_count = diagnostic_pending_list_count + 1;
          diagnostic_state_machine_index = diagnostic_state_machine_index + 1;
          (&diagnostic_pending_code_count)[(short)diagnostic_state_machine_index] = (byte)uVar4;
          (&diagnostic_pending_list_count)[(short)diagnostic_state_machine_index] =
               (&diagnostic_fault_parameter_array)[(uint)uVar4 * 3];
          if ((*(char *)((int)&diagnostic_sensor_data_ptr + (uint)uVar4 * 6) != '\0') &&
             ((*(ushort *)(&dtc_fault_table_base + (uint)uVar4 * 6) & 0x40) == 0)) {
            insite_fault_detail_state = insite_fault_detail_state + 1;
            circularBufferPush(&time_key_switch_is_on_and_ecm_is_running_boot_or_application_0_2_29,
                               (uint)(uint3)(CONCAT12((byte)uVar4,uVar9) | 0x800000));
          }
          diagnostic_active_fault_counter = diagnostic_active_fault_counter + 1;
        }
        if (*(char *)((short)uVar4 + 0x804f46) != -1) {
          *(char *)((short)uVar4 + 0x804f46) = *(char *)((short)uVar4 + 0x804f46) + '\x01';
        }
      }
    }
    uVar7 = uVar7 * 2;
    uVar8 = uVar8 + 1;
  } while (uVar8 < 0x10);
  (&diagnostic_fault_group_bitmask_array)[(short)diagnostic_fault_group_index] = uVar3 | uVar2;
  return;
}



/*
 * Function: faultFlagScannerAndProcessor @ 0x00011a0a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void faultFlagScannerAndProcessor(void)

{
  ushort uVar1;
  int iVar2;
  ushort uVar3;
  word *pwVar4;
  
  for (iVar2 = 0;
      ((((&fault_flags_active_base)[(short)diagnostic_fault_group_index] == 0 &&
        ((&fault_flags_history_base)[(short)diagnostic_fault_group_index] == 0)) &&
       ((&diagnostic_fault_group_bitmask_array)[(short)diagnostic_fault_group_index] == 0)) &&
      (iVar2 < 0x20)); iVar2 = iVar2 + 1) {
    diagnostic_fault_group_index = diagnostic_fault_group_index + 1;
    if (0x1f < diagnostic_fault_group_index) {
      diagnostic_fault_group_index = 0;
    }
  }
  if (iVar2 < 0x20) {
    diagnosticStateMachineProcessor();
    diagnostic_fault_group_index = diagnostic_fault_group_index + 1;
    if (0x1f < diagnostic_fault_group_index) {
      diagnostic_fault_group_index = 0;
    }
  }
  if ((fault_flag_scanner_state & 1) == 0) {
    if ((fault_flag_scanner_state & 2) != 0) {
      diagnosticCodeMaskedClear();
      fault_flag_scanner_state = 0;
    }
  }
  else {
    diagnosticCodeClearHandler();
    fault_flag_scanner_state = 0;
  }
  if (0x18 < (uint)(_loopCounter - _fault_scanner_loop_timestamp)) {
    uVar1 = 1;
    uVar3 = 0;
    pwVar4 = &fault_flag_bitmap_table_1_base;
    do {
      if (((uint)(&vp44_communication_status)[(int)(uint)*pwVar4 >> 3] & 1 << (*pwVar4 & 7)) == 0) {
        _fault_flag_snapshot_register_3 = ~uVar1 & _fault_flag_snapshot_register_3;
      }
      else {
        _fault_flag_snapshot_register_3 = uVar1 | _fault_flag_snapshot_register_3;
      }
      uVar1 = uVar1 * 2;
      pwVar4 = pwVar4 + 1;
      uVar3 = uVar3 + 1;
    } while (uVar3 < 0x10);
    uVar1 = 1;
    uVar3 = 0;
    pwVar4 = &fault_flag_bitmap_table_2_base;
    do {
      if (((uint)(&vp44_communication_status)[(int)(uint)*pwVar4 >> 3] & 1 << (*pwVar4 & 7)) == 0) {
        _fault_flag_snapshot_register_2 = ~uVar1 & _fault_flag_snapshot_register_2;
      }
      else {
        _fault_flag_snapshot_register_2 = uVar1 | _fault_flag_snapshot_register_2;
      }
      uVar1 = uVar1 * 2;
      pwVar4 = pwVar4 + 1;
      uVar3 = uVar3 + 1;
    } while (uVar3 < 0x10);
    uVar1 = 1;
    uVar3 = 0;
    pwVar4 = &fault_flag_bitmap_table_3_base;
    do {
      if (((uint)(&vp44_communication_status)[(int)(uint)*pwVar4 >> 3] & 1 << (*pwVar4 & 7)) == 0) {
        _fault_flag_snapshot_register_1 = ~uVar1 & _fault_flag_snapshot_register_1;
      }
      else {
        _fault_flag_snapshot_register_1 = uVar1 | _fault_flag_snapshot_register_1;
      }
      uVar1 = uVar1 * 2;
      pwVar4 = pwVar4 + 1;
      uVar3 = uVar3 + 1;
    } while (uVar3 < 0x10);
    diagnosticQueueIterator();
    _fault_scanner_loop_timestamp = _loopCounter;
  }
  return;
}



/*
 * Function: insitePidDtcHandler @ 0x00011ba0
 */

void insitePidDtcHandler(undefined4 param_1)

{
  bool bVar1;
  short sVar2;
  byte bVar3;
  word *pwVar4;
  
  bVar1 = false;
  insite_parameter_lookup_state = 0;
  pwVar4 = &diagnostic_fault_parameter_array;
  sVar2 = 0;
  for (bVar3 = 0; (!bVar1 && (bVar3 < 0x7d)); bVar3 = bVar3 + 1) {
    if (((char)((uint)param_1 >> 0x10) == *(char *)(pwVar4 + 2)) &&
       (((insite_pid_dtc_handler_state & 0x3f) == ((int)(uint)pwVar4[1] >> 7 & 0x3fU) &&
        ((&diagnostic_pid_dtc_index)[sVar2] != 0)))) {
      insite_parameter_lookup_state = *pwVar4;
      bVar1 = true;
    }
    sVar2 = sVar2 + 10;
    pwVar4 = pwVar4 + 3;
  }
  return;
}



/*
 * Function: initHourMeterSystem @ 0x00011c0c
 */

void initHourMeterSystem(void)

{
  undefined2 in_stack_00000000;
  
  circularBufferInit(&time_key_switch_is_on_and_ecm_is_running_boot_or_application_0_2_29,0x80bdb6,
                     CONCAT22(10,in_stack_00000000));
  return;
}



/*
 * Function: vp44_status_data_collector @ 0x00011c28
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort vp44_status_data_collector(void)

{
  uint uVar1;
  uint uVar2;
  undefined4 unaff_D2;
  short local_12;
  uint local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  local_8 = CONCAT13(qsm_test_reg_low,
                     CONCAT12(qsm_test_reg_high,CONCAT11(qsm_config_reg_low,qsm_config_reg_high)));
  local_c._1_3_ = (uint3)CONCAT11(qsm_int_vector_reg,qsm_int_level_reg);
  local_c = CONCAT13(sim_rsr,local_c._1_3_);
  local_10 = (uint)sim_swsr;
  vp44_status_buffer_start = qsm_config_reg_high;
  vp44_status_byte1 = qsm_config_reg_low;
  vp44_status_byte2 = qsm_test_reg_high;
  vp44_status_byte3 = qsm_test_reg_low;
  vp44_status_byte4 = qsm_int_level_reg;
  vp44_status_byte5 = qsm_int_vector_reg;
  vp44_status_byte6 = 0;
  vp44_status_byte7 = sim_rsr;
  vp44_status_byte8 = sim_swsr;
  (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] = _vp44_xor_mask_1 ^ local_8;
  *(uint *)(&vp44_extended_array_0 + (short)(ushort)vp44_buffer_index * 4) =
       _vp44_xor_mask_2 ^ local_c;
  *(uint *)(&vp44_third_array_0 + (short)(ushort)vp44_buffer_index * 4) =
       _high_limit_for_cruise_rsg_error_delta_0_255 ^ local_10;
  if ((vp44_flag_register_1 & 0x400) != 0) {
    (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] =
         (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] ^ 0x400;
  }
  if ((vp44_flag_register_1 & 0x800) != 0) {
    (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] =
         (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] ^ 0x800;
  }
  if ((_vp44_flag_register_2 & 1) != 0) {
    (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] =
         (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] ^ 2;
  }
  if ((_vp44_flag_register_2 & 2) != 0) {
    (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] =
         (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] ^ 4;
  }
  if ((_vp44_flag_register_2 & 4) != 0) {
    (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] =
         (&vp44_status_array_0)[(short)(ushort)vp44_buffer_index] ^ 8;
  }
  uVar2 = _vp44_status_array_3 | _vp44_status_array_2 | _vp44_status_array_1 | vp44_status_array_0;
  uVar1 = _vp44_status_array_3 & _vp44_status_array_2 & _vp44_status_array_1 & vp44_status_array_0;
  local_8._3_1_ = (byte)uVar2;
  local_c._3_1_ = (byte)uVar1;
  vp44_communication_status =
       ((byte)local_c | (byte)local_8 & vp44_communication_status) & ~_vp44_mask_array[1] |
       vp44_forced_status_1 & _vp44_mask_array[1];
  local_8._2_1_ = (byte)(uVar2 >> 8);
  local_c._2_1_ = (byte)(uVar1 >> 8);
  derate_status_byte =
       *_vp44_mask_array & vp44_forced_status_2 |
       ~*_vp44_mask_array & (local_c._2_1_ | local_8._2_1_ & derate_status_byte);
  local_8._1_1_ = (byte)(uVar2 >> 0x10);
  local_c._1_1_ = (byte)(uVar1 >> 0x10);
  vp44_sensor_history_state =
       (local_c._1_1_ | local_8._1_1_ & vp44_sensor_history_state) & ~_vp44_mask_array[3] |
       vp44_forced_status_3 & _vp44_mask_array[3];
  local_8._0_1_ = (byte)(uVar2 >> 0x18);
  local_c._0_1_ = (byte)(uVar1 >> 0x18);
  vp44_sensor_diagnostic_state_bdc9 =
       vp44_forced_status_4 & _vp44_mask_array[2] |
       ~_vp44_mask_array[2] & (local_c._0_1_ | local_8._0_1_ & vp44_sensor_diagnostic_state_bdc9);
  uVar2 = _vp44_extended_array_3 |
          _vp44_extended_array_2 | _vp44_extended_array_1 | _vp44_extended_array_0;
  uVar1 = _vp44_extended_array_3 &
          _vp44_extended_array_2 & _vp44_extended_array_1 & _vp44_extended_array_0;
  local_8._3_1_ = (byte)uVar2;
  local_c._3_1_ = (byte)uVar1;
  io_control_state_delay =
       ((byte)local_c | (byte)local_8 & io_control_state_delay) & ~_vp44_mask_array[5] |
       vp44_forced_status_5 & _vp44_mask_array[5];
  local_8._2_1_ = (byte)(uVar2 >> 8);
  local_c._2_1_ = (byte)(uVar1 >> 8);
  vp44_io_can_fault_state =
       vp44_forced_status_6 & _vp44_mask_array[4] |
       ~_vp44_mask_array[4] & (local_c._2_1_ | local_8._2_1_ & vp44_io_can_fault_state);
  if (_vp44_extended_processing_enable != 0) {
    local_8._1_1_ = (byte)(uVar2 >> 0x10);
    local_c._1_1_ = (byte)(uVar1 >> 0x10);
    sensor_status_register =
         (local_c._1_1_ | local_8._1_1_ & sensor_status_register) & ~_vp44_mask_array[7] |
         vp44_forced_status_7 & _vp44_mask_array[7];
  }
  local_8._0_1_ = (byte)(uVar2 >> 0x18);
  local_c._0_1_ = (byte)(uVar1 >> 0x18);
  vp44_extended_status_byte_4 =
       (local_c._0_1_ | local_8._0_1_ & vp44_extended_status_byte_4) & ~_vp44_mask_array[6] |
       vp44_forced_status_8 & _vp44_mask_array[6];
  local_8 = vp44_third_array_3 | vp44_third_array_2 | vp44_third_array_1 | _vp44_third_array_0;
  local_c = vp44_third_array_3 & vp44_third_array_2 & vp44_third_array_1 & _vp44_third_array_0;
  vp44_status_history_flag =
       ((byte)local_c | (byte)local_8 & vp44_status_history_flag) & ~_vp44_mask_array[9] |
       vp44_forced_status_9 & _vp44_mask_array[9];
  if ((_vp44_comm_bit0_prev_state != 0) && ((vp44_communication_status & 1) == 0)) {
    local_12 = vp44_comm_bit0_counter + 1;
    parameterCircularBufferWrite
              (0x803678,(undefined1 *)&local_12,CONCAT22(2,(short)((uint)unaff_D2 >> 0x10)));
  }
  _vp44_comm_bit0_prev_state = (byte)-((vp44_communication_status & 1) != 0) & 1;
  if (_vp44_extended_processing_enable != 0) {
    if ((vp44_communication_status & 8) == 0) {
      sensor_status_register = sensor_status_register & 0xef;
    }
    else {
      sensor_status_register = sensor_status_register | 0x10;
    }
    if ((vp44_communication_status & 4) == 0) {
      sensor_status_register = sensor_status_register & 0xfb;
    }
    else {
      sensor_status_register = sensor_status_register | 4;
    }
    if ((vp44_communication_status & 2) == 0) {
      sensor_status_register = sensor_status_register & 0xfe;
    }
    else {
      sensor_status_register = sensor_status_register | 1;
    }
    if (((vp44_communication_status & 2) == 0) || ((vp44_communication_status & 4) == 0)) {
      sensor_status_register = sensor_status_register & 0xdf;
    }
    else {
      sensor_status_register = sensor_status_register & 0xfa | 0x20;
    }
    if ((vp44_communication_status & 4) == 0) {
      vp44_comm_bit2_debounce_timer = 0;
      if (vp44_sensor_type_selector == 1) {
        sensor_status_register = sensor_status_register & 0xfd;
      }
      else {
        sensor_status_register = sensor_status_register & 0xf7;
      }
    }
    else {
      vp44_comm_bit2_debounce_timer = vp44_comm_bit2_debounce_timer + 1;
      if ((0x18 < vp44_comm_bit2_debounce_timer) &&
         (vp44_comm_bit2_debounce_timer = 0x19, (sensor_status_register & 0x20) == 0)) {
        if (vp44_sensor_type_selector == 1) {
          sensor_status_register = sensor_status_register | 2;
        }
        else {
          sensor_status_register = sensor_status_register | 8;
        }
      }
    }
    if ((vp44_communication_status & 2) == 0) {
      vp44_comm_bit1_debounce_timer = 0;
      if (vp44_sensor_type_selector == 1) {
        sensor_status_register = sensor_status_register & 0xf7;
      }
      else {
        sensor_status_register = sensor_status_register & 0xfd;
      }
    }
    else {
      vp44_comm_bit1_debounce_timer = vp44_comm_bit1_debounce_timer + 1;
      if ((0x18 < vp44_comm_bit1_debounce_timer) &&
         (vp44_comm_bit1_debounce_timer = 0x19, (sensor_status_register & 0x20) == 0)) {
        if (vp44_sensor_type_selector == 1) {
          sensor_status_register = sensor_status_register | 8;
        }
        else {
          sensor_status_register = sensor_status_register | 2;
        }
      }
    }
  }
  if (((vp44_sensor_diagnostic_state_bdc9 & 1) != 0) == ((vp44_sensor_history_state & 0x20) != 0)) {
    vp44_sensor_fault_debounce_timer = vp44_sensor_fault_debounce_timer + 1;
    if (0x31 < vp44_sensor_fault_debounce_timer) {
      engine_fault_register_a = engine_fault_register_a | 0x800;
      engine_fault_register_c = engine_fault_register_c | 0x800;
    }
  }
  else {
    vp44_sensor_fault_debounce_timer = 0;
    if (((engine_fault_register_a & 0x800) != 0) && ((engine_fault_register_c & 0x800) == 0)) {
      engine_fault_register_a = engine_fault_register_a & 0xf7ff;
    }
  }
  if (((derate_status_byte & 0x20) == 0) || ((derate_status_byte & 0x40) == 0)) {
    vp44_derate_fault_debounce_timer = 0;
    if (((io_fault_status_reg_4 & 2) != 0) && ((io_fault_latch_reg_4 & 2) == 0)) {
      io_fault_status_reg_4 = io_fault_status_reg_4 & 0xfffd;
    }
  }
  else {
    vp44_derate_fault_debounce_timer = vp44_derate_fault_debounce_timer + 1;
    if (0x31 < vp44_derate_fault_debounce_timer) {
      io_fault_status_reg_4 = io_fault_status_reg_4 | 2;
      io_fault_latch_reg_4 = io_fault_latch_reg_4 | 2;
    }
  }
  emptyStubFunction4();
  if ((vp44_flag_register_1 & 0x10) == 0) {
    if ((vp44_sensor_history_state & 2) == 0) {
      vp44_fuel_temperature_state = vp44_fuel_temperature_state & 0xfe;
    }
    else {
      vp44_fuel_temperature_state = vp44_fuel_temperature_state | 1;
    }
  }
  else if ((vp44_sensor_diagnostic_state_bdc9 & 4) == 0) {
    vp44_fuel_temperature_state = vp44_fuel_temperature_state & 0xfe;
  }
  else {
    vp44_fuel_temperature_state = vp44_fuel_temperature_state | 1;
  }
  vp44_buffer_index = vp44_buffer_index + 1;
  if (3 < vp44_buffer_index) {
    vp44_buffer_index = 0;
  }
  return vp44_flag_register_1 & 0x10;
}



/*
 * Function: ioControlAndCanPinSwitching @ 0x000122d0
 */

void ioControlAndCanPinSwitching(void)

{
  SIM_CAN_CONTROL_PORT_1 = io_control_source_register;
  SIM_CAN_CONTROL_PORT_2 = io_control_flags & 0xfe | ~io_control_flags & 1;
  sim_rsr = sim_data_direction_control;
  if ((~can_pin_switching_control_flags & 0x20) == 0) {
    can1_canidar2 = can1_canidar2 & 0xf3ff | 0x800;
  }
  else {
    can1_canidar2 = can1_canidar2 & 0xf3ff | 0x400;
  }
  return;
}



/*
 * Function: initVP44StatusMonitoring @ 0x00012356
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initVP44StatusMonitoring(void)

{
  byte bVar1;
  
  _vp44_mask_array = 0x8035ee;
  bVar1 = 0;
  do {
    vp44_status_data_collector();
    bVar1 = bVar1 + 1;
  } while (bVar1 < 4);
  return;
}



/*
 * Function: initCANBus @ 0x00012376
 */

void initCANBus(void)

{
  qsm_sci_control_0_high = 0xf;
  qsm_sci_control_0_low = 0x80;
  qsm_sci_control_1_high = 0x80;
  SIM_CAN_CONTROL_PORT_1 = 0;
  sim_data_direction_control = sim_data_direction_control | 0x10;
  can1_cantbsel = can1_cantbsel & 0xdfff;
  can1_canidmr2 = can1_canidmr2 & 0xdfff;
  can1_canidac = can1_canidac & 0xff0f | 0xe0;
  IMB_PICR = 0x113;
  can1_canidmr0 = can1_canidmr0 & 0xf3ff | 0x400;
  do {
  } while ((IMB_PITR & 0x8000) != 0);
  do {
  } while ((IMB_PITR & 0x8000) == 0);
  do {
  } while ((IMB_PITR & 0x8000) != 0);
  SIM_CAN_CONTROL_PORT_2 = SIM_CAN_CONTROL_PORT_2 & 0x7f | 0x80;
  can1_canidar2 = can1_canidar2 & 0xf3ff | 0x400;
  can_pin_switching_control_flags = can_pin_switching_control_flags | 0x20;
  io_control_source_register = io_control_source_register & 0xfa | 0x80;
  io_control_flags = io_control_flags | 1;
  output_control_status_byte = output_control_status_byte | 1;
  ioControlAndCanPinSwitching();
  return;
}



/*
 * Function: emptyStubFunction4 @ 0x00012482
 */

void emptyStubFunction4(void)

{
  return;
}



/*
 * Function: diagnosticCommandDispatcher @ 0x00012484
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticCommandDispatcher(void)

{
  undefined1 uVar1;
  char cVar2;
  ushort uVar3;
  uint uVar4;
  char securityCheckResult;
  char cVar6;
  undefined4 uVar5;
  undefined4 unaff_D2;
  byte bVar7;
  byte *pbVar8;
  byte subFunctionCode;
  undefined2 uVar9;
  ushort uVar10;
  undefined2 local_18;
  byte abStack_16 [10];
  undefined4 local_c;
  byte *messageDataPtr;
  ushort responsePrefix;
  char messageLength;
  
  uVar3 = hardware_timer_register._0_2_;
  responsePrefix = (ushort)((uint)unaff_D2 >> 0x10);
  if ((can_buffer_write_pending != 0) && (uVar4 = circularBufferEmptyCheck(), (char)uVar4 != '\0'))
  {
    can_buffer_write_pending = 0;
    diagnosticMessageQueueWrite((uint)responsePrefix);
  }
  do {
    if ((499 < (int)((uint)hardware_timer_register._0_2_ - (uint)uVar3)) ||
       ((_can_tx_message_type == _enables_input_of_eps_period_data_to_pptb_0_1 &&
        (tpu_transmission_active_flag != 1)))) {
      return;
    }
    messageLength = *_enables_input_of_eps_period_data_to_pptb_0_1;
    messageDataPtr._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
    cVar6 = (char)messageDataPtr;
    messageDataPtr._0_3_ = (undefined3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8);
    messageDataPtr = (byte *)CONCAT31(messageDataPtr._0_3_,(char)messageDataPtr + '\x01');
    if (*messageDataPtr < 8) {
      if ((_diagnostic_service_enable_flags & 1) != 0) {
        switch(*messageDataPtr) {
        case 3:
          messageDataPtr = (byte *)CONCAT31(messageDataPtr._0_3_,cVar6 + '\x02');
          bVar7 = 0;
          pbVar8 = abStack_16;
          do {
            *pbVar8 = *messageDataPtr;
            messageDataPtr = (byte *)CONCAT31(messageDataPtr._0_3_,(char)messageDataPtr + '\x01');
            bVar7 = bVar7 + 1;
            pbVar8 = pbVar8 + 1;
          } while (bVar7 < 10);
          securityCheckResult = systemSecurityCheckStub_AlwaysPasses();
          if (securityCheckResult == '\0') {
            switch(*messageDataPtr) {
            case 0x40:
              cVar6 = waterInFuelFaultClear();
              break;
            case 0x41:
              cVar6 = waterInFuelFaultValidation();
              break;
            case 0x42:
              cVar6 = activateHighRpmShutdownFlag();
              break;
            case 0x43:
              cVar6 = triggerDiagnosticSystemReset();
              break;
            default:
              cVar6 = '\x18';
              break;
            case 0x50:
              cVar6 = '\0';
              break;
            case 0x51:
              uVar4 = memoryPatchingSystem();
              cVar6 = (char)uVar4;
              break;
            case 0x52:
              cVar6 = requestSecuredShutdown();
              break;
            case 0x53:
              cVar6 = '\x04';
              break;
            case 0x54:
              uVar5 = canMessageBufferLogger();
              cVar6 = (char)uVar5;
            }
            if (cVar6 != -1) {
              diagnosticMessageQueueWrite((uint)CONCAT12(cVar6,responsePrefix));
            }
          }
          else {
            diagnosticMessageQueueWrite(CONCAT22(3,responsePrefix));
          }
          break;
        case 4:
          messageDataPtr = (byte *)CONCAT31(messageDataPtr._0_3_,cVar6 + '\x02');
          switch(*messageDataPtr) {
          case 100:
            systemControl64();
            break;
          case 0x65:
            uVar10 = 0;
            enableFaultFlagScanner();
            diagnosticMessageQueueWrite((uint)uVar10);
            break;
          case 0x66:
            diagnostic_command_state = 0;
            diagnosticMessageQueueWrite((uint)responsePrefix);
            break;
          default:
            diagnosticMessageQueueWrite(CONCAT22(0x18,responsePrefix));
            break;
          case 0x69:
            uVar9 = 0;
            uVar4 = waterInFuelDetectionStateInit();
            diagnosticMessageQueueWrite((uint)CONCAT12((char)uVar4,uVar9));
            break;
          case 0x70:
          case 0x72:
          case 0x76:
            diagnosticMessageQueueWrite(CONCAT22(4,responsePrefix));
            break;
          case 0x71:
            diagnostic_command_state = diagnostic_command_state | 1;
            diagnosticMessageQueueWrite((uint)responsePrefix);
            break;
          case 0x73:
            diagnostic_command_state = diagnostic_command_state | 2;
            diagnosticMessageQueueWrite((uint)responsePrefix);
            break;
          case 0x74:
            systemControl74();
            break;
          case 0x75:
            systemControl75();
          }
          break;
        case 5:
          messageDataPtr = (byte *)CONCAT31(messageDataPtr._0_3_,cVar6 + '\x02');
          if (((*messageDataPtr & 0xf) == 0) && ((*messageDataPtr & 0xf0) != 0xf0)) {
            cVar2 = messageLength + -1 + cVar6;
            local_c = (undefined1 *)CONCAT31(messageDataPtr._0_3_,cVar2);
            uVar1 = *local_c;
            local_c = (undefined1 *)CONCAT31(messageDataPtr._0_3_,cVar2 + '\x01');
            local_18 = CONCAT11(*local_c,uVar1);
            local_c = (undefined1 *)CONCAT31(messageDataPtr._0_3_,cVar6 + '\x03');
            uVar5 = crc16Calculate((byte *)CONCAT22((short)((uint)
                                                  _enables_input_of_eps_period_data_to_pptb_0_1 >>
                                                  0x10),(short)local_c),
                                   (uint)CONCAT12(messageLength + -4,responsePrefix));
            if ((short)uVar5 != local_18) {
              diagnosticMessageQueueWrite(CONCAT22(0x14,responsePrefix));
              break;
            }
          }
          bVar7 = *messageDataPtr & 0xf0;
          if (bVar7 == 0x60) {
            diagnosticMemoryReadHandler(CONCAT22(3,responsePrefix));
          }
          else if (bVar7 == 0xc0) {
            diagnosticMemoryReadHandler(CONCAT22(2,responsePrefix));
          }
          else if (bVar7 == 0x80) {
            diagnosticMemoryWriteHandler(CONCAT22(4,responsePrefix));
          }
          else if (bVar7 == 0xe0) {
            diagnosticMemoryReadHandler(CONCAT22(1,responsePrefix));
          }
          else if (bVar7 == 0xa0) {
            diagnosticMemoryWriteHandler(CONCAT22(2,responsePrefix));
          }
          else if (bVar7 == 0xf0) {
            multiPacketTransmitHandler();
          }
          else if (bVar7 == 0xb0) {
            multiPacketReceiveHandler();
          }
          else {
            diagnosticMessageQueueWrite(CONCAT22(4,responsePrefix));
          }
          break;
        case 6:
          messageDataPtr = (byte *)CONCAT31(messageDataPtr._0_3_,cVar6 + '\x02');
          if ((*messageDataPtr == 0x74) && (tpu_diagnostic_retry_counter != 0)) {
            diagnosticMessageQueueWrite(CONCAT22(1,responsePrefix));
            tpu_diagnostic_retry_counter = tpu_diagnostic_retry_counter - 1;
            diag_multipacket_transmit_pending = 0;
            if (multi_packet_receive_state != 0) {
              memoryPatchCountDecrement();
              multi_packet_receive_state = 0;
            }
          }
        }
      }
    }
    else if (*messageDataPtr < 0x80) {
      if (((0x44 < *messageDataPtr) && (*messageDataPtr < 0x57)) &&
         ((_diagnostic_service_enable_flags & 4) != 0)) {
        switch(*messageDataPtr) {
        case 0x4a:
          fuelArbitratorControlService();
          break;
        case 0x4c:
          extendedDiagnosticService4C();
          break;
        case 0x4f:
          extendedDiagnosticService4F();
          break;
        case 0x51:
          extendedDiagnosticService51();
        }
      }
    }
    else if ((_diagnostic_service_enable_flags & 2) != 0) {
      insiteLiveDataHandler();
    }
    _enables_input_of_eps_period_data_to_pptb_0_1 =
         (char *)CONCAT31(_enables_input_of_eps_period_data_to_pptb_0_1,
                          messageLength + '\x01' + CSSYSSCM);
    tpu_transmission_active_flag = 0;
    tpu_cier = tpu_cier | 0x20;
  } while( true );
}



/*
 * Function: safeDivideWithClamp @ 0x00012966
 */

int safeDivideWithClamp(uint param_1,int param_2)

{
  uint uVar1;
  uint uVar2;
  
  if ((((int)param_1 < 0) || (param_2 < 0)) && ((-1 < (int)param_1 || (-1 < param_2)))) {
    if (param_2._0_2_ * -0x8000 < 0) {
      uVar1 = param_2._0_2_ * 0x8000;
    }
    else {
      uVar1 = param_2._0_2_ * -0x8000;
    }
    uVar2 = param_1;
    if ((int)param_1 < 0) {
      uVar2 = -param_1;
    }
    if (uVar2 < uVar1) {
      return (int)param_1 / (int)param_2._0_2_;
    }
    return CONCAT22((short)(uVar1 >> 0x10),0x8000);
  }
  if (param_2._0_2_ * 0x7fff < 0) {
    uVar1 = param_2._0_2_ * -0x7fff;
  }
  else {
    uVar1 = param_2._0_2_ * 0x7fff;
  }
  uVar2 = param_1;
  if ((int)param_1 < 0) {
    uVar2 = -param_1;
  }
  if (uVar2 < uVar1) {
    return (int)param_1 / (int)param_2._0_2_;
  }
  return CONCAT22((short)(uVar1 >> 0x10),0x7fff);
}



/*
 * Function: clampedDivisionCalculator @ 0x00012a26
 */

uint clampedDivisionCalculator(uint param_1,uint param_2,int param_3)

{
  undefined2 uVar1;
  undefined4 in_D0;
  uint uVar2;
  uint uVar3;
  
  uVar1 = (undefined2)((uint)in_D0 >> 0x10);
  if ((((int)param_1 < 0) || ((int)param_2 < 0)) && ((-1 < (int)param_1 || (-1 < (int)param_2)))) {
    if (-1 < param_3) {
      return CONCAT22(uVar1,param_3._0_2_);
    }
    if ((int)param_2._0_2_ * (int)param_3._0_2_ < 0) {
      uVar2 = -((int)param_2._0_2_ * (int)param_3._0_2_);
    }
    else {
      uVar2 = (int)param_2._0_2_ * (int)param_3._0_2_;
    }
    uVar3 = param_1;
    if ((int)param_1 < 0) {
      uVar3 = -param_1;
    }
    if (uVar3 < uVar2) {
      uVar2 = (int)param_1 / (int)param_2._0_2_;
      if ((short)uVar2 < param_2._2_2_) {
        return uVar2;
      }
      return CONCAT22((short)(uVar2 >> 0x10),param_2._2_2_);
    }
    return CONCAT22((short)(uVar2 >> 0x10),param_3._0_2_);
  }
  if (param_2._2_2_ < 1) {
    return CONCAT22(uVar1,param_2._2_2_);
  }
  if ((int)param_2._0_2_ * (int)param_2._2_2_ < 0) {
    uVar2 = -((int)param_2._0_2_ * (int)param_2._2_2_);
  }
  else {
    uVar2 = (int)param_2._0_2_ * (int)param_2._2_2_;
  }
  uVar3 = param_1;
  if ((int)param_1 < 0) {
    uVar3 = -param_1;
  }
  if (uVar3 < uVar2) {
    uVar2 = (int)param_1 / (int)param_2._0_2_;
    if (param_3._0_2_ < (short)uVar2) {
      return uVar2;
    }
    return CONCAT22((short)(uVar2 >> 0x10),param_3._0_2_);
  }
  return CONCAT22((short)(uVar2 >> 0x10),param_2._2_2_);
}



/*
 * Function: param_address_calc @ 0x00012afa
 */

uint param_address_calc(uint param_1,undefined4 param_2)

{
  if ((uint)param_2._0_2_ * 0xffff <= param_1) {
    return CONCAT22((short)((uint)param_2._0_2_ * 0xffff >> 0x10),0xffff);
  }
  return param_1 / param_2._0_2_;
}



/*
 * Function: limitedDivisionCalculator @ 0x00012b30
 */

uint limitedDivisionCalculator(uint param_1,uint param_2,undefined4 param_3)

{
  uint uVar1;
  
  uVar1 = (uint)param_2._0_2_ * (param_2 & 0xffff);
  if (uVar1 <= param_1) {
    return CONCAT22((short)(uVar1 >> 0x10),param_2._2_2_);
  }
  uVar1 = param_1 / param_2._0_2_;
  if ((ushort)uVar1 <= param_3._0_2_) {
    return CONCAT22((short)(uVar1 >> 0x10),param_3._0_2_);
  }
  return uVar1;
}



/*
 * Function: multiPacketTransmitHandler @ 0x00012b74
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void multiPacketTransmitHandler(void)

{
  undefined1 uVar1;
  dword dVar2;
  char cVar3;
  char cVar6;
  int iVar4;
  undefined4 uVar5;
  undefined4 unaff_D2;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  undefined2 uVar10;
  undefined4 local_c;
  undefined4 local_8;
  
  dVar2 = can_transmit_buffer_ptr;
  uVar10 = (undefined2)((uint)unaff_D2 >> 0x10);
  diag_multipacket_transmit_pending = 0;
  if (*_enables_input_of_eps_period_data_to_pptb_0_1 == '\x06') {
    local_8._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
    cVar3 = (char)local_8;
    local_8._0_3_ = (undefined3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8);
    local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x03');
    uVar1 = *local_8;
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar3 + '\x04');
    diag_transfer_state_t_0080d3f8.target_address = CONCAT11(*local_8,uVar1);
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar3 + '\x05');
    cVar6 = diagnosticMemoryAddressResolver(0x80);
    if (cVar6 == '\0') {
      bVar8 = *local_8;
      local_8 = (byte *)CONCAT31(local_8._0_3_,cVar3 + '\x06');
      diag_transfer_state_t_0080d3f8.byte_count = CONCAT11(*local_8,bVar8);
      if (diag_transfer_state_t_0080d3f8.byte_count < 0xf) {
        bVar9 = bVar8 + 6;
      }
      else {
        bVar9 = 0x14;
        bVar8 = 0xe;
        diag_multipacket_transmit_pending = 1;
      }
      if ((int)dVar2 < _can_transmit_length) {
        iVar4 = (_can_transmit_length - dVar2) + -2;
      }
      else {
        iVar4 = (_can_transmit_length - dVar2) + 0xfe;
      }
      if ((int)(uint)bVar9 < iVar4) {
        local_c._3_1_ = (char)dVar2;
        cVar3 = (char)local_c;
        local_c._0_3_ = (undefined3)(dVar2 >> 8);
        local_c = (byte *)CONCAT31(local_c._0_3_,(char)local_c + '\x01');
        *local_c = 7;
        local_c = (byte *)CONCAT31(local_c._0_3_,cVar3 + '\x02');
        *local_c = bVar8 | 0xb0;
        local_c = (byte *)CONCAT31(local_c._0_3_,cVar3 + '\x03');
        uVar5 = addressRangeValidator
                          (diag_transfer_state_t_0080d3f8.data_pointer,
                           CONCAT22(diag_transfer_state_t_0080d3f8.byte_count,uVar10));
        cVar6 = (char)uVar5;
        if ((cVar6 == '\t') || (cVar6 == '\n')) {
          diagnosticMessageQueueWrite((uint)CONCAT12(cVar6,uVar10));
          diag_multipacket_transmit_pending = 0;
        }
        else {
          *local_c = (undefined1)diag_transfer_state_t_0080d3f8.target_address;
          local_c = (byte *)CONCAT31(local_c._0_3_,cVar3 + '\x04');
          *local_c = diag_transfer_state_t_0080d3f8.target_address._0_1_;
          local_c = (byte *)CONCAT31(local_c._0_3_,cVar3 + '\x05');
          *local_c = (undefined1)diag_transfer_state_t_0080d3f8.byte_count;
          local_c = (byte *)CONCAT31(local_c._0_3_,cVar3 + '\x06');
          *local_c = diag_transfer_state_t_0080d3f8.byte_count._0_1_;
          local_c = (byte *)CONCAT31(local_c._0_3_,cVar3 + '\a');
          for (bVar7 = 0; bVar7 < bVar8; bVar7 = bVar7 + 1) {
            uVar1 = *(undefined1 *)diag_transfer_state_t_0080d3f8.data_pointer;
            diag_transfer_state_t_0080d3f8.data_pointer =
                 diag_transfer_state_t_0080d3f8.data_pointer + 1;
            *local_c = uVar1;
            local_c = (byte *)CONCAT31(local_c._0_3_,(char)local_c + '\x01');
          }
          diag_transfer_state_t_0080d3f8.byte_count =
               diag_transfer_state_t_0080d3f8.byte_count - bVar8;
          *(byte *)dVar2 = bVar9;
          *local_c = 0;
          can_transmit_buffer_ptr = (dword)local_c;
          tpuTransmissionTrigger();
          diag_multipacket_transmit_pending = 1;
        }
      }
      else {
        diag_multipacket_transmit_pending = 0;
        diagnosticMessageQueueWrite(CONCAT22(4,uVar10));
        io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
        io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
      }
    }
    else {
      diagnosticMessageQueueWrite(CONCAT22(8,uVar10));
    }
  }
  else {
    diagnosticMessageQueueWrite(CONCAT22(4,uVar10));
  }
  return;
}



/*
 * Function: multiPacketReceiveHandler @ 0x00012d76
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void multiPacketReceiveHandler(void)

{
  undefined1 uVar1;
  byte bVar2;
  short sVar3;
  dword dVar4;
  undefined4 uVar5;
  char cVar6;
  undefined4 unaff_D2;
  byte bVar7;
  ushort uVar8;
  undefined2 local_a;
  undefined4 local_8;
  
  uVar8 = (ushort)((uint)unaff_D2 >> 0x10);
  local_8._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
  cVar6 = (char)local_8;
  local_8._0_3_ = (undefined3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8);
  local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x02');
  bVar2 = *local_8 & 0xf;
  if (multi_packet_receive_state == 1) {
    if ((uint)*_enables_input_of_eps_period_data_to_pptb_0_1 - (uint)bVar2 == 4) {
      local_8 = (byte *)CONCAT31(local_8._0_3_,cVar6 + '\x03');
      uVar1 = *local_8;
      local_8 = (byte *)CONCAT31(local_8._0_3_,cVar6 + '\x04');
      local_a = CONCAT11(*local_8,uVar1);
      local_8 = (byte *)CONCAT31(local_8._0_3_,cVar6 + '\x05');
      if (local_a == diag_transfer_state_t_0080d3f8.target_address) {
        switch(diag_transfer_state_t_0080d3f8.target_address) {
        case 0x15:
        case 0x17:
        case 0x18:
        case 0x19:
          for (bVar7 = 0; bVar7 < bVar2; bVar7 = bVar7 + 1) {
            dVar4 = diag_transfer_state_t_0080d3f8.data_pointer + 1;
            *(byte *)diag_transfer_state_t_0080d3f8.data_pointer = *local_8;
            diag_transfer_state_t_0080d3f8.data_pointer = dVar4;
            local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
          }
          diag_transfer_state_t_0080d3f8._10_2_ =
               diag_transfer_state_t_0080d3f8._10_2_ - (ushort)bVar2;
          if (diag_transfer_state_t_0080d3f8._10_2_ == 0) {
            multi_packet_receive_state = 0;
          }
          break;
        default:
          uVar5 = addressRangeValidator
                            (diag_transfer_state_t_0080d3f8.data_pointer,
                             CONCAT22(diag_transfer_state_t_0080d3f8._10_2_,uVar8));
          if (((char)uVar5 == '\x03') || ((char)uVar5 == '\x05')) {
            (&timer_used_to_disable_rsg_when_veh_and_eng_speeds_disagree_0_100)
            [(short)(_memory_patch_count * 3)] =
                 (ushort)bVar2 +
                 (&timer_used_to_disable_rsg_when_veh_and_eng_speeds_disagree_0_100)
                 [(short)(_memory_patch_count * 3)];
            for (bVar7 = 0; bVar7 < bVar2; bVar7 = bVar7 + 1) {
              dVar4 = can_rx_buffer_ptr + 1;
              *(byte *)can_rx_buffer_ptr = *local_8;
              can_rx_buffer_ptr = dVar4;
              local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
            }
            diag_transfer_state_t_0080d3f8._10_2_ =
                 diag_transfer_state_t_0080d3f8._10_2_ - (ushort)bVar2;
            if (diag_transfer_state_t_0080d3f8._10_2_ == 0) {
              multi_packet_receive_state = 0;
            }
          }
          else {
            for (bVar7 = 0; bVar7 < bVar2; bVar7 = bVar7 + 1) {
              dVar4 = diag_transfer_state_t_0080d3f8.data_pointer + 1;
              *(byte *)diag_transfer_state_t_0080d3f8.data_pointer = *local_8;
              diag_transfer_state_t_0080d3f8.data_pointer = dVar4;
              local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
            }
            diag_transfer_state_t_0080d3f8._10_2_ =
                 diag_transfer_state_t_0080d3f8._10_2_ - (ushort)bVar2;
            if (diag_transfer_state_t_0080d3f8._10_2_ == 0) {
              multi_packet_receive_state = 0;
            }
          }
        }
        diagnosticMessageQueueWrite((uint)uVar8);
      }
      else {
        _memory_patch_count = _memory_patch_count - 1;
        can_rx_buffer_ptr =
             can_rx_buffer_ptr - *(ushort *)((short)(_memory_patch_count * 3) * 2 + 0x80d3aa);
        multi_packet_receive_state = 0;
        diagnosticMessageQueueWrite(CONCAT22(4,uVar8));
      }
    }
    else {
      diagnosticMessageQueueWrite(CONCAT22(4,uVar8));
    }
  }
  else if ((uint)*_enables_input_of_eps_period_data_to_pptb_0_1 - (uint)bVar2 == 6) {
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar6 + '\x03');
    uVar1 = *local_8;
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar6 + '\x04');
    diag_transfer_state_t_0080d3f8.target_address = CONCAT11(*local_8,uVar1);
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar6 + '\x05');
    diag_transfer_state_t_0080d3f8.rx_active_flag = *local_8;
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar6 + '\x06');
    diag_transfer_state_t_0080d3f8.tx_active_flag = *local_8;
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar6 + '\a');
    cVar6 = diagnosticMemoryAddressResolver(0x80);
    if (cVar6 == '\0') {
      switch(diag_transfer_state_t_0080d3f8.target_address) {
      case 0x15:
      case 0x17:
      case 0x18:
      case 0x19:
        for (bVar7 = 0; bVar7 < bVar2; bVar7 = bVar7 + 1) {
          dVar4 = diag_transfer_state_t_0080d3f8.data_pointer + 1;
          *(byte *)diag_transfer_state_t_0080d3f8.data_pointer = *local_8;
          diag_transfer_state_t_0080d3f8.data_pointer = dVar4;
          local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
        }
        diag_transfer_state_t_0080d3f8._10_2_ =
             diag_transfer_state_t_0080d3f8._10_2_ - (ushort)bVar2;
        if (diag_transfer_state_t_0080d3f8._10_2_ != 0) {
          multi_packet_receive_state = 1;
        }
        break;
      default:
        uVar5 = addressRangeValidator
                          (diag_transfer_state_t_0080d3f8.data_pointer,
                           CONCAT22(diag_transfer_state_t_0080d3f8._10_2_,uVar8));
        cVar6 = (char)uVar5;
        if ((cVar6 == '\x05') || (cVar6 == '\x03')) {
          if ((10 < _memory_patch_count + 1) ||
             ((int)(0x80d3a5 - can_rx_buffer_ptr) <=
              (int)(uint)(ushort)diag_transfer_state_t_0080d3f8._10_2_)) {
            diagnosticMessageQueueWrite(CONCAT22(0xe,uVar8));
            return;
          }
          *(dword *)(&timer_used_to_disable_rsg_when_gear_ratio_changes_0_100 +
                    (short)(_memory_patch_count * 3)) = diag_transfer_state_t_0080d3f8.data_pointer;
          sVar3 = _memory_patch_count * 3;
          _memory_patch_count = _memory_patch_count + 1;
          *(ushort *)(sVar3 * 2 + 0x80d3aa) = (ushort)bVar2;
          for (bVar7 = 0; bVar7 < bVar2; bVar7 = bVar7 + 1) {
            dVar4 = can_rx_buffer_ptr + 1;
            *(byte *)can_rx_buffer_ptr = *local_8;
            can_rx_buffer_ptr = dVar4;
            local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
          }
          diag_transfer_state_t_0080d3f8._10_2_ =
               diag_transfer_state_t_0080d3f8._10_2_ - (ushort)bVar2;
          if (diag_transfer_state_t_0080d3f8._10_2_ != 0) {
            multi_packet_receive_state = 1;
          }
        }
        else {
          if (cVar6 != '\0') {
            if (cVar6 != '\n') {
              diagnosticMessageQueueWrite(CONCAT22(9,uVar8));
              return;
            }
            diagnosticMessageQueueWrite(CONCAT22(10,uVar8));
            return;
          }
          for (bVar7 = 0; bVar7 < bVar2; bVar7 = bVar7 + 1) {
            dVar4 = diag_transfer_state_t_0080d3f8.data_pointer + 1;
            *(byte *)diag_transfer_state_t_0080d3f8.data_pointer = *local_8;
            diag_transfer_state_t_0080d3f8.data_pointer = dVar4;
            local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
          }
          if (diag_transfer_state_t_0080d3f8._10_2_ != 0) {
            multi_packet_receive_state = 1;
          }
        }
      }
      diagnosticMessageQueueWrite((uint)uVar8);
    }
    else {
      diagnosticMessageQueueWrite(CONCAT22(8,uVar8));
    }
  }
  else {
    diagnosticMessageQueueWrite(CONCAT22(4,uVar8));
  }
  return;
}



/*
 * Function: circularBufferEmptyCheck @ 0x00013134
 */

uint circularBufferEmptyCheck(void)

{
  uint in_D0;
  
  if (circular_buffer_count == 0) {
    return 1;
  }
  return in_D0 & 0xffffff00;
}



/*
 * Function: parameterCircularBufferWrite @ 0x00013144
 */

uint parameterCircularBufferWrite(int param_1,undefined1 *param_2,undefined4 param_3)

{
  word wVar1;
  uint uVar2;
  
  if ((uint)param_3._0_2_ + (uint)circular_buffer_count < 0x201) {
    parameter_circular_buffer_value = (short)(param_1 + -0x8034f6) - 2;
    uVar2 = CONCAT22((short)((uint)(param_1 + -0x8034f6) >> 0x10),parameter_circular_buffer_value);
    (&circular_buffer_metadata)[circular_buffer_write_index] = parameter_circular_buffer_value;
    for (; param_3._0_2_ != 0; param_3._0_2_ = param_3._0_2_ - 1) {
      (&circular_buffer_data)[(short)circular_buffer_write_index] = *param_2;
      wVar1 = (short)(param_1 + -0x8034f6) - 2;
      uVar2 = CONCAT22((short)((uint)(param_1 + -0x8034f6) >> 0x10),wVar1);
      (&circular_buffer_metadata)[circular_buffer_write_index] = wVar1;
      circular_buffer_write_index = circular_buffer_write_index + 1 & 0x1ff;
      circular_buffer_count = circular_buffer_count + 1;
      param_1 = param_1 + 1;
      param_2 = param_2 + 1;
    }
    return uVar2 & 0xffffff00;
  }
  return 1;
}



/*
 * Function: circularBufferWrite @ 0x000131d6
 */
/* ERROR: Failed to decompile */
void circularBufferWrite(void) {
    /* Decompilation failed */
}


/*
 * Function: emptyPlaceholderFunction @ 0x00013240
 */

void emptyPlaceholderFunction(void)

{
  return;
}



/*
 * Function: tpuTransmissionTrigger @ 0x00013242
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void tpuTransmissionTrigger(void)

{
  if (((tpu_channel_state_value == 1) && ((tpu_cfsr0 & 0x20) == 0)) &&
     (tpu_channel_enable_state == 0)) {
    tpu_cfsr1 = (word)*_track_the_time_when_throttle_is_less_than_a_threshold_0_30;
    tpu_channel_enable_state = 1;
    tpu_channel_int_select = 0xfc8a;
    tpu_channel_priority_select = tpu_channel_priority_select & 0x7fff | 0x4000;
    tpu_channel_state_value = 0;
    _tpu_transmission_state_machine = 0;
    tpu_transmission_byte_counter = 1;
    tpu_transmission_state = *_track_the_time_when_throttle_is_less_than_a_threshold_0_30;
    tpu_cier = tpu_cier | 0x20;
  }
  return;
}



/*
 * Function: engine_fault_monitoring_and_rpm_calculation @ 0x000132c8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint engine_fault_monitoring_and_rpm_calculation(void)

{
  uint uVar1;
  
  if (_engine_fault_timer_1 == 0) {
    if (_engine_rpm_calculation_param_1 != 0) {
      _engine_rpm_calculation_param_1 = 0;
      canControllerConfigInit();
    }
  }
  else {
    _engine_fault_timer_1 = _engine_fault_timer_1 + -1;
    _engine_rpm_calculation_param_1 = (word)(_CRGNSC / engine_divisor_param_1);
  }
  if (_engine_fault_timer_2 == 0) {
    if (_engine_rpm_calculation_param_2 != 0) {
      _engine_rpm_calculation_param_2 = 0;
      canRpmModeConfigInit();
    }
  }
  else {
    _engine_fault_timer_2 = _engine_fault_timer_2 + -1;
    if ((_engine_system_status_flags & 0xc) != 0) {
      _engine_rpm_calculation_param_2 =
           (word)(_engine_calculation_constant_1 / _engine_divisor_param_2);
    }
  }
  if (_engine_fault_timer_3 == 0) {
    if (_engine_rpm_calculation_param_3 != 0) {
      _engine_rpm_calculation_param_3 = 0;
    }
  }
  else {
    _engine_fault_timer_3 = _engine_fault_timer_3 + -1;
  }
  if ((_engine_fault_timer_1 == 0) && (current_engine_rpm != 0)) {
    if (engine_fault_counter_1 < _engine_fault_threshold_1) {
      engine_fault_counter_1 = engine_fault_counter_1 + 1;
    }
    else {
      engine_fault_status_register_1 = engine_fault_status_register_1 | 0x1000;
      engine_fault_status_register_2 = engine_fault_status_register_2 | 0x1000;
    }
  }
  else if ((_engine_fault_timer_1 != 0) &&
          ((engine_fault_counter_1 = 0, (engine_fault_status_register_1 & 0x1000) != 0 &&
           ((engine_fault_status_register_2 & 0x1000) == 0)))) {
    engine_fault_status_register_1 = engine_fault_status_register_1 & 0xefff;
  }
  if ((((_engine_system_status_flags & 0xc) == 0) || (_engine_fault_timer_2 != 0)) ||
     (current_engine_rpm == 0)) {
    if (((_engine_fault_timer_2 != 0) &&
        (engine_fault_counter_2 = 0, (engine_fault_status_register_1 & 0x400) != 0)) &&
       ((engine_fault_status_register_2 & 0x400) == 0)) {
      engine_fault_status_register_1 = engine_fault_status_register_1 & 0xfbff;
    }
  }
  else if (engine_fault_counter_2 < _engine_fault_threshold_2) {
    engine_fault_counter_2 = engine_fault_counter_2 + 1;
  }
  else {
    engine_fault_status_register_1 = engine_fault_status_register_1 | 0x400;
    engine_fault_status_register_2 = engine_fault_status_register_2 | 0x400;
  }
  if ((_engine_fault_timer_3 == 0) && (current_engine_rpm != 0)) {
    if (engine_fault_counter_3 <
        mph_above_which_throttle_faults_can_be_logged_for_uncalibrated_0_255) {
      engine_fault_counter_3 = engine_fault_counter_3 + 1;
    }
    else {
      engine_fault_status_register_3 = engine_fault_status_register_3 | 4;
      engine_fault_status_register_4 = engine_fault_status_register_4 | 4;
    }
  }
  else if ((_engine_fault_timer_3 != 0) &&
          ((engine_fault_counter_3 = 0, (engine_fault_status_register_3 & 4) != 0 &&
           ((engine_fault_status_register_4 & 4) == 0)))) {
    engine_fault_status_register_3 = engine_fault_status_register_3 & 0xfffb;
  }
  if (((rpm_timer_capture_mode == 1) &&
      (engine_fault_counter_4 = 0, (engine_fault_status_register_1 & 0x4000) != 0)) &&
     ((engine_fault_status_register_2 & 0x4000) == 0)) {
    engine_fault_status_register_1 = engine_fault_status_register_1 & 0xbfff;
  }
  if ((rpm_timer_capture_mode == 0) && (current_engine_rpm != 0)) {
    if (engine_fault_counter_4 <
        flag_to_delay_resetting_of_throttle_min_when_sampled_thrott_true_false) {
      engine_fault_counter_4 = engine_fault_counter_4 + 1;
    }
    else {
      engine_fault_status_register_1 = engine_fault_status_register_1 | 0x4000;
      engine_fault_status_register_2 = engine_fault_status_register_2 | 0x4000;
    }
  }
  else if ((rpm_timer_capture_mode == 0) &&
          ((engine_fault_counter_4 = 0, (engine_fault_status_register_1 & 0x4000) != 0 &&
           ((engine_fault_status_register_2 & 0x4000) == 0)))) {
    engine_fault_status_register_1 = engine_fault_status_register_1 & 0xbfff;
  }
  if ((((rpm_timer_capture_state == CAPTURING) || (rpm_timer_capture_state == INITIALIZING)) &&
      (engine_fault_counter_5 = 0, (engine_fault_status_register_1 & 0x800) != 0)) &&
     ((engine_fault_status_register_2 & 0x800) == 0)) {
    engine_fault_status_register_1 = engine_fault_status_register_1 & 0xf7ff;
  }
  (*_engine_callback_function_ptr)();
  uVar1 = (uint)engine_rpm_source_selector;
  if (engine_rpm_source_selector == 0) {
    if (_engine_fault_timer_1 == 0) {
      current_engine_fuel_demand = 0;
      current_engine_rpm = 0;
      current_engine_rpm_raw = 0;
    }
    else {
      current_engine_fuel_demand = _engine_rpm_calculation_param_1;
      current_engine_rpm = coreTableInterpolation();
      uVar1 = _engine_rpm_base_frequency / _engine_rpm_divisor_1;
      current_engine_rpm_raw = (word)uVar1;
    }
  }
  else if (engine_rpm_source_selector == 1) {
    if (_engine_fault_timer_2 == 0) {
      current_engine_fuel_demand = 0;
      current_engine_rpm = 0;
      current_engine_rpm_raw = 0;
    }
    else {
      current_engine_fuel_demand = _engine_rpm_calculation_param_2;
      current_engine_rpm = coreTableInterpolation();
      uVar1 = _engine_rpm_base_frequency / _engine_rpm_divisor_2;
      current_engine_rpm_raw = (word)uVar1;
    }
  }
  else if (engine_rpm_source_selector == 2) {
    if (_engine_fault_timer_3 == 0) {
      current_engine_fuel_demand = 0;
      current_engine_rpm = 0;
      current_engine_rpm_raw = 0;
    }
    else {
      current_engine_fuel_demand = _engine_rpm_calculation_param_3;
      uVar1 = coreTableInterpolation();
      current_engine_rpm_raw = (word)uVar1;
      current_engine_rpm = current_engine_rpm_raw;
    }
  }
  if (_engine_override_enable != 0) {
    current_engine_rpm_raw = _engine_override_rpm_value;
    current_engine_fuel_demand = _engine_override_rpm_value;
    current_engine_rpm = _engine_override_rpm_value;
  }
  if (engine_operating_mode == ENGINE_IDLE) {
    uVar1 = vp44_communication_status & 1;
    if ((vp44_communication_status & 1) == 0) {
      system_logging_state = 0;
    }
    else {
      system_logging_state = 2;
    }
  }
  else {
    system_logging_state = 1;
  }
  if (current_engine_rpm_raw < 0x800) {
    engine_fault_rpm_source_value = CCMNFLLM;
    rpm_based_limit_2 = rpm_fault_limit_calibration;
    return uVar1;
  }
  if (current_engine_rpm_raw < 0xff8) {
    engine_fault_rpm_source_value = (word)((int)(uint)CCMNFLLM >> 1);
    rpm_based_limit_2 = (word)((int)(uint)rpm_fault_limit_calibration >> 1);
    return (int)(uint)rpm_fault_limit_calibration >> 1;
  }
  if (0x17ff < current_engine_rpm_raw) {
    engine_fault_rpm_source_value = (word)((int)(uint)CCMNFLLM >> 3);
    rpm_based_limit_2 = (word)((int)(uint)rpm_fault_limit_calibration >> 3);
    return (int)(uint)rpm_fault_limit_calibration >> 3;
  }
  engine_fault_rpm_source_value = (word)((int)(uint)CCMNFLLM >> 2);
  rpm_based_limit_2 = (word)((int)(uint)rpm_fault_limit_calibration >> 2);
  return (int)(uint)rpm_fault_limit_calibration >> 2;
}



/*
 * Function: engineRpmSourceInit @ 0x000137ac
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineRpmSourceInit(void)

{
  _engine_rpm_source_init_value = 0;
  engine_rpm_source_max_ptr = (dword)&CCMXFLLM;
  engine_fault_rpm_source_value = CCMNFLLM;
  _engine_callback_function_ptr = &LAB_000137d8;
  engine_rpm_source_selector = 0;
  return;
}



/*
 * Function: canControllerConfigInit @ 0x00013890
 */

void canControllerConfigInit(void)

{
  switch((undefined1)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000) {
  case 0:
    can1TimerBufferInit();
    delayWithWatchdogServiceWrapper();
    emptyStubFunction5();
    return;
  case 1:
    can1TimerBufferInitAlt();
    can1MessageTransmitInit();
    emptyStubFunction6();
    return;
  case 2:
    can1TimerBufferInitDivided();
    can1MessageTransmitInit2();
    emptyStubFunction7();
    return;
  case 3:
    can1TimerBufferInitConditional();
    delayWithWatchdogServiceWrapper2();
    emptyStubFunction8();
  }
  return;
}



/*
 * Function: canRpmModeConfigInit @ 0x000138fe
 */

void canRpmModeConfigInit(void)

{
  if (minimum_allowable_fueling_for_this_algorithm_to_operate_0_100 == 1) {
    dutyCycleMonitorCanInit();
    return;
  }
  if (minimum_allowable_fueling_for_this_algorithm_to_operate_0_100 != 2) {
    if (minimum_allowable_fueling_for_this_algorithm_to_operate_0_100 != 0) {
      return;
    }
    dutyCycleMonitorAltCanInit();
    return;
  }
  dutyCycleMonitorBufferInit();
  return;
}



/*
 * Function: rpmBasedFuelLimitCalculator @ 0x00013930
 */

void rpmBasedFuelLimitCalculator(void)

{
  if (((engine_operating_mode == LOW_RPM_RUNNING) || (engine_operating_mode == TRANSITIONAL_MODE_6))
     || (engine_operating_mode == TRANSITIONAL_MODE_7)) {
    rpm_based_fuel_limit_state = shutdown_protection_state_1 + frictional_load_calculator_state;
    if (rpm_fuel_limit_state_max < rpm_based_fuel_limit_state) {
      rpm_based_fuel_limit_state = rpm_fuel_limit_state_max;
    }
    rpm_based_fuel_limit_threshold = shutdown_protection_state_2 + frictional_load_fuel_offset;
    if (rpm_fuel_limit_threshold_max < rpm_based_fuel_limit_threshold) {
      rpm_based_fuel_limit_threshold = rpm_fuel_limit_threshold_max;
    }
    if (current_engine_rpm < rpm_based_fuel_limit_state) {
      fuel_demand_override = rpm_based_fuel_limit_threshold;
      return;
    }
    if ((rpm_based_fuel_limit_state <= current_engine_rpm) &&
       (current_engine_rpm <= rpm_source_selector_value)) {
      fuel_demand_override =
           (short)((((uint)current_engine_rpm - (uint)rpm_based_fuel_limit_state) *
                   ((uint)fuel_timing_mode_blend_factor_c806 + (uint)rpm_fuel_limit_blend_offset)) /
                  (uint)(ushort)(rpm_source_selector_value - rpm_based_fuel_limit_state)) +
           (short)(((uint)rpm_based_fuel_limit_threshold *
                   ((uint)rpm_source_selector_value - (uint)current_engine_rpm)) /
                  (uint)(ushort)(rpm_source_selector_value - rpm_based_fuel_limit_state));
    }
  }
  return;
}



/*
 * Function: fuelTimingModeBlendCalculator @ 0x00013a1e
 */

void fuelTimingModeBlendCalculator(void)

{
  short sVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  
  if (fuel_timing_mode_blend_factor_965a == 0x4000) {
    fuel_timing_blend_rpm_input_1 = rpm_source_selector_value;
    fuel_timing_blend_offset_input_1 =
         fuel_timing_mode_blend_factor_c806 + rpm_fuel_limit_blend_offset;
    uVar2 = tableInterpolationLookup((short *)&load_trending_table_2_size);
    fuel_timing_blend_rpm_component = (word)((ulonglong)uVar2 >> 0x20);
  }
  else if (fuel_timing_mode_blend_factor_965a == 0) {
    fuel_timing_blend_rpm_input_2 = rpm_source_selector_value;
    fuel_timing_blend_offset_input_2 =
         fuel_timing_mode_blend_factor_c806 + rpm_fuel_limit_blend_offset;
    uVar2 = tableInterpolationLookup((short *)&load_trending_table_4_size);
    fuel_timing_blend_rpm_component =
         (word)((uint)(ushort)((ulonglong)uVar2 >> 0x20) *
                (0x4000 - (uint)fuel_timing_mode_blend_factor_965a) >> 0xe);
  }
  else {
    fuel_timing_blend_rpm_input_1 = rpm_source_selector_value;
    fuel_timing_blend_offset_input_1 =
         fuel_timing_mode_blend_factor_c806 + rpm_fuel_limit_blend_offset;
    uVar2 = tableInterpolationLookup((short *)&load_trending_table_2_size);
    fuel_timing_blend_rpm_input_2 = rpm_source_selector_value;
    fuel_timing_blend_offset_input_2 =
         fuel_timing_mode_blend_factor_c806 + rpm_fuel_limit_blend_offset;
    uVar3 = tableInterpolationLookup((short *)&load_trending_table_4_size);
    fuel_timing_blend_rpm_component =
         (short)((uint)fuel_timing_mode_blend_factor_965a * (uint)(ushort)((ulonglong)uVar2 >> 0x20)
                >> 0xe) +
         (short)((uint)(ushort)((ulonglong)uVar3 >> 0x20) *
                 (0x4000 - (uint)fuel_timing_mode_blend_factor_965a) >> 0xe);
  }
  if ((uint)fuel_timing_mode_blend_factor_c806 + (uint)rpm_fuel_limit_blend_offset <
      (uint)upper_limit_at_which_loading_trigger_is_satisfied_in_trendin_0_127_5) {
    fuel_timing_intake_temp_input = intake_manifold_temp_raw;
    sVar1 = lookupTableInterpolation((table_interp_args_t *)&load_trending_lower_limit_size);
    fuel_timing_intake_temp_correction =
         sVar1 - (short)((int)((int)&fuel_timing_mode_blend_table - (uint)rpm_source_selector_init)
                        / (int)(short)rpm_divisor_value);
    if ((short)fuel_timing_intake_temp_correction < 0) {
      fuel_timing_intake_temp_correction = 0;
    }
  }
  else {
    fuel_timing_intake_temp_correction = 0;
  }
  fuel_timing_blend_throttle_input = throttle_position_raw;
  fuel_timing_blend_lookup_result =
       lookupTableInterpolation((table_interp_args_t *)&load_trending_table_1_size);
  if ((ushort)(fuel_timing_blend_lookup_result + fuel_timing_blend_rpm_component) <=
      fuel_timing_intake_temp_correction) {
    fuel_timing_mode_blend_value = fuel_timing_intake_temp_correction;
    return;
  }
  fuel_timing_mode_blend_value = fuel_timing_blend_lookup_result + fuel_timing_blend_rpm_component;
  return;
}



/*
 * Function: rpmBasedFuelTimingInterpolation @ 0x00013bd8
 */

void rpmBasedFuelTimingInterpolation(void)

{
  if (((engine_operating_mode == LOW_RPM_RUNNING) || (engine_operating_mode == TRANSITIONAL_MODE_6))
     || (engine_operating_mode == TRANSITIONAL_MODE_7)) {
    fuelTimingModeBlendCalculator();
    if (current_engine_rpm < frictional_load_interpolation_value) {
      timing_advance_value = frictional_load_torque_interpolator_result;
      return;
    }
    if ((frictional_load_interpolation_value <= current_engine_rpm) &&
       (current_engine_rpm <= rpm_source_selector_value)) {
      timing_advance_value =
           frictional_load_torque_interpolator_result +
           (short)(((int)(short)(fuel_timing_mode_blend_value -
                                frictional_load_torque_interpolator_result) *
                   (int)(short)(current_engine_rpm - frictional_load_interpolation_value)) /
                  (int)(short)(rpm_source_selector_value - frictional_load_interpolation_value));
    }
  }
  return;
}



/*
 * Function: frictionalLoadInterpolationCalculator @ 0x00013c6a
 */

uint frictionalLoadInterpolationCalculator(void)

{
  ushort uVar1;
  undefined2 uVar2;
  uint in_D0;
  uint uVar3;
  
  uVar3 = in_D0 & 0xffff0000;
  if (((engine_fault_status_register_1 & 1) == 0) ||
     (uVar3 = CONCAT22((short)(in_D0 >> 0x10),engine_fault_confirmation_register) & 0xffff0001,
     (engine_fault_confirmation_register & 1) == 0)) {
    uVar2 = (undefined2)(uVar3 >> 0x10);
    uVar3 = CONCAT22(uVar2,engine_fault_status_register_1) & 0xffff0002;
    if ((((engine_fault_status_register_1 & 2) == 0) ||
        (uVar3 = CONCAT22(uVar2,engine_fault_confirmation_register) & 0xffff0002,
        (engine_fault_confirmation_register & 2) == 0)) &&
       (throttle_frictional_load_lower_threshold <= throttle_position_raw)) {
      if (throttle_frictional_load_upper_threshold < throttle_position_raw) {
        frictional_load_fuel_offset = frictional_load_fuel_init;
        frictional_load_calculator_state = frictional_load_state_init;
        return uVar3;
      }
      uVar1 = throttle_frictional_load_upper_threshold - throttle_frictional_load_lower_threshold;
      frictional_load_fuel_offset =
           (short)((((uint)throttle_frictional_load_upper_threshold - (uint)throttle_position_raw) *
                   (uint)rpm_fuel_limit_threshold_max) / (uint)uVar1) +
           (short)((((uint)throttle_position_raw - (uint)throttle_frictional_load_lower_threshold) *
                   (uint)frictional_load_fuel_init) / (uint)uVar1);
      uVar3 = (((uint)throttle_frictional_load_upper_threshold - (uint)throttle_position_raw) *
              (uint)rpm_fuel_limit_state_max) / (uint)uVar1;
      frictional_load_calculator_state =
           (short)uVar3 +
           (short)((((uint)throttle_position_raw - (uint)throttle_frictional_load_lower_threshold) *
                   (uint)frictional_load_state_init) / (uint)uVar1);
      return uVar3;
    }
  }
  frictional_load_fuel_offset = rpm_fuel_limit_threshold_max;
  frictional_load_calculator_state = rpm_fuel_limit_state_max;
  return uVar3;
}



/*
 * Function: rpmSourceSelectorForFrictionalLoad @ 0x00013d66
 */

void rpmSourceSelectorForFrictionalLoad(void)

{
  if (rpm_source_selector_flag == 1) {
    rpm_source_selector_value = rpm_source_selector_init;
    return;
  }
  rpm_source_selector_value = governor_rpm_error_value;
  return;
}



/*
 * Function: frictionalLoadTorqueInterpolator @ 0x00013d86
 */

uint frictionalLoadTorqueInterpolator(void)

{
  ushort uVar1;
  undefined2 uVar2;
  uint in_D0;
  uint uVar3;
  
  uVar3 = in_D0 & 0xffff0000;
  if (((fault_flags_active_base & 0x2000) == 0) ||
     (uVar3 = CONCAT22((short)(in_D0 >> 0x10),fault_flags_enabled_base) & 0xffff2000,
     (fault_flags_enabled_base & 0x2000) == 0)) {
    uVar2 = (undefined2)(uVar3 >> 0x10);
    uVar3 = CONCAT22(uVar2,fault_flags_active_base) & 0xffff4000;
    if ((((fault_flags_active_base & 0x4000) == 0) ||
        (uVar3 = CONCAT22(uVar2,fault_flags_enabled_base) & 0xffff4000,
        (fault_flags_enabled_base & 0x4000) == 0)) &&
       (intake_temp_frictional_load_threshold <= intake_manifold_temp_raw)) {
      if (DCMNLDTB < intake_manifold_temp_raw) {
        frictional_load_torque_interpolator_result = frictional_load_torque_init;
        frictional_load_interpolation_value =
             jcomm_frict_load_line_slope_slope_used_to_calculate_frictiona_0_1_05;
        return uVar3;
      }
      uVar1 = DCMNLDTB - intake_temp_frictional_load_threshold;
      frictional_load_torque_interpolator_result =
           (short)((((uint)DCMNLDTB - (uint)intake_manifold_temp_raw) *
                   (uint)jcomm_frict_load_at_600_rpm_point_used_to_calculate_frictional_0_100) /
                  (uint)uVar1) +
           (short)((((uint)intake_manifold_temp_raw - (uint)intake_temp_frictional_load_threshold) *
                   (uint)frictional_load_torque_init) / (uint)uVar1);
      uVar3 = (((uint)DCMNLDTB - (uint)intake_manifold_temp_raw) *
              (uint)jcomm_peak_torque_tau_0_torque_rating_of_engine_associated_wi_0_5000) /
              (uint)uVar1;
      frictional_load_interpolation_value =
           (short)uVar3 +
           (short)((((uint)intake_manifold_temp_raw - (uint)intake_temp_frictional_load_threshold) *
                   (uint)jcomm_frict_load_line_slope_slope_used_to_calculate_frictiona_0_1_05) /
                  (uint)uVar1);
      return uVar3;
    }
  }
  frictional_load_torque_interpolator_result =
       jcomm_frict_load_at_600_rpm_point_used_to_calculate_frictional_0_100;
  frictional_load_interpolation_value =
       jcomm_peak_torque_tau_0_torque_rating_of_engine_associated_wi_0_5000;
  return uVar3;
}



/*
 * Function: peakTorqueFuelCorrection @ 0x00013e82
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void peakTorqueFuelCorrection(void)

{
  if ((engine_running_timer_threshold < engine_running_mode_timer) &&
     (peak_torque_correction_applied_flag == 0)) {
    peak_torque_correction_state =
         jcomm_peak_torque_min_fueling_tau_0_frict_load_fuel_at_peak_to_0_100 + JCPKT0RP;
    peak_torque_correction_applied_flag = 1;
  }
  if (current_engine_rpm == 0) {
    peak_torque_correction_state = JCPKT0RP;
  }
  _peak_torque_engine_mode_input = engine_operating_mode;
  return;
}



/*
 * Function: engineModeTransitionStateUpdater @ 0x00013ecc
 */

void engineModeTransitionStateUpdater(void)

{
  if (((engine_operating_mode == LOW_RPM_RUNNING) || (engine_operating_mode == TRANSITIONAL_MODE_6))
     || (engine_operating_mode == TRANSITIONAL_MODE_7)) {
    engine_mode_transition_state = fuel_limit_minimum_value;
    fuel_limit_minimum_value = timing_advance_value;
    fuel_demand_source_id = ENGINE_MODE_TRANSITION;
    fuel_adjustment_active_flag = 0;
  }
  return;
}



/*
 * Function: engineModeTransitionHandler @ 0x00013f06
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineModeTransitionHandler(void)

{
  if (((_engine_operating_mode_previous == 1) && (engine_operating_mode == LOW_RPM_RUNNING)) ||
     ((_engine_operating_mode_previous == 3 && (engine_operating_mode == TRANSITIONAL_MODE_7)))) {
    frictionalLoadInterpolationCalculator();
    frictionalLoadTorqueInterpolator();
    rpmSourceSelectorForFrictionalLoad();
  }
  peakTorqueFuelCorrection();
  _engine_operating_mode_previous = engine_operating_mode;
  return;
}



/*
 * Function: shutdownProtectionSlowCycle40Coordinator @ 0x00013f46
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void shutdownProtectionSlowCycle40Coordinator(void)

{
  if ((engine_operating_mode == TRANSITIONAL_MODE_6) &&
     (current_engine_rpm < rpm_based_fuel_limit_state)) {
    if ((int)(uint)shutdown_protection_step_2 <
        (int)((uint)max_number_of_shutdowns_before_restart_is_not_allowed_0_255 -
             (uint)shutdown_protection_state_2)) {
      shutdown_protection_state_2 = shutdown_protection_step_2 + shutdown_protection_state_2;
    }
    else {
      shutdown_protection_state_2 = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
    }
    if ((int)(uint)shutdown_protection_step_1 <
        (int)((uint)oil_pressure_precrank_status - (uint)shutdown_protection_state_1)) {
      shutdown_protection_state_1 = shutdown_protection_step_1 + shutdown_protection_state_1;
    }
    else {
      shutdown_protection_state_1 = oil_pressure_precrank_status;
    }
  }
  if ((_engine_mode_previous_0 == 7) && (engine_operating_mode == ENGINE_IDLE)) {
    shutdown_protection_state_2 = 0;
    shutdown_protection_state_1 = 0;
  }
  _engine_mode_previous_0 = engine_operating_mode;
  return;
}



/*
 * Function: frictionalLoadTorqueManagementSlowCycle40Coordinator @ 0x00013fe2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void frictionalLoadTorqueManagementSlowCycle40Coordinator(void)

{
  if ((((engine_operating_mode == LOW_RPM_RUNNING) || (engine_operating_mode == TRANSITIONAL_MODE_6)
       ) && (frictional_load_torque_in_fueling_at_breakpoint_4_engine_rpm_0_100 < current_engine_rpm
            )) &&
     (fuel_timing_mode_blend_factor_c806 =
           frictional_load_torque_in_fueling_at_breakpoint_5_engine_rpm_0_100 +
           fuel_timing_mode_blend_factor_c806,
     frictional_load_torque_in_fueling_at_rated_engine_rpm_0_100 <
     fuel_timing_mode_blend_factor_c806)) {
    fuel_timing_mode_blend_factor_c806 = frictional_load_torque_in_fueling_at_rated_engine_rpm_0_100
    ;
  }
  if ((_engine_mode_previous_1 != 3) && (engine_operating_mode == HIGH_RPM_RUNNING)) {
    fuel_timing_mode_blend_factor_c806 = 0;
  }
  _engine_mode_previous_1 = engine_operating_mode;
  return;
}



/*
 * Function: engineOperatingModeStateTrackingSlowCycle40Coordinator @ 0x0001403e
 */

void engineOperatingModeStateTrackingSlowCycle40Coordinator(void)

{
  if (engine_operating_mode == HIGH_RPM_RUNNING) {
    engine_running_mode_timer = engine_running_mode_timer + 1;
  }
  if (engine_operating_mode == ENGINE_IDLE) {
    engine_running_mode_timer = 0;
    peak_torque_correction_applied_flag = 0;
  }
  if (engine_operating_mode == LOW_RPM_RUNNING) {
    engine_rpm_cranking_threshold = engine_rpm_cranking_threshold + 1;
  }
  else if ((engine_mode_previous_state_2d2 == 7) && (engine_operating_mode == ENGINE_IDLE)) {
    engine_rpm_cranking_threshold = 0;
  }
  engine_mode_previous_state_2d2 = engine_operating_mode;
  return;
}



/*
 * Function: frictionalLoadTorqueTransitionHandler @ 0x00014090
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void frictionalLoadTorqueTransitionHandler(void)

{
  if (((_engine_mode_previous_2 == 3) && (engine_operating_mode == TRANSITIONAL_MODE_7)) &&
     (engine_running_timer_threshold < engine_running_mode_timer)) {
    shutdown_protection_state_2 = frictional_load_torque_table_value;
    shutdown_protection_state_1 = frictional_load_torque_in_fueling_at_breakpoint_3_engine_rpm_0_100
    ;
  }
  _engine_mode_previous_2 = engine_operating_mode;
  return;
}



/*
 * Function: initLoadTrendingSystem @ 0x000140ce
 */

void initLoadTrendingSystem(void)

{
  load_trending_kickdown_ptr =
       (dword)&engine_speed_at_0_fuel_which_activates_kick_down_signal_0_8000;
  load_trending_accel_ptr = (dword)&accel_threshold_to_disable_a_c_1200_1200;
  load_trending_table_1_size = 2;
  load_trending_lower_limit_ptr =
       (dword)&lower_limit_at_which_loading_trigger_is_satisfied_in_trendin_0_127_5;
  load_trending_count_min_ptr = (dword)&count_minimum_for_percent_load_to_be_low_0_100;
  load_trending_lower_limit_size = 2;
  load_trending_table_1_ptr = 0x8080c2;
  load_trending_table_2_size = 2;
  load_trending_table_2_ptr = 0x8080e8;
  load_trending_table_2_base = 2;
  load_trending_table_3_ptr = 0x808100;
  load_trending_table_4_ptr = 0x80828c;
  load_trending_table_4_size = 2;
  load_trending_table_5_ptr = 0x8082b2;
  load_trending_table_5_base = 2;
  load_trending_table_6_ptr = 0x8082ca;
  return;
}



/*
 * Function: engineOperatingModeStateMachine @ 0x00014174
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineOperatingModeStateMachine(void)

{
  switch(engine_operating_mode) {
  case ENGINE_IDLE:
    if ((engine_rpm_idle_threshold < current_engine_rpm) && (engine_startup_inhibit_flag == 0)) {
      engine_operating_mode = LOW_RPM_RUNNING;
    }
    else if ((((vp44_communication_status & 1) == 0) && (secured_shutdown_request_flag == 0)) ||
            (high_rpm_shutdown_active_flag == 1)) {
      engine_operating_mode = FAULT_EMERGENCY;
    }
    break;
  case LOW_RPM_RUNNING:
    if (engine_rpm_idle_threshold < current_engine_rpm) {
      if (current_engine_rpm < rpm_source_selector_value) {
        if (jcomm_peak_fueling_tau_0_max_fueling_on_100_throttle_curve_fo_0_100 <
            engine_rpm_cranking_threshold) {
          engine_operating_mode = TRANSITIONAL_MODE_6;
        }
        else if ((((vp44_communication_status & 1) == 0) && (secured_shutdown_request_flag == 0)) ||
                (high_rpm_shutdown_active_flag == 1)) {
          engine_operating_mode = FAULT_EMERGENCY;
        }
      }
      else {
        engine_operating_mode = HIGH_RPM_RUNNING;
      }
    }
    else {
      engine_operating_mode = ENGINE_IDLE;
    }
    break;
  case HIGH_RPM_RUNNING:
    if (vp44_injection_system_active == 1) {
      engine_operating_mode = VP44_INJECTION_ACTIVE;
    }
    else if (peak_torque_correction_state < current_engine_rpm) {
      if ((((vp44_communication_status & 1) == 0) && (secured_shutdown_request_flag == 0)) ||
         (high_rpm_shutdown_active_flag == 1)) {
        engine_operating_mode = FAULT_EMERGENCY;
      }
      else if (current_engine_rpm <
               _user_inversion_bit_mask_for_the_ac_high_pressure_swit_invert_no_invert) {
        engine_overspeed_counter = 0;
      }
      else {
        engine_overspeed_counter = engine_overspeed_counter + 1;
        if (engine_overspeed_counter_limit < engine_overspeed_counter) {
          engine_operating_mode = HIGH_PERFORMANCE;
          engine_overspeed_counter = 0;
        }
      }
    }
    else {
      engine_operating_mode = TRANSITIONAL_MODE_7;
    }
    break;
  case VP44_INJECTION_ACTIVE:
    if (vp44_injection_system_active == 0) {
      engine_operating_mode = HIGH_RPM_RUNNING;
    }
    else if ((((vp44_communication_status & 1) == 0) && (secured_shutdown_request_flag == 0)) ||
            (high_rpm_shutdown_active_flag == 1)) {
      engine_operating_mode = FAULT_EMERGENCY;
    }
    break;
  case HIGH_PERFORMANCE:
    if (current_engine_rpm < engine_rpm_overspeed_exit_threshold) {
      engine_operating_mode = HIGH_RPM_RUNNING;
    }
    else if ((((vp44_communication_status & 1) == 0) && (secured_shutdown_request_flag == 0)) ||
            (high_rpm_shutdown_active_flag == 1)) {
      engine_operating_mode = FAULT_EMERGENCY;
    }
    engine_fault_status_register_1 = engine_fault_status_register_1 | 0x8000;
    engine_fault_status_register_2 = engine_fault_status_register_2 | 0x8000;
    if (overspeed_event_active_flag == 0) {
      overspeed_event_active_flag = 1;
      *(undefined4 *)((short)overspeed_event_buffer_index * 8 + 0x804c68) = _loopCounter;
      *(undefined2 *)((short)overspeed_event_buffer_index * 8 + 0x804c6e) = 0;
      *(word *)((short)overspeed_event_buffer_index * 8 + 0x804c6c) = current_engine_rpm;
    }
    else if (*(ushort *)((short)overspeed_event_buffer_index * 8 + 0x804c6c) < current_engine_rpm) {
      *(word *)((short)overspeed_event_buffer_index * 8 + 0x804c6c) = current_engine_rpm;
    }
    break;
  case TRANSITIONAL_MODE_6:
    if (engine_rpm_idle_threshold < current_engine_rpm) {
      if (current_engine_rpm < rpm_source_selector_value) {
        if ((((vp44_communication_status & 1) == 0) && (secured_shutdown_request_flag == 0)) ||
           (high_rpm_shutdown_active_flag == 1)) {
          engine_operating_mode = FAULT_EMERGENCY;
        }
      }
      else {
        engine_operating_mode = HIGH_RPM_RUNNING;
      }
    }
    else {
      engine_operating_mode = ENGINE_IDLE;
    }
    break;
  case TRANSITIONAL_MODE_7:
    if (engine_rpm_idle_threshold < current_engine_rpm) {
      if (current_engine_rpm < rpm_source_selector_value) {
        if ((((vp44_communication_status & 1) == 0) && (secured_shutdown_request_flag == 0)) ||
           (high_rpm_shutdown_active_flag == 1)) {
          engine_operating_mode = FAULT_EMERGENCY;
        }
      }
      else {
        engine_operating_mode = HIGH_RPM_RUNNING;
      }
    }
    else {
      engine_operating_mode = ENGINE_IDLE;
    }
    break;
  case FAULT_EMERGENCY:
    if ((((high_rpm_shutdown_active_flag == 1) && (current_engine_rpm == 0)) ||
        ((high_rpm_shutdown_active_flag == 0 && ((vp44_communication_status & 1) != 0)))) &&
       ((engine_operating_mode = ENGINE_IDLE, current_engine_rpm == 0 &&
        (high_rpm_shutdown_active_flag == 1)))) {
      high_rpm_shutdown_active_flag = 0;
    }
    if (((current_engine_rpm == 0) && ((vp44_communication_status & 1) == 0)) &&
       (secured_shutdown_request_flag == 0)) {
      engine_shutdown_complete_flag = 1;
    }
    break;
  default:
    engine_operating_mode = ENGINE_IDLE;
  }
  if (((engine_operating_mode != HIGH_PERFORMANCE) &&
      ((engine_fault_status_register_1 & 0x8000) != 0)) &&
     ((engine_fault_status_register_2 & 0x8000) == 0)) {
    engine_fault_status_register_1 = engine_fault_status_register_1 & 0x7fff;
    *(word *)((short)overspeed_event_buffer_index * 8 + 0x804c6e) =
         system_time_seconds_counter -
         *(short *)((short)overspeed_event_buffer_index * 8 + 0x804c6a);
    overspeed_event_active_flag = 0;
    overspeed_event_buffer_index = (ushort)(overspeed_event_buffer_index + 1) % 5;
  }
  if (((vp44_communication_status & 1) != 0) && (vp44_communication_status_latch == 0)) {
    secured_shutdown_request_flag = 0;
  }
  vp44_communication_status_latch = -((vp44_communication_status & 1) != 0) & 1;
  return;
}



/*
 * Function: engineOperatingModeInit @ 0x00014536
 */

void engineOperatingModeInit(void)

{
  engine_operating_mode = ENGINE_IDLE;
  vp44_communication_status_latch = 0;
  return;
}



/*
 * Function: engineProtectionMultiStateSlowCycle40Coordinator @ 0x00014546
 */

ushort engineProtectionMultiStateSlowCycle40Coordinator(void)

{
  PROTECTION_STATE PVar1;
  
  if ((diagnostic_system_flags_2 & 0x10) == 0) {
    fuel_arbitrator_threshold_1 = oil_pressure_precrank_status;
    protection_shutdown_fuel_limit = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
    protection_mode_state = 0;
    lamp_3_blink_trigger = 0;
    PVar1 = FAULT_DURATION_COUNT;
  }
  else {
    PVar1 = protection_state_machine_index;
    switch(protection_state_machine_index) {
    case FAULT_DURATION_COUNT:
      PVar1 = protectionState0FaultDurationCounter();
      break;
    case DIAGNOSTIC_VALIDATE:
      PVar1 = protectionState1DiagnosticValidator();
      break;
    case THRESHOLD_CALC:
      PVar1 = protectionState2ThresholdCalculator();
      break;
    case PRIMARY_RPM_MONITOR:
      protectionState3aPrimaryCoordinator();
      PVar1 = protectionState3bRpmMonitor();
      break;
    case EMERGENCY_HANDLER:
      PVar1 = protectionState4EmergencyHandler();
    }
    protection_state_machine_index = protection_state_machine_index + DIAGNOSTIC_VALIDATE;
    if (EMERGENCY_HANDLER < protection_state_machine_index) {
      protection_state_machine_index = FAULT_DURATION_COUNT;
      return PVar1;
    }
  }
  return PVar1;
}



/*
 * Function: protectionThresholdCalculationHelper @ 0x000145d4
 */

ushort protectionThresholdCalculationHelper
                 (int param_1,int param_2,ushort *param_3,undefined4 param_4)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  
  if (param_4._0_2_ == 0) {
    uVar3 = *param_3;
    uVar1 = *(ushort *)(param_2 + 6);
    uVar2 = *(ushort *)(param_1 + 2);
    uVar4 = *(ushort *)(param_1 + 6);
  }
  else {
    uVar3 = param_3[1];
    uVar1 = *(ushort *)(param_2 + 8);
    uVar2 = *(ushort *)(param_1 + 4);
    uVar4 = *(ushort *)(param_1 + 8);
  }
  if (uVar2 < uVar1) {
    uVar4 = uVar4 + uVar3;
    if (0x100 < uVar4) {
      uVar4 = 0x100;
    }
  }
  else if (uVar4 < uVar3) {
    uVar4 = uVar3 - uVar4;
  }
  else {
    uVar4 = 0;
  }
  return uVar4;
}



/*
 * Function: protectionPercentageCalculator @ 0x0001462e
 */

undefined4 protectionPercentageCalculator(undefined4 param_1,undefined4 param_2)

{
  int iVar1;
  short sVar2;
  
  iVar1 = ((int)(short)(param_1._0_2_ - param_1._2_2_) << 8) /
          (int)(short)(param_2._0_2_ - param_1._2_2_);
  sVar2 = (short)iVar1;
  if (sVar2 < 0x101) {
    if (sVar2 < 0) {
      sVar2 = 0;
    }
  }
  else {
    sVar2 = 0x100;
  }
  return CONCAT22((short)((uint)iVar1 >> 0x10),sVar2);
}



/*
 * Function: engineProtectionSystemInit @ 0x00014664
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineProtectionSystemInit(void)

{
  _protection_state_rpm_threshold = &vp44_sensor_history_state;
  pwm_timer_output_value = 0x2000;
  _pwm_timer_counter = 0x804c90;
  _pwm_timer_state = &throttle_position_raw;
  engine_protection_oil_pressure_ptr_1 = (dword)&dzg_threshold_level_2;
  engine_protection_oil_pressure_ptr_2 =
       (dword)&time_abuse_event_must_be_continuously_present_before_it_will_b_0_100;
  engine_protection_oil_pressure_ptr_3 =
       (dword)&time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000;
  engine_protection_boost_ptr_1 = 0x804cb8;
  engine_protection_boost_ptr_2 = 0x804cb8;
  engine_protection_boost_ptr_3 = (dword)&vp44_injection_timing_state;
  engine_protection_intake_temp_ptr_1 =
       (dword)&time_abuse_event_must_be_continuously_present_before_it_will_0_100;
  engine_protection_intake_temp_ptr_2 =
       (dword)&time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000;
  engine_protection_intake_temp_ptr_3 = 0x807db4;
  engine_protection_coolant_ptr_1 = 0x804ce0;
  engine_protection_coolant_ptr_2 = 0x804ce0;
  engine_protection_coolant_ptr_3 = (dword)&insite_parameter_display_value;
  engine_protection_fuel_temp_ptr_1 = (dword)&dzg_pressure_threshold_high;
  engine_protection_fuel_temp_ptr_2 = (dword)&eps_main_lost_duration_0_20;
  engine_protection_sensor_ptr_1 = 0x804d08;
  engine_protection_sensor_ptr_2 = 0x804d30;
  engine_protection_sensor_ptr_3 = (dword)&rpm_histogram_temp_value;
  engine_protection_shutdown_ptr_1 = 0x807df0;
  engine_protection_shutdown_ptr_2 = 0x807df2;
  engine_protection_derate_ptr_1 = 0x804d58;
  engine_protection_derate_ptr_2 = 0x80c98c;
  engine_protection_limit_ptr_1 = 0x80c988;
  engine_protection_state_ptr_1 = (dword)&engine_fluid_level_temp_data;
  engine_protection_state_ptr_2 = 0x807e50;
  protectionThresholdPointerInit();
  initShutdownLimitVariables();
  protection_state_machine_index = FAULT_DURATION_COUNT;
  return;
}



/*
 * Function: protectionConditionEvaluator @ 0x000147b6
 */

uint protectionConditionEvaluator(ushort *param_1,undefined4 *param_2,undefined4 param_3)

{
  ushort uVar1;
  ushort uVar2;
  uint in_D0;
  uint uVar3;
  ushort unaff_D3w;
  
  uVar1 = *param_1;
  if ((uVar1 & 0x30) == 0) {
    uVar2 = *(ushort *)*param_2;
    if (param_3._0_2_ == 0) {
      if (param_3._2_2_ == 0) {
        unaff_D3w = **(ushort **)((int)param_2 + 10);
      }
      else if (param_3._2_2_ == 2) {
        unaff_D3w = param_1[8];
      }
    }
    else if (param_3._2_2_ == 0) {
      unaff_D3w = **(ushort **)((int)param_2 + 0x12);
    }
    else if (param_3._2_2_ == 2) {
      unaff_D3w = param_1[9];
    }
    uVar3 = in_D0 & 0xffff0000;
    if ((uVar1 & 4) == 0) {
      if (uVar2 < unaff_D3w) {
        return 1;
      }
    }
    else if (unaff_D3w <= uVar2) {
      return 1;
    }
  }
  else {
    uVar3 = (byte)-((*(ushort *)(param_2 + 1) & *(ushort *)*param_2) != 0) & 1;
    if (uVar3 == ((byte)-((uVar1 & 0x10) != 0) & 1)) {
      return 1;
    }
  }
  return uVar3 & 0xffff0000;
}



/*
 * Function: protectionState0FaultDurationCounter @ 0x0001485a
 */

void protectionState0FaultDurationCounter(void)

{
  ushort uVar1;
  uint uVar2;
  word *pwVar3;
  word *pwVar4;
  
  pwVar3 = &protection_state_rpm_threshold;
  for (pwVar4 = &protection_state_config_table; pwVar4 < &protection_state2_config;
      pwVar4 = pwVar4 + 0x10) {
    if (pwVar3[0xb] == 0) {
      pwVar3[3] = 0;
      pwVar3[4] = 0;
    }
    else {
      uVar1 = *pwVar4;
      if ((uVar1 & 0x101) != 0) {
        uVar2 = protectionConditionEvaluator(pwVar4,(undefined4 *)pwVar3,0);
        if ((short)uVar2 == 0) {
          pwVar3[3] = 0;
        }
        else if (pwVar3[3] != 0xffff) {
          pwVar3[3] = pwVar3[3] + 1;
        }
      }
      if ((uVar1 & 0x402) != 0) {
        uVar2 = protectionConditionEvaluator(pwVar4,(undefined4 *)pwVar3,0x10000);
        if ((short)uVar2 == 0) {
          pwVar3[4] = 0;
        }
        else if (pwVar3[4] != 0xffff) {
          pwVar3[4] = pwVar3[4] + 1;
        }
      }
    }
    pwVar3 = pwVar3 + 0x17;
  }
  return;
}



/*
 * Function: diagnosticProtectionEvaluator @ 0x000148f8
 */

uint diagnosticProtectionEvaluator(void)

{
  ushort uVar1;
  int iVar2;
  uint uVar3;
  ushort *puVar4;
  
  uVar3 = diagnostic_system_flags_2 & 0x10;
  if ((((((diagnostic_system_flags_2 & 0x10) != 0) &&
        (uVar3 = diagnostic_system_flags_2 & 1, (diagnostic_system_flags_2 & 1) != 0)) &&
       (uVar3 = diagnostic_system_flags_2 & 0x20, (diagnostic_system_flags_2 & 0x20) != 0)) &&
      ((diagnostic_protection_state != 0xff && (diagnostic_protection_state != 3)))) &&
     (uVar3 = (uint)protection_state_4_emergency_counter,
     diagnostic_protection_threshold <= protection_state_4_emergency_counter)) {
    puVar4 = &protection_state_config_table + (short)diagnostic_protection_state * 0x10;
    iVar2 = (int)(short)diagnostic_protection_state;
    uVar1 = diagnostic_protection_state * 4 + 0x70;
    uVar3 = (uint)(&vp44_status_flags_1)[(short)((int)(uVar1 + 2) >> 4)] & 1 << (uVar1 + 2) % 0x10;
    if ((uVar3 != 0) &&
       (uVar3 = (uint)(&vp44_status_flags_1)[(short)((int)(uVar1 + 3) >> 4)] &
                1 << (uVar1 + 3) % 0x10, uVar3 != 0)) {
      uVar1 = *puVar4;
      uVar3 = 0;
      if ((uVar1 & 1) != 0) {
        uVar3 = protectionConditionEvaluator
                          (puVar4,(undefined4 *)(&protection_state_rpm_threshold + iVar2 * 0x17),0);
        if ((short)uVar3 != 0) {
          (&protection_state_3b_rpm_array)[iVar2 * 0x17] = 1;
          high_rpm_protection_triggered_flag = 1;
        }
      }
      uVar3 = CONCAT22((short)(uVar3 >> 0x10),uVar1) & 0xffff0002;
      if ((uVar1 & 2) != 0) {
        uVar3 = protectionConditionEvaluator
                          (puVar4,(undefined4 *)(&protection_state_rpm_threshold + iVar2 * 0x17),
                           0x10000);
        if ((short)uVar3 != 0) {
          (&protection_state_3b_rpm_array)[iVar2 * 0x17] = 1;
          high_rpm_protection_triggered_flag = 1;
        }
      }
    }
  }
  return uVar3;
}



/*
 * Function: diagnosticProtectionProcessor @ 0x00014a4a
 */

uint diagnosticProtectionProcessor(ushort *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  uint in_D0;
  uint uVar2;
  undefined4 unaff_D2;
  undefined2 uVar3;
  
  uVar3 = (undefined2)((uint)unaff_D2 >> 0x10);
  uVar1 = *param_1;
  uVar2 = in_D0 & 0xffff0000;
  if ((uVar1 & 1) != 0) {
    uVar2 = protectionConditionEvaluator(param_1,param_2,0);
    if ((short)uVar2 == 0) {
      *(undefined2 *)(param_3 + 4) = 0;
    }
    else {
      uVar2 = uVar2 & 0xffff0000;
      if ((uVar1 & 0x40) == 0) {
        uVar2 = protectionPercentageCalculator
                          (CONCAT22(*(undefined2 *)*param_2,**(undefined2 **)((int)param_2 + 10)),
                           CONCAT22(**(undefined2 **)((int)param_2 + 0xe),uVar3));
        *(short *)(param_3 + 4) = (short)uVar2;
      }
      else {
        *(undefined2 *)(param_3 + 4) = 0x100;
      }
    }
  }
  uVar2 = CONCAT22((short)(uVar2 >> 0x10),uVar1) & 0xffff0002;
  if ((uVar1 & 2) != 0) {
    uVar2 = protectionConditionEvaluator(param_1,param_2,0x10000);
    if ((short)uVar2 == 0) {
      *(undefined2 *)(param_3 + 6) = 0;
      return uVar2;
    }
    *(undefined2 *)(param_3 + 6) = 0x100;
  }
  return uVar2;
}



/*
 * Function: protectionState1DiagnosticValidator @ 0x00014ae4
 */

ushort protectionState1DiagnosticValidator(void)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  word *pwVar4;
  word *pwVar5;
  word *pwVar6;
  
  uVar1 = diagnostic_system_flags_2 & 1;
  if ((((diagnostic_system_flags_2 & 1) != 0) &&
      (uVar1 = diagnostic_system_flags_2 & 0x20, (diagnostic_system_flags_2 & 0x20) != 0)) &&
     (diagnostic_protection_state != 0xff)) {
    pwVar6 = &protection_state_rpm_threshold;
    pwVar4 = &engine_mode_transition_timer_array;
    uVar2 = 0x70;
    uVar3 = 0;
    for (pwVar5 = &protection_state_config_table; pwVar5 < &protection_state2_config;
        pwVar5 = pwVar5 + 0x10) {
      if ((((int)(short)diagnostic_protection_state == (uint)uVar3) &&
          (((uint)(&vp44_status_flags_1)[(short)((int)(uVar2 + 2) >> 4)] & 1 << (uVar2 + 2) % 0x10)
           != 0)) &&
         (((uint)(&vp44_status_flags_1)[(short)((int)(uVar2 + 3) >> 4)] & 1 << (uVar2 + 3) % 0x10)
          != 0)) {
        diagnosticProtectionProcessor(pwVar5,(undefined4 *)pwVar6,(int)pwVar4);
        protectionUpdateHandler();
      }
      else {
        pwVar4[2] = 0;
        pwVar4[3] = 0;
      }
      pwVar6 = pwVar6 + 0x17;
      uVar1 = 0x1e;
      pwVar4 = pwVar4 + 0xf;
      uVar2 = uVar2 + 4;
      uVar3 = uVar3 + 1;
    }
  }
  return uVar1;
}



/*
 * Function: protectionUpdateHandler @ 0x00014bdc
 */
/* ERROR: Failed to decompile */
void protectionUpdateHandler(void) {
    /* Decompilation failed */
}


/*
 * Function: protectionState3aPrimaryCoordinator @ 0x00014c3a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void protectionState3aPrimaryCoordinator(void)

{
  ushort uVar1;
  undefined4 unaff_D2;
  uint uVar2;
  ushort uVar3;
  word *pwVar4;
  word *pwVar5;
  word *pwVar6;
  undefined2 uVar7;
  
  uVar7 = (undefined2)((uint)unaff_D2 >> 0x10);
  pwVar6 = &protection_state_rpm_threshold;
  pwVar4 = &engine_mode_transition_timer_array;
  uVar2 = 0x71;
  uVar3 = 0;
  for (pwVar5 = &protection_state_config_table; pwVar5 < &protection_state2_config;
      pwVar5 = pwVar5 + 0x10) {
    if ((*pwVar5 & 2) != 0) {
      if (((uint)(&vp44_status_flags_1)[(short)((int)uVar2 >> 4)] & 1 << (uVar2 & 0xf)) == 0) {
        uVar1 = 0;
      }
      else {
        uVar1 = protectionThresholdCalculationHelper
                          ((int)pwVar5,(int)pwVar6,pwVar4,CONCAT22(1,uVar7));
        if (uVar1 < pwVar4[3]) {
          uVar1 = pwVar4[3];
        }
      }
      pwVar4[1] = uVar1;
      if (uVar3 < uVar1) {
        uVar3 = pwVar4[1];
      }
    }
    pwVar6 = pwVar6 + 0x17;
    pwVar4 = pwVar4 + 0xf;
    uVar2 = (uint)(ushort)((short)uVar2 + 4);
  }
  fuel_arbitrator_threshold_1 = coreTableInterpolation(0x80);
  return;
}



/*
 * Function: protectionThresholdPointerInit @ 0x00014cfc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void protectionThresholdPointerInit(void)

{
  protection_threshold_status_shifted = (uint)oil_pressure_precrank_status << 0x10;
  _protection_threshold_table_ptr = 0x807e6e;
  fuel_arbitrator_threshold_1 = oil_pressure_precrank_status;
  return;
}



/*
 * Function: protectionStateUpdater @ 0x00014d24
 */

void protectionStateUpdater(int param_1,int param_2,undefined4 param_3)

{
  if (param_3._0_2_ == 0) {
    if (*(short *)(param_2 + 0x1a) != -1) {
      *(short *)(param_2 + 0x1a) = *(short *)(param_2 + 0x1a) + 1;
    }
  }
  else if (*(short *)(param_2 + 0x1c) != -1) {
    *(short *)(param_2 + 0x1c) = *(short *)(param_2 + 0x1c) + 1;
  }
  if (engine_mode_transition_flag != 0) {
    if (param_3._0_2_ == 0) {
      *(undefined2 *)(param_2 + 0x1e) = *(undefined2 *)(param_1 + 0x14);
      return;
    }
    *(undefined2 *)(param_2 + 0x20) = *(undefined2 *)(param_1 + 0x14);
  }
  return;
}



/*
 * Function: protectionState4EmergencyHandler @ 0x00014d6a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort protectionState4EmergencyHandler(void)

{
  uint uVar1;
  ushort uVar2;
  undefined4 unaff_D2;
  ushort uVar3;
  uint uVar4;
  word wVar5;
  word *pwVar6;
  word *pwVar7;
  
  uVar3 = (ushort)((uint)unaff_D2 >> 0x10);
  if ((((diagnostic_system_flags_2 & 1) == 0) || (engine_operating_mode == FAULT_EMERGENCY)) ||
     (engine_operating_mode == ENGINE_IDLE)) {
    lamp_3_blink_trigger = 0;
    uVar3 = 0;
    pwVar6 = &protection_state_rpm_threshold;
    do {
      pwVar6[0xd] = 0;
      pwVar6[0xe] = 0;
      uVar2 = 0x2e;
      pwVar6 = pwVar6 + 0x17;
      uVar3 = uVar3 + 1;
    } while (uVar3 < 8);
  }
  else {
    lamp_3_blink_trigger = 0;
    pwVar7 = &protection_state_config_table;
    pwVar6 = &protection_state_rpm_threshold;
    uVar4 = 0x72;
    wVar5 = 0;
    if ((engine_rpm_previous_nonzero == 0) && (current_engine_rpm != 0)) {
      engine_mode_transition_flag = 1;
    }
    else {
      engine_mode_transition_flag = 0;
    }
    for (; pwVar7 < &protection_state2_config; pwVar7 = pwVar7 + 0x10) {
      uVar2 = *pwVar7;
      if (((uint)(&vp44_status_flags_1)[(short)((int)uVar4 >> 4)] & 1 << (uVar4 & 0xf)) == 0) {
        pwVar6[0xd] = 0;
        pwVar6[0xe] = 0;
      }
      else {
        if ((uVar2 & 0x300) != 0) {
          if (pwVar6[0xb] == 0) {
            pwVar6[0xd] = 0;
          }
          else {
            if ((uVar2 & 0x100) == 0) {
              if ((uVar2 & 0x200) != 0) {
                uVar1 = protectionConditionEvaluator(pwVar7,(undefined4 *)pwVar6,2);
                if ((short)uVar1 == 0) {
                  pwVar6[0xd] = 0;
                  pwVar6[0xf] = 0;
                }
                else {
                  protectionStateUpdater((int)pwVar7,(int)pwVar6,(uint)uVar3);
                }
              }
            }
            else if (pwVar7[8] < pwVar6[3]) {
              protectionStateUpdater((int)pwVar7,(int)pwVar6,(uint)uVar3);
            }
            else {
              pwVar6[0xd] = 0;
              pwVar6[0xf] = 0;
            }
            if (pwVar6[0xf] < pwVar6[0xd]) {
              lamp_3_blink_trigger = 1;
            }
            if ((uint)pwVar7[0xf] + (uint)pwVar6[0xf] < (uint)pwVar6[0xd]) {
              high_rpm_shutdown_active_flag = 1;
              diagnostic_protection_state = wVar5;
            }
          }
        }
        if ((uVar2 & 0xc00) != 0) {
          if (pwVar6[0xb] == 0) {
            pwVar6[0xe] = 0;
          }
          else {
            if ((uVar2 & 0x400) == 0) {
              if ((uVar2 & 0x800) != 0) {
                uVar1 = protectionConditionEvaluator(pwVar7,(undefined4 *)pwVar6,0x10002);
                if ((short)uVar1 == 0) {
                  pwVar6[0xe] = 0;
                  pwVar6[0x10] = 0;
                }
                else {
                  protectionStateUpdater((int)pwVar7,(int)pwVar6,CONCAT22(1,uVar3));
                }
              }
            }
            else if (pwVar7[9] < pwVar6[4]) {
              protectionStateUpdater((int)pwVar7,(int)pwVar6,CONCAT22(1,uVar3));
            }
            else {
              pwVar6[0xe] = 0;
              pwVar6[0x10] = 0;
            }
            if (pwVar6[0x10] < pwVar6[0xe]) {
              lamp_3_blink_trigger = 1;
            }
            if ((uint)pwVar7[0xf] + (uint)pwVar6[0x10] < (uint)pwVar6[0xe]) {
              high_rpm_shutdown_active_flag = 1;
              diagnostic_protection_state = wVar5;
            }
          }
        }
      }
      pwVar6 = pwVar6 + 0x17;
      uVar4 = (uint)(ushort)((short)uVar4 + 4);
      wVar5 = wVar5 + 1;
    }
    if (high_rpm_protection_triggered_flag != 0 || protection_emergency_fuel_value != 0) {
      lamp_3_blink_trigger = 1;
    }
    uVar2 = high_rpm_protection_triggered_flag | protection_emergency_rpm_value;
    if (uVar2 != 0) {
      high_rpm_shutdown_active_flag = 1;
    }
    if ((high_rpm_shutdown_active_flag != 0) && (_high_rpm_shutdown_previous == 0)) {
      if (_retry_counter_byte != 0xff) {
        _retry_counter_byte = _retry_counter_byte + 1;
      }
      uVar2 = diagnostic_protection_state;
      if (diagnostic_protection_state == _diagnostic_protection_previous) {
        if (protection_state_4_emergency_counter != 0xff) {
          protection_state_4_emergency_counter = protection_state_4_emergency_counter + 1;
        }
      }
      else {
        protection_state_4_emergency_counter = 1;
      }
    }
    _high_rpm_shutdown_previous = high_rpm_shutdown_active_flag;
    _diagnostic_protection_previous = diagnostic_protection_state;
  }
  engine_rpm_previous_nonzero = current_engine_rpm;
  return uVar2;
}



/*
 * Function: protectionCalculationHelper @ 0x00015038
 */

uint protectionCalculationHelper(undefined4 param_1,uint param_2)

{
  uint in_D0;
  
  if ((param_2 & 0x40000) == 0) {
    if (((param_2 & 0x80000) != 0) && (param_1._0_2_ < param_1._2_2_)) {
      return 1;
    }
  }
  else if (param_1._2_2_ < param_1._0_2_) {
    return 1;
  }
  return in_D0 & 0xffff0000;
}



/*
 * Function: protectionStateProcessor @ 0x00015078
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint protectionStateProcessor(undefined4 param_1)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 unaff_D2;
  ushort uVar3;
  ushort uVar4;
  ushort uVar5;
  short *psVar6;
  int iVar7;
  
  if (param_1._0_2_ == 0) {
    uVar4 = *(ushort *)(_engine_mode_transition_timer + 0x18);
    uVar3 = _protection_fault_id_table[0xd];
    iVar7 = *(int *)((int)_engine_state_timer + 0x26);
    psVar6 = (short *)(_engine_mode_transition_timer + 0x16);
  }
  else {
    uVar4 = *(ushort *)(_engine_mode_transition_timer + 0x1c);
    uVar3 = _protection_fault_id_table[0xe];
    iVar7 = *(int *)((int)_engine_state_timer + 0x2a);
    psVar6 = (short *)(_engine_mode_transition_timer + 0x1a);
  }
  if (*psVar6 == 0) {
    *psVar6 = 1;
    puVar1 = (undefined4 *)(iVar7 + (uint)uVar4 * 8);
    *puVar1 = _loopCounter;
    *(undefined2 *)((int)puVar1 + 6) = 0;
    if ((*_protection_fault_id_table & 8) == 0) {
      *(undefined2 *)(puVar1 + 1) = 0;
    }
    else {
      *(undefined2 *)(puVar1 + 1) = 0xffff;
    }
  }
  uVar5 = 1 << (uVar3 & 0xf);
  (&fault_flags_active_base)[(short)((int)(uint)uVar3 >> 4)] =
       uVar5 | (&fault_flags_active_base)[(short)((int)(uint)uVar3 >> 4)];
  (&fault_flags_history_base)[(short)((int)(uint)uVar3 >> 4)] =
       uVar5 | (&fault_flags_history_base)[(short)((int)(uint)uVar3 >> 4)];
  uVar2 = *_protection_fault_id_table & 0xffff000c;
  if ((*_protection_fault_id_table & 0xc) != 0) {
    uVar2 = protectionCalculationHelper
                      (CONCAT22(*(undefined2 *)*_engine_state_timer,
                                *(undefined2 *)(iVar7 + 4 + (uint)uVar4 * 8)),
                       CONCAT22(*_protection_fault_id_table,(short)((uint)unaff_D2 >> 0x10)));
    if ((short)uVar2 != 0) {
      uVar2 = CONCAT22((short)(uVar2 >> 0x10),*(undefined2 *)*_engine_state_timer);
      *(undefined2 *)(iVar7 + 4 + (uint)uVar4 * 8) = *(undefined2 *)*_engine_state_timer;
    }
  }
  return uVar2;
}



/*
 * Function: protectionStateValidator @ 0x0001517c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 protectionStateValidator(undefined4 param_1)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  ushort uVar4;
  ushort *puVar5;
  int iVar6;
  short *psVar7;
  
  if (param_1._0_2_ == 0) {
    puVar5 = (ushort *)(_engine_mode_transition_timer + 0x18);
    uVar4 = *(ushort *)(_protection_fault_id_table + 0x1a);
    iVar6 = *(int *)(_engine_state_timer + 0x26);
    psVar7 = (short *)(_engine_mode_transition_timer + 0x16);
  }
  else {
    puVar5 = (ushort *)(_engine_mode_transition_timer + 0x1c);
    uVar4 = *(ushort *)(_protection_fault_id_table + 0x1c);
    iVar6 = *(int *)(_engine_state_timer + 0x2a);
    psVar7 = (short *)(_engine_mode_transition_timer + 0x1a);
  }
  uVar2 = (uint)(&fault_flags_active_base)[(short)((int)(uint)uVar4 >> 4)];
  uVar3 = uVar2 & 1 << (uVar4 & 0xf);
  if (uVar3 != 0) {
    uVar2 = (uint)(&fault_flags_history_base)[(short)((int)(uint)uVar4 >> 4)];
    uVar3 = uVar2 & 1 << (uVar4 & 0xf);
    if (uVar3 == 0) {
      uVar1 = ~(1 << (uVar4 & 0xf));
      uVar3 = (uint)uVar1;
      uVar2 = (int)(uint)uVar4 >> 4;
      (&fault_flags_active_base)[(short)uVar2] = uVar1 & (&fault_flags_active_base)[(short)uVar2];
      if (*psVar7 != 0) {
        *psVar7 = 0;
        *(word *)(iVar6 + 6 + (uint)*puVar5 * 8) =
             system_time_seconds_counter - (short)*(undefined4 *)(iVar6 + (uint)*puVar5 * 8);
        *puVar5 = *puVar5 + 1;
        uVar3 = (uint)*puVar5 % 5;
        uVar2 = *puVar5 / 5;
        *puVar5 = (ushort)uVar3;
      }
    }
  }
  return CONCAT44(uVar2,uVar3);
}



/*
 * Function: protectionState3bRpmMonitor @ 0x00015272
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void protectionState3bRpmMonitor(void)

{
  ushort uVar1;
  word wVar2;
  bool bVar3;
  bool bVar4;
  uint uVar5;
  undefined4 unaff_D2;
  ushort uVar6;
  
  uVar6 = (ushort)((uint)unaff_D2 >> 0x10);
  _engine_state_timer = &protection_state_rpm_threshold;
  _engine_mode_transition_timer = &engine_mode_transition_timer_array;
  for (_protection_fault_id_table = &protection_state_config_table;
      _protection_fault_id_table < &protection_state2_config;
      _protection_fault_id_table = _protection_fault_id_table + 0x10) {
    uVar1 = *_protection_fault_id_table;
    if ((_protection_fault_id_table[0xb] == 0) && (_protection_fault_id_table[0xc] == 0)) {
      _engine_state_timer[0xb] = 1;
    }
    else {
      if (_protection_fault_id_table[0xb] < current_engine_rpm) {
        _engine_state_timer[0x12] = 1;
      }
      else if (current_engine_rpm == 0) {
        _engine_state_timer[0xb] = 0;
        _engine_state_timer[0x11] = 0;
        _engine_state_timer[0x12] = 0;
      }
      if (_engine_state_timer[0x12] != 0) {
        if (_engine_state_timer[0x11] < _protection_fault_id_table[0xc]) {
          _engine_state_timer[0x11] = _engine_state_timer[0x11] + 1;
        }
        else {
          _engine_state_timer[0xb] = 1;
        }
      }
    }
    bVar3 = false;
    bVar4 = false;
    if (_engine_state_timer[0xb] == 0) {
      protectionStateValidator((uint)uVar6);
      protectionStateValidator(CONCAT22(1,uVar6));
    }
    else {
      if (_engine_state_timer[0xc] == 0) {
        if ((*_engine_mode_transition_timer != 0) || (_engine_state_timer[0xd] != 0)) {
          bVar3 = true;
        }
        if ((_engine_mode_transition_timer[1] != 0) || (_engine_state_timer[0xe] != 0)) {
          bVar4 = true;
        }
      }
      else {
        bVar3 = true;
        bVar4 = true;
      }
      if ((uVar1 & 0x1000) == 0) {
        if (bVar3) {
          *(int *)(_engine_mode_transition_timer + 7) =
               *(int *)(_engine_mode_transition_timer + 7) + 1;
          protectionStateProcessor((uint)uVar6);
        }
        else {
          protectionStateValidator((uint)uVar6);
        }
        if (bVar4) {
          *(int *)(_engine_mode_transition_timer + 9) =
               *(int *)(_engine_mode_transition_timer + 9) + 1;
          protectionStateProcessor(CONCAT22(1,uVar6));
        }
        else {
          protectionStateValidator(CONCAT22(1,uVar6));
        }
      }
      else if (bVar3 || bVar4) {
        *(int *)(_engine_mode_transition_timer + 7) =
             *(int *)(_engine_mode_transition_timer + 7) + 1;
        protectionStateProcessor((uint)uVar6);
      }
      else {
        protectionStateValidator((uint)uVar6);
      }
      if ((uVar1 & 0xc) != 0) {
        wVar2 = **(word **)_engine_state_timer;
        uVar5 = protectionCalculationHelper
                          (CONCAT22(wVar2,_engine_mode_transition_timer[4]),CONCAT22(uVar1,uVar6));
        if ((short)uVar5 != 0) {
          _engine_mode_transition_timer[4] = wVar2;
          *(undefined4 *)(_engine_mode_transition_timer + 5) = _loopCounter;
        }
      }
    }
    _engine_state_timer = _engine_state_timer + 0x17;
    _engine_mode_transition_timer = _engine_mode_transition_timer + 0xf;
  }
  return;
}



/*
 * Function: shutdownMinimumSelector29 @ 0x0001542a
 */

void shutdownMinimumSelector29(void)

{
  if (protection_shutdown_fuel_limit < shutdown_limit_accumulator) {
    shutdown_limit_accumulator = protection_shutdown_fuel_limit;
    shutdown_minimum_selector_value = PROTECTION_SHUTDOWN_LIMIT;
  }
  return;
}



/*
 * Function: protectionState2ThresholdCalculator @ 0x00015448
 */

void protectionState2ThresholdCalculator(void)

{
  ushort uVar3;
  undefined4 uVar1;
  short sVar4;
  int iVar2;
  undefined4 unaff_D2;
  uint uVar5;
  ushort uVar6;
  word *pwVar7;
  word *pwVar8;
  word *pwVar9;
  ushort uVar10;
  
  uVar10 = (ushort)((uint)unaff_D2 >> 0x10);
  pwVar7 = &protection_state_rpm_threshold;
  pwVar9 = &engine_mode_transition_timer_array;
  uVar5 = 0x70;
  uVar6 = 0;
  for (pwVar8 = &protection_state_config_table; pwVar8 < &protection_state2_config;
      pwVar8 = pwVar8 + 0x10) {
    if ((*pwVar8 & 1) != 0) {
      if (((uint)(&vp44_status_flags_1)[(short)((int)uVar5 >> 4)] & 1 << (uVar5 & 0xf)) == 0) {
        uVar3 = 0;
      }
      else {
        if ((*pwVar8 & 0x40) == 0) {
          if (pwVar8[1] < pwVar7[3]) {
            uVar1 = protectionPercentageCalculator
                              (CONCAT22(**(undefined2 **)pwVar7,**(undefined2 **)(pwVar7 + 5)),
                               CONCAT22(**(undefined2 **)(pwVar7 + 7),uVar10));
            uVar3 = (ushort)uVar1;
          }
          else {
            uVar3 = 0;
          }
        }
        else {
          uVar3 = protectionThresholdCalculationHelper((int)pwVar8,(int)pwVar7,pwVar9,(uint)uVar10);
        }
        if (uVar3 < pwVar9[2]) {
          uVar3 = pwVar9[2];
        }
      }
      *pwVar9 = uVar3;
      if (uVar6 < uVar3) {
        uVar6 = *pwVar9;
      }
    }
    pwVar7 = pwVar7 + 0x17;
    pwVar9 = pwVar9 + 0xf;
    uVar5 = (uint)(ushort)((short)uVar5 + 4);
  }
  if ((protection_state_enable_flags & 0x1000) != 0) {
    if (current_engine_rpm == 0) {
      protection_state2_rpm_timer = 0;
    }
    else if (protection_state2_rpm_timer < protection_state2_threshold_value) {
      protection_state2_rpm_timer = protection_state2_rpm_timer + 1;
    }
    if (protection_state2_rpm_timer < protection_state2_threshold_value) {
      protection_state2_output_value = 0x100;
      uVar6 = 0x100;
    }
  }
  if ((int)(short)(protection_state2_config + protection_state2_threshold) < (int)(uint)uVar6) {
    uVar6 = protection_state2_config + protection_state2_threshold;
  }
  else if ((int)(uint)uVar6 < (int)(short)(protection_state2_threshold - protection_state2_config))
  {
    uVar6 = protection_state2_threshold - protection_state2_config;
  }
  protection_state2_threshold = uVar6;
  if (0x100 < (short)protection_state2_threshold) {
    protection_state2_threshold = 0x100;
  }
  if (protection_state2_threshold == 0) {
    protection_shutdown_fuel_limit = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
  }
  else {
    protection_state2_rpm_snapshot = current_engine_rpm;
    sVar4 = lookupTableInterpolation((table_interp_args_t *)&protection_state2_lookup_args);
    iVar2 = (int)(short)(0x100 - protection_state2_threshold) *
            (int)(short)(calculated_fuel_timing_value - sVar4);
    if (iVar2 < 0) {
      iVar2 = iVar2 + 0xff;
    }
    protection_shutdown_fuel_limit = sVar4 + (short)((uint)iVar2 >> 8);
  }
  if ((short)protection_state2_threshold < 1) {
    protection_mode_state = 0;
    return;
  }
  protection_mode_state = 1;
  return;
}



/*
 * Function: initShutdownLimitVariables @ 0x0001562e
 */

void initShutdownLimitVariables(void)

{
  protection_state2_rpm_timer = 0;
  protection_state2_threshold = 0;
  protection_state2_lookup_args = 2;
  protection_state2_table_ptr_1 = 0x807e72;
  protection_state2_table_ptr_2 = 0x807ea4;
  protection_shutdown_fuel_limit = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
  protection_mode_state = 0;
  return;
}



/*
 * Function: can1TimerBufferInit @ 0x0001566a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void can1TimerBufferInit(void)

{
  dword *pdVar1;
  
  can1_canidmr0 = can1_canidmr0 & 0xffcf;
  can1_cantbsel = can1_cantbsel & 0xfbff;
  can1_canidmr2 = can1_canidmr2 & 0xfbff;
  rpm_filter_buffer_end = (uint)can1_timer_buffer_count * 4 + 0x80c42c;
  for (pdVar1 = &rpm_filter_buffer_start; pdVar1 <= rpm_filter_buffer_end; pdVar1 = pdVar1 + 1) {
    *pdVar1 = _CRFLOFPZ;
  }
  _fuel_demand_smoothed = &rpm_filter_buffer_start;
  if (can1_timer_buffer_divisor < 2) {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start;
  }
  else {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start + can1_timer_buffer_divisor;
  }
  _engine_rpm_divisor_1 = _CRFLOFPZ * can1_timer_buffer_count;
  engine_divisor_param_1 = _CRFLOFPZ * can1_timer_buffer_divisor;
  rpm_timer_interrupt_handler_ptr = (dword)rpmTimerInterruptHandler;
  can1_reserved = can1_reserved & 0xf0ff | 0xd00;
  IMB_CSOR0 = (ushort)can1_timer_buffer_config << 8;
  IMB_CSOR1 = 0;
  rpm_timer_capture_value = 0;
  IMB_CSBAR0 = 0xb;
  can1_canidar0 = can1_canidar0 & 0xffcf | 0x30;
  can1_canidar2 = can1_canidar2 & 0xffcf | 0x30;
  can1_cantbsel = can1_cantbsel | 0x400;
  can1_canidmr0 = can1_canidmr0 & 0xffcf | 0x20;
  if ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 == '\0') {
    _engine_callback_function_ptr = &LAB_0001416c;
  }
  return;
}



/*
 * Function: delayWithWatchdogServiceWrapper @ 0x0001578c
 */

void delayWithWatchdogServiceWrapper(void)

{
  pwmTimerMode0Init();
  return;
}



/*
 * Function: emptyStubFunction5 @ 0x00015794
 */

void emptyStubFunction5(void)

{
  return;
}



/*
 * Function: rpmTimerInterruptHandler @ 0x00015796
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 rpmTimerInterruptHandler(void)

{
  dword dVar1;
  undefined4 in_D0;
  undefined4 in_D1;
  undefined2 uVar2;
  undefined2 uStack_1e;
  
  dVar1 = rpm_timer_capture_value;
  uVar2 = (undefined2)((uint)in_D0 >> 0x10);
  uStack_1e = (undefined2)in_D0;
  _rpm_timer_interrupt_capture = rpm_timer_capture_value;
  rpm_timer_capture_value = rpm_timer_capture_value & 0xffff;
  _engine_rpm_divisor_1 = dVar1 + (_engine_rpm_divisor_1 - *_throttle_position_buffer_ptr);
  *_throttle_position_buffer_ptr = dVar1;
  if (_throttle_position_buffer_ptr < rpm_filter_buffer_end) {
    _throttle_position_buffer_ptr = _throttle_position_buffer_ptr + 1;
  }
  else {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start;
  }
  if (rpm_timing_accumulator < -(uint)rpm_timer_interrupt_threshold_7cd2 - 1) {
    rpm_timing_accumulator = rpm_timer_interrupt_threshold_7cd2 + rpm_timing_accumulator;
  }
  engine_divisor_param_1 =
       _rpm_timer_interrupt_capture + (engine_divisor_param_1 - *_fuel_demand_smoothed);
  if (_fuel_demand_smoothed < rpm_filter_buffer_end) {
    _fuel_demand_smoothed = (dword *)((int *)_fuel_demand_smoothed + 1);
  }
  else {
    _fuel_demand_smoothed = &rpm_filter_buffer_start;
  }
  if ((int)(uint)rpm_sample_index < (int)(can1_timer_buffer_count - 1)) {
    rpm_sample_index = rpm_sample_index + 1;
  }
  else {
    rpm_sample_index = 0;
  }
  _engine_fault_timer_1 = engine_fault_rpm_source_value;
  if (minimum_allowable_fueling_for_this_algorithm_to_operate_0_100 == 1) {
    if (rpm_sensor_fault_debounce == 0) {
      if (rpm_sensor_fault_counter < rpm_timer_interrupt_threshold_7d20) {
        rpm_sensor_fault_counter = rpm_sensor_fault_counter + 1;
      }
      else {
        fault_flags_active_base = fault_flags_active_base | 1;
        fault_flags_history_base = fault_flags_history_base | 1;
      }
      rpm_timer_capture_state = RPM_FAULT_DETECTED;
      engine_fault_status_register_1 = engine_fault_status_register_1 | 0x800;
      engine_fault_status_register_2 = engine_fault_status_register_2 | 0x800;
    }
    else {
      rpm_sensor_fault_debounce = rpm_sensor_fault_debounce - 1;
      if (rpm_sensor_fault_counter == 0) {
        if (((fault_flags_active_base & 1) != 0) && ((fault_flags_history_base & 1) == 0)) {
          fault_flags_active_base = fault_flags_active_base & 0xfffe;
        }
      }
      else {
        rpm_sensor_fault_counter = rpm_sensor_fault_counter - 1;
      }
    }
  }
  vp44_communication_state_machine(CONCAT22(1,uVar2));
  if ((_rpm_timer_interrupt_capture < -rpm_period_accumulator - 1) &&
     (rpm_period_accumulator = _rpm_timer_interrupt_capture + rpm_period_accumulator,
     timer_capture_delta_count != 0xffff)) {
    timer_capture_delta_count = timer_capture_delta_count + 1;
  }
  rpmTimingDeltaComparator();
  emptyStubFunction3();
  can1_canidmr2 = can1_canidmr2 & 0xfbff;
  return CONCAT44(CONCAT22(uVar2,uStack_1e),in_D1);
}



/*
 * Function: can1TimerBufferInitAlt @ 0x00015968
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void can1TimerBufferInitAlt(void)

{
  dword *pdVar1;
  
  can1_canidmr0 = can1_canidmr0 & 0xffcf;
  can1_cantbsel = can1_cantbsel & 0xfbff;
  can1_canidmr2 = can1_canidmr2 & 0xfbff;
  rpm_filter_buffer_end = (uint)can1_timer_buffer_count * 4 + 0x80c42c;
  for (pdVar1 = &rpm_filter_buffer_start; pdVar1 <= rpm_filter_buffer_end; pdVar1 = pdVar1 + 1) {
    *pdVar1 = _CRFLOFPZ;
  }
  _fuel_demand_smoothed = &rpm_filter_buffer_start;
  if (can1_timer_buffer_divisor < 2) {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start;
  }
  else {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start + can1_timer_buffer_divisor;
  }
  _engine_rpm_divisor_1 = _CRFLOFPZ * can1_timer_buffer_count;
  engine_divisor_param_1 = _CRFLOFPZ * can1_timer_buffer_divisor;
  rpm_timer_interrupt_handler_ptr = (dword)rpmTimerInterruptHandlerAlt;
  can1_reserved = can1_reserved & 0xf0ff | 0xd00;
  IMB_CSOR0 = (ushort)can1_timer_buffer_config << 8;
  IMB_CSOR1 = 0;
  rpm_timer_capture_value = 0;
  IMB_CSBAR0 = 0xb;
  can1_canidar0 = can1_canidar0 & 0xffcf | 0x30;
  can1_canidar2 = can1_canidar2 & 0xffcf | 0x30;
  can1_cantbsel = can1_cantbsel | 0x400;
  can1_canidmr0 = can1_canidmr0 & 0xffcf | 0x20;
  if ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 == '\0') {
    _engine_callback_function_ptr = &LAB_0001416c;
  }
  return;
}



/*
 * Function: can1MessageTransmitInit @ 0x00015a8a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void can1MessageTransmitInit(void)

{
  can1_canidmr2 = can1_canidmr2 & 0xfffe;
  can1_cantxerr = can1_cantxerr & 0xfff0 | 9;
  state_machine_return_address = (dword)&LAB_00015c30;
  QSM_QMCR = 7;
  QSM_QTEST = maximum_allowed_timing_advance_for_this_algorithm_0_20 | 0x100;
  QSM_QSMCR = 0x100;
  QSM_QILR = CONCAT11(can1_message_transmit_config,
                      maximum_allowed_engine_speed_for_timing_advance_in_this_algor_0_4500._0_1_);
  _QSM_QIVR = 0;
  QSM_QILR_IVL = 0;
  can1_canidar1 = can1_canidar1 & 0xfffc | 3;
  can1_canidar3 = can1_canidar3 & 0xfffc | 1;
  can1_cantbsel = can1_cantbsel & 0xfffe | 1;
  can1_canidmr1 = can1_canidmr1 & 0xfffc | 1;
  pwmTimerMode0Init();
  return;
}



/*
 * Function: emptyStubFunction6 @ 0x00015b48
 */

void emptyStubFunction6(void)

{
  return;
}



/*
 * Function: rpmTimerInterruptHandlerAlt @ 0x00015b4a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 rpmTimerInterruptHandlerAlt(void)

{
  dword dVar1;
  undefined4 in_D0;
  undefined4 in_D1;
  undefined2 uVar2;
  undefined2 uStack_1e;
  
  dVar1 = rpm_timer_capture_value;
  uVar2 = (undefined2)((uint)in_D0 >> 0x10);
  uStack_1e = (undefined2)in_D0;
  _rpm_timer_interrupt_capture = rpm_timer_capture_value;
  rpm_timer_capture_value = rpm_timer_capture_value & 0xffff;
  _engine_rpm_divisor_1 = dVar1 + (_engine_rpm_divisor_1 - *_throttle_position_buffer_ptr);
  *_throttle_position_buffer_ptr = dVar1;
  if (_throttle_position_buffer_ptr < rpm_filter_buffer_end) {
    _throttle_position_buffer_ptr = _throttle_position_buffer_ptr + 1;
  }
  else {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start;
  }
  if (rpm_timing_accumulator < -(uint)rpm_timer_interrupt_threshold_7cd2 - 1) {
    rpm_timing_accumulator = rpm_timer_interrupt_threshold_7cd2 + rpm_timing_accumulator;
  }
  engine_divisor_param_1 =
       _rpm_timer_interrupt_capture + (engine_divisor_param_1 - *_fuel_demand_smoothed);
  if (_fuel_demand_smoothed < rpm_filter_buffer_end) {
    _fuel_demand_smoothed = (dword *)((int *)_fuel_demand_smoothed + 1);
  }
  else {
    _fuel_demand_smoothed = &rpm_filter_buffer_start;
  }
  _engine_fault_timer_1 = engine_fault_rpm_source_value;
  vp44_communication_state_machine(CONCAT22(1,uVar2));
  if ((_rpm_timer_interrupt_capture < -rpm_period_accumulator - 1) &&
     (rpm_period_accumulator = _rpm_timer_interrupt_capture + rpm_period_accumulator,
     timer_capture_delta_count != 0xffff)) {
    timer_capture_delta_count = timer_capture_delta_count + 1;
  }
  rpmTimingDeltaComparator();
  emptyStubFunction3();
  can1_canidmr2 = can1_canidmr2 & 0xfbff;
  return CONCAT44(CONCAT22(uVar2,uStack_1e),in_D1);
}



/*
 * Function: rpmTimingDeltaComparator @ 0x00015e96
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void rpmTimingDeltaComparator(void)

{
  ushort uVar1;
  
  if (_engine_fault_timer_2 == 0) {
    rpm_timing_delta_result_flag_1 = 1;
    return;
  }
  if (rpm_sample_index == rpm_sample_comparison_index) {
    rpm_timing_capture_delta = rpm_timing_capture_current - rpm_timing_capture_previous;
    if (rpm_timing_capture_current < rpm_timing_capture_previous) {
      uVar1 = rpm_timing_capture_previous - rpm_timing_capture_current;
    }
    else {
      uVar1 = rpm_timing_capture_current - rpm_timing_capture_previous;
    }
    if (uVar1 < _crank_sync_threshold) {
      rpm_timing_delta_result_flag_1 = 1;
      rpm_timing_delta_result_flag_2 = 1;
      return;
    }
    if (0 < (short)rpm_timing_capture_delta) {
      rpm_timing_delta_result_flag_1 = 1;
      rpm_timing_delta_result_flag_2 = 0;
      return;
    }
    rpm_timing_delta_result_flag_1 = 0;
    rpm_timing_delta_result_flag_2 = 1;
  }
  return;
}



/*
 * Function: rpmTimingDeltaComparatorWithReturn @ 0x00015f26
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint rpmTimingDeltaComparatorWithReturn(void)

{
  uint in_D0;
  uint uVar1;
  ushort uVar2;
  
  if (_engine_fault_timer_1 == 0) {
    rpm_timing_delta_result_flag_2 = 1;
    return in_D0;
  }
  uVar1 = CONCAT22((short)(in_D0 >> 0x10),rpm_sample_index);
  if (rpm_sample_index == rpm_sample_comparison_index) {
    rpm_timing_capture_delta = rpm_timing_capture_current - rpm_timing_capture_previous;
    if (rpm_timing_capture_current < rpm_timing_capture_previous) {
      uVar2 = rpm_timing_capture_previous - rpm_timing_capture_current;
    }
    else {
      uVar2 = rpm_timing_capture_current - rpm_timing_capture_previous;
    }
    if (uVar2 < _crank_sync_threshold) {
      rpm_timing_delta_result_flag_1 = 1;
      rpm_timing_delta_result_flag_2 = 1;
      return (uint)uVar2;
    }
    uVar1 = (uint)(ushort)(rpm_timing_capture_previous - rpm_timing_capture_current);
    if ((word)(rpm_timing_capture_previous - rpm_timing_capture_current) != 0 &&
        (short)rpm_timing_capture_current <= (short)rpm_timing_capture_previous) {
      rpm_timing_delta_result_flag_1 = 0;
      rpm_timing_delta_result_flag_2 = 1;
      return uVar1;
    }
    rpm_timing_delta_result_flag_1 = 1;
    rpm_timing_delta_result_flag_2 = 0;
  }
  return uVar1;
}



/*
 * Function: can1TimerBufferInitDivided @ 0x00015fb6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void can1TimerBufferInitDivided(void)

{
  dword *pdVar1;
  
  can1_canidmr0 = can1_canidmr0 & 0xffcf;
  can1_cantbsel = can1_cantbsel & 0xfbff;
  can1_canidmr2 = can1_canidmr2 & 0xfbff;
  rpm_filter_buffer_end = (uint)can1_timer_buffer_count * 4 + 0x80c42c;
  for (pdVar1 = &rpm_filter_buffer_start; pdVar1 <= rpm_filter_buffer_end; pdVar1 = pdVar1 + 1) {
    *pdVar1 = _CRFLOFPZ;
  }
  _fuel_demand_smoothed = &rpm_filter_buffer_start;
  if (can1_timer_buffer_divisor < 2) {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start;
  }
  else {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start + can1_timer_buffer_divisor;
  }
  _engine_rpm_divisor_1 = _CRFLOFPZ * can1_timer_buffer_count;
  engine_divisor_param_1 = _CRFLOFPZ * can1_timer_buffer_divisor;
  rpm_timer_interrupt_handler_ptr = (dword)rpmTimerInterruptHandler2;
  can1_reserved = can1_reserved & 0xf0ff | 0xd00;
  IMB_CSOR0 = can1_timer_callback_state / can1_timer_buffer_count << 8;
  IMB_CSOR1 = 0;
  rpm_timer_capture_value = 0;
  IMB_CSBAR0 = 0xb;
  can1_canidar0 = can1_canidar0 & 0xffcf | 0x30;
  can1_canidar2 = can1_canidar2 & 0xffcf | 0x30;
  can1_cantbsel = can1_cantbsel | 0x400;
  can1_canidmr0 = can1_canidmr0 & 0xffcf | 0x20;
  if ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 == '\0') {
    _engine_callback_function_ptr = &LAB_0001416c;
  }
  return;
}



/*
 * Function: can1MessageTransmitInit2 @ 0x000160e2
 */

void can1MessageTransmitInit2(void)

{
  can1_canidmr2 = can1_canidmr2 & 0xfffe;
  can1_cantxerr = can1_cantxerr & 0xfff0 | 9;
  QSM_QMCR = 4;
  QSM_QTEST = maximum_allowed_timing_advance_for_this_algorithm_0_20 | 0x100;
  QSM_QILR = CONCAT11(can1_message_transmit_config,
                      maximum_allowed_engine_speed_for_timing_advance_in_this_algor_0_4500._0_1_);
  IMB_CSBAR10 = 0xc000;
  can1_canidar1 = can1_canidar1 & 0xfffc | 3;
  can1_canidar3 = can1_canidar3 & 0xfffc | 1;
  can1_canidmr1 = can1_canidmr1 & 0xfffc | 2;
  state_machine_return_address = (dword)&LAB_00016370;
  can1_cantbsel = can1_cantbsel & 0xfffe | 1;
  pwmTimerMode0Init();
  return;
}



/*
 * Function: emptyStubFunction7 @ 0x00016190
 */

void emptyStubFunction7(void)

{
  return;
}



/*
 * Function: rpmTimerInterruptHandler2 @ 0x00016192
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 rpmTimerInterruptHandler2(void)

{
  dword dVar1;
  undefined4 in_D0;
  undefined4 in_D1;
  undefined2 uVar2;
  undefined2 uStack_1e;
  
  dVar1 = rpm_timer_capture_value;
  uVar2 = (undefined2)((uint)in_D0 >> 0x10);
  uStack_1e = (undefined2)in_D0;
  _rpm_timer_interrupt_capture = rpm_timer_capture_value;
  rpm_timer_capture_value = rpm_timer_capture_value & 0xffff;
  _engine_rpm_divisor_1 = dVar1 + (_engine_rpm_divisor_1 - *_throttle_position_buffer_ptr);
  *_throttle_position_buffer_ptr = dVar1;
  if (_throttle_position_buffer_ptr < rpm_filter_buffer_end) {
    _throttle_position_buffer_ptr = _throttle_position_buffer_ptr + 1;
  }
  else {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start;
  }
  if (rpm_timing_accumulator < -(uint)rpm_timer_interrupt_threshold_7cd2 - 1) {
    rpm_timing_accumulator = rpm_timer_interrupt_threshold_7cd2 + rpm_timing_accumulator;
  }
  engine_divisor_param_1 =
       _rpm_timer_interrupt_capture + (engine_divisor_param_1 - *_fuel_demand_smoothed);
  if (_fuel_demand_smoothed < rpm_filter_buffer_end) {
    _fuel_demand_smoothed = (dword *)((int *)_fuel_demand_smoothed + 1);
  }
  else {
    _fuel_demand_smoothed = &rpm_filter_buffer_start;
  }
  if ((int)(uint)rpm_sample_index < (int)(can1_timer_buffer_count - 1)) {
    rpm_sample_index = rpm_sample_index + 1;
  }
  else {
    rpm_sample_index = 0;
  }
  _engine_fault_timer_1 = engine_fault_rpm_source_value;
  if (minimum_allowable_fueling_for_this_algorithm_to_operate_0_100 == 1) {
    if (rpm_sensor_fault_debounce == 0) {
      if (rpm_sensor_fault_counter < rpm_timer_interrupt_threshold_7d20) {
        rpm_sensor_fault_counter = rpm_sensor_fault_counter + 1;
      }
      else {
        fault_flags_active_base = fault_flags_active_base | 1;
        fault_flags_history_base = fault_flags_history_base | 1;
      }
      rpm_timer_capture_state = RPM_FAULT_DETECTED;
      engine_fault_status_register_1 = engine_fault_status_register_1 | 0x800;
      engine_fault_status_register_2 = engine_fault_status_register_2 | 0x800;
    }
    else {
      rpm_sensor_fault_debounce = rpm_sensor_fault_debounce - 1;
      if (rpm_sensor_fault_counter == 0) {
        if (((fault_flags_active_base & 1) != 0) && ((fault_flags_history_base & 1) == 0)) {
          fault_flags_active_base = fault_flags_active_base & 0xfffe;
        }
      }
      else {
        rpm_sensor_fault_counter = rpm_sensor_fault_counter - 1;
      }
    }
  }
  vp44_communication_state_machine(CONCAT22(1,uVar2));
  vp44_communication_state_machine(CONCAT22(1,uVar2));
  if ((_rpm_timer_interrupt_capture < -rpm_period_accumulator - 1) &&
     (rpm_period_accumulator = _rpm_timer_interrupt_capture + rpm_period_accumulator,
     timer_capture_delta_count != 0xffff)) {
    timer_capture_delta_count = timer_capture_delta_count + 1;
  }
  rpmTimingDeltaComparator();
  emptyStubFunction3();
  if ((_rpm_timer_interrupt_capture < -rpm_period_accumulator - 1) &&
     (rpm_period_accumulator = _rpm_timer_interrupt_capture + rpm_period_accumulator,
     timer_capture_delta_count != 0xffff)) {
    timer_capture_delta_count = timer_capture_delta_count + 1;
  }
  can1_canidmr2 = can1_canidmr2 & 0xfbff;
  return CONCAT44(CONCAT22(uVar2,uStack_1e),in_D1);
}



/*
 * Function: can1TimerBufferInitConditional @ 0x000163f8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint can1TimerBufferInitConditional(void)

{
  undefined4 in_D0;
  uint uVar1;
  dword *pdVar2;
  
  uVar1 = CONCAT22((short)((uint)in_D0 >> 0x10),_engine_system_status_flags) & 0xffff0001;
  if ((_engine_system_status_flags & 1) != 0) {
    can1_canidmr0 = can1_canidmr0 & 0xffcf;
    can1_cantbsel = can1_cantbsel & 0xfbff;
    can1_canidmr2 = can1_canidmr2 & 0xfbff;
    rpm_filter_buffer_end = (uint)can1_timer_buffer_count * 4 + 0x80c42c;
    for (pdVar2 = &rpm_filter_buffer_start; pdVar2 <= rpm_filter_buffer_end; pdVar2 = pdVar2 + 1) {
      *pdVar2 = _CRFLOFPZ;
    }
    _fuel_demand_smoothed = &rpm_filter_buffer_start;
    if (can1_timer_buffer_divisor < 2) {
      _throttle_position_buffer_ptr = &rpm_filter_buffer_start;
    }
    else {
      _throttle_position_buffer_ptr = &rpm_filter_buffer_start + can1_timer_buffer_divisor;
    }
    _engine_rpm_divisor_1 = _CRFLOFPZ * can1_timer_buffer_count;
    uVar1 = _CRFLOFPZ * can1_timer_buffer_divisor;
    rpm_filter_buffer_ptr = (dword)&rpm_filter_buffer_start;
    rpm_timer_interrupt_handler_ptr = (dword)rpmTimerInterruptHandler3;
    can1_reserved = can1_reserved & 0xf0ff | 0xd00;
    IMB_CSOR0 = 0x100;
    IMB_CSOR1 = 0;
    rpm_timer_capture_value = 0;
    IMB_CSBAR0 = 7;
    can1_canidar0 = can1_canidar0 & 0xffcf | 0x20;
    can1_canidar2 = can1_canidar2 & 0xffcf | 0x30;
    can1_cantbsel = can1_cantbsel | 0x400;
    can1_canidmr0 = can1_canidmr0 & 0xffcf | 0x20;
    _can1_timer_buffer_state = &LAB_00016814;
    engine_divisor_param_1 = uVar1;
  }
  if ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 == '\0') {
    _engine_callback_function_ptr = &LAB_0001416c;
  }
  return uVar1;
}



/*
 * Function: delayWithWatchdogServiceWrapper2 @ 0x00016548
 */

void delayWithWatchdogServiceWrapper2(void)

{
  pwmTimerMode0Init();
  return;
}



/*
 * Function: emptyStubFunction8 @ 0x00016550
 */

void emptyStubFunction8(void)

{
  return;
}



/*
 * Function: rpmTimerInterruptHandler3 @ 0x00016552
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 rpmTimerInterruptHandler3(void)

{
  dword dVar1;
  undefined4 in_D0;
  int iVar2;
  undefined4 in_D1;
  undefined2 uVar3;
  undefined2 uVar4;
  undefined2 uStack_22;
  
  dVar1 = rpm_timer_capture_value;
  uVar4 = (undefined2)((uint)in_D0 >> 0x10);
  uStack_22 = (undefined2)in_D0;
  rpm_timer_capture_value = rpm_timer_capture_value & 0xffff;
  uVar3 = (undefined2)(dVar1 >> 0x10);
  iVar2 = throttleTimeAccumulatorProcessor(dVar1,CONCAT22(IMB_CSBAR1,uVar4));
  if (rpm_timer_capture_state == CAPTURING) {
    if (iVar2 == 0) {
      IMB_CSBAR0 = 0xffff;
      can1_canidar2 = can1_canidar2 & 0xffcf | 0x20;
    }
  }
  else {
    IMB_CSBAR0 = 0x8080;
    can1_canidar2 = can1_canidar2 & 0xffcf | 0x20;
  }
  vp44_communication_state_machine(CONCAT22(1,uVar3));
  if ((_rpm_timer_interrupt_capture < -rpm_period_accumulator - 1) &&
     (rpm_period_accumulator = _rpm_timer_interrupt_capture + rpm_period_accumulator,
     timer_capture_delta_count != 0xffff)) {
    timer_capture_delta_count = timer_capture_delta_count + 1;
  }
  rpmTimingDeltaComparator();
  emptyStubFunction3();
  can1_canidmr2 = can1_canidmr2 & 0xfbff;
  return CONCAT44(CONCAT22(uVar4,uStack_22),in_D1);
}



/*
 * Function: throttleTimeAccumulatorProcessor @ 0x00016622
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

int throttleTimeAccumulatorProcessor(int param_1,undefined4 param_2)

{
  short sVar1;
  uint unaff_A2;
  
  _rpm_timer_interrupt_capture = param_1;
  rpm_timing_capture_previous = param_2._0_2_;
  sVar1 = throttlePositionValidator(unaff_A2 >> 0x10);
  if (sVar1 != 0) {
    if (can1_timer_buffer_count == _throttle_zero_position_counter) {
      rpm_timer_capture_state = CAPTURING;
    }
    else {
      if (rpm_timer_capture_state == CAPTURING) {
        rpm_timer_capture_state = RPM_FAULT_DETECTED;
      }
      if ((current_engine_fuel_demand < time_to_delay_before_setting_a_new_throttle_min_0_25500) &&
         (throttle_fault_delay_counter <
          minimum_allowable_engine_speed_for_this_algorithm_to_operate_0_4500._0_1_)) {
        throttle_fault_delay_counter = throttle_fault_delay_counter + 1;
      }
      else if (((rpm_timer_capture_state == RPM_FAULT_DETECTED) &&
               (throttle_fault_threshold_low <= throttle_fault_threshold_high)) ||
              ((pwm_timer_calc_value_2._0_1_ == '\x02' &&
               (throttle_fault_threshold_low <= throttle_fault_threshold_alt)))) {
        engine_fault_status_register_1 = engine_fault_status_register_1 | 0x800;
        engine_fault_status_register_2 = engine_fault_status_register_2 | 0x800;
      }
    }
    throttle_timer_capture_backup = _rpm_timer_interrupt_capture;
    _throttle_zero_position_counter = 0;
    _engine_fault_timer_1 = engine_fault_rpm_source_value;
    return 0;
  }
  _throttle_zero_position_counter = _throttle_zero_position_counter + 1;
  if (_throttle_zero_position_counter == 1) {
    _rpm_timer_interrupt_capture = throttle_timer_capture_backup + _rpm_timer_interrupt_capture;
    rpm_sample_index = 0;
  }
  else if ((rpm_sample_index < can1_timer_buffer_count) || (rpm_timer_capture_state != CAPTURING)) {
    rpm_sample_index = rpm_sample_index + 1;
  }
  else {
    rpm_timer_capture_state = RPM_FAULT_DETECTED;
  }
  _engine_rpm_divisor_1 =
       _rpm_timer_interrupt_capture + (_engine_rpm_divisor_1 - *_throttle_position_buffer_ptr);
  *_throttle_position_buffer_ptr = _rpm_timer_interrupt_capture;
  if (_throttle_position_buffer_ptr < rpm_filter_buffer_end) {
    _throttle_position_buffer_ptr = _throttle_position_buffer_ptr + 1;
  }
  else {
    _throttle_position_buffer_ptr = &rpm_filter_buffer_start;
  }
  if (rpm_timing_accumulator < -(uint)rpm_timer_interrupt_threshold_7cd2 - 1) {
    rpm_timing_accumulator = rpm_timer_interrupt_threshold_7cd2 + rpm_timing_accumulator;
  }
  engine_divisor_param_1 =
       _rpm_timer_interrupt_capture + (engine_divisor_param_1 - *_fuel_demand_smoothed);
  if (_fuel_demand_smoothed < rpm_filter_buffer_end) {
    _fuel_demand_smoothed = (dword *)((int *)_fuel_demand_smoothed + 1);
  }
  else {
    _fuel_demand_smoothed = &rpm_filter_buffer_start;
  }
  if (throttle_fault_threshold_alt != 0 || throttle_fault_threshold_high != 0) {
    _engine_fault_timer_1 = engine_fault_rpm_source_value;
    return _throttle_zero_position_counter;
  }
  if ((engine_fault_status_register_1 & 0x800) == 0) {
    _engine_fault_timer_1 = engine_fault_rpm_source_value;
    throttle_fault_delay_counter = 0;
    return _throttle_zero_position_counter;
  }
  if ((engine_fault_status_register_2 & 0x800) != 0) {
    _engine_fault_timer_1 = engine_fault_rpm_source_value;
    throttle_fault_delay_counter = 0;
    return _throttle_zero_position_counter;
  }
  engine_fault_status_register_1 = engine_fault_status_register_1 & 0xf7ff;
  _engine_fault_timer_1 = engine_fault_rpm_source_value;
  throttle_fault_delay_counter = 0;
  return _throttle_zero_position_counter;
}



/*
 * Function: fuelTimingOilPressureModeController @ 0x0001685c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort fuelTimingOilPressureModeController(void)

{
  ushort uVar1;
  
  uVar1 = vp44_status_flags_2 & 0x10;
  if (uVar1 != 0) {
    if (oil_pressure_mode_active_flag == 0) {
      if (oil_pressure_mode_selector == 2) {
        crank_exit_rpm_threshold = engine_speed_for_transition_into_out_of_crank_reentr_state_0_300;
      }
      else {
        crank_exit_rpm_threshold = crank_exit_fuel_ramp_rpm_0_1000;
      }
      if (active_derate_value < crank_exit_rpm_threshold) {
        if (fuel_timing_oil_pressure_state < determines_how_engine_position_is_sync_d_to_cam_0) {
          fuel_timing_oil_pressure_state = fuel_timing_oil_pressure_state + 1;
        }
      }
      else {
        fuel_timing_oil_pressure_state = 0;
      }
      if (((active_derate_value < crank_exit_fuel_ramp_rpm_0_1000) &&
          (determines_how_engine_position_is_sync_d_to_cam_0 <= fuel_timing_oil_pressure_state)) ||
         (oil_pressure_mode_selector == 2)) {
        fuel_timing_oil_pressure_timer = 0;
      }
      else if (fuel_timing_oil_pressure_timer < _software_padding_0_255) {
        fuel_timing_oil_pressure_timer = fuel_timing_oil_pressure_timer + 1;
      }
      engine_rpm_delta = engine_rpm_previous_sample - current_engine_rpm;
      engine_rpm_previous_sample = current_engine_rpm;
      rpm_moving_average = exponentialMovingAverage();
      if ((int)(uint)crank_exited_initial_rpm_offset_1000_1000 < (int)(short)rpm_moving_average) {
        if (_fuel_timing_oil_pressure_mode_state < crank_exited_initial_fueling_offset_100_100) {
          _fuel_timing_oil_pressure_mode_state = _fuel_timing_oil_pressure_mode_state + 1;
        }
      }
      else {
        _fuel_timing_oil_pressure_mode_state = 0;
      }
      fuelTimingTransitionStateMachine();
      if (oil_pressure_mode_selector == 0) {
        if ((((int)((uint)calculated_fuel_timing_value - (uint)_software_padding_0) <=
              (int)(uint)current_fuel_demand_value) && (fuel_timing_transition_value_1 != 0)) &&
           (((derate_status_byte & 8) == 0 &&
            ((throttle_position_raw < crank_exit_fuel_ramp_rate_maximum_0_100 &&
             (intake_manifold_temp_raw < intake_manifold_temp_threshold)))))) {
          fuel_timing_control_value = 0x4000;
          oil_pressure_mode_selector = 2;
        }
        if ((((((vp44_status_flags_2 & 0x20) != 0) && ((derate_status_byte & 8) == 0)) &&
             (fuel_timing_transition_value_2 != 0)) &&
            ((fuel_timing_mode_blend_factor_965a < crank_jumpstart_rpm_ramp_rate_0_1000 &&
             (crank_exit_fuel_ramp_rpm_0_1000 <= active_derate_value)))) &&
           ((throttle_position_raw < crank_exit_fuel_ramp_rate_maximum_0_100 &&
            (intake_manifold_temp_raw < intake_manifold_temp_threshold)))) {
          fuel_timing_control_value = crank_exit_fuel_ramp_rate_0_100;
          oil_pressure_mode_selector = 1;
        }
      }
      else if (oil_pressure_mode_selector == 2) {
        if (((fuel_timing_transition_value_1 != 0) ||
            (throttle_position_raw_threshold < throttle_position_raw)) ||
           (intake_temp_upper_threshold < intake_manifold_temp_raw)) {
          fuel_timing_control_value = 0;
          oil_pressure_mode_selector = 0;
        }
      }
      else if (oil_pressure_mode_selector == 1) {
        if ((((fuel_timing_transition_value_2 != 0) ||
             (crank_jumpstart_rpm_ramp_rate_0_1000 <= fuel_timing_mode_blend_factor_965a)) ||
            (determines_how_engine_position_is_sync_d_to_cam_0 <= fuel_timing_oil_pressure_state))
           || ((throttle_position_raw_threshold < throttle_position_raw ||
               (intake_temp_upper_threshold < intake_manifold_temp_raw)))) {
          fuel_timing_control_value = 0;
          oil_pressure_mode_selector = 0;
        }
      }
      else {
        fuel_timing_control_value = 0;
        oil_pressure_mode_selector = 0;
      }
    }
    else {
      oil_pressure_mode_selector = oil_pressure_override_mode;
      if (oil_pressure_override_mode == 0) {
        fuel_timing_control_value = 0;
      }
      else if (oil_pressure_override_mode == 2) {
        fuel_timing_control_value = 0x4000;
      }
      else {
        fuel_timing_control_value = crank_exit_fuel_ramp_rate_0_100;
      }
    }
    uVar1 = 0x4000 - fuel_timing_control_value;
    fuel_timing_mode_selector = uVar1;
  }
  return uVar1;
}



/*
 * Function: initOilPressureModeSystem @ 0x00016af2
 */

void initOilPressureModeSystem(void)

{
  oil_pressure_mode_selector = 0;
  oil_pressure_mode_init_flag = 0x80000000;
  oil_pressure_crank_exit_ptr = (dword)&crank_exit_time_0_13107;
  return;
}



/*
 * Function: oilPressureModeParameterPointerConfig @ 0x00016b0e
 */

ushort oilPressureModeParameterPointerConfig(void)

{
  ushort uVar1;
  
  uVar1 = vp44_status_flags_2 & 0x10;
  if ((vp44_status_flags_2 & 0x10) != 0) {
    if (oil_pressure_mode_selector == 0) {
      param_pointer_set_1 = 0x807f2a;
      param_pointer_set_2 = 0x807f2c;
      param_pointer_set_3 =
           (dword)&max_crank_sync_backup_error_count_crank_sync_backup_errors_b_0_255;
      return 0;
    }
    if (oil_pressure_mode_selector == 2) {
      param_pointer_set_1 =
           (dword)&max_cam_sync_backup_error_count_of_cam_sync_backup_errors_be_0_255;
      param_pointer_set_2 =
           (dword)&time_to_reach_full_derate_during_engine_protection_fuelin_0_0039_256;
      param_pointer_set_3 =
           (dword)&period_of_time_after_powerup_during_which_no_oil_pres_faults_0_255;
      return 2;
    }
    if (oil_pressure_mode_selector == 1) {
      param_pointer_set_1 =
           (dword)&fills_hole_left_by_making_engine_protection_rpm_delta_a_globa_0_3000;
      param_pointer_set_2 = (dword)&EPMXDQRP;
      param_pointer_set_3 = (dword)&maximum_rpm_limit_filter_time_constant_0_1_0;
      return 1;
    }
    param_pointer_set_1 = 0x807f2a;
    param_pointer_set_2 = 0x807f2c;
    param_pointer_set_3 = (dword)&max_crank_sync_backup_error_count_crank_sync_backup_errors_b_0_255
    ;
    uVar1 = oil_pressure_mode_selector;
  }
  return uVar1;
}



/*
 * Function: dutyCycleMonitorCanInit @ 0x00016ba8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void dutyCycleMonitorCanInit(void)

{
  dword *pdVar1;
  
  can1_canidmr1 = can1_canidmr1 & 0xfff3;
  can1_cantbsel = can1_cantbsel & 0xfffd;
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  rpm_timer_capture_state = INITIALIZING;
  rpm_timer_capture_mode = 0;
  duty_cycle_buffer_end_ptr = (uint)can1_timer_buffer_reserved * 4 + 0x80c5bc;
  for (pdVar1 = &duty_cycle_monitor_buffer_start; pdVar1 <= duty_cycle_buffer_end_ptr;
      pdVar1 = pdVar1 + 1) {
    *pdVar1 = _duty_cycle_monitor_config;
  }
  duty_cycle_monitor_buffer_ptr = (dword)&duty_cycle_monitor_buffer_start;
  if (can1_timer_buffer_config_reserved < 2) {
    duty_cycle_buffer_current_ptr = (dword)&duty_cycle_monitor_buffer_start;
  }
  else {
    duty_cycle_buffer_current_ptr =
         (dword)(&duty_cycle_monitor_buffer_start + can1_timer_buffer_config_reserved);
  }
  _engine_rpm_divisor_2 = _duty_cycle_monitor_config * can1_timer_buffer_reserved;
  _engine_divisor_param_2 = _duty_cycle_monitor_config * can1_timer_buffer_config_reserved;
  _duty_cycle_monitor_slot_config = dutyCycleMonitorIsrHandler;
  can1_cantxerr = can1_cantxerr & 0xff0f | 0xd0;
  QSM_PQSCTL = 0x100;
  QSM_DDRQS = 0;
  _QSM_PQSPAR = 0;
  QSM_PORTQS = 0x4f;
  can1_canidar1 = can1_canidar1 & 0xfff3;
  can1_canidar3 = can1_canidar3 & 0xfff3 | 0xc;
  can1_cantbsel = can1_cantbsel | 2;
  can1_canidmr1 = can1_canidmr1 & 0xfff3 | 8;
  return;
}



/*
 * Function: dutyCycleMonitorIsrHandler @ 0x00016cb4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 dutyCycleMonitorIsrHandler(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  duty_cycle_monitor_buffer_state = QSM_QPAR;
  QSM_PQSPAR = 0;
  rpm_sensor_fault_debounce = (byte)duty_cycle_short_term_log_time_period_1_0_1000_0;
  if (QSM_QPAR == DCMNHIES) {
    if (duty_cycle_monitor_fault_counter == 0) {
      if (((fault_flags_active_base & 1) != 0) && ((fault_flags_history_base & 1) == 0)) {
        fault_flags_active_base = fault_flags_active_base & 0xfffe;
      }
    }
    else {
      duty_cycle_monitor_fault_counter = duty_cycle_monitor_fault_counter - 1;
    }
    if (rpm_sample_index == fuel_rate_at_maximum_fueling_conditions_32000_450000) {
      rpm_timer_capture_state = CAPTURING;
      rpm_timer_capture_mode = 1;
      if (((engine_fault_status_register_1 & 0x800) != 0) &&
         ((engine_fault_status_register_2 & 0x800) == 0)) {
        engine_fault_status_register_1 = engine_fault_status_register_1 & 0xf7ff;
      }
      if (duty_cycle_error_counter == 0) {
        if (((fault_flags_active_base & 1) != 0) && ((fault_flags_history_base & 1) == 0)) {
          fault_flags_active_base = fault_flags_active_base & 0xfffe;
        }
      }
      else {
        duty_cycle_error_counter = duty_cycle_error_counter - 1;
      }
    }
    else {
      rpm_timer_capture_state = RPM_FAULT_DETECTED;
      rpm_timer_capture_mode = 2;
      rpm_sample_index = fuel_rate_at_maximum_fueling_conditions_32000_450000;
      if (duty_cycle_error_counter < duty_cycle_monitor_DCMNESTB_00807d1e.rpm_thresholds._0_1_) {
        duty_cycle_error_counter = duty_cycle_error_counter + 1;
      }
      else {
        fault_flags_active_base = fault_flags_active_base | 1;
        fault_flags_history_base = fault_flags_history_base | 1;
        engine_fault_status_register_1 = engine_fault_status_register_1 | 0x800;
        engine_fault_status_register_2 = engine_fault_status_register_2 | 0x800;
      }
    }
  }
  else if (QSM_QPAR == load_min_rpm_DCMNLOES) {
    if (duty_cycle_monitor_fault_counter == 0) {
      if (((fault_flags_active_base & 1) != 0) && ((fault_flags_history_base & 1) == 0)) {
        fault_flags_active_base = fault_flags_active_base & 0xfffe;
      }
    }
    else {
      duty_cycle_monitor_fault_counter = duty_cycle_monitor_fault_counter - 1;
    }
    if (rpm_sample_index == CPBS01) {
      rpm_timer_capture_state = CAPTURING;
      rpm_timer_capture_mode = 1;
      if (((engine_fault_status_register_1 & 0x800) != 0) &&
         ((engine_fault_status_register_2 & 0x800) == 0)) {
        engine_fault_status_register_1 = engine_fault_status_register_1 & 0xf7ff;
      }
      if (duty_cycle_error_counter == 0) {
        if (((fault_flags_active_base & 1) != 0) && ((fault_flags_history_base & 1) == 0)) {
          fault_flags_active_base = fault_flags_active_base & 0xfffe;
        }
      }
      else {
        duty_cycle_error_counter = duty_cycle_error_counter - 1;
      }
    }
    else {
      rpm_timer_capture_state = RPM_FAULT_DETECTED;
      rpm_timer_capture_mode = 2;
      rpm_sample_index = CPBS01;
      if (duty_cycle_error_counter < duty_cycle_monitor_DCMNESTB_00807d1e.rpm_thresholds._0_1_) {
        duty_cycle_error_counter = duty_cycle_error_counter + 1;
      }
      else {
        fault_flags_active_base = fault_flags_active_base | 1;
        fault_flags_history_base = fault_flags_history_base | 1;
        engine_fault_status_register_1 = engine_fault_status_register_1 | 0x800;
        engine_fault_status_register_2 = engine_fault_status_register_2 | 0x800;
      }
    }
  }
  else if (duty_cycle_monitor_fault_counter <
           (byte)duty_cycle_monitor_DCMNESTB_00807d1e.rpm_thresholds) {
    duty_cycle_monitor_fault_counter = duty_cycle_monitor_fault_counter + 1;
  }
  else {
    fault_flags_active_base = fault_flags_active_base | 1;
    fault_flags_history_base = fault_flags_history_base | 1;
  }
  if ((_duty_cycle_timing_capture_value < -timer_capture_accumulator - 1) &&
     (timer_capture_accumulator = _duty_cycle_timing_capture_value + timer_capture_accumulator,
     timer_capture_sample_count != 0xffff)) {
    timer_capture_sample_count = timer_capture_sample_count + 1;
  }
  pwmTimerMode0Reset();
  emptyStubFunction2();
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: dutyCycleMonitorAltCanInit @ 0x00016f98
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint dutyCycleMonitorAltCanInit(void)

{
  dword *pdVar1;
  
  can1_canidmr1 = can1_canidmr1 & 0xfff3;
  can1_cantbsel = can1_cantbsel & 0xfffd;
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  duty_cycle_buffer_end_ptr = (uint)can1_timer_buffer_reserved * 4 + 0x80c5bc;
  for (pdVar1 = &duty_cycle_monitor_buffer_start; pdVar1 <= duty_cycle_buffer_end_ptr;
      pdVar1 = pdVar1 + 1) {
    *pdVar1 = _duty_cycle_monitor_config;
  }
  duty_cycle_monitor_buffer_ptr = (dword)&duty_cycle_monitor_buffer_start;
  if (can1_timer_buffer_config_reserved < 2) {
    duty_cycle_buffer_current_ptr = (dword)&duty_cycle_monitor_buffer_start;
  }
  else {
    duty_cycle_buffer_current_ptr =
         (dword)(&duty_cycle_monitor_buffer_start + can1_timer_buffer_config_reserved);
  }
  _engine_rpm_divisor_2 = _duty_cycle_monitor_config * can1_timer_buffer_reserved;
  _engine_divisor_param_2 = _duty_cycle_monitor_config * can1_timer_buffer_config_reserved;
  if ((_engine_system_status_flags & 8) != 0) {
    _duty_cycle_monitor_slot_config = dutyCycleMonitorAltIsrHandler;
    can1_cantxerr = can1_cantxerr & 0xff0f | 0xd0;
    QSM_PQSCTL = 0x100;
    QSM_DDRQS = 0;
    _QSM_PQSPAR = 0;
    QSM_PORTQS = 0xb;
    can1_canidar1 = can1_canidar1 & 0xfff3 | 0xc;
    can1_canidar3 = can1_canidar3 & 0xfff3 | 0xc;
    can1_cantbsel = can1_cantbsel | 2;
    can1_canidmr1 = can1_canidmr1 & 0xfff3 | 8;
    can1_canidmr2 = can1_canidmr2 & 0xfffd;
  }
  return CONCAT22((short)(_duty_cycle_monitor_config * can1_timer_buffer_config_reserved >> 0x10),
                  _engine_system_status_flags) & 0xffff0008;
}



/*
 * Function: dutyCycleMonitorAltIsrHandler @ 0x000170b4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 dutyCycleMonitorAltIsrHandler(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  if ((_engine_system_status_flags & 8) != 0) {
    _engine_fault_timer_2 = rpm_based_limit_2;
    _duty_cycle_timing_capture_value = _QSM_PQSPAR;
    pwm_timer_calc_value_1._0_1_ = 1;
    if (((engine_fault_status_register_1 & 0x800) != 0) &&
       ((engine_fault_status_register_2 & 0x800) == 0)) {
      engine_fault_status_register_1 = engine_fault_status_register_1 & 0xf7ff;
    }
    duty_cycle_monitor_buffer_start = _QSM_PQSPAR;
    _engine_divisor_param_2 = _QSM_PQSPAR;
  }
  _QSM_PQSPAR = _QSM_PQSPAR & 0xffff;
  if ((_duty_cycle_timing_capture_value < -timer_capture_accumulator - 1) &&
     (timer_capture_accumulator = _duty_cycle_timing_capture_value + timer_capture_accumulator,
     timer_capture_sample_count != 0xffff)) {
    timer_capture_sample_count = timer_capture_sample_count + 1;
  }
  pwmTimerMode0Reset();
  emptyStubFunction2();
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: dutyCycleMonitorBufferInit @ 0x00017164
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void dutyCycleMonitorBufferInit(void)

{
  dword *pdVar1;
  
  duty_cycle_buffer_end_ptr = (uint)can1_timer_buffer_reserved * 4 + 0x80c5bc;
  for (pdVar1 = &duty_cycle_monitor_buffer_start; pdVar1 <= duty_cycle_buffer_end_ptr;
      pdVar1 = pdVar1 + 1) {
    *pdVar1 = _duty_cycle_monitor_config;
  }
  duty_cycle_monitor_buffer_ptr = (dword)&duty_cycle_monitor_buffer_start;
  if (can1_timer_buffer_config_reserved < 2) {
    duty_cycle_buffer_current_ptr = (dword)&duty_cycle_monitor_buffer_start;
  }
  else {
    duty_cycle_buffer_current_ptr =
         (dword)(&duty_cycle_monitor_buffer_start + can1_timer_buffer_config_reserved);
  }
  _engine_rpm_divisor_2 = _duty_cycle_monitor_config * can1_timer_buffer_reserved;
  _engine_divisor_param_2 = _duty_cycle_monitor_config * can1_timer_buffer_config_reserved;
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  can1_cantxerr = can1_cantxerr & 0xff0f | 0xd0;
  QSM_PQSCTL = 0x100;
  QSM_DDRQS = 0;
  _QSM_PQSPAR = 0;
  QSM_PORTQS = 0xb;
  can1_canidar1 = can1_canidar1 & 0xfff3 | 0xc;
  can1_canidar3 = can1_canidar3 & 0xfff3 | 0xc;
  can1_canidmr1 = can1_canidmr1 & 0xfff3 | 8;
  _duty_cycle_monitor_slot_config = timerAccumulatorWithWatchdog;
  can1_cantbsel = can1_cantbsel & 0xfffd | 2;
  can_initialization_clear_flag._0_1_ = 0;
  _can1_init_state_flag = 0;
  return;
}



/*
 * Function: phase2_slot_0_handler @ 0x000171a6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void phase2_slot_0_handler(void)

{
  int *in_A1;
  int unaff_A3;
  byte *unaff_A4;
  
  duty_cycle_buffer_current_ptr = unaff_A3 + (uint)*unaff_A4 * 4;
  _engine_rpm_divisor_2 = *in_A1 * (uint)can1_timer_buffer_reserved;
  _engine_divisor_param_2 = *in_A1 * (uint)*unaff_A4;
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  can1_cantxerr = can1_cantxerr & 0xff0f | 0xd0;
  QSM_PQSCTL = 0x100;
  QSM_DDRQS = 0;
  _QSM_PQSPAR = 0;
  QSM_PORTQS = 0xb;
  can1_canidar1 = can1_canidar1 & 0xfff3 | 0xc;
  can1_canidar3 = can1_canidar3 & 0xfff3 | 0xc;
  can1_canidmr1 = can1_canidmr1 & 0xfff3 | 8;
  _duty_cycle_monitor_slot_config = timerAccumulatorWithWatchdog;
  can1_cantbsel = can1_cantbsel & 0xfffd | 2;
  can_initialization_clear_flag._0_1_ = 0;
  _can1_init_state_flag = 0;
  return;
}



/*
 * Function: phase2_slot_1_handler @ 0x000171d2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void phase2_slot_1_handler(void)

{
  int *in_A1;
  byte *unaff_A4;
  
  _engine_divisor_param_2 = *in_A1 * (uint)*unaff_A4;
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  can1_cantxerr = can1_cantxerr & 0xff0f | 0xd0;
  QSM_PQSCTL = 0x100;
  QSM_DDRQS = 0;
  _QSM_PQSPAR = 0;
  QSM_PORTQS = 0xb;
  can1_canidar1 = can1_canidar1 & 0xfff3 | 0xc;
  can1_canidar3 = can1_canidar3 & 0xfff3 | 0xc;
  can1_canidmr1 = can1_canidmr1 & 0xfff3 | 8;
  _duty_cycle_monitor_slot_config = timerAccumulatorWithWatchdog;
  can1_cantbsel = can1_cantbsel & 0xfffd | 2;
  can_initialization_clear_flag._0_1_ = 0;
  _can1_init_state_flag = 0;
  return;
}



/*
 * Function: phase2_slot_5_handler @ 0x00017266
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void phase2_slot_5_handler(void)

{
  can_initialization_clear_flag._0_1_ = 0;
  _can1_init_state_flag = 0;
  return;
}



/*
 * Function: timerAccumulatorWithWatchdog @ 0x00017278
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 timerAccumulatorWithWatchdog(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  if ((_duty_cycle_timing_capture_value < -timer_capture_accumulator - 1) &&
     (timer_capture_accumulator = _duty_cycle_timing_capture_value + timer_capture_accumulator,
     timer_capture_sample_count != 0xffff)) {
    timer_capture_sample_count = timer_capture_sample_count + 1;
  }
  pwmTimerMode0Reset();
  emptyStubFunction2();
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: phase2_slot_7_handler @ 0x00017296
 */

undefined8 phase2_slot_7_handler(void)

{
  short *unaff_A2;
  int *unaff_A3;
  int *unaff_A4;
  undefined8 in_stack_00000000;
  
  *unaff_A4 = *unaff_A3 + *unaff_A4;
  if (*unaff_A2 != -1) {
    *unaff_A2 = *unaff_A2 + 1;
  }
  pwmTimerMode0Reset();
  emptyStubFunction2();
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  return in_stack_00000000;
}



/*
 * Function: phase2_slot_8_handler @ 0x000172ae
 */

undefined8 phase2_slot_8_handler(void)

{
  undefined8 in_stack_00000000;
  
  can1_canidmr2 = can1_canidmr2 & 0xfffd;
  return in_stack_00000000;
}



/*
 * Function: ioControlAndCanPinSwitchingWrapper @ 0x000172bc
 */

void ioControlAndCanPinSwitchingWrapper(void)

{
  ioControlAndCanPinSwitching();
  return;
}



/*
 * Function: evenPhaseSchedulerTaskSet @ 0x000172c4
 */

void evenPhaseSchedulerTaskSet(void)

{
  timerBasedTaskScheduler();
  systemStatusProcessor();
  memoryRegisterController();
  messageQueueDispatcher();
  systemStatusMonitor();
  return;
}



/*
 * Function: oddPhaseSchedulerTaskSet @ 0x000172e4
 */

void oddPhaseSchedulerTaskSet(void)

{
  phase3_retarder_condition_monitor();
  phase3_periodic_task_scheduler();
  phase3_countdown_timer_manager();
  return;
}



/*
 * Function: vp44_engine_management_system @ 0x000172f8
 */

void vp44_engine_management_system(void)

{
  ushort in_stack_00000000;
  
  vp44_communication_state_machine((uint)in_stack_00000000);
  vp44_status_data_collector();
  engine_fault_monitoring_and_rpm_calculation();
  vp44_rpm_derate_monitor();
  rpm_derate_calculation_and_fault_processing();
  fuel_timing_calculation_with_fault_checking();
  diagnostic_fuel_calculation_with_vp44_monitoring();
  derate_application_controller();
  engine_protection_coordinator();
  return;
}



/*
 * Function: engine_control_cycle @ 0x00017334
 */

void engine_control_cycle(void)

{
  engine_speed_governor();
  diagnostic_parameter_handler();
  oil_pressure_protection_controller();
  advanced_oil_pressure_protection_system();
  oil_pressure_shutdown_controller();
  diagnostic_protection_coordinator();
  fuel_limit_arbitrator();
  fuel_delivery_controller();
  return;
}



/*
 * Function: engineDiagnosticSystemCoordinator @ 0x00017366
 */

void engineDiagnosticSystemCoordinator(void)

{
  engine_fault_monitoring_and_rpm_calculation();
  governorFuelPidController();
  sensorFaultDebounceMonitor();
  faultFlagScannerAndProcessor();
  engineModeTransitionHandler();
  rpmLoadParameterLookup();
  engineOperatingModeStateMachine();
  rpmBasedFuelLimitCalculator();
  diagnosticFuelOverrideHandler();
  fuelDemandModeSelector();
  fuelDemandTableBlendCalculator();
  baseTimingTableLookup();
  return;
}



/*
 * Function: slowCycle4Coordinator @ 0x000173b0
 */

void slowCycle4Coordinator(void)

{
  rpmBasedFuelTimingInterpolation();
  frictionalLoadTorqueTransitionHandler();
  fuelDemandBasedParameterCalculator();
  emptyPlaceholderFunction();
  diagnosticTimingIncrementController();
  diagnosticModeFuelArbitrationHandler();
  liftPumpFuelDeliveryController();
  canPinVp44StatusController();
  derateThresholdIoController();
  engineModeBasedIoController();
  rpmDerateCalculationController();
  return;
}



/*
 * Function: empty_debug_hook @ 0x000173f4
 */

void empty_debug_hook(void)

{
  return;
}



/*
 * Function: engineParameterAndBoostControlWrapper @ 0x000173f6
 */

void engineParameterAndBoostControlWrapper(void)

{
  engineParameterControllerWithTimer();
  boostPressureFeedbackController();
  return;
}



/*
 * Function: auxiliarySystemControlWrapper @ 0x00017404
 */

void auxiliarySystemControlWrapper(void)

{
  fuelTempProtectionLimitCalculator();
  shutdownLimitSelector();
  return;
}



/*
 * Function: slowCycle8Coordinator @ 0x00017412
 */

void slowCycle8Coordinator(void)

{
  vp44SensorStatusMonitor();
  vp44ExtendedProcessingRouter();
  diagnosticFlagResetHandler();
  return;
}



/*
 * Function: boostPressureControlCoordinator @ 0x00017426
 */

void boostPressureControlCoordinator(void)

{
  boostPressureTargetCalculator();
  boostPressureProtectionStateMachine();
  return;
}



/*
 * Function: boost_pressure_control_wrapper @ 0x00017434
 */

void boost_pressure_control_wrapper(void)

{
  boost_pressure_control_and_diagnostics();
  return;
}



/*
 * Function: emptySlowCycle8Placeholder @ 0x0001743c
 */

void emptySlowCycle8Placeholder(void)

{
  return;
}



/*
 * Function: emptySlowCycle8PlaceholderCase7 @ 0x0001743e
 */

void emptySlowCycle8PlaceholderCase7(void)

{
  return;
}



/*
 * Function: rpm_control_system @ 0x00017440
 */

void rpm_control_system(void)

{
  rpm_rate_limiter();
  rpm_system_state_controller();
  return;
}



/*
 * Function: rpmBasedFuelLimiterCoordinator @ 0x0001744e
 */

void rpmBasedFuelLimiterCoordinator(void)

{
  lowRpmFuelProtectionLimiter();
  highRpmFuelControlLimiter();
  return;
}



/*
 * Function: secondaryMonitoringWrapper @ 0x0001745c
 */

void secondaryMonitoringWrapper(void)

{
  j1939TimeoutDataClearHandler();
  return;
}



/*
 * Function: slowCycle10Coordinator @ 0x00017464
 */

void slowCycle10Coordinator(void)

{
  hourMeterEventLogger();
  return;
}



/*
 * Function: diagnosticMonitoringCoordinator @ 0x0001746c
 */

void diagnosticMonitoringCoordinator(void)

{
  oilPressureRpmFaultMonitor();
  liftPumpCommStatusMonitor();
  vp44FsoFaultEnableController();
  multiParameterMinimumSelector();
  return;
}



/*
 * Function: epsSignalMonitoringCoordinator @ 0x00017486
 */

void epsSignalMonitoringCoordinator(void)

{
  epsSignalQualityValidator();
  return;
}



/*
 * Function: ioControlSlowCycle10Coordinator @ 0x0001748e
 */

void ioControlSlowCycle10Coordinator(void)

{
  ioControlPinSwitchingWrapper();
  return;
}



/*
 * Function: shutdownProtectionSlowCycle10Coordinator @ 0x00017496
 */

ulonglong shutdownProtectionSlowCycle10Coordinator(void)

{
  ulonglong uVar1;
  
  uVar1 = shutdownProtectionCalculator();
  return uVar1;
}



/*
 * Function: diagnosticCommunicationSlowCycle10Coordinator @ 0x0001749e
 */

void diagnosticCommunicationSlowCycle10Coordinator(void)

{
  diagnosticCommandDispatcher();
  return;
}



/*
 * Function: diagnosticDataTransmissionSlowCycle10Coordinator @ 0x000174a6
 */

void diagnosticDataTransmissionSlowCycle10Coordinator(void)

{
  diagnosticMessageTransmissionManager();
  return;
}



/*
 * Function: vp44ControlSystemCoordinator @ 0x000174ae
 */

void vp44ControlSystemCoordinator(void)

{
  fuelTimingOilPressureModeController();
  oilPressureModeParameterPointerConfig();
  vp44FsoCircuitFaultDetection();
  vp44FsoCircuitFaultDetectionBit1();
  return;
}



/*
 * Function: vp44ExtendedFaultDetectionCoordinator @ 0x000174c8
 */

void vp44ExtendedFaultDetectionCoordinator(void)

{
  acceleratorThrottleFaultDetector();
  vp44FsoFaultRangeMonitor();
  vp44TimingFaultMonitor();
  return;
}



/*
 * Function: advancedEngineProtectionCoordinator @ 0x000174dc
 */

void advancedEngineProtectionCoordinator(void)

{
  crankFuelCalculationAndProtection();
  crankAndProtectionStateMonitor();
  vp44FsoFaultBit0Monitor();
  vp44FsoFaultBit15Monitor();
  vp44FsoMultiBitFaultMonitor();
  return;
}



/*
 * Function: slowCycle20Coordinator @ 0x000174fc
 */

void slowCycle20Coordinator(void)

{
  vp44InjectionSystemStateController();
  return;
}



/*
 * Function: fuelTimingCoordinator @ 0x00017504
 */

void fuelTimingCoordinator(void)

{
  timingOffsetCalculatorWrapper();
  engineModeTimingAdjuster();
  return;
}



/*
 * Function: slowCycle20ExtendedCoordinator @ 0x00017512
 */

void slowCycle20ExtendedCoordinator(void)

{
  engineRunTimeHistogramAccumulator();
  oilPressureFuelArbitrationMonitor();
  vp44FsoStuckHighFaultDetector();
  vp44FsoStuckLowFaultDetector();
  return;
}



/*
 * Function: fuelCalculationSlowCycle20Coordinator @ 0x0001752c
 */

void fuelCalculationSlowCycle20Coordinator(void)

{
  dualTableFuelInterpolationCalculator();
  return;
}



/*
 * Function: sensorStatusHistorySlowCycle20Coordinator @ 0x00017534
 */

void sensorStatusHistorySlowCycle20Coordinator(void)

{
  sensorStatusHistoryTracker();
  return;
}



/*
 * Function: fuelSmokeLimiterSlowCycle20Coordinator @ 0x0001753c
 */

void fuelSmokeLimiterSlowCycle20Coordinator(void)

{
  fuelSmokeLimiterCalculator();
  return;
}



/*
 * Function: camSyncDiagnosticProcessingSlowCycle20Coordinator @ 0x00017544
 */

void camSyncDiagnosticProcessingSlowCycle20Coordinator(void)

{
  camSyncDiagnosticProcessor();
  return;
}



/*
 * Function: derateProtectionSlowCycle20Coordinator @ 0x0001754c
 */

ulonglong derateProtectionSlowCycle20Coordinator(void)

{
  ulonglong uVar1;
  
  uVar1 = derateThresholdMonitorAndFaultController();
  return uVar1;
}



/*
 * Function: vp44ProtectionSlowCycle20Coordinator @ 0x00017554
 */

void vp44ProtectionSlowCycle20Coordinator(void)

{
  vp44FaultProtectionController();
  highRpmEngineProtectionStateMachine();
  vp44FsoFaultDetectionMonitor();
  return;
}



/*
 * Function: vp44FsoFaultDetectionSlowCycle20Coordinator @ 0x00017568
 */

void vp44FsoFaultDetectionSlowCycle20Coordinator(void)

{
  vp44FsoFaultDetectionAndProtectionController();
  return;
}



/*
 * Function: vp44DiagnosticFaultMonitoringSlowCycle20Coordinator @ 0x00017570
 */

void vp44DiagnosticFaultMonitoringSlowCycle20Coordinator(void)

{
  vp44FaultRegisterBit2Monitor();
  vp44DiagnosticSensorThresholdMonitor();
  return;
}



/*
 * Function: vp44FsoFaultMonitoringSlowCycle20Coordinator @ 0x0001757e
 */

void vp44FsoFaultMonitoringSlowCycle20Coordinator(void)

{
  vp44FsoFaultConditionDetector();
  return;
}



/*
 * Function: emptySlowCycle20PlaceholderCase15 @ 0x00017586
 */

void emptySlowCycle20PlaceholderCase15(void)

{
  return;
}



/*
 * Function: dzgTimingAndPressureSlowCycle10Coordinator @ 0x00017588
 */

void dzgTimingAndPressureSlowCycle10Coordinator(void)

{
  dzgTimingAndPressureControlStateMachine();
  return;
}



/*
 * Function: engineModeBasedOutputControlSlowCycle20Coordinator @ 0x00017590
 */

void engineModeBasedOutputControlSlowCycle20Coordinator(void)

{
  faultBasedOutputStateCalculator();
  engineModeOutputControlStateMachine();
  return;
}



/*
 * Function: vp44DiagnosticControlSlowCycle20Coordinator @ 0x0001759e
 */

void vp44DiagnosticControlSlowCycle20Coordinator(void)

{
  vp44SensorDiagnosticControl();
  return;
}



/*
 * Function: diagnosticStatisticsSlowCycle20Coordinator @ 0x000175a6
 */

void diagnosticStatisticsSlowCycle20Coordinator(void)

{
  timeDeltaCalculator();
  fuelStatisticsTracker();
  clutchOperatingStatisticsTracker();
  return;
}



/*
 * Function: main_loop @ 0x000175ba
 */

undefined8 main_loop(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  mainLoopTaskSchedulerInit();
  switch(main_loop_phase_index) {
  case PHASE_0_VP44_RPM:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    empty_debug_hook();
    rpm_control_system();
    vp44ControlSystemCoordinator();
    incrementCounters();
    scheduler_phase_pointer = (dword)&scheduler_phase_table;
    main_loop_phase_index = PHASE_1_ENGINE_FUEL;
    break;
  case PHASE_1_ENGINE_FUEL:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    engineParameterAndBoostControlWrapper();
    rpmBasedFuelLimiterCoordinator();
    vp44ExtendedFaultDetectionCoordinator();
    periodicIoAndCanFaultMonitor();
    main_loop_phase_index = PHASE_2_DIAG_AUX;
    break;
  case PHASE_2_DIAG_AUX:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    auxiliarySystemControlWrapper();
    secondaryMonitoringWrapper();
    advancedEngineProtectionCoordinator();
    engineRpmHardwareTimerSetup();
    main_loop_phase_index = PHASE_3_SLOW_CYCLES;
    break;
  case PHASE_3_SLOW_CYCLES:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    slowCycle8Coordinator();
    slowCycle10Coordinator();
    slowCycle20Coordinator();
    main_loop_phase_index = PHASE_4_BOOST_DIAG;
    break;
  case PHASE_4_BOOST_DIAG:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    boostPressureControlCoordinator();
    diagnosticMonitoringCoordinator();
    fuelTimingCoordinator();
    canMessageMemorySyncController();
    main_loop_phase_index = PHASE_5_EPS_SLOW20;
    break;
  case PHASE_5_EPS_SLOW20:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    boost_pressure_control_wrapper();
    epsSignalMonitoringCoordinator();
    slowCycle20ExtendedCoordinator();
    main_loop_phase_index = PHASE_6_FUEL_CALC;
    break;
  case PHASE_6_FUEL_CALC:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    emptySlowCycle8Placeholder();
    ioControlSlowCycle10Coordinator();
    fuelCalculationSlowCycle20Coordinator();
    kickdownSignalSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_7_SHUTDOWN;
    break;
  case PHASE_7_SHUTDOWN:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    emptySlowCycle8PlaceholderCase7();
    shutdownProtectionSlowCycle10Coordinator();
    sensorStatusHistorySlowCycle20Coordinator();
    engineDataTrendingSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_8_DIAG_COMM;
    break;
  case PHASE_8_DIAG_COMM:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    empty_debug_hook();
    diagnosticCommunicationSlowCycle10Coordinator();
    fuelSmokeLimiterSlowCycle20Coordinator();
    coldStartFuelControlSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_9_CAM_TIMING;
    break;
  case PHASE_9_CAM_TIMING:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    engineParameterAndBoostControlWrapper();
    diagnosticDataTransmissionSlowCycle10Coordinator();
    camSyncDiagnosticProcessingSlowCycle20Coordinator();
    fuelTimingModeArbitrationSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_10_DERATE;
    break;
  case PHASE_10_DERATE:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    auxiliarySystemControlWrapper();
    rpm_control_system();
    derateProtectionSlowCycle20Coordinator();
    ioOutputFlagMappingSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_11_VP44_PROT;
    break;
  case PHASE_11_VP44_PROT:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    slowCycle8Coordinator();
    rpmBasedFuelLimiterCoordinator();
    vp44ProtectionSlowCycle20Coordinator();
    shutdownProtectionSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_12_FSO_FRIC;
    break;
  case PHASE_12_FSO_FRIC:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    boostPressureControlCoordinator();
    secondaryMonitoringWrapper();
    vp44FsoFaultDetectionSlowCycle20Coordinator();
    frictionalLoadTorqueManagementSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_13_DIAG_FAULT;
    break;
  case PHASE_13_DIAG_FAULT:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    boost_pressure_control_wrapper();
    slowCycle10Coordinator();
    vp44DiagnosticFaultMonitoringSlowCycle20Coordinator();
    engineOperatingModeStateTrackingSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_14_FSO_MON;
    break;
  case PHASE_14_FSO_MON:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    emptySlowCycle8Placeholder();
    diagnosticMonitoringCoordinator();
    vp44FsoFaultMonitoringSlowCycle20Coordinator();
    fuelDemandProportionalCalculationSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_15_EPS_TIMING;
    break;
  case PHASE_15_EPS_TIMING:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    emptySlowCycle8PlaceholderCase7();
    epsSignalMonitoringCoordinator();
    emptySlowCycle20PlaceholderCase15();
    epsTimingCalculationSlowCycle40Coordinator();
    vp44InjectionTimingSlowCycle40Coordinator();
    engineProtectionMultiStateSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_16_DZG_TIMING;
    break;
  case PHASE_16_DZG_TIMING:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    empty_debug_hook();
    ioControlSlowCycle10Coordinator();
    dzgTimingAndPressureSlowCycle10Coordinator();
    emptySlowCycle20PlaceholderCase16();
    main_loop_phase_index = PHASE_17_OUTPUT_CTRL;
    break;
  case PHASE_17_OUTPUT_CTRL:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    engineParameterAndBoostControlWrapper();
    shutdownProtectionSlowCycle10Coordinator();
    engineModeBasedOutputControlSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_18_DIAG_TEMP;
    break;
  case PHASE_18_DIAG_TEMP:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    auxiliarySystemControlWrapper();
    diagnosticCommunicationSlowCycle10Coordinator();
    vp44DiagnosticControlSlowCycle20Coordinator();
    fuelTemperatureProtectionSlowCycle40Coordinator();
    main_loop_phase_index = PHASE_19_DIAG_STATS;
    break;
  case PHASE_19_DIAG_STATS:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    slowCycle8Coordinator();
    diagnosticDataTransmissionSlowCycle10Coordinator();
    diagnosticStatisticsSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_20_RPM_VP44;
    break;
  case PHASE_20_RPM_VP44:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    boostPressureControlCoordinator();
    rpm_control_system();
    vp44ControlSystemCoordinator();
    main_loop_phase_index = PHASE_21_EXT_FAULT;
    break;
  case PHASE_21_EXT_FAULT:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    boost_pressure_control_wrapper();
    rpmBasedFuelLimiterCoordinator();
    vp44ExtendedFaultDetectionCoordinator();
    main_loop_phase_index = PHASE_22_ADV_PROT;
    break;
  case PHASE_22_ADV_PROT:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    emptySlowCycle8Placeholder();
    secondaryMonitoringWrapper();
    advancedEngineProtectionCoordinator();
    main_loop_phase_index = PHASE_23_SLOW_ALL;
    break;
  case PHASE_23_SLOW_ALL:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    emptySlowCycle8PlaceholderCase7();
    slowCycle10Coordinator();
    slowCycle20Coordinator();
    main_loop_phase_index = PHASE_24_FUEL_TIME;
    break;
  case PHASE_24_FUEL_TIME:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    empty_debug_hook();
    diagnosticMonitoringCoordinator();
    fuelTimingCoordinator();
    main_loop_phase_index = PHASE_25_EPS_EXT;
    break;
  case PHASE_25_EPS_EXT:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    engineParameterAndBoostControlWrapper();
    epsSignalMonitoringCoordinator();
    slowCycle20ExtendedCoordinator();
    main_loop_phase_index = PHASE_26_IO_FUEL;
    break;
  case PHASE_26_IO_FUEL:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    auxiliarySystemControlWrapper();
    ioControlSlowCycle10Coordinator();
    fuelCalculationSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_27_SENSOR_HIST;
    break;
  case PHASE_27_SENSOR_HIST:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    slowCycle8Coordinator();
    shutdownProtectionSlowCycle10Coordinator();
    sensorStatusHistorySlowCycle20Coordinator();
    main_loop_phase_index = PHASE_28_SMOKE_LIM;
    break;
  case PHASE_28_SMOKE_LIM:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    boostPressureControlCoordinator();
    diagnosticCommunicationSlowCycle10Coordinator();
    fuelSmokeLimiterSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_29_CAM_SYNC;
    break;
  case PHASE_29_CAM_SYNC:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    boost_pressure_control_wrapper();
    diagnosticDataTransmissionSlowCycle10Coordinator();
    camSyncDiagnosticProcessingSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_30_DERATE2;
    break;
  case PHASE_30_DERATE2:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    emptySlowCycle8Placeholder();
    rpm_control_system();
    derateProtectionSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_31_VP44_PROT2;
    break;
  case PHASE_31_VP44_PROT2:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    emptySlowCycle8PlaceholderCase7();
    rpmBasedFuelLimiterCoordinator();
    vp44ProtectionSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_32_FSO_DET;
    break;
  case PHASE_32_FSO_DET:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    empty_debug_hook();
    secondaryMonitoringWrapper();
    vp44FsoFaultDetectionSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_33_DIAG_MON;
    break;
  case PHASE_33_DIAG_MON:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    engineParameterAndBoostControlWrapper();
    slowCycle10Coordinator();
    vp44DiagnosticFaultMonitoringSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_34_FSO_MON2;
    break;
  case PHASE_34_FSO_MON2:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    auxiliarySystemControlWrapper();
    diagnosticMonitoringCoordinator();
    vp44FsoFaultMonitoringSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_35_EPS_EMPTY;
    break;
  case PHASE_35_EPS_EMPTY:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    slowCycle8Coordinator();
    epsSignalMonitoringCoordinator();
    emptySlowCycle20PlaceholderCase15();
    main_loop_phase_index = PHASE_36_DZG_IO;
    break;
  case PHASE_36_DZG_IO:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    vp44_engine_management_system();
    boostPressureControlCoordinator();
    ioControlSlowCycle10Coordinator();
    dzgTimingAndPressureSlowCycle10Coordinator();
    main_loop_phase_index = PHASE_37_OUTPUT2;
    break;
  case PHASE_37_OUTPUT2:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    engine_control_cycle();
    boost_pressure_control_wrapper();
    shutdownProtectionSlowCycle10Coordinator();
    engineModeBasedOutputControlSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_38_VP44_DIAG;
    break;
  case PHASE_38_VP44_DIAG:
    ioControlAndCanPinSwitchingWrapper();
    evenPhaseSchedulerTaskSet();
    engineDiagnosticSystemCoordinator();
    emptySlowCycle8Placeholder();
    diagnosticCommunicationSlowCycle10Coordinator();
    vp44DiagnosticControlSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_39_FINAL;
    break;
  case PHASE_39_FINAL:
    ioControlAndCanPinSwitchingWrapper();
    oddPhaseSchedulerTaskSet();
    slowCycle4Coordinator();
    emptySlowCycle8PlaceholderCase7();
    diagnosticDataTransmissionSlowCycle10Coordinator();
    diagnosticStatisticsSlowCycle20Coordinator();
    main_loop_phase_index = PHASE_0_VP44_RPM;
    break;
  default:
    main_loop_phase_index = PHASE_0_VP44_RPM;
  }
  schedulerPerformanceMonitor();
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: scheduler_init @ 0x00017b3a
 */

void scheduler_init(void)

{
  schedule_armed = 0;
  scheduler_phase_slot_count = 5;
  scheduler_phase_timeout = 200;
  scheduler_overrun_threshold = 0x9b7;
  scheduler_tick_interval = 500;
  scheduler_wait_loop_limit = 0;
  main_loop_counter = 0;
  sim_csor0 = 0x152;
  system_callback_table_t_00808f02.main_loop_callback = (dword)main_loop;
  sim_csbar1 = 0x27;
  return;
}



/*
 * Function: mainLoopTaskSchedulerInit @ 0x00017b88
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void mainLoopTaskSchedulerInit(void)

{
  scheduler_phase_table_t *psVar1;
  
  if (schedule_armed != 0) {
    if (main_loop_counter == 0) {
      for (psVar1 = &scheduler_phase_table; psVar1 < (scheduler_phase_table_t *)0x809a02;
          psVar1 = psVar1 + 1) {
        (psVar1->phase_slots).last_execution_time = 0;
        (psVar1->phase_slots).runtime_ticks = 0;
        (psVar1->phase_slots).deadline_ticks = 0xffff;
        (psVar1->phase_slots).execution_count = 0;
        (psVar1->phase_slots).overrun_count = 0;
      }
      scheduler_overrun_counter = 0;
      _scheduler_wait_loop_counter = 0;
      main_loop_counter = 1;
    }
    main_loop_reserved = hardware_timer_register._0_2_;
    return;
  }
  main_loop_counter = 0;
  return;
}



/*
 * Function: schedulerPerformanceMonitor @ 0x00017bf2
 */

void schedulerPerformanceMonitor(void)

{
  if (schedule_armed != 0) {
    scheduler_phase_execution_time = hardware_timer_register._0_2_ - main_loop_reserved;
    if (*(ushort *)(scheduler_phase_pointer + 8) < scheduler_phase_execution_time) {
      *(word *)(scheduler_phase_pointer + 8) = scheduler_phase_execution_time;
    }
    if (scheduler_phase_execution_time < *(ushort *)(scheduler_phase_pointer + 6)) {
      *(word *)(scheduler_phase_pointer + 6) = scheduler_phase_execution_time;
    }
    *(uint *)scheduler_phase_pointer =
         (uint)scheduler_phase_execution_time + *(int *)scheduler_phase_pointer;
    *(short *)(scheduler_phase_pointer + 4) = *(short *)(scheduler_phase_pointer + 4) + 1;
    if ((scheduler_overrun_threshold < scheduler_phase_execution_time) &&
       (*(short *)(scheduler_phase_pointer + 10) = *(short *)(scheduler_phase_pointer + 10) + 1,
       scheduler_overrun_counter != 0xffff)) {
      scheduler_overrun_counter = scheduler_overrun_counter + 1;
    }
    scheduler_phase_pointer = scheduler_phase_pointer + 0x10;
  }
  return;
}



/*
 * Function: schedulerWaitLoop @ 0x00017c6e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void schedulerWaitLoop(void)

{
  while (engine_shutdown_complete_flag == 0) {
    if (schedule_armed != 0) {
      for (scheduler_wait_loop_index = 0; scheduler_wait_loop_index < scheduler_wait_loop_limit;
          scheduler_wait_loop_index = scheduler_wait_loop_index + 1) {
      }
      _scheduler_wait_loop_counter = _scheduler_wait_loop_counter + 1;
    }
  }
  return;
}



/*
 * Function: circularBufferPush @ 0x00017ca6
 */

uint circularBufferPush(uint *param_1,undefined4 param_2)

{
  if (*(char *)(param_1 + 4) == '\0') {
    *(undefined1 *)param_1[1] = param_2._1_1_;
    param_1[1] = param_1[1] + 1;
    if (param_1[1] == param_1[3]) {
      param_1[1] = param_1[2];
    }
    if (*param_1 == param_1[1]) {
      *(undefined1 *)(param_1 + 4) = 1;
    }
    return *param_1 & 0xffffff00;
  }
  return 1;
}



/*
 * Function: circularBufferPop @ 0x00017ce2
 */

uint circularBufferPop(uint *param_1,undefined1 *param_2)

{
  uint uVar1;
  
  if ((*param_1 == param_1[1]) && (*(char *)(param_1 + 4) != '\x01')) {
    return 1;
  }
  *param_2 = *(undefined1 *)*param_1;
  *param_1 = *param_1 + 1;
  uVar1 = *param_1;
  if (uVar1 == param_1[3]) {
    *param_1 = param_1[2];
  }
  *(undefined1 *)(param_1 + 4) = 0;
  return uVar1 & 0xffffff00;
}



/*
 * Function: circularBufferInit @ 0x00017d1a
 */

void circularBufferInit(undefined4 *param_1,undefined4 param_2,uint param_3)

{
  param_1[2] = param_2;
  param_1[1] = param_2;
  *param_1 = param_2;
  param_1[3] = param_1[2] + (param_3 >> 0x10);
  *(undefined1 *)(param_1 + 4) = 0;
  return;
}



/*
 * Function: fuelDemandModeSelector @ 0x00017d40
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort fuelDemandModeSelector(void)

{
  ushort uVar1;
  ushort unaff_D2w;
  
  uVar1 = fuel_demand_control_flags & 0x10;
  if (uVar1 == 0) {
    uVar1 = shutdownMinimumSelectorOrchestrator();
  }
  else {
    shutdown_limit_accumulator = fuel_demand_mode_selector_value;
    shutdown_minimum_selector_value = FUEL_DEMAND_MODE_OVERRIDE;
  }
  if (engine_operating_mode == ENGINE_IDLE) {
    current_fuel_demand_value = 0;
    vp44_engine_state = IDLE_STATE;
  }
  else {
    if (engine_operating_mode == FAULT_EMERGENCY) {
      vp44_engine_state = FAULT_EMERGENCY_STATE;
      current_fuel_demand_value = mask_used_for_can_msg_object_15_0_ffffffff;
    }
    else if (engine_operating_mode == HIGH_PERFORMANCE) {
      vp44_engine_state = HIGH_PERFORMANCE_MODE;
      current_fuel_demand_value = intercept_fueling_between_hsg_brkpt_and_the_epf_curve_0_100;
    }
    else {
      uVar1 = fuel_demand_control_flags & 2;
      if (uVar1 == 0) {
        if (engine_operating_mode == VP44_INJECTION_ACTIVE) {
          vp44_engine_state = VP44_ACTIVE_MODE;
          current_fuel_demand_value = intercept_fueling_between_lsg_ref_and_the_epf_curve_0_100;
        }
        else if ((engine_operating_mode == LOW_RPM_RUNNING) ||
                (engine_operating_mode == TRANSITIONAL_MODE_6)) {
          vp44_engine_state = LOW_RPM_OR_TRANSITIONAL;
          current_fuel_demand_value = fuel_demand_override;
        }
        else if (engine_operating_mode == HIGH_RPM_RUNNING) {
          if ((_engine_operating_mode_cached == 2) || (_engine_operating_mode_cached == 6)) {
            uVar1 = governorPidFuelCalculator();
            diagnostic_rpm_threshold_status = fuel_demand_override;
          }
          if (((diagnostic_fuel_control_mode == 0xb) &&
              (shutdown_minimum_selector_value == FUEL_ARBITRATOR_DIAG)) ||
             (uVar1 = diagnostic_rpm_threshold_status,
             diagnostic_rpm_threshold_status < shutdown_limit_accumulator)) {
            vp44_engine_state = diagnostic_fuel_control_mode;
            current_fuel_demand_value = diagnostic_rpm_threshold_status;
          }
          else {
            vp44_engine_state = shutdown_minimum_selector_value;
            current_fuel_demand_value = shutdown_limit_accumulator;
          }
        }
        else {
          current_fuel_demand_value = unaff_D2w;
          if (engine_operating_mode == TRANSITIONAL_MODE_7) {
            if (((diagnostic_fuel_control_mode == 0xb) &&
                (shutdown_minimum_selector_value == FUEL_ARBITRATOR_DIAG)) ||
               (uVar1 = diagnostic_rpm_threshold_status,
               diagnostic_rpm_threshold_status < shutdown_limit_accumulator)) {
              vp44_engine_state = diagnostic_fuel_control_mode;
              current_fuel_demand_value = diagnostic_rpm_threshold_status;
            }
            else {
              vp44_engine_state = shutdown_minimum_selector_value;
              current_fuel_demand_value = shutdown_limit_accumulator;
            }
            if (current_fuel_demand_value < fuel_demand_override) {
              vp44_engine_state = LOW_RPM_OR_TRANSITIONAL;
              current_fuel_demand_value = fuel_demand_override;
            }
          }
        }
      }
      else {
        vp44_engine_state = MANUAL_OVERRIDE;
        current_fuel_demand_value = fuel_demand_mode_override;
      }
    }
    if (max_number_of_shutdowns_before_restart_is_not_allowed_0_255 < current_fuel_demand_value) {
      current_fuel_demand_value = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
    }
    else if (current_fuel_demand_value < mask_used_for_can_msg_object_15_0_ffffffff) {
      current_fuel_demand_value = mask_used_for_can_msg_object_15_0_ffffffff;
    }
  }
  _engine_operating_mode_cached = engine_operating_mode;
  return uVar1;
}



/*
 * Function: flashEraseWithWatchdog @ 0x00017ed4
 */

/* WARNING: Removing unreachable block (ram,0x00018018) */
/* WARNING: Removing unreachable block (ram,0x00018026) */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 flashEraseWithWatchdog(void)

{
  ushort uVar1;
  ushort uVar2;
  short sVar3;
  ushort uVar4;
  
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  uVar4 = 0;
  *(undefined2 *)flash_control_register_ptr = 0x2020;
  *(undefined2 *)flash_control_register_ptr = 0xd0d0;
  _calibration_download_size_n_a = 0;
  uVar2 = 0;
  do {
    uVar1 = uVar2 + 1;
    if (40000 < uVar2) {
      _calibration_download_size_n_a = 0xffff;
      return 1;
    }
    if ((qsm_config_reg_high & 1) == 0) {
      uVar4 = 0;
    }
    else {
      uVar4 = uVar4 + 1;
      if (3 < uVar4) {
        *(undefined2 *)flash_control_register_ptr = 0xb0b0;
        uVar4 = 0;
        while ((uVar2 = uVar4 + 1, uVar4 < 40000 &&
               ((_calibration_download_size_n_a & 0x80) != 0x80))) {
          sVar3 = 0;
          do {
            uVar4 = 0;
            do {
              REG_SIM_SWSR = 0xaa;
              qsm_sci_data_reg._1_1_ = 0xaa;
              uVar4 = uVar4 + 1;
            } while (uVar4 < 0xa0);
            sVar3 = sVar3 + 1;
            uVar4 = uVar2;
          } while (sVar3 == 0);
        }
        _calibration_download_size_n_a = 0xffff;
        return 2;
      }
    }
    sVar3 = 0;
    do {
      uVar2 = 0;
      do {
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        uVar2 = uVar2 + 1;
      } while (uVar2 < 0xa0);
      sVar3 = sVar3 + 1;
      uVar2 = uVar1;
    } while (sVar3 == 0);
  } while( true );
}



/*
 * Function: flashEraseFromRam @ 0x0001802e
 */

void flashEraseFromRam(dword param_1)

{
  undefined2 *puVar1;
  code *pcVar2;
  undefined1 auStack_804 [2048];
  
  flash_control_register_ptr = param_1;
  puVar1 = (undefined2 *)auStack_804;
  for (pcVar2 = flashEraseWithWatchdog; pcVar2 < flashEraseFromRam; pcVar2 = pcVar2 + 2) {
    *puVar1 = *(undefined2 *)pcVar2;
    puVar1 = puVar1 + 1;
  }
  (*(code *)auStack_804)();
  return;
}



/*
 * Function: flashProgramWordWithWatchdog @ 0x0001805c
 */

/* WARNING: Removing unreachable block (ram,0x00018104) */
/* WARNING: Removing unreachable block (ram,0x0001810e) */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 flashProgramWordWithWatchdog(void)

{
  ushort uVar1;
  ushort uVar2;
  
  uVar1 = 0;
  while( true ) {
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    if (flash_write_end_address <= flash_control_register_ptr) {
      if ((_calibration_download_size_n_a & 0x10) != 0x10) {
        return 1;
      }
      return 0;
    }
    *(undefined2 *)flash_control_register_ptr = 0x4040;
    *(undefined2 *)flash_control_register_ptr = *(undefined2 *)flash_write_data_pointer;
    uVar2 = 0;
    while (uVar2 < 5000) {
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
      uVar2 = uVar2 + 1;
    }
    _calibration_download_size_n_a = 0xffff;
    if (4 < uVar1) break;
    uVar1 = uVar1 + 1;
  }
  return 0;
}



/*
 * Function: flashProgramFromRam @ 0x00018174
 */

void flashProgramFromRam(int param_1,dword param_2,uint param_3)

{
  undefined2 *puVar1;
  code *pcVar2;
  undefined1 auStack_804 [2048];
  
  flash_write_data_pointer = param_2;
  flash_control_register_ptr = param_1;
  flash_write_end_address = param_1 + (param_3 >> 0x10);
  puVar1 = (undefined2 *)auStack_804;
  for (pcVar2 = flashProgramWordWithWatchdog; pcVar2 < flashProgramFromRam; pcVar2 = pcVar2 + 2) {
    *puVar1 = *(undefined2 *)pcVar2;
    puVar1 = puVar1 + 1;
  }
  (*(code *)auStack_804)();
  return;
}



/*
 * Function: diagnosticStatusDefaultSetter @ 0x000181bc
 */

void diagnosticStatusDefaultSetter(void)

{
  if (diagnostic_status_register == NORMAL_OPERATION) {
    diagnostic_status_register = DEFAULT_DIAGNOSTIC;
  }
  return;
}



/*
 * Function: diagnostic_parameter_handler @ 0x000181cc
 */

void diagnostic_parameter_handler(void)

{
  if (diagnostic_status_register == DEFAULT_DIAGNOSTIC) {
    diagnostic_parameter_buffer = activeParamReadFunction();
    cached_parameter_value = diagnostic_parameter_buffer;
  }
  return;
}



/*
 * Function: fuelDemandTableBlendCalculator @ 0x000181ea
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelDemandTableBlendCalculator(void)

{
  word wVar1;
  word extraout_D0w;
  word extraout_D0w_00;
  ushort extraout_D0w_01;
  ushort extraout_D0w_02;
  
  if ((diagnostic_status_flags & 0x100) == 0) {
    wVar1 = current_fuel_demand_value;
    if (_fuel_demand_blend_mode_select == 1) {
      fuel_demand_blend_input = current_fuel_demand_value;
      wVar1 = lookupTableInterpolation((table_interp_args_t *)&fuel_demand_rating_table_size);
    }
    if (fuel_timing_mode_blend_factor_965a == 0x4000) {
      rpm_snapshot_0 = current_engine_rpm;
      fuel_snapshot_0 = wVar1;
      tableInterpolationLookup((short *)&fuel_demand_blend_table_1_size);
      fuel_demand_table_output = extraout_D0w;
    }
    else if (fuel_timing_mode_blend_factor_965a == 0) {
      rpm_snapshot_1 = current_engine_rpm;
      fuel_snapshot_1 = wVar1;
      tableInterpolationLookup((short *)&fuel_demand_blend_table_2_size);
      fuel_demand_table_output = extraout_D0w_00;
    }
    else {
      rpm_snapshot_0 = current_engine_rpm;
      fuel_snapshot_0 = wVar1;
      tableInterpolationLookup((short *)&fuel_demand_blend_table_1_size);
      rpm_snapshot_1 = current_engine_rpm;
      fuel_snapshot_1 = wVar1;
      tableInterpolationLookup((short *)&fuel_demand_blend_table_2_size);
      fuel_demand_table_output =
           (short)((uint)fuel_timing_mode_blend_factor_965a * (uint)extraout_D0w_01 >> 0xe) +
           (short)((uint)extraout_D0w_02 * (0x4000 - (uint)fuel_timing_mode_blend_factor_965a) >>
                  0xe);
    }
    fuel_demand_source_id = TABLE_BLEND_CALC;
  }
  else {
    fuel_demand_table_output = fuel_demand_blend_param_2;
    fuel_demand_source_id = BLEND_PARAM_FALLBACK;
  }
  if ((diagnostic_system_flags_2 & 0x4000) != 0) {
    fuel_demand_table_output = fuel_demand_blend_param_1 + fuel_demand_table_output;
    fuel_adjustment_active_flag = 1;
  }
  fuel_limit_minimum_value = fuel_demand_table_output;
  fuelDemandUpdateOrchestrator();
  return;
}



/*
 * Function: initFuelDemandCalculationSystem @ 0x0001832a
 */

void initFuelDemandCalculationSystem(void)

{
  fuel_demand_table_1_ptr_370 = 0x807c9a;
  fuel_demand_rating_ptr = (dword)&CCRFRTNG;
  fuel_demand_rating_table_size = 2;
  fuel_demand_table_2_ptr_37c = 0x8080c2;
  fuel_demand_blend_table_1_size = 2;
  fuel_demand_table_3_ptr_384 = 0x8080e8;
  fuel_demand_table_2_base = 2;
  fuel_demand_table_4_ptr = 0x808100;
  fuel_demand_table_5_ptr = 0x80828c;
  fuel_demand_blend_table_2_size = 2;
  fuel_demand_table_6_ptr = 0x8082b2;
  fuel_demand_table_5_base = 2;
  fuel_demand_table_7_ptr = 0x8082ca;
  return;
}



/*
 * Function: fuelDemandProportionalCalculationSlowCycle40Coordinator @ 0x000183a6
 */

void fuelDemandProportionalCalculationSlowCycle40Coordinator(void)

{
  uint uVar1;
  
  if (current_fuel_demand_value < fuel_demand_offset_threshold) {
    fuel_timing_clamp_value = 0;
    return;
  }
  uVar1 = proportionalCalculation
                    ((uint)current_engine_rpm * 0x280,
                     (uint)current_fuel_demand_value - (uint)fuel_demand_offset_threshold,
                     (uint)fuel_demand_proportional_param * 0x1d7);
  if (31999 < uVar1) {
    fuel_timing_clamp_value = 32000;
    return;
  }
  fuel_timing_clamp_value = (word)uVar1;
  return;
}



/*
 * Function: emptySlowCycle20PlaceholderCase16 @ 0x00018428
 */

void emptySlowCycle20PlaceholderCase16(void)

{
  return;
}



/*
 * Function: emptyInit2 @ 0x0001842a
 */

void emptyInit2(void)

{
  return;
}



/*
 * Function: canPinVp44StatusController @ 0x0001842c
 */

ushort canPinVp44StatusController(void)

{
  ushort uVar1;
  
  uVar1 = vp44_communication_status & 1;
  if (((((vp44_communication_status & 1) != 0) && (engine_control_system_ready == 0)) &&
      ((vp44_injection_system_active == 0 ||
       (uVar1 = vp44_status_flags_1 & 0x40, (vp44_status_flags_1 & 0x40) == 0)))) &&
     (((engine_operating_mode == HIGH_PERFORMANCE &&
       (uVar1 = vp44_status_flags_2 & 2, (vp44_status_flags_2 & 2) == 0)) ||
      (engine_operating_mode != HIGH_PERFORMANCE)))) {
    can_pin_switching_control_flags = can_pin_switching_control_flags | 0x20;
    return uVar1;
  }
  can_pin_switching_control_flags = can_pin_switching_control_flags & 0xdf;
  return uVar1;
}



/*
 * Function: fuel_timing_calculation_with_fault_checking @ 0x0001848e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuel_timing_calculation_with_fault_checking(void)

{
  word wVar1;
  short sVar2;
  ushort unaff_D3w;
  ushort unaff_D4w;
  undefined8 uVar3;
  
  wVar1 = fuel_timing_mode_selector;
  if (fuel_timing_mode_selector != 0) {
    _rpm_input_for_fuel_table_1 = current_engine_rpm;
    uVar3 = tableInterpolationLookup((short *)&fuel_lookup_table_1_base);
    unaff_D4w = (ushort)((ulonglong)uVar3 >> 0x20);
  }
  if (wVar1 < 0x4000) {
    _rpm_input_for_fuel_table_2 = current_engine_rpm;
    uVar3 = tableInterpolationLookup((short *)&fuel_lookup_table_2_base);
    unaff_D3w = (ushort)((ulonglong)uVar3 >> 0x20);
  }
  calculated_fuel_timing_value = unaff_D4w;
  if ((wVar1 != 0x4000) && (calculated_fuel_timing_value = unaff_D3w, wVar1 != 0)) {
    calculated_fuel_timing_value =
         unaff_D3w + (short)((uint)wVar1 * ((uint)unaff_D4w - (uint)unaff_D3w) >> 0xe);
  }
  if (((((vp44_flag_register_1 & 0x8000) == 0) ||
       (((engine_fault_status_register_1 & 2) != 0 &&
        ((engine_fault_confirmation_register & 2) != 0)))) ||
      (((engine_fault_status_register_1 & 1) != 0 && ((engine_fault_confirmation_register & 1) != 0)
       ))) || (((engine_fault_status_register_1 & 0x10) != 0 &&
               ((engine_fault_confirmation_register & 0x10) != 0)))) {
    sVar2 = 0;
  }
  else {
    _fuel_correction_input = throttle_position_raw;
    sVar2 = lookupTableInterpolation((table_interp_args_t *)&fuel_correction_table_base);
  }
  calculated_fuel_timing_value = sVar2 + calculated_fuel_timing_value;
  if (calculated_fuel_timing_value < mask_used_for_can_msg_object_15_0_ffffffff) {
    calculated_fuel_timing_value = mask_used_for_can_msg_object_15_0_ffffffff;
  }
  return;
}



/*
 * Function: fuelLimitParameterPointerSetup @ 0x00018590
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelLimitParameterPointerSetup(void)

{
  _fuel_limit_lookup_1_base = 0x807f42;
  _fuel_lookup_table_1_base = 2;
  fuel_limit_table_1_limit = 400;
  fuel_limit_table_3_ptr = 0x807f68;
  fuel_limit_lookup_1_divisor = 2;
  fuel_limit_intake_temp_ptr =
       (dword)&lower_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293;
  fuel_limit_table_4_ptr = 0x808002;
  _fuel_lookup_table_2_base = 2;
  fuel_limit_table_2_limit = 400;
  fuel_limit_table_5_ptr = 0x808028;
  fuel_limit_lookup_2_divisor = 2;
  fuel_limit_table_6_ptr = 0x808032;
  _fuel_correction_input = throttle_position_raw;
  ram0x008003a6 = 0x808862;
  fuel_limit_table_2_ptr = 0x808876;
  fuel_correction_table_base._0_2_ = 2;
  return;
}



/*
 * Function: shutdownMinimumSelector19 @ 0x00018620
 */

void shutdownMinimumSelector19(void)

{
  if (calculated_fuel_timing_value < shutdown_limit_accumulator) {
    shutdown_limit_accumulator = calculated_fuel_timing_value;
    shutdown_minimum_selector_value = CALCULATED_FUEL_TIMING;
  }
  return;
}



/*
 * Function: fuel_delivery_controller @ 0x0001863e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuel_delivery_controller(void)

{
  short sVar1;
  word wVar2;
  int iVar3;
  
  wVar2 = fuel_delivery_target;
  if (diagnostic_fuel_control_mode == 0xc) {
    if (((int)((int)_number_of_engine_speed_targets_per_crankshaft_revolution_1_255 +
              (uint)arbitrator_fuel_value_buffer) < (int)(uint)current_engine_rpm) &&
       (diagnostic_rpm_threshold_status < _rpm_comparison_threshold)) {
      final_fuel_delivery_command =
           (uint)engine_speed_above_which_the_overspeed_algorithm_disables_fue_0_4000 << 0x10;
      fuel_delivery_target = 0;
      _fuel_delivery_status = -0x80000000;
    }
    else {
      fuel_delivery_target = exponentialMovingAverage();
      if ((short)_fuel_delivery_max_limit < (short)fuel_delivery_target) {
        fuel_delivery_target = _fuel_delivery_max_limit;
        _fuel_delivery_status = (short)_fuel_delivery_max_limit * 0x10000 + -0x80000000;
      }
      else if ((short)fuel_delivery_target < (short)_fuel_delivery_min_limit) {
        fuel_delivery_target = _fuel_delivery_min_limit;
        _fuel_delivery_status = (short)_fuel_delivery_min_limit * 0x10000 + -0x80000000;
      }
      _fuel_delivery_scaled =
           (short)(((int)(short)fuel_delivery_target * (int)_fuel_delivery_gain_factor) / 0x3c0);
      if ((int)_fuel_delivery_rate_limit_gain *
          ((int)(short)fuel_delivery_target - (int)(short)wVar2) < 0x77ff10) {
        iVar3 = ((int)(short)fuel_delivery_target - (int)(short)wVar2) *
                (int)_fuel_delivery_rate_limit_gain;
        if (iVar3 < -0x77ffff) {
          _fuel_delivery_rate_delta = -0x8000;
        }
        else {
          _fuel_delivery_rate_delta = (short)(iVar3 / 0xf0);
        }
      }
      else {
        _fuel_delivery_rate_delta = 0x7fff;
      }
      iVar3 = (int)(short)fuel_delivery_target * (int)(short)(_fuel_delivery_offset_factor << 2) +
              final_fuel_delivery_command;
      final_fuel_delivery_command._0_2_ = (word)((uint)iVar3 >> 0x10);
      sVar1 = final_fuel_delivery_command._0_2_ - _fuel_delivery_offset_correction;
      final_fuel_delivery_command = CONCAT22(sVar1,(short)iVar3);
      if (sVar1 < (short)_fuel_delivery_upper_bound) {
        if (sVar1 < (short)_fuel_delivery_lower_bound) {
          final_fuel_delivery_command = (uint)_fuel_delivery_lower_bound << 0x10;
        }
      }
      else {
        final_fuel_delivery_command = (uint)_fuel_delivery_upper_bound << 0x10;
      }
      fuel_delivery_state_variable = final_fuel_delivery_command._0_2_;
      iVar3 = (int)(short)final_fuel_delivery_command._0_2_ +
              (int)_fuel_delivery_rate_delta + (int)_fuel_delivery_scaled;
      if ((int)(uint)intercept_of_rpm_vs_phase_lag_line_defining_time_offset_for_syn_0_16 < iVar3) {
        fuel_delivery_phase_lag_result =
             intercept_of_rpm_vs_phase_lag_line_defining_time_offset_for_syn_0_16;
      }
      else if (iVar3 < (int)(uint)
                            slope_of_rpm_vs_phase_lag_line_defining_time_offset_for_s_0_0_031136) {
        fuel_delivery_phase_lag_result =
             slope_of_rpm_vs_phase_lag_line_defining_time_offset_for_s_0_0_031136;
      }
      else {
        fuel_delivery_phase_lag_result = (word)iVar3;
      }
      diagnostic_rpm_threshold_status = fuel_delivery_phase_lag_result;
    }
  }
  return;
}



/*
 * Function: fuelRpmDeviationCalculator @ 0x0001883a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelRpmDeviationCalculator(void)

{
  fuel_delivery_target =
       (word)((int)((int)(short)fuel_delivery_rpm_deviation_param *
                   ((uint)arbitrator_fuel_value_buffer - (uint)current_engine_rpm)) >> 9);
  if ((short)_fuel_delivery_max_limit < (short)fuel_delivery_target) {
    fuel_delivery_target = _fuel_delivery_max_limit;
  }
  else if ((short)fuel_delivery_target < (short)_fuel_delivery_min_limit) {
    fuel_delivery_target = _fuel_delivery_min_limit;
  }
  _fuel_delivery_status = (short)fuel_delivery_target * 0x10000 + -0x80000000;
  final_fuel_delivery_command._0_2_ =
       current_fuel_demand_value -
       (short)(((int)(short)fuel_delivery_target * (int)_fuel_delivery_gain_factor) / 0x3c0);
  if ((short)final_fuel_command_max < (short)final_fuel_delivery_command._0_2_) {
    final_fuel_delivery_command._0_2_ = final_fuel_command_max;
  }
  else if ((short)final_fuel_delivery_command._0_2_ < (short)final_fuel_command_min) {
    final_fuel_delivery_command._0_2_ = final_fuel_command_min;
  }
  final_fuel_delivery_command._2_2_ = 0;
  if (fuel_rpm_deviation_calc_param != 0) {
    fuel_delivery_controller();
  }
  return;
}



/*
 * Function: fuelDeliverySystemInit @ 0x000188f6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelDeliverySystemInit(void)

{
  _fuel_delivery_gain_factor = fuel_delivery_gain_factor_init;
  _fuel_delivery_offset_factor = fuel_delivery_offset_factor_init;
  _fuel_delivery_rate_limit_gain = fuel_delivery_rate_limit_gain_init;
  _fuel_delivery_status = 0x80000000;
  fuel_delivery_param_ptr = 0x808464;
  return;
}



/*
 * Function: fuel_limit_arbitrator @ 0x0001892a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuel_limit_arbitrator(void)

{
  uint uVar1;
  word wVar2;
  
  if (fuel_arbitrator_diag_t_0080cff8.speed_limit == 1) {
    arbitrator_fuel_value_buffer = _diagnostic_mode_parameter;
    arbitrator_active_limit_priority = 8;
    _arbitrator_status_flag = 0;
    return;
  }
  fuel_limit_offset_value = *(word *)param_pointer_set_1;
  fuel_limit_comparison_low = *(word *)param_pointer_set_2;
  fuel_limit_comparison_high = *(word *)param_pointer_set_3;
  if (fuel_limit_offset_value < fuel_arbitrator_threshold_1) {
    arbitrator_active_limit_priority = 6;
    arbitrated_fuel_limit = fuel_limit_offset_value;
  }
  else {
    arbitrated_fuel_limit = fuel_arbitrator_threshold_1;
    arbitrator_active_limit_priority = 5;
  }
  if ((fuel_arbitrator_diag_t_0080cff8.rpm_target == 3) &&
     (fuel_arbitrator_diag_t_0080cff8.command_counter <= arbitrated_fuel_limit)) {
    arbitrated_fuel_limit = fuel_arbitrator_diag_t_0080cff8.command_counter;
    arbitrator_active_limit_priority = 9;
  }
  if (fuel_arbitrator_threshold_2 <= arbitrated_fuel_limit) {
    arbitrated_fuel_limit = fuel_arbitrator_threshold_2;
    arbitrator_active_limit_priority = 4;
  }
  if (fuel_arbitrator_threshold_3 <= arbitrated_fuel_limit) {
    arbitrated_fuel_limit = fuel_arbitrator_threshold_3;
    arbitrator_active_limit_priority = 3;
  }
  if (fuel_arbitrator_threshold_4 <= arbitrated_fuel_limit) {
    arbitrated_fuel_limit = fuel_arbitrator_threshold_4;
    arbitrator_active_limit_priority = 2;
  }
  if (_fuel_arbitrator_threshold_5 <= arbitrated_fuel_limit) {
    arbitrated_fuel_limit = _fuel_arbitrator_threshold_5;
    arbitrator_active_limit_priority = 1;
  }
  if (fuel_arbitrator_threshold_6 <= arbitrated_fuel_limit) {
    arbitrated_fuel_limit = fuel_arbitrator_threshold_6;
    arbitrator_active_limit_priority = 7;
  }
  if (true_oil_pressure_precrank_error_1_true_0_false <= arbitrated_fuel_limit) {
    arbitrated_fuel_limit = true_oil_pressure_precrank_error_1_true_0_false;
    arbitrator_active_limit_priority = 0xb;
  }
  if (allowed_rate_of_torque_limit_change_0_2000 < arbitrated_fuel_limit) {
    arbitrated_fuel_limit = allowed_rate_of_torque_limit_change_0_2000;
  }
  if (arbitrator_active_limit_priority == 9) {
    if ((uint)arbitrated_fuel_limit <
        (uint)fuel_limit_rpm_error_offset + (uint)governor_rpm_error_value) {
      arbitrated_fuel_limit = fuel_limit_rpm_error_offset + governor_rpm_error_value;
    }
  }
  else if (arbitrated_fuel_limit < arbitrated_fuel_limit_min) {
    arbitrated_fuel_limit = arbitrated_fuel_limit_min;
  }
  if (fuel_demand_rate_limit < arbitrated_fuel_limit) {
    fuel_demand_rate_limit =
         number_of_consecutive_occurances_of_powerdown_data_lost_to_set_1_255 +
         fuel_demand_rate_limit;
  }
  if (arbitrated_fuel_limit < fuel_demand_rate_limit) {
    fuel_demand_rate_limit = arbitrated_fuel_limit;
  }
  if (((fuel_limit_comparison_high != 0) && (fuel_limit_comparison_low != 0)) &&
     ((arbitrator_active_limit_priority != 9 || (fuel_arbitrator_diag_t_0080cff8._28_2_ != 1)))) {
    _arbitrator_status_flag = 1;
    wVar2 = load_descriminator_to_determine_lugback_0_100;
    if ((diagnostic_rpm_threshold_status <= load_descriminator_to_determine_lugback_0_100) &&
       (wVar2 = diagnostic_rpm_threshold_status,
       diagnostic_rpm_threshold_status < load_descriminator_to_determine_lugback_0_100)) {
      wVar2 = load_descriminator_to_determine_lugback_0_100;
    }
    uVar1 = ((uint)fuel_limit_comparison_high * ((uint)fuel_limit_comparison_low - (uint)wVar2)) /
            0x1111;
    if ((int)(uVar1 & 0xffff) < (int)((uint)fuel_limit_offset_value - (uint)fuel_demand_rate_limit))
    {
      fuel_demand_delta = 0;
    }
    else {
      fuel_demand_delta =
           (short)uVar1 - (short)((uint)fuel_limit_offset_value - (uint)fuel_demand_rate_limit);
    }
    if (fuel_demand_delta <= fuel_demand_rate_limit) {
      arbitrator_fuel_value_buffer = fuel_demand_rate_limit;
      return;
    }
    arbitrator_fuel_value_buffer = fuel_demand_delta;
    return;
  }
  arbitrator_fuel_value_buffer = fuel_demand_rate_limit;
  _arbitrator_status_flag = 0;
  return;
}



/*
 * Function: fuelArbitratorInit @ 0x00018b6e
 */

void fuelArbitratorInit(void)

{
  param_pointer_set_1 = (dword)&fuel_demand_rate_limit_init;
  param_pointer_set_3 = 0x8036d8;
  param_pointer_set_2 = 0x8036da;
  fuel_demand_rate_limit = fuel_demand_rate_limit_init;
  arbitrator_active_limit_priority = 6;
  arbitrated_fuel_limit = oil_pressure_precrank_status;
  fuel_arbitrator_threshold_6 = oil_pressure_precrank_status;
  fuel_arbitrator_threshold_2 = oil_pressure_precrank_status;
  return;
}



/*
 * Function: derateChangeDetector @ 0x00018bbe
 */

void derateChangeDetector(void)

{
  ushort uVar1;
  
  uVar1 = (byte)-((derate_status_byte & 8) != 0) & 1;
  derate_bit8_changed_flag = (word)(uVar1 != derate_bit8_previous_state);
  derate_bit8_previous_state = uVar1;
  uVar1 = (byte)-((derate_status_byte & 4) != 0) & 1;
  derate_bit4_changed_flag = (word)(uVar1 != derate_bit4_previous_state);
  derate_bit4_previous_state = uVar1;
  if (active_derate_value < derate_reference_value) {
    uVar1 = derate_reference_value - active_derate_value;
  }
  else {
    uVar1 = active_derate_value - derate_reference_value;
  }
  if (the_can_1_bus_configuration_register_0_255 < uVar1) {
    derate_reference_value = active_derate_value;
    derate_value_changed_flag = 1;
    return;
  }
  derate_value_changed_flag = 0;
  return;
}



/*
 * Function: highRpmEngineProtectionStateMachine @ 0x00018c62
 */

ushort highRpmEngineProtectionStateMachine(void)

{
  ushort uVar1;
  
  uVar1 = diagnostic_system_flags_1 & 2;
  if ((diagnostic_system_flags_1 & 2) != 0) {
    uVar1 = derateChangeDetector();
    if (high_rpm_protection_state == MONITORING) {
      high_rpm_protection_timer = high_rpm_protection_initial_timer;
      high_rpm_protection_warning_flag = 0;
      high_rpm_protection_fault_flag = 0;
      derate_reference_value = active_derate_value;
      if (the_can_1_bit_timing_0_register_0_255 == 0) {
        output_control_status_byte = output_control_status_byte | 1;
      }
      else {
        output_control_status_byte = output_control_status_byte & 0xfe;
      }
      if (((oil_pressure_protection_enabled == 0) ||
          (uVar1 = diagnostic_system_flags_2 & 8, (diagnostic_system_flags_2 & 8) != 0)) &&
         ((throttle_position_value == 0 &&
          ((engine_operating_mode == HIGH_RPM_RUNNING &&
           (uVar1 = throttle_position_raw,
           the_can_1_cpu_interface_register_0_255 < throttle_position_raw)))))) {
        if (((engine_fault_register_a & 0x100) == 0) || ((engine_fault_register_b & 0x100) == 0)) {
          uVar1 = 0;
        }
        else {
          uVar1 = 1;
        }
        if ((((uVar1 == 0) && (derate_bit4_changed_flag == 0)) && (derate_bit8_changed_flag == 0))
           && (derate_value_changed_flag == 0)) {
          high_rpm_protection_state = TIMER_COUNTING;
          return 0;
        }
      }
    }
    else if (high_rpm_protection_state == TIMER_COUNTING) {
      high_rpm_protection_timer = high_rpm_protection_timer - 1;
      if ((((oil_pressure_protection_enabled != 0) && ((diagnostic_system_flags_2 & 8) == 0)) ||
          (engine_operating_mode != HIGH_RPM_RUNNING)) ||
         (((throttle_position_raw <= the_can_1_cpu_interface_register_0_255 ||
           (derate_bit4_changed_flag != 0)) ||
          ((derate_bit8_changed_flag != 0 || (derate_value_changed_flag != 0)))))) {
        high_rpm_protection_state = MONITORING;
      }
      uVar1 = high_rpm_protection_timer;
      if (high_rpm_protection_timer <= the_can_1_bit_timing_1_register_0_255) {
        high_rpm_protection_state = RPM_PROTECTION_WARNING_ACTIVE;
        high_rpm_protection_warning_flag = 1;
        return high_rpm_protection_timer;
      }
    }
    else if (high_rpm_protection_state == RPM_PROTECTION_WARNING_ACTIVE) {
      high_rpm_protection_timer = high_rpm_protection_timer - 1;
      uVar1 = diagnostic_system_flags_1 & 4;
      if ((diagnostic_system_flags_1 & 4) == 0) {
        if ((((oil_pressure_protection_enabled != 0) &&
             (uVar1 = diagnostic_system_flags_2 & 8, (diagnostic_system_flags_2 & 8) == 0)) ||
            (throttle_position_value != 0)) ||
           (((engine_operating_mode != HIGH_RPM_RUNNING || (derate_bit4_changed_flag != 0)) ||
            ((derate_bit8_changed_flag != 0 || (derate_value_changed_flag != 0)))))) {
          high_rpm_protection_state = MONITORING;
        }
      }
      else {
        uVar1 = derate_bit8_changed_flag | derate_bit4_changed_flag;
        if ((uVar1 != 0) || (derate_value_changed_flag != 0)) {
          high_rpm_protection_state = FAULT_TRIGGERED;
          high_rpm_protection_warning_flag = 0;
          high_rpm_protection_fault_flag = 1;
        }
      }
      if (high_rpm_protection_timer == 0) {
        high_rpm_protection_state = SHUTDOWN_PENDING;
        high_rpm_protection_warning_flag = 0;
        high_rpm_shutdown_active_flag = 1;
        if (the_can_1_bit_timing_0_register_0_255 != 0) {
          output_control_status_byte = output_control_status_byte | 1;
          return uVar1;
        }
        output_control_status_byte = output_control_status_byte & 0xfe;
        return uVar1;
      }
    }
    else if (high_rpm_protection_state == FAULT_TRIGGERED) {
      if ((throttle_position_value != 0) || (engine_operating_mode == ENGINE_IDLE)) {
        high_rpm_protection_state = MONITORING;
        return uVar1;
      }
    }
    else if ((high_rpm_protection_state == SHUTDOWN_PENDING) &&
            (engine_operating_mode == ENGINE_IDLE)) {
      high_rpm_protection_state = MONITORING;
    }
  }
  return uVar1;
}



/*
 * Function: initFuelArbitratorThreshold3 @ 0x00018e9c
 */

void initFuelArbitratorThreshold3(void)

{
  high_rpm_protection_timer = high_rpm_protection_initial_timer;
  high_rpm_protection_state = MONITORING;
  high_rpm_shutdown_active_flag = 0;
  return;
}



/*
 * Function: vp44ControlStructureInit @ 0x00018eb4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44ControlStructureInit(void)

{
  _timing_blend_accumulator = 0;
  _vp44_control_structure_init_value = 0x806fb0;
  timing_protection_blend_ramp = 0;
  fuel_source_mode_11_state = 0;
  fuel_mode_transition_state = 0;
  vp44_status_threshold_flag = 0;
  timing_protection_counter_2 = 0;
  return;
}



/*
 * Function: diagnosticBufferPointerInit @ 0x00018ee4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticBufferPointerInit(void)

{
  _can_transmit_length = &diagnostic_tx_buffer_base;
  can_transmit_buffer_ptr = (dword)&diagnostic_tx_buffer_base;
  _track_the_time_when_throttle_is_less_than_a_threshold_0_30 = 0x808b01;
  diagnostic_tx_buffer_base = 0;
  ci_tooth_count_error_incremented_when_ci_pulse_width_is_wrong_0_255 = 0;
  diagnostic_tx_buffer_start_ptr = (dword)&diagnostic_tx_buffer_base;
  _dummy_variable_0_65535 = 0x808c01;
  diagnostic_rx_buffer_base = 0;
  tpu_transmission_active_flag = 0;
  diagnostic_rx_buffer_start_ptr = (dword)&diagnostic_rx_buffer_base;
  diagnostic_buffer_end_address = 0x808cff;
  _can_tx_message_type = &diagnostic_rx_buffer_base;
  _enables_input_of_eps_period_data_to_pptb_0_1 = &diagnostic_rx_buffer_base;
  return;
}



/*
 * Function: initFuelArbitratorThreshold5 @ 0x00018f6c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initFuelArbitratorThreshold5(void)

{
  _fuel_arbitrator_threshold_5 = oil_pressure_precrank_status;
  fuel_arbitrator_oil_pressure_snapshot = oil_pressure_precrank_status;
  return;
}



/*
 * Function: activeParamReadFunction @ 0x00018f82
 */

short activeParamReadFunction(void)

{
  word wVar1;
  ushort extraout_D0w;
  ushort extraout_D0w_00;
  ushort extraout_D0w_01;
  ushort extraout_D0w_02;
  ushort extraout_D0w_03;
  ushort extraout_D0w_04;
  ushort unaff_D2w;
  ushort uVar2;
  ushort unaff_D3w;
  
  wVar1 = fuel_timing_mode_selector;
  if (active_derate_value != 0) {
    if (fuel_timing_mode_selector != 0) {
      fuel_timing_mode_rpm_input_1 = current_engine_rpm;
      derate_interpolation_value_1 = active_derate_value;
      tableInterpolationLookup((short *)&interpolation_table_1_base);
      unaff_D3w = extraout_D0w;
      if ((active_derate_value != 0) && (active_derate_value != 400)) {
        derate_interpolation_value_1 = 0;
        tableInterpolationLookup((short *)&interpolation_table_1_base);
        derate_interpolation_value_1 = 400;
        tableInterpolationLookup((short *)&interpolation_table_1_base);
        if (extraout_D0w < extraout_D0w_00) {
          unaff_D3w = extraout_D0w_00;
        }
        if (extraout_D0w_01 < unaff_D3w) {
          unaff_D3w = extraout_D0w_01;
        }
      }
    }
    if (wVar1 < 0x4000) {
      fuel_timing_mode_rpm_input_2 = current_engine_rpm;
      derate_interpolation_value_2 = active_derate_value;
      tableInterpolationLookup((short *)&interpolation_table_2_base);
      unaff_D2w = extraout_D0w_02;
      if ((active_derate_value != 0) && (active_derate_value != 400)) {
        derate_interpolation_value_2 = 0;
        tableInterpolationLookup((short *)&interpolation_table_2_base);
        derate_interpolation_value_2 = 400;
        tableInterpolationLookup((short *)&interpolation_table_2_base);
        if (extraout_D0w_02 < extraout_D0w_03) {
          unaff_D2w = extraout_D0w_03;
        }
        if (extraout_D0w_04 < unaff_D2w) {
          unaff_D2w = extraout_D0w_04;
        }
      }
    }
    uVar2 = unaff_D2w;
    if ((wVar1 != 0) && (uVar2 = unaff_D3w, wVar1 != 0x4000)) {
      uVar2 = unaff_D2w + (short)((uint)wVar1 * ((uint)unaff_D3w - (uint)unaff_D2w) >> 0xe);
    }
    return fuel_timing_base_offset + uVar2;
  }
  return mask_used_for_can_msg_object_15_0_ffffffff;
}



/*
 * Function: fuelTimingModeInit @ 0x00019076
 */

void fuelTimingModeInit(void)

{
  fuel_timing_mode_table_1_ptr = 0x807f42;
  interpolation_table_1_base = 2;
  fuel_timing_mode_table_2_ptr = 0x807f68;
  fuel_timing_mode_lookup_1_base = 2;
  fuel_timing_mode_intake_temp_ptr =
       (dword)&lower_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293;
  fuel_timing_mode_table_3_ptr = 0x808002;
  interpolation_table_2_base = 2;
  fuel_timing_mode_table_4_ptr = 0x808028;
  fuel_timing_mode_lookup_2_base = 2;
  fuel_timing_mode_table_5_ptr = 0x808032;
  fuel_timing_mode_selector = 0x4000;
  return;
}



/*
 * Function: serialNodeAddressChecker @ 0x000190d8
 */

void serialNodeAddressChecker(undefined4 param_1)

{
  if ((param_1._0_2_ & 0xff) == serial_node_address_state) {
    serialTransmitHandler();
    return;
  }
  emptyStubFunction1();
  return;
}



/*
 * Function: serialNodeAddressForwarder @ 0x00019108
 */

void serialNodeAddressForwarder(undefined4 param_1)

{
  undefined4 unaff_D2;
  
  if ((serial_node_address_state < (param_1._0_2_ & 0xff)) &&
     ((byte)((uint)param_1 >> 0x10) <= serial_node_address_limit)) {
    serialReceiveBufferProcessor(CONCAT22(param_1._0_2_,(short)((uint)unaff_D2 >> 0x10)) & 0xffffff)
    ;
  }
  return;
}



/*
 * Function: canFrameDataCopy @ 0x0001913e
 */
/* ERROR: Failed to decompile */
void canFrameDataCopy(void) {
    /* Decompilation failed */
}


/*
 * Function: serialPort1IsrHandler @ 0x0001917c
 */

undefined8 serialPort1IsrHandler(void)

{
  byte *pbVar1;
  byte bVar2;
  undefined3 uVar3;
  undefined4 in_D0;
  undefined4 in_D1;
  undefined2 uVar4;
  undefined2 uStack_1a;
  
  uVar4 = (undefined2)((uint)in_D0 >> 0x10);
  uStack_1a = (undefined2)in_D0;
  while (bVar2 = serial_port_1_rx_data_register, serial_port_1_rx_data_register != 0) {
    if ((serial_port_1_rx_data_register < 3) || (0x10 < serial_port_1_rx_data_register)) {
      serial_port_1_isr_counter._0_1_ = serial_port_1_base_register._1_1_;
      if ((serial_port_1_base_register._1_1_ & 0x80) != 0) {
        do {
        } while ((serial_port_1_base_register._2_1_ & 0x80) != 0);
        serial_port_1_base_register._0_1_ = 10;
      }
    }
    else {
      pbVar1 = (byte *)((uint)serial_port_1_rx_data_register * 0x10 + 0xffd7e0);
      *pbVar1 = 0xfd;
      uVar3 = (undefined3)((uint)pbVar1 >> 8);
      if ((*pbVar1 & 0x20) == 0) {
        serialNodeAddressForwarder(CONCAT22((short)CONCAT31(uVar3,bVar2 - 2),uVar4));
      }
      else {
        serialNodeAddressChecker(CONCAT22((short)CONCAT31(uVar3,bVar2 - 2),uVar4));
      }
    }
  }
  return CONCAT44(CONCAT22(uVar4,uStack_1a),in_D1);
}



/*
 * Function: canMessageInterruptHandlerSetup @ 0x0001920a
 */

void canMessageInterruptHandlerSetup(void)

{
  can_message_isr_register_address = (dword)serialPort1IsrHandler;
  return;
}



/*
 * Function: emptyStubWrapper1 @ 0x00019216
 */

void emptyStubWrapper1(void)

{
  emptyStubFunction1();
  return;
}



/*
 * Function: modeBasedDataDispatcherWrapper @ 0x00019228
 */

void modeBasedDataDispatcherWrapper(undefined4 param_1)

{
  undefined2 in_D0w;
  undefined2 in_stack_00000000;
  
  modeBasedDataDispatcher
            (CONCAT22(CONCAT11((char)((ushort)in_D0w >> 8),(char)((uint)param_1 >> 0x10)),
                      in_stack_00000000));
  return;
}



/*
 * Function: serialPort2IsrHandler @ 0x0001923a
 */

undefined8 serialPort2IsrHandler(void)

{
  byte *pbVar1;
  byte bVar2;
  undefined4 in_D0;
  undefined4 in_D1;
  undefined2 uVar3;
  undefined2 uStack_1a;
  
  uVar3 = (undefined2)((uint)in_D0 >> 0x10);
  uStack_1a = (undefined2)in_D0;
  while (bVar2 = serial_port_2_rx_data_register, serial_port_2_rx_data_register != 0) {
    if ((serial_port_2_rx_data_register < 3) || (0x10 < serial_port_2_rx_data_register)) {
      serial_port_1_isr_counter._1_1_ = serial_port_2_base_register._1_1_;
      if ((serial_port_2_base_register._1_1_ & 0x80) != 0) {
        do {
        } while ((serial_port_2_base_register._2_1_ & 0x80) != 0);
        serial_port_2_base_register._0_1_ = 10;
      }
    }
    else {
      pbVar1 = (byte *)((uint)serial_port_2_rx_data_register * 0x10 + 0xffc7e0);
      *pbVar1 = 0xfd;
      if ((*pbVar1 & 0x20) == 0) {
        modeBasedDataDispatcherWrapper
                  (CONCAT22((short)CONCAT31((int3)((uint)pbVar1 >> 8),bVar2 - 2),uVar3));
      }
      else {
        emptyStubWrapper1();
      }
    }
  }
  return CONCAT44(CONCAT22(uVar3,uStack_1a),in_D1);
}



/*
 * Function: serialCommunicationIsrRegister @ 0x000192c4
 */

void serialCommunicationIsrRegister(void)

{
  serial_comm_isr_register_address = (dword)serialPort2IsrHandler;
  return;
}



/*
 * Function: tpuTimerChannelEnable @ 0x000192d0
 */

void tpuTimerChannelEnable(void)

{
  tpu_channel_enable_state = 1;
  tpu_channel_int_select = 0xfc8a;
  tpu_channel_priority_select = tpu_channel_priority_select & 0x7fff | 0x4000;
  return;
}



/*
 * Function: epsPositionSensorIsrHandler @ 0x000192f2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 epsPositionSensorIsrHandler(void)

{
  byte *pbVar1;
  undefined4 in_D0;
  undefined4 in_D1;
  byte bVar2;
  
  pbVar1 = _track_the_time_when_throttle_is_less_than_a_threshold_0_30;
  if ((tpu_cfsr0 & 0x40) != 0) {
    tpu_channel_enable_state = 0;
    tpu_channel_priority_select = tpu_channel_priority_select & 0x8fff;
    bVar2 = (byte)tpu_cfsr1;
    if (tpu_channel_state_value == 1) {
      *_dummy_variable_0_65535 = bVar2;
      _dummy_variable_0_65535 =
           (byte *)CONCAT31(_dummy_variable_0_65535,flag_indicating_eps_sensor_not_used_0_1 + 1);
      *_can_tx_message_type = *_can_tx_message_type + 1;
      tpu_transmission_state = bVar2 + tpu_transmission_state;
      if (_enables_input_of_eps_period_data_to_pptb_0_1 == _dummy_variable_0_65535) {
        if (_can_tx_message_type == _enables_input_of_eps_period_data_to_pptb_0_1) {
          *_can_tx_message_type = 0;
          tpu_transmission_state = 0;
          _dummy_variable_0_65535 =
               (byte *)CONCAT31(_dummy_variable_0_65535,(char)dummy_variable_0_65535 + '\x01');
        }
        else {
          tpu_transmission_active_flag = 1;
          tpu_cier = tpu_cier & 0xffdf;
          if ((byte *)can_transmit_buffer_ptr != _can_transmit_length) {
            tpuTimerChannelEnable();
            tpu_channel_enable_state = 1;
          }
        }
      }
      else {
        tpuTimerChannelEnable();
      }
    }
    else {
      switch(_tpu_transmission_state_machine) {
      case 0:
        if (bVar2 == *_track_the_time_when_throttle_is_less_than_a_threshold_0_30) {
          _track_the_time_when_throttle_is_less_than_a_threshold_0_30 =
               (byte *)CONCAT31(_track_the_time_when_throttle_is_less_than_a_threshold_0_30,
                                (char)
                                flag_shows_posibility_of_esp_transitioning_between_normal_false_true
                                + '\x01');
          tpu_cfsr1 = (word)*_track_the_time_when_throttle_is_less_than_a_threshold_0_30;
          tpuTimerChannelEnable();
          tpu_transmission_state =
               *_track_the_time_when_throttle_is_less_than_a_threshold_0_30 + tpu_transmission_state
          ;
          tpu_transmission_byte_counter = tpu_transmission_byte_counter + 1;
          if (tpu_transmission_byte_counter == *_can_transmit_length) {
            _tpu_transmission_state_machine = 2;
          }
          else {
            _tpu_transmission_state_machine = 1;
          }
        }
        else if (tpu_transmission_active_flag == 0) {
          tpu_channel_state_value = 1;
          tpu_transmission_state = bVar2;
          *_dummy_variable_0_65535 = bVar2;
          _dummy_variable_0_65535 =
               (byte *)CONCAT31(_dummy_variable_0_65535,flag_indicating_eps_sensor_not_used_0_1 + 1)
          ;
          *_can_tx_message_type = *_can_tx_message_type + 1;
          if (_dummy_variable_0_65535 == _enables_input_of_eps_period_data_to_pptb_0_1) {
            tpu_transmission_active_flag = 1;
            tpu_cier = tpu_cier & 0xffdf;
          }
          else {
            tpuTimerChannelEnable();
          }
        }
        else {
          tpu_channel_state_value = 1;
          tpu_transmission_state = 0;
          tpuTimerChannelEnable();
        }
        break;
      case 1:
        _track_the_time_when_throttle_is_less_than_a_threshold_0_30 =
             (byte *)CONCAT31(_track_the_time_when_throttle_is_less_than_a_threshold_0_30,
                              (char)
                              flag_shows_posibility_of_esp_transitioning_between_normal_false_true +
                              '\x01');
        tpu_cfsr1 = (word)*_track_the_time_when_throttle_is_less_than_a_threshold_0_30;
        tpuTimerChannelEnable();
        tpu_transmission_state =
             *_track_the_time_when_throttle_is_less_than_a_threshold_0_30 + tpu_transmission_state;
        tpu_transmission_byte_counter = tpu_transmission_byte_counter + 1;
        if (tpu_transmission_byte_counter == *_can_transmit_length) {
          _tpu_transmission_state_machine = 2;
        }
        break;
      case 2:
        tpu_cfsr1 = ~(ushort)tpu_transmission_state + 1 & 0xff;
        tpuTimerChannelEnable();
        _track_the_time_when_throttle_is_less_than_a_threshold_0_30 =
             (byte *)CONCAT31(_track_the_time_when_throttle_is_less_than_a_threshold_0_30,
                              (char)
                              flag_shows_posibility_of_esp_transitioning_between_normal_false_true +
                              '\x01');
        _tpu_transmission_state_machine = 3;
        break;
      case 3:
        _can_transmit_length = _track_the_time_when_throttle_is_less_than_a_threshold_0_30;
        _track_the_time_when_throttle_is_less_than_a_threshold_0_30 =
             (byte *)CONCAT31(_track_the_time_when_throttle_is_less_than_a_threshold_0_30,
                              (char)
                              flag_shows_posibility_of_esp_transitioning_between_normal_false_true +
                              '\x01');
        tpu_transmission_state = 0;
        ci_tooth_count_error_incremented_when_ci_pulse_width_is_wrong_0_255 = 0;
        if (((((io_fault_status_reg_4 & 4) != 0) && ((fault_mask_flags_1 & 4) != 0)) &&
            ((io_fault_status_reg_4 & 4) != 0)) && ((io_fault_latch_reg_4 & 4) == 0)) {
          io_fault_status_reg_4 = io_fault_status_reg_4 & 0xfffb;
        }
        tpu_channel_state_value = 1;
        if (tpu_transmission_active_flag == 0) {
          tpu_cier = tpu_cier | 0x20;
        }
        else {
          tpu_cier = tpu_cier & 0xffdf;
        }
        if ((byte *)can_transmit_buffer_ptr != pbVar1) {
          tpu_channel_enable_state = 1;
          tpu_channel_priority_select = tpu_channel_priority_select | 0x4000;
          tpu_channel_int_select = 0xfcbe;
        }
      }
    }
  }
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: tpuChannelIsrRegister @ 0x0001958c
 */

void tpuChannelIsrRegister(void)

{
  system_callback_table_t_00808f02.engine_position_sensor_isr = (dword)epsPositionSensorIsrHandler;
  return;
}



/*
 * Function: serialTransmitHandler @ 0x00019598
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint serialTransmitHandler(void)

{
  undefined2 uVar1;
  uint uVar2;
  
  _serial_transmit_ready_flag = 1;
  *(undefined1 *)serial_node_transmit_ptr = 0xfd;
  uVar2 = can_transmit_buffer_ptr_2;
  if ((can_transmit_buffer_ptr_2 == can_transmit_buffer_ptr_1) &&
     (can_single_frame_transmit_flag != 1)) {
    *(undefined1 *)serial_node_transmit_ptr = 0x7f;
  }
  else {
    canFrameDataCopy(&serial_port_1_base_register);
    can_single_frame_transmit_flag = 0;
    uVar2 = can_transmit_buffer_ptr_1 + 0xe;
    can_transmit_buffer_ptr_1 = uVar2;
    if (0x80cf6a < uVar2) {
      can_transmit_buffer_ptr_1 = 0x80ce60;
    }
  }
  uVar1 = (undefined2)(uVar2 >> 0x10);
  uVar2 = CONCAT22(uVar1,io_fault_status_reg_2) & 0xffff0200;
  if ((((io_fault_status_reg_2 & 0x200) != 0) &&
      (uVar2 = CONCAT22(uVar1,_engine_mode_output_control_state_68ce) & 0xffff0200,
      (_engine_mode_output_control_state_68ce & 0x200) != 0)) &&
     (uVar2 = CONCAT22(uVar1,io_fault_status_reg_2) & 0xffff0200,
     (io_fault_status_reg_2 & 0x200) != 0)) {
    uVar2 = CONCAT22(uVar1,io_fault_latch_reg_2) & 0xffff0200;
    if ((io_fault_latch_reg_2 & 0x200) == 0) {
      io_fault_status_reg_2 = io_fault_status_reg_2 & 0xfdff;
    }
  }
  return uVar2;
}



/*
 * Function: serialReceiveBufferProcessor @ 0x0001965a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void serialReceiveBufferProcessor(uint param_1)

{
  int iVar1;
  ushort uVar2;
  word wVar3;
  undefined1 *puVar4;
  byte *pbVar5;
  undefined1 *puVar6;
  
  if (serial_receive_timer == 0) {
    iVar1 = (param_1 >> 0x10 & 0xff) * 0x10;
    do {
      *(undefined1 *)((int)&serial_port_1_base_register + iVar1 + 1) = 0xfd;
      *_serial_receive_buffer_state = *(uint *)((int)&serial_port_1_base_register + iVar1 + 2) >> 3;
      *(short *)(_serial_receive_buffer_state + 1) =
           (short)((int)((&sim_tpu_control_0)[iVar1] & 0xf0) >> 4);
      *(uint *)((int)_serial_receive_buffer_state + 6) = (int)_serial_receive_buffer_state + 10;
      uVar2 = 0;
      puVar4 = (undefined1 *)(iVar1 + 0xffd807);
      puVar6 = (undefined1 *)((int)_serial_receive_buffer_state + 10);
      do {
        *puVar6 = *puVar4;
        uVar2 = uVar2 + 1;
        puVar4 = puVar4 + 1;
        puVar6 = puVar6 + 1;
      } while (uVar2 < 8);
    } while ((*(byte *)((int)&serial_port_1_base_register + iVar1 + 1) & 2) != 0);
    _serial_receive_buffer_state = (dword *)((int)_serial_receive_buffer_state + 0x12);
    if ((dword *)0x80ce4e < _serial_receive_buffer_state) {
      _serial_receive_buffer_state =
           &average_pulse_period_time_period_over_1_cyl_of_primary_s_1000_65535;
    }
    if (_serial_receive_buffer_state == _timer_task_scheduler_state) {
      serial_receive_timer = 1;
      pbVar5 = &can_controller_config_register + (uint)serial_node_address_state * 0x10;
      wVar3 = serial_node_address_state;
      while (wVar3 = wVar3 + 1, wVar3 <= serial_node_address_limit) {
        *pbVar5 = 0xf7;
        *pbVar5 = 0xfd;
        pbVar5 = pbVar5 + 0x10;
      }
    }
  }
  return;
}



/*
 * Function: interruptCounter1Increment @ 0x00019738
 */

undefined8 interruptCounter1Increment(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  general_counter_0 = general_counter_0 + 1;
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: interruptCounter2Increment @ 0x0001976e
 */

undefined8 interruptCounter2Increment(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  general_counter_1 = general_counter_1 + 1;
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: initVectorTable @ 0x0001977e
 */

void initVectorTable(void)

{
  dword *pdVar1;
  
  for (pdVar1 = &vector_table_init_address; pdVar1 < (dword *)0x8091c2; pdVar1 = pdVar1 + 1) {
    *pdVar1 = (dword)interruptCounter2Increment;
  }
  return;
}



/*
 * Function: bitPatternToIndexConverter @ 0x000197c8
 */

undefined1 bitPatternToIndexConverter(void)

{
  ushort uVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte *pbVar5;
  
  pbVar5 = (byte *)diagnostic_buffer_write_pointer;
  if (bit_pattern_index_counter == 0) {
    for (; *pbVar5 == 0; pbVar5 = pbVar5 + 1) {
      bit_pattern_input_value = bit_pattern_input_value + 8;
    }
    bVar2 = 0x80;
    bVar3 = 0;
    bVar4 = bit_pattern_input_value;
    diagnostic_buffer_write_pointer = (dword)pbVar5;
    do {
      if ((bVar2 & *pbVar5) != 0) {
        uVar1 = (ushort)bit_pattern_index_counter;
        bit_pattern_index_counter = bit_pattern_index_counter + 1;
        *(byte *)((short)uVar1 + 0x80061c) = bVar4;
      }
      bVar2 = bVar2 >> 1;
      bVar4 = bVar4 - 1;
      bVar3 = bVar3 + 1;
    } while (bVar3 < 8);
    diagnostic_buffer_write_pointer = diagnostic_buffer_write_pointer + 1;
    bit_pattern_input_value = bit_pattern_input_value + 8;
  }
  bit_pattern_index_counter = bit_pattern_index_counter - 1;
  return *(undefined1 *)((short)(ushort)bit_pattern_index_counter + 0x80061c);
}



/*
 * Function: insiteMultiFrameResponseBuilder @ 0x0001984e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint insiteMultiFrameResponseBuilder(undefined4 param_1)

{
  char cVar1;
  uint uVar2;
  char cVar3;
  
  cVar1 = insite_response_buffer_length - 2;
  multi_packet_sequence_counter = (byte)((uint)param_1 >> 0x10);
  insite_multi_frame_state = 0;
  bit_pattern_index_result = (byte)param_1;
  cVar3 = multi_packet_sequence_counter + 6;
  for (insite_multiframe_response_index = cVar1 - multi_packet_sequence_counter;
      bit_pattern_index_result < insite_multiframe_response_index;
      insite_multiframe_response_index = insite_multiframe_response_index - bit_pattern_index_result
      ) {
    insite_multi_frame_state = insite_multi_frame_state + 1;
    cVar3 = bit_pattern_index_result + 5 + cVar3;
  }
  insite_multi_frame_state = insite_multi_frame_state + 1;
  multi_packet_tx_state = 0;
  insite_response_buffer_index = multi_packet_sequence_counter + 6;
  if ((int)can_transmit_buffer_ptr < _can_transmit_length) {
    uVar2 = (_can_transmit_length - can_transmit_buffer_ptr) - 2;
  }
  else {
    uVar2 = (_can_transmit_length - can_transmit_buffer_ptr) + 0xfe;
  }
  if ((int)(uint)(byte)(insite_multiframe_response_index + 5 + cVar3) < (int)uVar2) {
    *_insite_response_buffer_ptr = 0xc0;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = multi_packet_sequence_counter + 3;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = insite_command_byte;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = insite_multi_frame_state << 4;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = cVar1;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    return uVar2 & 0xffffff00;
  }
  io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
  io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
  return 1;
}



/*
 * Function: insiteMultiFrameContinuation @ 0x00019952
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteMultiFrameContinuation(void)

{
  *(byte *)insite_response_continuation_ptr = insite_response_buffer_index;
  *_insite_response_buffer_ptr = 0;
  can_transmit_buffer_ptr = (dword)_insite_response_buffer_ptr;
  insite_response_continuation_ptr = (dword)_insite_response_buffer_ptr;
  tpuTransmissionTrigger();
  multi_packet_tx_state = multi_packet_tx_state + 1;
  if (multi_packet_tx_state < insite_multi_frame_state) {
    multi_packet_sequence_counter = bit_pattern_index_result;
  }
  else {
    multi_packet_sequence_counter = insite_multiframe_response_index;
  }
  _insite_response_buffer_ptr =
       (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
  *_insite_response_buffer_ptr = 0x80;
  _insite_response_buffer_ptr =
       (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
  insite_response_buffer_index = multi_packet_sequence_counter + 5;
  *_insite_response_buffer_ptr = 0xc0;
  _insite_response_buffer_ptr =
       (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
  *_insite_response_buffer_ptr = multi_packet_sequence_counter + 2;
  _insite_response_buffer_ptr =
       (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
  *_insite_response_buffer_ptr = insite_command_byte;
  _insite_response_buffer_ptr =
       (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
  *_insite_response_buffer_ptr = multi_packet_tx_state & 0xf | insite_multi_frame_state << 4;
  _insite_response_buffer_ptr =
       (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
  return;
}



/*
 * Function: insiteLiveDataHandler @ 0x00019a0a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteLiveDataHandler(void)

{
  byte bVar1;
  char cVar2;
  short sVar3;
  char cVar5;
  undefined2 uVar4;
  undefined4 unaff_D2;
  byte bVar6;
  byte bVar7;
  word *pwVar8;
  undefined2 uVar9;
  
  uVar9 = (undefined2)((uint)unaff_D2 >> 0x10);
  _insite_data_read_ptr = _enables_input_of_eps_period_data_to_pptb_0_1;
  insite_response_continuation_ptr = can_transmit_buffer_ptr;
  _insite_response_buffer_ptr = can_transmit_buffer_ptr;
  insite_data_valid_flag = 1;
  bVar1 = *_enables_input_of_eps_period_data_to_pptb_0_1;
  if (bVar1 < 0x15) {
    insite_data_buffer_offset = (byte)_enables_input_of_eps_period_data_to_pptb_0_1;
    bVar7 = insite_data_buffer_offset;
    _insite_data_read_ptr = (undefined3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8);
    _insite_data_read_ptr = (byte *)CONCAT31(_insite_data_read_ptr,insite_data_buffer_offset + 1);
    cVar2 = *_insite_data_read_ptr;
    _insite_data_read_ptr = (byte *)CONCAT31(_insite_data_read_ptr,bVar7 + 2);
    bVar7 = 1;
    insite_response_buffer_index = 0;
    responseBufferSpaceCheck();
    if (insite_bytes_remaining != 0) {
LAB_00019c2a:
      if (bVar7 < bVar1) {
        insite_command_byte = *_insite_data_read_ptr;
        _insite_data_read_ptr =
             (byte *)CONCAT31(_insite_data_read_ptr,insite_data_buffer_offset + 1);
        cVar5 = insiteParameterParser();
        if (cVar5 == '\0') goto LAB_00019c30;
        bVar7 = cVar5 + bVar7;
        bVar6 = insite_data_buffer_offset;
        if (insite_command_byte == 0) {
          insite_command_byte = *_insite_data_read_ptr;
          _insite_data_read_ptr =
               (byte *)CONCAT31(_insite_data_read_ptr,insite_data_buffer_offset + 1);
          uVar4 = parameterLookupForInsite();
          insite_response_buffer_length = (byte)uVar4;
          bVar6 = '\x01' << (insite_command_byte & 7);
          sVar3 = (short)((int)(uint)insite_command_byte >> 3);
          if (((bVar6 & *(byte *)((int)&
                                       maximum_time_between_tailshaft_pulses_allowed_before_vehicle_0_04_40
                                 + (int)sVar3)) != 0) &&
             ((bVar6 & *(byte *)(sVar3 + 0x8055fe)) == 0)) {
            insiteParameterResponseBuilder();
          }
        }
        else if (insite_command_byte == 0x80) {
          insite_command_byte = *_insite_data_read_ptr;
          _insite_data_read_ptr =
               (byte *)CONCAT31(_insite_data_read_ptr,insite_data_buffer_offset + 1);
          cVar5 = *_insite_data_read_ptr;
          _insite_data_read_ptr = (byte *)CONCAT31(_insite_data_read_ptr,bVar6 + 2);
          if (cVar5 == -0x80) {
            uVar4 = parameterLookupForInsite();
            insite_response_buffer_length = (byte)uVar4;
            bVar6 = '\x01' << (insite_command_byte & 7);
            sVar3 = (short)((int)(uint)insite_command_byte >> 3);
            if (((bVar6 & *(byte *)((int)&
                                         maximum_time_between_tailshaft_pulses_allowed_before_vehicle_0_04_40
                                   + (int)sVar3)) != 0) &&
               ((bVar6 & *(byte *)(sVar3 + 0x8055fe)) == 0)) {
              insiteParameterResponseBuilder();
            }
          }
        }
        else if (insite_command_byte == 0xc3) {
          _insite_data_read_ptr =
               (byte *)CONCAT31(_insite_data_read_ptr,insite_data_buffer_offset + 1);
          cVar5 = *_insite_data_read_ptr;
          _insite_data_read_ptr = (byte *)CONCAT31(_insite_data_read_ptr,bVar6 + 2);
          insite_dtc_pid_byte = *_insite_data_read_ptr;
          _insite_data_read_ptr = (byte *)CONCAT31(_insite_data_read_ptr,bVar6 + 3);
          insite_live_data_parameter_index = *_insite_data_read_ptr;
          _insite_data_read_ptr = (byte *)CONCAT31(_insite_data_read_ptr,bVar6 + 4);
          if ((cVar5 == -0x80) && ((insite_live_data_parameter_index & 0xc0) < 0xc0)) {
            bVar6 = 0;
            pwVar8 = &insite_live_data_offset;
            while( true ) {
              if ((*(char *)pwVar8 == '\0') || (9 < bVar6)) goto LAB_00019c2a;
              if (cVar2 == *(char *)pwVar8) break;
              bVar6 = bVar6 + 1;
              pwVar8 = (word *)((int)pwVar8 + 1);
            }
            insite_pid_dtc_handler_state = (word)insite_live_data_parameter_index;
            if (((insite_live_data_parameter_index & 0xc0) == 0x80) ||
               ((insite_live_data_parameter_index & 0xc0) == 0x40)) {
              fault_flag_scanner_state = 2;
              diagnostic_code_clear_handler_state = (word)insite_dtc_pid_byte;
            }
            else {
              insitePidDtcHandler((uint)CONCAT12(insite_dtc_pid_byte,uVar9));
            }
            insite_command_byte = 0xc4;
            uVar4 = parameterLookupForInsite();
            insite_response_buffer_length = (byte)uVar4;
            insiteParameterResponseBuilder();
          }
        }
        else {
          _insite_data_read_ptr =
               (byte *)CONCAT31(_insite_data_read_ptr,cVar5 + -1 + insite_data_buffer_offset);
        }
        goto LAB_00019c2a;
      }
LAB_00019c30:
      responseBufferFinalize();
    }
  }
  return;
}



/*
 * Function: responseBufferSpaceCheck @ 0x00019c3c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void responseBufferSpaceCheck(void)

{
  byte bVar1;
  
  bVar1 = (crank_tooth_count_error_incremented_when_eps_tooth_count_wro_0_65535 -
          (char)can_transmit_buffer_ptr) - 2;
  if (bVar1 < 5) {
    insite_bytes_remaining = 0;
    io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
    return;
  }
  if (0x15 < bVar1) {
    insite_bytes_remaining = 0x13;
    return;
  }
  insite_bytes_remaining =
       (crank_tooth_count_error_incremented_when_eps_tooth_count_wro_0_65535 -
       (char)can_transmit_buffer_ptr) - 4;
  return;
}



/*
 * Function: responseBufferFinalize @ 0x00019cbc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void responseBufferFinalize(void)

{
  if (1 < insite_response_buffer_index) {
    *(byte *)insite_response_continuation_ptr = insite_response_buffer_index;
    *_insite_response_buffer_ptr = 0;
    can_transmit_buffer_ptr = (dword)_insite_response_buffer_ptr;
    tpuTransmissionTrigger();
  }
  return;
}



/*
 * Function: diagnosticMemoryWriteHandler @ 0x00019cf0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticMemoryWriteHandler(undefined4 param_1)

{
  char cVar3;
  undefined4 uVar1;
  uint uVar2;
  undefined4 unaff_D2;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  char cVar8;
  byte *pbVar9;
  byte *pbVar10;
  bool bVar11;
  undefined2 uVar12;
  byte bStack_f;
  uint local_e;
  byte local_9;
  undefined4 local_8;
  
  uVar12 = (undefined2)((uint)unaff_D2 >> 0x10);
  local_9 = *_enables_input_of_eps_period_data_to_pptb_0_1;
  local_8._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
  cVar8 = (char)local_8;
  local_8._0_3_ = (undefined3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8);
  local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x02');
  bVar6 = *local_8 & 0xf;
  bVar11 = bVar6 == 0;
  if (bVar11) {
    bVar5 = 4;
  }
  else {
    bVar5 = 2;
  }
  local_8 = (byte *)CONCAT31(local_8._0_3_,cVar8 + '\x03');
  cVar8 = '\0';
  pbVar9 = &CMSYRSFG;
  bVar7 = (byte)((uint)param_1 >> 0x10);
  do {
    if (local_9 <= bVar5) {
      if (bVar5 == local_9) {
        uVar2 = diagnosticResponseBuilder((uint)CONCAT12(cVar8,uVar12));
        if ((char)uVar2 != -1) {
          diagnosticMessageQueueWrite((uint)CONCAT12((char)uVar2,uVar12));
        }
      }
      else {
        diagnosticMessageQueueWrite(CONCAT22(2,uVar12));
      }
      return;
    }
    pbVar10 = &bStack_f + bVar7;
    for (bVar4 = 0; bVar4 < bVar7; bVar4 = bVar4 + 1) {
      *pbVar10 = *local_8;
      local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
      pbVar10 = pbVar10 + -1;
    }
    if (bVar11) {
      bVar6 = *local_8;
      local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
      bVar5 = bVar5 + 1;
    }
    bVar5 = bVar6 + bVar7 + bVar5;
    cVar8 = cVar8 + '\x01';
    if (bVar7 == 2) {
      pointer_to_intake_man_temp_rpm_fault_log_data_0_2_32._2_1_ = 2;
      if (local_e._0_2_ == 0x15) {
        memory_patch_pending_flag = 1;
      }
      cVar3 = diagnosticMemoryAddressResolver((short)((uint)&local_e >> 0x10));
      if (cVar3 != '\0') {
        diagnosticMessageQueueWrite(CONCAT22(8,uVar12));
        return;
      }
    }
    else {
      pointer_to_intake_man_temp_rpm_fault_log_data_0_2_32._2_1_ = 4;
    }
    uVar1 = addressRangeValidator(local_e,(uint)CONCAT12(bVar6,uVar12));
    bVar4 = (byte)uVar1;
    if ((bVar4 == 10) || (bVar4 == 4)) {
      diagnosticMessageQueueWrite(CONCAT22(10,uVar12));
      return;
    }
    if (bVar4 == 9) {
      diagnosticMessageQueueWrite(CONCAT22(9,uVar12));
      return;
    }
    *(uint *)pbVar9 = local_e;
    *(byte **)((int)pbVar9 + 4) = local_8;
    *(byte *)((int)pbVar9 + 8) = bVar6;
    *(byte *)((int)pbVar9 + 9) = bVar4;
    pbVar9 = (byte *)((int)pbVar9 + 10);
    local_8 = (byte *)CONCAT31(local_8._0_3_,bVar6 + (char)local_8);
  } while( true );
}



/*
 * Function: diagnosticMemoryReadHandler @ 0x00019e62
 */

/* WARNING: Removing unreachable block (ram,0x00019fea) */
/* WARNING: Removing unreachable block (ram,0x0001a010) */
/* WARNING: Removing unreachable block (ram,0x00019ff8) */
/* WARNING: Removing unreachable block (ram,0x0001a014) */
/* WARNING: Removing unreachable block (ram,0x0001a01c) */
/* WARNING: Removing unreachable block (ram,0x0001a032) */
/* WARNING: Removing unreachable block (ram,0x0001a038) */
/* WARNING: Removing unreachable block (ram,0x0001a03e) */
/* WARNING: Removing unreachable block (ram,0x0001a052) */
/* WARNING: Removing unreachable block (ram,0x0001a060) */
/* WARNING: Removing unreachable block (ram,0x0001a09a) */
/* WARNING: Removing unreachable block (ram,0x0001a0b4) */
/* WARNING: Removing unreachable block (ram,0x0001a0ba) */
/* WARNING: Removing unreachable block (ram,0x0001a0ca) */
/* WARNING: Removing unreachable block (ram,0x0001a0d4) */
/* WARNING: Removing unreachable block (ram,0x0001a0e6) */
/* WARNING: Removing unreachable block (ram,0x0001a102) */
/* WARNING: Removing unreachable block (ram,0x0001a0ee) */
/* WARNING: Removing unreachable block (ram,0x0001a066) */
/* WARNING: Removing unreachable block (ram,0x0001a08c) */
/* WARNING: Removing unreachable block (ram,0x0001a06c) */
/* WARNING: Removing unreachable block (ram,0x0001a076) */
/* WARNING: Removing unreachable block (ram,0x0001a08a) */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticMemoryReadHandler(undefined4 param_1)

{
  byte bVar1;
  bool bVar2;
  dword dVar3;
  int iVar4;
  undefined4 uVar5;
  undefined4 unaff_D2;
  uint uVar6;
  char cVar7;
  byte bVar8;
  byte bVar9;
  char cVar10;
  undefined4 unaff_D7;
  undefined1 *puVar11;
  undefined2 uVar12;
  undefined1 local_16;
  byte bStack_15;
  undefined4 local_c;
  undefined4 local_8;
  
  dVar3 = can_transmit_buffer_ptr;
  puVar11 = &stack0xffffffbc;
  uVar12 = (undefined2)((uint)unaff_D2 >> 0x10);
  cVar10 = (char)((uint)param_1 >> 0x10);
  if (cVar10 == '\x02') {
    bVar8 = 4;
  }
  else {
    bVar8 = 2;
  }
  bVar9 = *_enables_input_of_eps_period_data_to_pptb_0_1;
  local_8._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
  local_8._0_3_ = (undefined3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8);
  local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x02');
  bVar1 = *local_8 & 0xf;
  if (bVar1 == 0) {
    if ((int)(bVar9 - 4) % (int)(bVar8 + 1) != 0) {
      diagnosticMessageQueueWrite(CONCAT22(2,uVar12));
      return;
    }
    uVar6 = (int)(bVar9 - 4) / (int)(bVar8 + 1) & 0xff;
    bVar9 = 4;
    while (cVar7 = (char)uVar6, uVar6 = (uint)(byte)(cVar7 - 1), cVar7 != '\0') {
      local_8 = (byte *)CONCAT31(local_8._0_3_,bVar8 + 1 + (char)local_8);
      bVar9 = bVar8 + *local_8 + '\x01' + bVar9;
    }
    bVar2 = true;
  }
  else {
    if ((int)(bVar9 - 2) % (int)(uint)bVar8 != 0) {
      diagnosticMessageQueueWrite(CONCAT22(2,uVar12));
      return;
    }
    bVar9 = (bVar1 + bVar8) * (char)((int)(bVar9 - 2) / (int)(uint)bVar8) + 2;
    bVar2 = false;
  }
  if ((int)can_transmit_buffer_ptr < _can_transmit_length) {
    iVar4 = (_can_transmit_length - can_transmit_buffer_ptr) + -2;
  }
  else {
    iVar4 = (_can_transmit_length - can_transmit_buffer_ptr) + 0xfe;
  }
  if ((int)(uint)bVar9 < iVar4) {
    local_c._3_1_ = (char)can_transmit_buffer_ptr;
    cVar7 = (char)local_c;
    local_c._0_3_ = (undefined3)(can_transmit_buffer_ptr >> 8);
    local_c = (byte *)CONCAT31(local_c._0_3_,(char)local_c + '\x01');
    *local_c = 7;
    local_c = (byte *)CONCAT31(local_c._0_3_,cVar7 + '\x02');
    if (cVar10 == '\x02') {
      *local_c = bVar1 | 0x80;
    }
    else if (cVar10 == '\x01') {
      *local_c = bVar1 | 0xa0;
    }
    else {
      *local_c = bVar1 | 0x20;
    }
    local_c = (byte *)CONCAT31(local_c._0_3_,cVar7 + '\x03');
    if (bVar2) {
      puVar11 = &stack0xffffffb6;
      uVar5 = crc16Calculate(local_c,CONCAT22((short)CONCAT31((int3)((uint)unaff_D7 >> 8),bVar9 - 4)
                                              ,uVar12));
      bStack_15 = (byte)uVar5;
      *local_c = bStack_15;
      local_c = (byte *)CONCAT31(local_c._0_3_,cVar7 + '\x04');
      local_16 = (undefined1)((uint)uVar5 >> 8);
      *local_c = local_16;
      local_c = (byte *)CONCAT31(local_c._0_3_,cVar7 + '\x05');
    }
    *(byte *)dVar3 = bVar9;
    *local_c = 0;
    can_transmit_buffer_ptr = (dword)local_c;
    *(undefined4 *)(puVar11 + -4) = 0x1a160;
    tpuTransmissionTrigger();
  }
  else {
    diagnosticMessageQueueWrite(CONCAT22(4,uVar12));
    io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
  }
  return;
}



/*
 * Function: diagnosticMessage45Builder @ 0x0001a192
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticMessage45Builder(void)

{
  bool bVar1;
  char cVar2;
  int iVar3;
  byte bVar4;
  undefined4 local_8;
  
  fuelDemandPercentageCalculator();
  if ((arbitrated_fuel_limit != arbitrated_fuel_previous) ||
     (governor_rpm_error_value != governor_rpm_error_previous)) {
    fuel_demand_change_flag = 1;
    arbitrated_fuel_previous = arbitrated_fuel_limit;
    governor_rpm_error_previous = governor_rpm_error_value;
  }
  if ((int)can_transmit_buffer_ptr < _can_transmit_length) {
    iVar3 = (_can_transmit_length - can_transmit_buffer_ptr) + -2;
  }
  else {
    iVar3 = (_can_transmit_length - can_transmit_buffer_ptr) + 0xfe;
  }
  if (iVar3 < 7) {
    io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
    return;
  }
  local_8._3_1_ = (char)can_transmit_buffer_ptr;
  cVar2 = (char)local_8;
  local_8._0_3_ = (undefined3)(can_transmit_buffer_ptr >> 8);
  local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
  *local_8 = 0x45;
  local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x02');
  *local_8 = (char)(fuel_demand_percentage >> 8);
  local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x03');
  if (((engine_fault_register_a & 0x20) == 0) || ((engine_fault_register_b & 0x20) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    if (((engine_fault_register_a & 8) == 0) || ((engine_fault_register_b & 8) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (((engine_fault_register_a & 0x10) == 0) || ((engine_fault_register_b & 0x10) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        *local_8 = (char)(((uint)active_derate_value * 0xff) / 400);
        goto LAB_0001a2b8;
      }
    }
  }
  *local_8 = 0;
LAB_0001a2b8:
  local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x04');
  bVar4 = protection_system_enable_flag == 1;
  if (oil_pressure_protection_enabled == 1) {
    bVar4 = bVar4 | 2;
  }
  if (vp44_engine_state == 10) {
    bVar4 = bVar4 | 4;
  }
  if (((io_control_flags & 1) == 0) || ((output_control_status_byte & 1) == 0)) {
    bVar4 = bVar4 | 8;
  }
  if (proprietary_load_threshold < active_derate_value) {
    bVar4 = bVar4 | 0x10;
  }
  if (derate_threshold_exceeded == 0) {
    bVar4 = bVar4 | 0x20;
  }
  if (fuel_demand_change_flag == 1) {
    bVar4 = bVar4 | 0x40;
  }
  *local_8 = bVar4;
  local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x05');
  *local_8 = (char)((int)(uint)param_limit_value >> 7);
  local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x06');
  *local_8 = param_config_byte;
  local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\a');
  *(undefined1 *)can_transmit_buffer_ptr = 6;
  *local_8 = 0;
  can_transmit_buffer_ptr = (dword)local_8;
  tpuTransmissionTrigger();
  return;
}



/*
 * Function: diagnosticMessage46Builder @ 0x0001a398
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticMessage46Builder(void)

{
  short sVar1;
  dword dVar2;
  char cVar3;
  int iVar4;
  undefined1 local_e;
  undefined1 uStack_d;
  undefined4 local_8;
  
  dVar2 = can_transmit_buffer_ptr;
  if ((int)can_transmit_buffer_ptr < _can_transmit_length) {
    iVar4 = (_can_transmit_length - can_transmit_buffer_ptr) + -2;
  }
  else {
    iVar4 = (_can_transmit_length - can_transmit_buffer_ptr) + 0xfe;
  }
  if (iVar4 < 0x17) {
    io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
  }
  else {
    local_8._3_1_ = (char)can_transmit_buffer_ptr;
    cVar3 = (char)local_8;
    local_8._0_3_ = (undefined3)(can_transmit_buffer_ptr >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
    *local_8 = 0x46;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x02');
    sVar1 = governor_rpm_error_value * 2;
    uStack_d = (undefined1)sVar1;
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x03');
    local_e = (undefined1)((ushort)sVar1 >> 8);
    *local_8 = local_e;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x04');
    multiSpeedParameterInterpolation();
    *local_8 = (char)(speed_difference_interp_result_3 >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x05');
    sVar1 = the_minimum_speed_a_customer_may_program_to_correspond_with_s_1_5_15 * 2;
    uStack_d = (undefined1)sVar1;
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x06');
    local_e = (undefined1)((ushort)sVar1 >> 8);
    *local_8 = local_e;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\a');
    *local_8 = (char)(speed_difference_interp_result_4 >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\b');
    sVar1 = speed_lookup_parameter_value * 2;
    uStack_d = (undefined1)sVar1;
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\t');
    local_e = (undefined1)((ushort)sVar1 >> 8);
    *local_8 = local_e;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\n');
    *local_8 = (char)(manifold_temp_calculated >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\v');
    sVar1 = CRACSWAC * 2;
    uStack_d = (undefined1)sVar1;
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\f');
    local_e = (undefined1)((ushort)sVar1 >> 8);
    *local_8 = local_e;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\r');
    *local_8 = (char)(speed_difference_interp_result_1 >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x0e');
    sVar1 = CRCNDTRF * 2;
    uStack_d = (undefined1)sVar1;
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x0f');
    local_e = (undefined1)((ushort)sVar1 >> 8);
    *local_8 = local_e;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x10');
    *local_8 = (char)(speed_difference_interp_result_2 >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x11');
    sVar1 = the_maximum_speed_a_customer_may_program_to_correspond_with_10_10_25 * 2;
    uStack_d = (undefined1)sVar1;
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x12');
    local_e = (undefined1)((ushort)sVar1 >> 8);
    *local_8 = local_e;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x13');
    uStack_d = (undefined1)(the_deceleration_value_where_e_braking_will_be_removed_1_0_01 / 10);
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x14');
    sVar1 = arbitrator_fuel_value_buffer * 2;
    uStack_d = (undefined1)sVar1;
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x15');
    local_e = (undefined1)((ushort)sVar1 >> 8);
    *local_8 = local_e;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x16');
    uStack_d = (undefined1)((int)(uint)allowed_rate_of_torque_limit_change_0_2000 >> 7);
    *local_8 = uStack_d;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar3 + '\x17');
    *(undefined1 *)dVar2 = 0x16;
    *local_8 = 0;
    can_transmit_buffer_ptr = (dword)local_8;
    tpuTransmissionTrigger();
  }
  return;
}



/*
 * Function: fuelArbitratorControlService @ 0x0001a5b0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint fuelArbitratorControlService(void)

{
  char cVar1;
  undefined1 uVar2;
  byte bVar3;
  ushort uVar4;
  char cVar5;
  word wVar6;
  uint uVar7;
  undefined4 unaff_D2;
  word unaff_D3w;
  bool bVar8;
  undefined2 local_c;
  undefined2 local_a;
  undefined4 local_8;
  
  cVar1 = *_enables_input_of_eps_period_data_to_pptb_0_1;
  local_8._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
  cVar5 = (char)local_8;
  local_8._0_3_ = (undefined3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8);
  local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x02');
  uVar4 = *local_8 & 3;
  uVar7 = diagnosticMessageValidator
                    (0x4a,CONCAT12(*local_8,(short)((uint)unaff_D2 >> 0x10)) & 0x3ffff);
  if ((short)uVar7 != 0) {
    return uVar7;
  }
  if (3 < (uint)(int)(short)uVar4) goto LAB_0001a636;
  uVar7 = (uint)(&switchD_0001a604::switchdataD_0001a608)[(short)uVar4];
  switch(uVar4) {
  case 0:
    if (cVar1 != '\x03') {
      return uVar7;
    }
    goto LAB_0001a636;
  case 1:
    break;
  case 2:
    if (cVar1 != '\x04') {
      return uVar7;
    }
    goto LAB_0001a636;
  case 3:
  }
  if (cVar1 != '\x05') {
    return uVar7;
  }
LAB_0001a636:
  if (fuel_arbitrator_diag_t_0080cff8.rpm_target == 0) {
    uVar7 = diagnosticSessionValidator(0x4a);
    if ((short)uVar7 != 0) {
      return uVar7;
    }
    _timer_capture_value = _fuel_arbitrator_control_mode;
  }
  else if ((fuel_arbitrator_diag_t_0080cff8._28_2_ != 0) ||
          ((char)fuel_arbitrator_diag_t_0080cff8.limited_value != 'J')) {
    uVar7 = diagnosticSessionValidator(0x4a);
    if ((short)uVar7 != 0) {
      return uVar7;
    }
    if (_timer_capture_value < _fuel_arbitrator_control_mode) {
      return _fuel_arbitrator_control_mode;
    }
    _timer_capture_value = _fuel_arbitrator_control_mode;
  }
  fuel_arbitrator_diag_t_0080cff8.control_flags = (word)*local_8;
  fuel_arbitrator_diag_t_0080cff8._26_2_ = 0;
  fuel_arbitrator_diag_t_0080cff8._28_2_ = 0;
  fuel_arbitrator_diag_t_0080cff8.limited_value._1_1_ = 0x4a;
  wVar6 = unaff_D3w;
  switch(uVar4) {
  case 0:
    torque_control_mode_timer = 0;
    fuel_arbitrator_diag_t_0080cff8.rpm_target = 0;
    fuel_arbitrator_diag_t_0080cff8.fuel_mode = 0;
    fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
    wVar6 = fuel_arbitrator_increment + 1;
    break;
  case 1:
    diagnosticStateInitializer(0x4a);
    torque_control_mode_timer = *(short *)(_timer_capture_value + 4) + 1;
    fuel_arbitrator_diag_t_0080cff8.rpm_target = 1;
    fuel_arbitrator_diag_t_0080cff8.fuel_mode = 1;
    fuel_arbitrator_diag_t_0080cff8._20_2_ = 1;
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar5 + '\x03');
    uVar2 = *local_8;
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar5 + '\x04');
    local_a = CONCAT11(*local_8,uVar2);
    fuel_arbitrator_diag_t_0080cff8.state_pointer._1_2_ = (undefined2)((int)(uint)local_a >> 1);
    wVar6 = torque_control_mode_timer;
    break;
  case 2:
    diagnosticStateInitializer(0x4a);
    torque_control_mode_timer = *(short *)(_timer_capture_value + 8) + 1;
    fuel_arbitrator_diag_t_0080cff8.rpm_target = 2;
    fuel_arbitrator_diag_t_0080cff8.fuel_mode = 1;
    fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
    local_c = (ushort)(byte)local_c;
    fuel_arbitrator_diag_t_0080cff8._16_2_ = local_c << 8;
    fuel_arbitrator_diag_t_0080cff8._24_2_ =
         fuel_demand_percentage_current +
         (short)(((int)(short)(the_maximum_speed_a_customer_may_program_to_correspond_with_s_1_5_15
                              - boost_pressure_protection_state_bda0) *
                 (int)(short)fuel_arbitrator_diag_t_0080cff8._16_2_) / 0x6400);
    wVar6 = torque_control_mode_timer;
    if ((short)fuel_arbitrator_diag_t_0080cff8._24_2_ < 0) {
      fuel_arbitrator_diag_t_0080cff8._24_2_ = 0;
      wVar6 = torque_control_mode_timer;
    }
    break;
  case 3:
    diagnosticStateInitializer(0x4a);
    torque_control_mode_timer = *(short *)(_timer_capture_value + 0xc) + 1;
    fuel_arbitrator_diag_t_0080cff8.rpm_target = 3;
    fuel_arbitrator_diag_t_0080cff8.fuel_mode = 1;
    fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar5 + '\x03');
    local_a = (ushort)*local_8;
    fuel_arbitrator_diag_t_0080cff8.command_counter = local_a << 7;
    local_8 = (byte *)CONCAT31(local_8._0_3_,cVar5 + '\x04');
    bVar3 = *local_8;
    if (bVar3 < 0x80) {
      local_c = (ushort)bVar3;
    }
    else {
      local_c = CONCAT11(0xff,bVar3);
    }
    fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ =
         fuel_demand_percentage_current +
         (short)(((int)(short)(the_maximum_speed_a_customer_may_program_to_correspond_with_s_1_5_15
                              - boost_pressure_protection_state_bda0) * (short)local_c * 8) / 0x6400
                );
    wVar6 = torque_control_mode_timer;
    if (fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ < 0) {
      fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ = 0;
      wVar6 = torque_control_mode_timer;
    }
  }
  fuel_arbitrator_session_timer = wVar6;
  bVar8 = (fuel_arbitrator_diag_t_0080cff8.control_flags & 4) != 0;
  fuel_arbitrator_throttle_override = fuel_arbitrator_session_timer;
  if (bVar8) {
    fuel_arbitrator_throttle_override = 0;
  }
  fuel_arbitrator_diag_t_0080cff8.throttle_mode = (word)!bVar8;
  bVar8 = (fuel_arbitrator_diag_t_0080cff8.control_flags & 8) == 0;
  fuel_arbitrator_speed_timer = fuel_arbitrator_session_timer;
  if (bVar8) {
    fuel_arbitrator_speed_timer = 0;
  }
  fuel_arbitrator_diag_t_0080cff8.speed_limit = (word)!bVar8;
  bVar8 = (fuel_arbitrator_diag_t_0080cff8.control_flags & 0x10) == 0;
  if (bVar8) {
    fuel_arbitrator_diag_t_0080cff8._30_2_ = 0;
  }
  else {
    fuel_arbitrator_session_timer = 0;
  }
  fuel_arbitrator_diag_t_0080cff8.fuel_limit = (word)bVar8;
  return fuel_arbitrator_diag_t_0080cff8.control_flags & 0xffff0010;
}



/*
 * Function: extendedDiagnosticService4C @ 0x0001a910
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void extendedDiagnosticService4C(void)

{
  undefined4 local_8;
  
  if (*_enables_input_of_eps_period_data_to_pptb_0_1 == '\x02') {
    local_8._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
    local_8 = (byte *)CONCAT31((int3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8),
                               (char)local_8 + '\x02');
    if ((*local_8 & 1) != 0) {
      diagnosticMessage46Builder();
      fuel_demand_change_flag = 0;
    }
    if ((*local_8 & 8) != 0) {
      diagnosticMessage54Builder();
    }
    if ((*local_8 & 0x80) == 0) {
      fuel_arbitrator_diag_t_0080cff8.session_counter = 0;
      fuel_arbitrator_session_counter = 0;
    }
    else {
      fuel_arbitrator_diag_t_0080cff8.session_counter = 1;
      fuel_arbitrator_session_counter = fuel_arbitrator_session_init;
    }
  }
  return;
}



/*
 * Function: extendedDiagnosticService4F @ 0x0001a97e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint extendedDiagnosticService4F(void)

{
  char cVar1;
  byte bVar2;
  ushort uVar3;
  char cVar4;
  word wVar5;
  undefined2 extraout_D0u;
  uint uVar6;
  int iVar7;
  undefined4 unaff_D2;
  word unaff_D3w;
  undefined2 local_c;
  ushort local_a;
  undefined4 local_8;
  
  cVar1 = *_enables_input_of_eps_period_data_to_pptb_0_1;
  local_8._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
  cVar4 = (char)local_8;
  local_8._0_3_ = (undefined3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8);
  local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x02');
  uVar6 = *local_8 & 4;
  if ((*local_8 & 4) == 0) {
    uVar3 = *local_8 & 3;
    uVar6 = diagnosticMessageValidator
                      (0x4f,CONCAT12(*local_8,(short)((uint)unaff_D2 >> 0x10)) & 0x3ffff);
    if ((short)uVar6 == 0) {
      if ((uint)(int)(short)uVar3 < 4) {
        switch(uVar3) {
        case 0:
          if (cVar1 != '\x02') {
            return (uint)(&switchD_0001a9e2::switchdataD_0001a9e6)[(short)uVar3];
          }
          break;
        default:
          if (cVar1 != '\x03') {
            return (uint)(&switchD_0001a9e2::switchdataD_0001a9e6)[(short)uVar3];
          }
        }
      }
      if (fuel_arbitrator_diag_t_0080cff8.rpm_target == 0) {
        uVar6 = diagnosticSessionValidator(0x4f);
        if ((short)uVar6 != 0) {
          return uVar6;
        }
        _timer_capture_value = _fuel_arbitrator_control_mode;
      }
      else if ((fuel_arbitrator_diag_t_0080cff8._28_2_ != 0) ||
              ((char)fuel_arbitrator_diag_t_0080cff8.limited_value != 'O')) {
        uVar6 = diagnosticSessionValidator(0x4f);
        if ((short)uVar6 != 0) {
          return uVar6;
        }
        if (_timer_capture_value < _fuel_arbitrator_control_mode) {
          return _fuel_arbitrator_control_mode;
        }
        _timer_capture_value = _fuel_arbitrator_control_mode;
      }
      fuel_arbitrator_diag_t_0080cff8.control_flags = (word)*local_8;
      fuel_arbitrator_diag_t_0080cff8._26_2_ = 0;
      fuel_arbitrator_diag_t_0080cff8._28_2_ = 0;
      fuel_arbitrator_diag_t_0080cff8.limited_value._1_1_ = 'O';
      iVar7 = (int)(short)uVar3;
      wVar5 = unaff_D3w;
      switch((int)(short)uVar3) {
      case 0:
        torque_control_mode_timer = 0;
        fuel_arbitrator_diag_t_0080cff8.rpm_target = 0;
        fuel_arbitrator_diag_t_0080cff8.fuel_mode = 0;
        fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
        iVar7 = 0;
        wVar5 = fuel_arbitrator_increment + 1;
        break;
      case 1:
        diagnosticStateInitializer(0x4f);
        torque_control_mode_timer = *(short *)(_timer_capture_value + 4) + 1;
        fuel_arbitrator_diag_t_0080cff8.rpm_target = 1;
        fuel_arbitrator_diag_t_0080cff8.fuel_mode = 2;
        fuel_arbitrator_diag_t_0080cff8._20_2_ = 1;
        local_8 = (byte *)CONCAT31(local_8._0_3_,cVar4 + '\x03');
        local_a = (ushort)*local_8;
        fuel_arbitrator_diag_t_0080cff8.state_pointer._1_2_ = local_a << 7;
        iVar7 = CONCAT22(extraout_D0u,fuel_arbitrator_diag_t_0080cff8.state_pointer._1_2_);
        wVar5 = torque_control_mode_timer;
        break;
      case 2:
        diagnosticStateInitializer(0x4f);
        torque_control_mode_timer = *(short *)(_timer_capture_value + 8) + 1;
        fuel_arbitrator_diag_t_0080cff8.rpm_target = 2;
        fuel_arbitrator_diag_t_0080cff8.fuel_mode = 2;
        fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
        local_8 = (byte *)CONCAT31(local_8._0_3_,cVar4 + '\x03');
        local_c = (ushort)*local_8;
        fuel_arbitrator_diag_t_0080cff8._16_2_ = local_c << 8;
        iVar7 = ((int)(short)(the_maximum_speed_a_customer_may_program_to_correspond_with_s_1_5_15 -
                             boost_pressure_protection_state_bda0) *
                (int)(short)fuel_arbitrator_diag_t_0080cff8._16_2_) / 0x6400;
        fuel_arbitrator_diag_t_0080cff8._24_2_ = fuel_demand_percentage_current + (short)iVar7;
        iVar7 = CONCAT22((short)((uint)iVar7 >> 0x10),fuel_arbitrator_diag_t_0080cff8._24_2_);
        wVar5 = torque_control_mode_timer;
        if ((short)fuel_arbitrator_diag_t_0080cff8._24_2_ < 0) {
          fuel_arbitrator_diag_t_0080cff8._24_2_ = 0;
          wVar5 = torque_control_mode_timer;
        }
        break;
      case 3:
        diagnosticStateInitializer(0x4f);
        torque_control_mode_timer = *(short *)(_timer_capture_value + 0xc) + 1;
        fuel_arbitrator_diag_t_0080cff8.rpm_target = 3;
        fuel_arbitrator_diag_t_0080cff8.fuel_mode = 2;
        fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
        fuel_arbitrator_diag_t_0080cff8.command_counter = oil_pressure_precrank_status;
        local_8 = (byte *)CONCAT31(local_8._0_3_,cVar4 + '\x03');
        bVar2 = *local_8;
        if (bVar2 < 0x80) {
          local_c = (ushort)bVar2;
        }
        else {
          local_c = CONCAT11(0xff,bVar2);
        }
        iVar7 = ((int)(short)(the_maximum_speed_a_customer_may_program_to_correspond_with_s_1_5_15 -
                             boost_pressure_protection_state_bda0) * (short)local_c * 0x100) /
                0x6400;
        fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ =
             fuel_demand_percentage_current + (short)iVar7;
        iVar7 = CONCAT22((short)((uint)iVar7 >> 0x10),
                         fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_);
        wVar5 = torque_control_mode_timer;
        if (fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ < 0) {
          fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ = 0;
          wVar5 = torque_control_mode_timer;
        }
      }
      fuel_arbitrator_throttle_override = wVar5;
      uVar6 = CONCAT22((short)((uint)iVar7 >> 0x10),fuel_arbitrator_diag_t_0080cff8.control_flags) &
              0xffff0010;
      if ((fuel_arbitrator_diag_t_0080cff8.control_flags & 0x10) == 0) {
        fuel_arbitrator_diag_t_0080cff8.throttle_mode = 0;
        fuel_arbitrator_throttle_override = 0;
      }
      else {
        fuel_arbitrator_diag_t_0080cff8.throttle_mode = 1;
      }
    }
  }
  return uVar6;
}



/*
 * Function: extendedDiagnosticService51 @ 0x0001ac64
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void extendedDiagnosticService51(void)

{
  undefined4 local_8;
  
  if (*_enables_input_of_eps_period_data_to_pptb_0_1 == '\x02') {
    local_8._3_1_ = (char)_enables_input_of_eps_period_data_to_pptb_0_1;
    local_8 = (byte *)CONCAT31((int3)((uint)_enables_input_of_eps_period_data_to_pptb_0_1 >> 8),
                               (char)local_8 + '\x02');
    if ((*local_8 & 1) != 0) {
      diagnosticMessage46Builder();
      fuel_demand_change_flag = 0;
    }
    if ((*local_8 & 8) != 0) {
      diagnosticMessage54Builder();
    }
  }
  return;
}



/*
 * Function: diagnosticMessage53Builder @ 0x0001aca8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticMessage53Builder(void)

{
  char cVar1;
  int iVar2;
  undefined1 uVar3;
  undefined4 local_8;
  
  if ((int)can_transmit_buffer_ptr < _can_transmit_length) {
    iVar2 = (_can_transmit_length - can_transmit_buffer_ptr) + -2;
  }
  else {
    iVar2 = (_can_transmit_length - can_transmit_buffer_ptr) + 0xfe;
  }
  if (iVar2 < 3) {
    io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
  }
  else {
    local_8._3_1_ = (char)can_transmit_buffer_ptr;
    cVar1 = (char)local_8;
    local_8._0_3_ = (undefined3)(can_transmit_buffer_ptr >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
    *local_8 = 0x53;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar1 + '\x02');
    uVar3 = 0;
    if (vp44_injection_system_active == 1) {
      uVar3 = 2;
    }
    *local_8 = uVar3;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar1 + '\x03');
    *(undefined1 *)can_transmit_buffer_ptr = 2;
    *local_8 = 0;
    can_transmit_buffer_ptr = (dword)local_8;
    tpuTransmissionTrigger();
  }
  return;
}



/*
 * Function: diagnosticMessage54Builder @ 0x0001ad50
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticMessage54Builder(void)

{
  char cVar1;
  int iVar2;
  undefined4 local_8;
  
  if ((int)can_transmit_buffer_ptr < _can_transmit_length) {
    iVar2 = (_can_transmit_length - can_transmit_buffer_ptr) + -2;
  }
  else {
    iVar2 = (_can_transmit_length - can_transmit_buffer_ptr) + 0xfe;
  }
  if (iVar2 < 4) {
    io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
  }
  else {
    local_8._3_1_ = (char)can_transmit_buffer_ptr;
    cVar1 = (char)local_8;
    local_8._0_3_ = (undefined3)(can_transmit_buffer_ptr >> 8);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
    *local_8 = 0x54;
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar1 + '\x02');
    if (retarder_mode_threshold_value_37d4 == 3) {
      *local_8 = 4;
    }
    else {
      *local_8 = 2;
    }
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar1 + '\x03');
    *local_8 = (char)(((uint)vp44_fuel_temperature_raw * 0x2e1) / 10000);
    local_8 = (undefined1 *)CONCAT31(local_8._0_3_,cVar1 + '\x04');
    *(undefined1 *)can_transmit_buffer_ptr = 3;
    *local_8 = 0;
    can_transmit_buffer_ptr = (dword)local_8;
    tpuTransmissionTrigger();
  }
  return;
}



/*
 * Function: j1939TimeoutDataClearHandler @ 0x0001ae20
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint j1939TimeoutDataClearHandler(void)

{
  uint uVar1;
  
  uVar1 = diagnostic_system_flags_2 & 0x100;
  if (((diagnostic_system_flags_2 & 0x100) != 0) &&
     (uVar1 = _j1939_timeout_clear_value + _vp44_sensor_diag_counter, uVar1 < _loopCounter)) {
    j1939_message_type_total_counter = 0;
    _vp44_sensor_diag_counter = 0;
    rpm_histogram_bin_2_counter = 0;
    _loop_counter_snapshot_1 = 0;
    rpm_histogram_overflow_counter = 0;
    _loop_counter_snapshot_2 = 0;
    rpm_histogram_bin_1_counter = 0;
    _loop_counter_snapshot_0 = 0;
  }
  return uVar1;
}



/*
 * Function: j1939MessageTypeCounter @ 0x0001ae74
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint j1939MessageTypeCounter(undefined4 param_1)

{
  undefined4 in_D0;
  uint uVar1;
  
  uVar1 = CONCAT22((short)((uint)in_D0 >> 0x10),diagnostic_system_flags_2) & 0xffff0080;
  if ((diagnostic_system_flags_2 & 0x80) != 0) {
    if (param_1._0_2_ == 1) {
      j1939_message_type_total_counter = j1939_message_type_total_counter + 1;
      rpm_histogram_bin_2_counter = rpm_histogram_bin_2_counter + 1;
      _loop_counter_snapshot_1 = _loopCounter;
      _vp44_sensor_diag_counter = _loopCounter;
      return _loopCounter;
    }
    if (param_1._0_2_ == 2) {
      j1939_message_type_total_counter = j1939_message_type_total_counter + 1;
      rpm_histogram_overflow_counter = rpm_histogram_overflow_counter + 1;
      _loop_counter_snapshot_2 = _loopCounter;
      _vp44_sensor_diag_counter = _loopCounter;
      return _loopCounter;
    }
    if (param_1._0_2_ != 3) {
      return (int)param_1._0_2_;
    }
    j1939_message_type_total_counter = j1939_message_type_total_counter + 1;
    rpm_histogram_bin_1_counter = rpm_histogram_bin_1_counter + 1;
    _loop_counter_snapshot_0 = _loopCounter;
    _vp44_sensor_diag_counter = _loopCounter;
    uVar1 = _loopCounter;
  }
  return uVar1;
}



/*
 * Function: canMessageFilterInit @ 0x0001aef4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void canMessageFilterInit(void)

{
  byte bVar1;
  word *pwVar2;
  word *pwVar3;
  word *pwVar4;
  dword *pdVar5;
  
  bVar1 = 0;
  pwVar2 = (word *)((int)&mask_used_for_can_msg_object_15_0_ffffffff + 2);
  pwVar3 = &can_filter_mask_array_high;
  pwVar4 = &can_filter_mask_array_low;
  pdVar5 = &the_can_extended_mask_0x0_0xffffffff;
  do {
    *pwVar4 = *(word *)pdVar5;
    *pwVar3 = *pwVar2;
    bVar1 = bVar1 + 1;
    pwVar2 = pwVar2 + 1;
    pwVar3 = pwVar3 + 1;
    pwVar4 = pwVar4 + 1;
    pdVar5 = (dword *)((int)pdVar5 + 2);
  } while (bVar1 < 4);
  _j1939_multiframe_source_address = can_message_filter_init_value;
  _can_cpu_interface_address = the_can_cpu_interface_register_0_255;
  return;
}



/*
 * Function: timerSchedulerSetup @ 0x0001af38
 */
/* ERROR: Failed to decompile */
void timerSchedulerSetup(void) {
    /* Decompilation failed */
}


/*
 * Function: phase3_periodic_task_scheduler @ 0x0001afe4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort phase3_periodic_task_scheduler(void)

{
  ushort uVar1;
  byte bVar2;
  int iVar3;
  
  uVar1 = _diagnostic_service_enable_flags & 8;
  if (uVar1 != 0) {
    if ((diagnostic_command_state & 4) != 0) {
      iVar3 = 0x80063c;
      for (bVar2 = 0; bVar2 < timer_scheduler_phase3_count_1; bVar2 = bVar2 + 1) {
        if (*(word *)(iVar3 + 4) == throttle_histogram_bin_index_1) {
          *(short *)(iVar3 + 4) = *(short *)(iVar3 + 2) + *(short *)(iVar3 + 4);
          (**(code **)(iVar3 + 6))();
        }
        iVar3 = iVar3 + 10;
      }
      throttle_histogram_bin_index_1 = throttle_histogram_bin_index_1 + 1;
    }
    uVar1 = diagnostic_command_state & 8;
    if (uVar1 != 0) {
      iVar3 = 0x800704;
      for (bVar2 = 0; bVar2 < timer_scheduler_phase3_count_2; bVar2 = bVar2 + 1) {
        if (*(word *)(iVar3 + 4) == throttle_histogram_bin_index_2) {
          *(short *)(iVar3 + 4) = *(short *)(iVar3 + 2) + *(short *)(iVar3 + 4);
          (**(code **)(iVar3 + 6))();
        }
        uVar1 = 10;
        iVar3 = iVar3 + 10;
      }
      throttle_histogram_bin_index_2 = throttle_histogram_bin_index_2 + 1;
    }
  }
  return uVar1;
}



/*
 * Function: emptyPlaceholderInit @ 0x0001b07c
 */

void emptyPlaceholderInit(void)

{
  return;
}



/*
 * Function: j1939TorqueControlModeParser @ 0x0001b082
 */

uint j1939TorqueControlModeParser(int param_1,undefined4 param_2)

{
  byte bVar1;
  char cVar2;
  undefined2 uVar3;
  undefined4 in_D0;
  ushort uVar4;
  
  uVar3 = (undefined2)((uint)in_D0 >> 0x10);
  bVar1 = *(byte *)(*(int *)(param_1 + 6) + 1);
  cVar2 = *(char *)(*(int *)(param_1 + 6) + 2);
  if ((bVar1 == 0xfe) && (cVar2 == -2)) {
    uVar4 = 0xffff;
  }
  else if (cVar2 == '\x01') {
    uVar3 = (undefined2)(bVar1 - 1 >> 0x10);
    switch(bVar1 - 1) {
    case 0:
      uVar4 = 0xc;
      break;
    case 1:
      uVar4 = 0x80;
      break;
    default:
      return 4;
    case 5:
      uVar4 = 1;
      break;
    case 6:
      uVar4 = 2;
    }
  }
  else {
    if (cVar2 != -3) {
      return 4;
    }
    uVar3 = 0;
    if (bVar1 == 0xfe) {
      uVar4 = 0x8c;
    }
    else if (bVar1 == 1) {
      uVar4 = 0xc;
    }
    else {
      if (bVar1 != 2) {
        return 4;
      }
      uVar4 = 0x80;
    }
  }
  if (param_2._1_1_ == '\x01') {
    diagnostic_command_state = uVar4 | diagnostic_command_state;
  }
  else {
    uVar4 = ~uVar4;
    diagnostic_command_state = uVar4 & diagnostic_command_state;
  }
  return CONCAT22(uVar3,uVar4) & 0xffffff00;
}



/*
 * Function: j1939TorqueControlModeClear @ 0x0001b150
 */

void j1939TorqueControlModeClear(int param_1)

{
  ushort in_stack_00000000;
  
  j1939TorqueControlModeParser(param_1,(uint)in_stack_00000000);
  return;
}



/*
 * Function: j1939TorqueControlModeSet @ 0x0001b160
 */

void j1939TorqueControlModeSet(int param_1)

{
  undefined2 in_stack_00000000;
  
  j1939TorqueControlModeParser(param_1,CONCAT22(1,in_stack_00000000));
  return;
}



/*
 * Function: systemFunction4xParameterizedAlt @ 0x0001b172
 */

void systemFunction4xParameterizedAlt(void)

{
  undefined2 uVar1;
  undefined2 uVar2;
  undefined2 uVar3;
  
  uVar3 = 0xb07e;
  coreSystemFunction(1);
  uVar2 = 0xb07e;
  uVar1 = 0x10;
  coreSystemFunction(1,uVar3);
  coreSystemFunction(1,uVar1,uVar2);
  coreSystemFunction();
  return;
}



/*
 * Function: coreSystemControlFunction @ 0x0001b1b4
 */
/* ERROR: Failed to decompile */
void coreSystemControlFunction(void) {
    /* Decompilation failed */
}


/*
 * Function: timerBasedTaskScheduler @ 0x0001b1f4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint timerBasedTaskScheduler(void)

{
  char cVar1;
  bool bVar2;
  ushort uVar3;
  undefined4 in_D0;
  byte bVar4;
  dword *pdVar5;
  byte *pbVar6;
  undefined2 local_6;
  
  uVar3 = hardware_timer_register._0_2_;
  pdVar5 = (dword *)(CONCAT22((short)((uint)in_D0 >> 0x10),_diagnostic_service_enable_flags) &
                    0xffff0008);
  if ((_diagnostic_service_enable_flags & 8) != 0) {
    while ((pdVar5 = (dword *)((uint)hardware_timer_register._0_2_ - (uint)uVar3),
           (int)((uint)hardware_timer_register._0_2_ - (uint)uVar3) < 0xfa &&
           ((_serial_receive_buffer_state != _timer_task_scheduler_state ||
            (pdVar5 = _serial_receive_buffer_state, serial_receive_timer == 1))))) {
      bVar4 = *(byte *)((int)_timer_task_scheduler_state + 1);
      if (bVar4 < 0xf0) {
        local_6 = (ushort)bVar4 << 8;
      }
      else {
        local_6 = CONCAT11(bVar4,*(undefined1 *)((int)_timer_task_scheduler_state + 2));
      }
      bVar2 = false;
      pdVar5 = &can_transmission_scheduler_data;
      do {
        if (*(char *)pdVar5 == -2) goto LAB_0001b262;
        cVar1 = *(char *)pdVar5;
        pdVar5 = (dword *)((int)pdVar5 + 1);
      } while ((char)*_timer_task_scheduler_state != cVar1);
      bVar2 = true;
LAB_0001b262:
      if (!bVar2) {
        pdVar5 = &task_scheduler_dispatch_table_ptr;
        for (bVar4 = 0; bVar4 < task_scheduler_dispatch_count; bVar4 = bVar4 + 1) {
          if (*(short *)pdVar5 == local_6) {
            (**(code **)((int)pdVar5 + 2))(_timer_task_scheduler_state);
            break;
          }
          pdVar5 = (dword *)((int)pdVar5 + 6);
        }
      }
      _timer_task_scheduler_state = (dword *)((int)_timer_task_scheduler_state + 0x12);
      if ((dword *)0x80ce4e < _timer_task_scheduler_state) {
        _timer_task_scheduler_state =
             &average_pulse_period_time_period_over_1_cyl_of_primary_s_1000_65535;
      }
      if (serial_receive_timer == 1) {
        serial_receive_timer = 0;
        pbVar6 = &can_controller_config_register + (uint)serial_node_address_state * 0x10;
        bVar4 = (byte)serial_node_address_state;
        while (bVar4 = bVar4 + 1, bVar4 <= serial_node_address_limit) {
          *pbVar6 = 0xfb;
          pbVar6 = pbVar6 + 0x10;
        }
      }
    }
  }
  return (uint)pdVar5;
}



/*
 * Function: phase3_retarder_condition_monitor @ 0x0001b314
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort phase3_retarder_condition_monitor(void)

{
  ushort uVar1;
  
  uVar1 = diagnostic_system_flags_2 & 0x1000;
  if (((((diagnostic_system_flags_2 & 0x1000) != 0) && (fuel_arbitrator_state == 2)) &&
      (retarder_mode_can_source_priority == 1)) &&
     (((fuel_arbitrator_diag_t_0080cff8.rpm_target == 1 &&
       (fuel_arbitrator_diag_t_0080cff8.fuel_mode == 1)) &&
      (uVar1 = cached_parameter_value, cached_parameter_upper_limit <= cached_parameter_value)))) {
    _retarder_mode_threshold_result = 0;
    _retarder_mode_table_count = 3;
    fuel_arbitrator_diag_t_0080cff8.throttle_mode = 0;
    fuel_arbitrator_throttle_override = 0;
    _retarder_mode_override_flag = 0;
  }
  return uVar1;
}



/*
 * Function: memoryOperationDispatcher @ 0x0001b37a
 */

uint memoryOperationDispatcher(int param_1,undefined1 *param_2,uint param_3)

{
  undefined1 *puVar1;
  bool bVar2;
  undefined4 in_D0;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  char securityCheckResult3;
  char securityCheckResult;
  char securityCheckResult2;
  undefined4 unaff_D2;
  short sVar6;
  ushort uVar7;
  undefined2 uVar8;
  
  uVar8 = (undefined2)((uint)unaff_D2 >> 0x10);
  if (0x6e4 < param_3) {
    return 2;
  }
  sVar6 = (short)param_3;
  uVar3 = addressLookupFunction
                    (CONCAT22((short)CONCAT31((int3)((uint)in_D0 >> 8),
                                              **(undefined1 **)(param_1 + 6)),uVar8));
  uVar7 = sVar6 + ((ushort)uVar3 & 0xff);
  if (uVar7 < 8) {
    uVar7 = 8;
  }
  if (uVar7 == *(ushort *)(param_1 + 4)) {
    bVar2 = false;
  }
  else {
    if (uVar7 + 10 != (uint)*(ushort *)(param_1 + 4)) {
      return 2;
    }
    bVar2 = true;
  }
  puVar1 = (undefined1 *)(*(int *)(param_1 + 6) + (uVar3 & 0xff));
  uVar4 = addressRangeValidator((uint)param_2,CONCAT22(sVar6,uVar8));
  uVar5 = uVar4 & 0xff;
  uVar3 = uVar5;
  if (uVar5 < 6) {
    uVar3 = (uint)(&switchD_0001b416::switchdataD_0001b41a)[uVar5];
    switch(uVar5) {
    case 0:
      uVar3 = memcpy(param_2,puVar1,CONCAT22(sVar6,uVar8));
      return uVar3 & 0xffffff00;
    case 3:
      if (security_bypass_flag != 0xff) {
        if (!bVar2) {
          return 3;
        }
        securityCheckResult3 = systemSecurityCheckStub_AlwaysPasses();
        if (securityCheckResult3 != '\0') {
          return 3;
        }
      }
      uVar3 = memcpy(param_2,puVar1,CONCAT22(sVar6,uVar8));
      return uVar3 & 0xffffff00;
    case 4:
      return 10;
    case 5:
      if ((system_logging_state == 1) &&
         (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 != 0)) {
        return 7;
      }
      if (security_bypass_flag != 0xff) {
        if (!bVar2) {
          return 3;
        }
        securityCheckResult = systemSecurityCheckStub_AlwaysPasses();
        if (securityCheckResult != '\0') {
          return 3;
        }
      }
      if (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 == 1) {
        securityCheckResult2 = circularBufferWrite((short)((uint)puVar1 >> 0x10),sVar6);
        if (securityCheckResult2 == '\x01') {
          return 0xb;
        }
      }
      uVar3 = memcpy(param_2 + -0x7fcb08,puVar1,CONCAT22(sVar6,uVar8));
      return uVar3 & 0xffffff00;
    }
  }
  return CONCAT31((int3)(uVar3 >> 8),(char)uVar4);
}



/*
 * Function: j1939MemoryDataCopyResolver @ 0x0001b532
 */
/* ERROR: Failed to decompile */
void j1939MemoryDataCopyResolver(void) {
    /* Decompilation failed */
}


/*
 * Function: j1939DataCopyWrapper @ 0x0001b56e
 */

void j1939DataCopyWrapper(int param_1)

{
  undefined4 unaff_A2;
  undefined1 local_6 [2];
  
  memcpy(local_6,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(2,(short)((uint)unaff_A2 >> 0x10)));
  j1939MemoryDataCopyResolver(param_1);
  return;
}



/*
 * Function: j1939DataCopyWrapper2Byte @ 0x0001b5b6
 */

void j1939DataCopyWrapper2Byte(int param_1)

{
  undefined4 unaff_A2;
  undefined1 *puVar1;
  undefined1 local_a [4];
  undefined1 local_6 [2];
  
  puVar1 = local_6;
  memcpy(puVar1,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(2,(short)((uint)unaff_A2 >> 0x10)));
  memcpy(local_a,(undefined1 *)(*(int *)(param_1 + 6) + 3),CONCAT22(4,(short)puVar1));
  j1939MemoryDataCopyResolver(param_1);
  return;
}



/*
 * Function: j1939DataCopyWrapper2ByteAlt @ 0x0001b604
 */

void j1939DataCopyWrapper2ByteAlt(int param_1)

{
  undefined4 unaff_A2;
  undefined1 local_6 [2];
  
  memcpy(local_6,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(2,(short)((uint)unaff_A2 >> 0x10)));
  j1939MemoryDataCopyResolver(param_1);
  return;
}



/*
 * Function: j1939DataCopyWrapperExtended @ 0x0001b668
 */

void j1939DataCopyWrapperExtended(int param_1)

{
  undefined4 unaff_A2;
  undefined1 *puVar1;
  undefined1 *puVar2;
  undefined1 local_e [4];
  undefined1 local_a [4];
  undefined1 local_6 [2];
  
  puVar2 = local_6;
  memcpy(puVar2,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(2,(short)((uint)unaff_A2 >> 0x10)));
  puVar1 = local_a;
  memcpy(puVar1,(undefined1 *)(*(int *)(param_1 + 6) + 3),CONCAT22(4,(short)puVar2));
  memcpy(local_e,(undefined1 *)(*(int *)(param_1 + 6) + 7),CONCAT22(4,(short)puVar1));
  j1939MemoryDataCopyResolver(param_1);
  return;
}



/*
 * Function: memoryOperationFromMessage @ 0x0001b6ce
 */

void memoryOperationFromMessage(int param_1)

{
  undefined4 unaff_A2;
  uint local_c;
  undefined1 *local_8;
  
  memcpy((undefined1 *)&local_8,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(4,(short)((uint)unaff_A2 >> 0x10)));
  local_c = (uint)*(byte *)(*(int *)(param_1 + 6) + 5);
  memoryOperationDispatcher(param_1,local_8,local_c);
  return;
}



/*
 * Function: memoryOperationFromMessageExtended @ 0x0001b716
 */

void memoryOperationFromMessageExtended(int param_1)

{
  undefined4 unaff_A2;
  undefined1 **ppuVar1;
  uint local_c;
  undefined1 *local_8;
  
  ppuVar1 = &local_8;
  memcpy((undefined1 *)ppuVar1,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(4,(short)((uint)unaff_A2 >> 0x10)));
  memcpy((undefined1 *)&local_c,(undefined1 *)(*(int *)(param_1 + 6) + 5),CONCAT22(4,(short)ppuVar1)
        );
  memoryOperationDispatcher(param_1,local_8,local_c);
  return;
}



/*
 * Function: systemFunction6xParameterized @ 0x0001b762
 */

void systemFunction6xParameterized(void)

{
  undefined2 uVar1;
  undefined2 uVar2;
  undefined2 uVar3;
  
  uVar3 = 0xb56e;
  coreSystemFunction(1);
  uVar2 = 0xb56e;
  uVar1 = 0x45;
  coreSystemFunction(1,uVar3);
  coreSystemFunction(1,uVar1,uVar2);
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  return;
}



/*
 * Function: addressLookupFunction @ 0x0001b7ca
 */

uint addressLookupFunction(undefined4 param_1)

{
  uint in_D0;
  
  if (0x40 < (byte)((uint)param_1 >> 0x10)) {
    return (uint)*(byte *)((short)(param_1._0_2_ & 0xff) + 0x1b77b);
  }
  return in_D0 & 0xffffff00;
}



/*
 * Function: diagnosticServiceSecurityValidator @ 0x0001b7e8
 */

undefined4 diagnosticServiceSecurityValidator(int param_1)

{
  undefined3 extraout_var;
  char securityCheckResult;
  undefined4 in_D0;
  char cVar1;
  char cVar2;
  byte serviceId;
  
  serviceId = **(byte **)(param_1 + 6);
  cVar1 = *(char *)(param_1 + 5);
  if (0x17 < serviceId) {
    return CONCAT31((int3)((uint)in_D0 >> 8),0xff);
  }
  if ((serviceId == 3) || (serviceId == 4)) {
    cVar2 = '\x03';
  }
  else {
    cVar2 = '\x01';
  }
  if ((('\x01' << (serviceId & 7) &
       *(byte *)((int)&can_number_of_retarder_destination_non_specific_rx_objects_0_14 +
                ((int)(uint)serviceId >> 3))) == 0) || (security_bypass_flag != 0xb522)) {
    if ((cVar1 != '\b') && (cVar1 != (char)(cVar2 + '\n'))) {
      return 2;
    }
    return 0xff;
  }
  if ((char)(cVar2 + '\n') != cVar1) {
    return 2;
  }
  cVar1 = systemSecurityCheckStub_AlwaysPasses();
  if (cVar1 == '\0') {
    return CONCAT31(extraout_var,0xff);
  }
  return 3;
}



/*
 * Function: diagnosticGroupPositionBufferStore @ 0x0001b8b8
 */

void diagnosticGroupPositionBufferStore(undefined4 param_1)

{
  ushort uVar1;
  uint uVar2;
  byte bVar3;
  undefined2 *puVar4;
  byte *pbVar5;
  
  uVar1 = diagnostic_buffer_write_index + 1;
  uVar2 = (uint)diagnostic_buffer_write_index;
  diagnostic_buffer_write_index = uVar1;
  if (4 < uVar1) {
    diagnostic_buffer_write_index = 0;
  }
  if (param_1._1_1_ == '\0') {
    pbVar5 = &DGRPOSLF;
  }
  else {
    pbVar5 = &diagnostic_snapshot_position_flag;
  }
  bVar3 = 0;
  puVar4 = (undefined2 *)(uVar2 * 0x18 + 0x8054c0);
  do {
    *puVar4 = *(undefined2 *)pbVar5;
    bVar3 = bVar3 + 1;
    puVar4 = puVar4 + 1;
    pbVar5 = pbVar5 + 2;
  } while (bVar3 < 0xc);
  return;
}



/*
 * Function: diagnosticGroupSnapshotCapture @ 0x0001b916
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticGroupSnapshotCapture(undefined4 param_1)

{
  if (param_1._1_1_ == '\0') {
    diagnostic_capture_active_flag = 1;
    diagnostic_snapshot_fuel_mode_capture = fuel_arbitrator_diag_t_0080cff8.fuel_mode;
    DGRPOSLF = 0;
    diagnostic_snapshot_limited_byte = (byte)fuel_arbitrator_diag_t_0080cff8.limited_value;
    diagnostic_snapshot_fuel_mode_0 = fuel_arbitrator_diag_t_0080cff8.fuel_mode;
    vp44_sensor_diag_state_1 = 1;
    fuel_arbitrator_rpm_target_history = fuel_arbitrator_diag_t_0080cff8.rpm_target;
    diagnostic_snapshot_zero_0 = 0;
    diagnostic_snapshot_zero_1 = 0;
    diagnostic_snapshot_zero_2 = 0;
    fuel_arbitrator_rpm_history_index = 0;
    loop_counter_capture_start_2 = _loopCounter;
    loop_counter_elapsed_time_2 = 0;
    return;
  }
  timing_measurement_active_flag_1 = 1;
  diagnostic_snapshot_retarder_mode = retarder_mode_can_source_priority;
  diagnostic_snapshot_position_flag = 1;
  diagnostic_snapshot_byte_1 = retarder_control_source_byte;
  diagnostic_snapshot_fuel_mode_1 = retarder_mode_can_source_priority;
  vp44_sensor_diag_state_2 = 1;
  fuel_arbitrator_state_history = fuel_arbitrator_state;
  diagnostic_snapshot_zero_3 = 0;
  diagnostic_snapshot_zero_4 = 0;
  diagnostic_snapshot_zero_5 = 0;
  _DGCLLVLF = 0;
  loop_counter_capture_start_1 = _loopCounter;
  loop_counter_elapsed_time_1 = 0;
  return;
}



/*
 * Function: memoryRegisterController @ 0x0001b9da
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint memoryRegisterController(void)

{
  undefined2 uVar1;
  undefined4 in_D0;
  uint uVar2;
  undefined4 unaff_A2;
  word *pwVar3;
  ushort uVar4;
  
  uVar4 = (ushort)((uint)unaff_A2 >> 0x10);
  uVar1 = (undefined2)((uint)in_D0 >> 0x10);
  uVar2 = CONCAT22(uVar1,diagnostic_system_flags_2) & 0xffff0800;
  if ((diagnostic_system_flags_2 & 0x800) != 0) {
    uVar2 = CONCAT22(uVar1,fuel_arbitrator_diag_t_0080cff8.rpm_target);
    if (((fuel_arbitrator_diag_t_0080cff8.rpm_target != fuel_arbitrator_previous_rpm_target) ||
        (uVar2 = CONCAT22(uVar1,fuel_arbitrator_diag_t_0080cff8._28_2_),
        fuel_arbitrator_diag_t_0080cff8._28_2_ != fuel_arbitrator_previous_state)) ||
       (uVar2 = CONCAT31((int3)(uVar2 >> 8),(byte)fuel_arbitrator_diag_t_0080cff8.limited_value),
       (byte)fuel_arbitrator_diag_t_0080cff8.limited_value != fuel_arbitrator_limited_value_prev)) {
      if (fuel_arbitrator_diag_t_0080cff8.rpm_target == 0) {
        if ((fuel_arbitrator_previous_rpm_target != 0) && (fuel_arbitrator_previous_state == 1)) {
          diagnostic_capture_active_flag = 0;
          loop_counter_elapsed_time_2 = _loopCounter - loop_counter_capture_start_2;
          uVar2 = diagnosticGroupPositionBufferStore((uint)uVar4);
        }
      }
      else if (fuel_arbitrator_diag_t_0080cff8._28_2_ == 1) {
        if (diagnostic_capture_active_flag == 1) {
          if ((byte)fuel_arbitrator_diag_t_0080cff8.limited_value ==
              fuel_arbitrator_limited_value_prev) {
            if (vp44_sensor_diag_state_1 < 5) {
              uVar2 = (uint)vp44_sensor_diag_state_1;
              vp44_sensor_diag_state_1 = vp44_sensor_diag_state_1 + 1;
              (&fuel_arbitrator_rpm_target_history)[uVar2] =
                   fuel_arbitrator_diag_t_0080cff8.rpm_target;
            }
            else {
              uVar2 = 0;
              for (pwVar3 = &fuel_arbitrator_rpm_target_history;
                  pwVar3 < &fuel_arbitrator_rpm_history_index; pwVar3 = pwVar3 + 1) {
                *pwVar3 = pwVar3[1];
              }
              fuel_arbitrator_rpm_history_index = fuel_arbitrator_diag_t_0080cff8.rpm_target;
            }
          }
          else {
            loop_counter_elapsed_time_2 = _loopCounter - loop_counter_capture_start_2;
            diagnosticGroupPositionBufferStore((uint)uVar4);
            uVar2 = diagnosticGroupSnapshotCapture((uint)uVar4);
          }
        }
        else {
          uVar2 = diagnosticGroupSnapshotCapture((uint)uVar4);
        }
      }
      else if (fuel_arbitrator_previous_state == 1) {
        diagnostic_capture_active_flag = 0;
        uVar2 = diagnosticGroupPositionBufferStore((uint)uVar4);
      }
    }
    fuel_arbitrator_previous_rpm_target = fuel_arbitrator_diag_t_0080cff8.rpm_target;
    fuel_arbitrator_previous_state = fuel_arbitrator_diag_t_0080cff8._28_2_;
    fuel_arbitrator_limited_value_prev = (byte)fuel_arbitrator_diag_t_0080cff8.limited_value;
    uVar2 = CONCAT22((short)(uVar2 >> 0x10),fuel_arbitrator_state);
    if ((fuel_arbitrator_state != fuel_arbitrator_previous_state_2) ||
       (uVar2 = (uint)_retarder_control_can_source, uVar2 != retarder_control_source_previous)) {
      if (fuel_arbitrator_state == 0) {
        if (fuel_arbitrator_previous_state_2 != 0) {
          timing_measurement_active_flag_1 = 0;
          loop_counter_elapsed_time_1 = _loopCounter - loop_counter_capture_start_1;
          uVar2 = diagnosticGroupPositionBufferStore(CONCAT22(1,uVar4));
        }
      }
      else if (timing_measurement_active_flag_1 == 1) {
        if (_retarder_control_can_source == retarder_control_source_previous) {
          if (vp44_sensor_diag_state_2 < 5) {
            uVar2 = (uint)vp44_sensor_diag_state_2;
            vp44_sensor_diag_state_2 = vp44_sensor_diag_state_2 + 1;
            (&fuel_arbitrator_state_history)[uVar2] = fuel_arbitrator_state;
          }
          else {
            uVar2 = 0xe;
            for (pwVar3 = &fuel_arbitrator_state_history; pwVar3 < &DGCLLVLF; pwVar3 = pwVar3 + 1) {
              *pwVar3 = pwVar3[1];
            }
            _DGCLLVLF = fuel_arbitrator_state;
          }
        }
        else {
          loop_counter_elapsed_time_1 = _loopCounter - loop_counter_capture_start_1;
          diagnosticGroupPositionBufferStore(CONCAT22(1,uVar4));
          uVar2 = diagnosticGroupSnapshotCapture(CONCAT22(1,uVar4));
        }
      }
      else {
        uVar2 = diagnosticGroupSnapshotCapture(CONCAT22(1,uVar4));
      }
    }
    fuel_arbitrator_previous_state_2 = fuel_arbitrator_state;
    retarder_control_source_previous = retarder_control_source_byte;
  }
  return uVar2;
}



/*
 * Function: byteSwap32 @ 0x0001bc1e
 */

undefined4 byteSwap32(undefined4 *param_1)

{
  undefined4 uVar1;
  undefined2 uVar2;
  undefined4 local_8;
  
  uVar1 = *param_1;
  local_8._3_1_ = (undefined1)uVar1;
  local_8._0_1_ = (undefined1)((uint)uVar1 >> 0x18);
  local_8._1_1_ = (undefined1)((uint)uVar1 >> 0x10);
  local_8._2_1_ = (undefined1)((uint)uVar1 >> 8);
  uVar2 = CONCAT11((undefined1)local_8,local_8._2_1_);
  local_8 = CONCAT22(uVar2,CONCAT11(local_8._1_1_,local_8._0_1_));
  return local_8;
}



/*
 * Function: byteSwap16 @ 0x0001bc52
 */

undefined2 byteSwap16(undefined2 *param_1)

{
  undefined2 local_6;
  
  local_6._1_1_ = (undefined1)*param_1;
  local_6._0_1_ = (undefined1)((ushort)*param_1 >> 8);
  local_6 = CONCAT11((undefined1)local_6,local_6._0_1_);
  return local_6;
}



/*
 * Function: ioControlBitMapper @ 0x0001bc74
 */

uint ioControlBitMapper(void)

{
  uint in_D0;
  uint uVar1;
  
  uVar1 = in_D0 & 0xffffff00;
  if ((io_control_source_register & 0x10) != 0) {
    uVar1 = 0x40;
  }
  if ((io_control_source_register & 2) != 0) {
    uVar1 = uVar1 | 0x10;
  }
  if ((io_control_source_register & 0x40) != 0) {
    uVar1 = uVar1 | 4;
  }
  return uVar1;
}



/*
 * Function: canDiagnosticResponseSender @ 0x0001bc9c
 */

undefined4 canDiagnosticResponseSender(undefined1 *param_1)

{
  undefined1 uVar1;
  undefined1 uVar2;
  char cVar4;
  undefined4 uVar3;
  undefined1 local_1a;
  undefined1 local_19;
  undefined1 local_18;
  uint local_12;
  undefined2 local_e;
  undefined1 *local_c;
  
  uVar1 = *(undefined1 *)(*(int *)(param_1 + 6) + 1);
  uVar2 = *(undefined1 *)(*(int *)(param_1 + 6) + 2);
  cVar4 = diagnosticMemoryAddressResolver();
  if (cVar4 == '\0') {
    local_12 = CONCAT31(CONCAT21((short)(CONCAT13(*param_1,0xef0000) >> 0x10),param_1[3]),param_1[2]
                       ) & 0x1cffffff;
    local_e = 7;
    local_1a = 0x42;
    local_19 = uVar1;
    local_18 = uVar2;
    local_c = &local_1a;
    uVar3 = sendCanSingleFrame(local_12,(short)((uint)&local_1a >> 0x10));
    uVar3 = CONCAT31((int3)((uint)uVar3 >> 8),0xff);
  }
  else {
    uVar3 = 8;
  }
  return uVar3;
}



/*
 * Function: systemFunction1xCaller @ 0x0001bd58
 */

void systemFunction1xCaller(void)

{
  coreSystemFunction();
  return;
}



/*
 * Function: diagMemoryReadResponseBuilder @ 0x0001bd76
 */

undefined4 diagMemoryReadResponseBuilder(byte *param_1,undefined1 *param_2,uint param_3)

{
  int iVar1;
  char cVar2;
  byte bVar3;
  byte bVar4;
  undefined3 uVar5;
  undefined4 in_D0;
  uint uVar6;
  undefined4 uVar7;
  undefined2 uVar8;
  j1939_header_t *msg_header;
  undefined4 unaff_D2;
  byte bVar9;
  ushort uVar10;
  byte *pbVar11;
  byte *pbVar12;
  undefined2 uVar13;
  
  uVar13 = (undefined2)((uint)unaff_D2 >> 0x10);
  cVar2 = **(char **)(param_1 + 6);
  if (0x6e4 < param_3) {
    return 2;
  }
  uVar6 = addressLookupFunction(CONCAT22((short)CONCAT31((int3)((uint)in_D0 >> 8),cVar2),uVar13));
  bVar9 = (byte)uVar6;
  if (bVar9 < 8) {
    bVar9 = 8;
  }
  if (((ushort)bVar9 != *(ushort *)(param_1 + 4)) &&
     ((ushort)(bVar9 + 10) != *(short *)(param_1 + 4))) {
    return 2;
  }
  uVar10 = (ushort)param_3;
  uVar7 = addressRangeValidator((uint)param_2,CONCAT22(uVar10,uVar13));
  uVar5 = (undefined3)((uint)uVar7 >> 8);
  if (((char)uVar7 == '\n') || ((char)uVar7 == '\t')) {
    return uVar7;
  }
  if ((cVar2 == 'C') && (uVar10 < 0x100)) {
    bVar9 = 0x44;
    *(undefined1 *)(*(int *)(param_1 + 6) + 3) = *(undefined1 *)(*(int *)(param_1 + 6) + 6);
  }
  else {
    uVar5 = 0;
    bVar9 = (&diag_memory_read_response_code_table)[(short)(ushort)(byte)(cVar2 + 0xbd)];
  }
  uVar8 = (undefined2)CONCAT31(uVar5,bVar9);
  uVar6 = addressLookupFunction(CONCAT22(uVar8,uVar13));
  bVar4 = (char)uVar6 - 1;
  msg_header = (j1939_header_t *)multiPacketBufferAllocator(CONCAT22(uVar10 + bVar4 + 1,uVar8));
  if (msg_header == (j1939_header_t *)0x0) {
    return 4;
  }
  pbVar12 = (byte *)msg_header[1].id;
  msg_header->id = 0xef0000;
  bVar3 = *param_1;
  *(byte *)&msg_header->id = *(byte *)&msg_header->id & 0xe3;
  *(byte *)&msg_header->id = bVar3 & 0x1c | *(byte *)&msg_header->id;
  *(byte *)((int)&msg_header->id + 2) = param_1[3];
  *(byte *)((int)&msg_header->id + 3) = param_1[2];
  iVar1 = *(int *)(param_1 + 6);
  pbVar11 = pbVar12 + 1;
  *pbVar12 = bVar9;
  pbVar12 = pbVar11;
  memcpy(pbVar11,(undefined1 *)(iVar1 + 1),(uint)CONCAT12(bVar4,uVar13));
  if ((undefined1 *)0xffffff < param_2) {
    param_2 = param_2 + -0x7fcb08;
  }
  memcpy(pbVar11 + bVar4,param_2,CONCAT22(uVar10,(short)((uint)pbVar12 >> 0x10)));
  uVar7 = sendCanMessage(msg_header);
  return CONCAT31((int3)((uint)uVar7 >> 8),0xff);
}



/*
 * Function: diagMemoryReadWithOffsetBuilder @ 0x0001bedc
 */
/* ERROR: Failed to decompile */
void diagMemoryReadWithOffsetBuilder(void) {
    /* Decompilation failed */
}


/*
 * Function: diagMemoryReadService43Handler @ 0x0001bf18
 */

void diagMemoryReadService43Handler(int param_1)

{
  undefined4 unaff_A2;
  undefined1 *puVar1;
  undefined1 local_a [4];
  undefined1 local_6 [2];
  
  puVar1 = local_6;
  memcpy(puVar1,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(2,(short)((uint)unaff_A2 >> 0x10)));
  memcpy(local_a,(undefined1 *)(*(int *)(param_1 + 6) + 3),CONCAT22(4,(short)puVar1));
  diagMemoryReadWithOffsetBuilder(param_1);
  return;
}



/*
 * Function: diagMemoryReadService46Handler @ 0x0001bf64
 */

void diagMemoryReadService46Handler(int param_1)

{
  undefined4 unaff_A2;
  undefined1 local_6 [2];
  
  memcpy(local_6,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(2,(short)((uint)unaff_A2 >> 0x10)));
  diagMemoryReadWithOffsetBuilder(param_1);
  return;
}



/*
 * Function: diagMemoryReadService48Handler @ 0x0001bfc8
 */

void diagMemoryReadService48Handler(int param_1)

{
  undefined4 unaff_A2;
  undefined1 *puVar1;
  undefined1 *puVar2;
  undefined1 local_e [4];
  undefined1 local_a [4];
  undefined1 local_6 [2];
  
  puVar2 = local_6;
  memcpy(puVar2,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(2,(short)((uint)unaff_A2 >> 0x10)));
  puVar1 = local_a;
  memcpy(puVar1,(undefined1 *)(*(int *)(param_1 + 6) + 3),CONCAT22(4,(short)puVar2));
  memcpy(local_e,(undefined1 *)(*(int *)(param_1 + 6) + 7),CONCAT22(4,(short)puVar1));
  diagMemoryReadWithOffsetBuilder(param_1);
  return;
}



/*
 * Function: diagMemoryReadService4aHandler @ 0x0001c02e
 */

void diagMemoryReadService4aHandler(byte *param_1)

{
  undefined4 unaff_A2;
  uint local_c;
  undefined1 *local_8;
  
  memcpy((undefined1 *)&local_8,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(4,(short)((uint)unaff_A2 >> 0x10)));
  local_c = (uint)*(byte *)(*(int *)(param_1 + 6) + 5);
  diagMemoryReadResponseBuilder(param_1,local_8,local_c);
  return;
}



/*
 * Function: diagMemoryReadService4cHandler @ 0x0001c076
 */

void diagMemoryReadService4cHandler(byte *param_1)

{
  undefined4 unaff_A2;
  undefined1 **ppuVar1;
  uint local_c;
  undefined1 *local_8;
  
  ppuVar1 = &local_8;
  memcpy((undefined1 *)ppuVar1,(undefined1 *)(*(int *)(param_1 + 6) + 1),
         CONCAT22(4,(short)((uint)unaff_A2 >> 0x10)));
  memcpy((undefined1 *)&local_c,(undefined1 *)(*(int *)(param_1 + 6) + 5),CONCAT22(4,(short)ppuVar1)
        );
  diagMemoryReadResponseBuilder(param_1,local_8,local_c);
  return;
}



/*
 * Function: systemFunction5xCaller @ 0x0001c0c2
 */

void systemFunction5xCaller(void)

{
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  coreSystemFunction();
  return;
}



/*
 * Function: sendJ1939MultiFrame @ 0x0001c10e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void sendJ1939MultiFrame(uint *param_1)

{
  undefined1 *puVar1;
  undefined2 uVar2;
  byte bVar3;
  ushort uVar4;
  word wVar5;
  byte *pbVar6;
  byte *pbVar7;
  byte local_8;
  byte bStack_7;
  byte bStack_5;
  
  pbVar7 = diag_tp_state_t_00800f34.tx_cm_buf;
  bVar3 = *(byte *)((int)param_1 + 1);
  uVar4 = *(ushort *)((int)param_1 + 1);
  bStack_5 = (byte)uVar4;
  if ((bVar3 < 0xf0) && (bStack_5 != 0xff)) {
    if (diag_tp_state_t_00800f34.diag_state == 0) {
      diag_tp_state_t_00800f34.diag_state = 1;
      diag_tp_state_t_00800f34.expected_id_low = bStack_5;
      diag_tp_state_t_00800f34.expected_guard = uVar4 & 0xff00;
      diag_tp_state_t_00800f34.total_bytes = *(word *)(param_1 + 1);
      diag_tp_state_t_00800f34.total_packets =
           (char)((int)(diag_tp_state_t_00800f34.total_bytes - 1) / 7) + 1;
      diag_tp_state_t_00800f34.req_count = 0;
      diag_tp_state_t_00800f34.src_data_ptr = *(byte **)((int)param_1 + 6);
      diag_tp_state_t_00800f34.tx_header_id = *param_1 & 0xff00ffff | 0xec0000;
      diag_tp_state_t_00800f34.tx_length = 8;
      diag_tp_state_t_00800f34.status_code = 0;
      diag_tp_state_t_00800f34.reserved_0x47 = 0x37;
      diag_tp_state_t_00800f34.resp_byte_ptr = *(byte **)((int)param_1 + 10);
      pbVar6 = diag_tp_state_t_00800f34.tx_cm_buf + 1;
      *diag_tp_state_t_00800f34.tx_cm_buf = 0x10;
      wVar5 = diag_tp_state_t_00800f34.total_bytes;
      bStack_7 = (byte)diag_tp_state_t_00800f34.total_bytes;
      *pbVar6 = bStack_7;
      local_8 = (byte)(wVar5 >> 8);
      pbVar7[2] = local_8;
      pbVar7[3] = diag_tp_state_t_00800f34.total_packets;
      pbVar7[4] = 0xff;
      pbVar7[5] = 0;
      pbVar7[6] = bVar3;
      pbVar7[7] = 0;
      sendCanSingleFrame(diag_tp_state_t_00800f34.tx_header_id);
      if (diag_tp_state_t_00800f34.pre_status == 0) {
        *diag_tp_state_t_00800f34.resp_byte_ptr = 0x12;
        diag_tp_state_t_00800f34.tx_header_id = *param_1 & 0xff00ffff | 0xeb0000;
      }
      else {
        *diag_tp_state_t_00800f34.resp_byte_ptr = diag_tp_state_t_00800f34.pre_status;
        diag_tp_state_t_00800f34.diag_state = 0;
      }
    }
    else {
      **(undefined1 **)((int)param_1 + 10) = 8;
    }
  }
  else {
    if ((byte)*param_1 == _j1939_multiframe_source_address) {
      pbVar7 = &debounce_state_flag;
    }
    else {
      if ((byte)*param_1 != _can_cpu_interface_address) {
        **(undefined1 **)((int)param_1 + 10) = 3;
        return;
      }
      pbVar7 = &j1939_multi_frame_active_flag;
    }
    if (*pbVar7 == 1) {
      **(undefined1 **)((int)param_1 + 10) = 2;
    }
    else {
      *pbVar7 = 1;
      *(undefined2 *)(pbVar7 + 2) = *(undefined2 *)(param_1 + 1);
      pbVar7[1] = (char)((int)(*(ushort *)(pbVar7 + 2) - 1) / 7) + 1;
      pbVar7[6] = 1;
      pbVar7[4] = 0;
      pbVar7[5] = 1;
      *(undefined4 *)(pbVar7 + 8) = *(undefined4 *)((int)param_1 + 6);
      *(uint *)(pbVar7 + 0x12) = *param_1 & 0xff0000ff | 0xecff00;
      pbVar7[0x16] = 0;
      pbVar7[0x17] = 8;
      pbVar7[0x10] = 0;
      pbVar7[0x11] = 5;
      *(undefined4 *)(pbVar7 + 0xc) = *(undefined4 *)((int)param_1 + 10);
      puVar1 = *(undefined1 **)(pbVar7 + 0x18);
      *puVar1 = 0x20;
      uVar2 = *(undefined2 *)(pbVar7 + 2);
      bStack_7 = (byte)uVar2;
      puVar1[1] = bStack_7;
      local_8 = (byte)((ushort)uVar2 >> 8);
      puVar1[2] = local_8;
      puVar1[3] = pbVar7[1];
      puVar1[4] = 0xff;
      puVar1[5] = bStack_5;
      puVar1[6] = bVar3;
      puVar1[7] = 0;
      sendCanSingleFrame(*(undefined4 *)(pbVar7 + 0x12));
      if (pbVar7[7] == 0) {
        **(byte **)(pbVar7 + 0xc) = 0x10;
        *(uint *)(pbVar7 + 0x12) = *param_1 & 0xff0000ff | 0xebff00;
      }
      else {
        **(byte **)(pbVar7 + 0xc) = pbVar7[7];
        *pbVar7 = 0;
      }
    }
  }
  return;
}



/*
 * Function: diagnosticParamRequestHandler @ 0x0001c33e
 */

void diagnosticParamRequestHandler(can_std_rx_desc_t *rx_msg)

{
  byte bVar1;
  byte bVar2;
  word local_6;
  
  bVar1 = rx_msg->data_ptr[2];
  local_6 = (ushort)rx_msg->data_ptr[6] << 8;
  if ((((diag_tp_state_t_00800f34.diag_state == 1) &&
       ((byte)rx_msg->id == diag_tp_state_t_00800f34.expected_id_low)) &&
      (bVar1 <= diag_tp_state_t_00800f34.total_packets)) &&
     (local_6 == diag_tp_state_t_00800f34.expected_guard)) {
    bVar2 = rx_msg->data_ptr[1];
    if (bVar2 == 0) {
      diag_tp_state_t_00800f34.status_code = 0;
      diag_tp_state_t_00800f34.reserved_0x47 = 0x37;
    }
    else {
      diag_tp_state_t_00800f34.req_start = bVar1;
      diag_tp_state_t_00800f34.req_count = bVar2;
      if ((int)(uint)diag_tp_state_t_00800f34.total_packets < (int)((uint)bVar2 + (uint)bVar1 + -1))
      {
        diag_tp_state_t_00800f34.req_count = (diag_tp_state_t_00800f34.total_packets - bVar1) + 1;
      }
    }
  }
  return;
}



/*
 * Function: messageErrorHandler @ 0x0001c3d2
 */

void messageErrorHandler(undefined4 param_1)

{
  undefined1 *puVar1;
  byte bVar2;
  undefined1 *puVar3;
  undefined1 local_1e;
  undefined1 uStack_1c;
  undefined1 auStack_1b [9];
  undefined4 local_12;
  undefined2 local_e;
  undefined1 *local_c;
  
  local_12 = CONCAT31(CONCAT21(0x18ec,param_1._1_1_),j1939_source_address_primary);
  local_e = 8;
  local_c = &uStack_1c;
  uStack_1c = 0xff;
  bVar2 = 0;
  puVar1 = auStack_1b;
  do {
    puVar3 = puVar1;
    *puVar3 = 0xff;
    bVar2 = bVar2 + 1;
    puVar1 = puVar3 + 1;
  } while (bVar2 < 4);
  puVar3[1] = 0;
  local_1e = (undefined1)((uint)param_1 >> 8);
  puVar3[2] = local_1e;
  puVar3[3] = 0;
  sendCanSingleFrame(local_12);
  return;
}



/*
 * Function: vp44CanFrameBuilder @ 0x0001c440
 */

void vp44CanFrameBuilder(undefined4 param_1)

{
  undefined1 local_20;
  undefined1 uStack_1f;
  undefined1 local_1e;
  undefined1 uStack_1c;
  undefined1 uStack_1b;
  undefined1 uStack_1a;
  byte bStack_19;
  undefined1 uStack_18;
  undefined1 uStack_17;
  undefined1 uStack_16;
  undefined1 local_15;
  undefined4 local_12;
  undefined2 local_e;
  undefined1 *local_c;
  
  local_12 = CONCAT31(CONCAT21(0x18ec,param_1._1_1_),j1939_source_address_primary);
  local_e = 8;
  local_c = &uStack_1c;
  uStack_1c = 0x13;
  uStack_1f = (undefined1)serial_port_config_value;
  uStack_1b = uStack_1f;
  local_20 = (undefined1)(serial_port_config_value >> 8);
  uStack_1a = local_20;
  bStack_19 = vp44_sequence_number;
  uStack_18 = 0xff;
  uStack_17 = 0;
  local_1e = (undefined1)((uint)param_1 >> 8);
  uStack_16 = local_1e;
  local_15 = 0;
  sendCanSingleFrame(local_12);
  return;
}



/*
 * Function: vp44MessageTransmitter @ 0x0001c4c0
 */

undefined1 vp44MessageTransmitter(undefined4 param_1,undefined2 param_2)

{
  undefined1 local_1e;
  undefined1 auStack_1c [2];
  undefined1 uStack_1a;
  undefined1 uStack_19;
  undefined1 uStack_18;
  undefined1 uStack_17;
  undefined1 uStack_16;
  undefined1 local_15;
  undefined1 local_13;
  undefined4 local_12;
  undefined2 local_e;
  undefined1 *local_c;
  
  local_12 = CONCAT31(CONCAT21(0x18ec,param_1._1_1_),j1939_source_address_primary);
  local_e = 8;
  local_c = auStack_1c;
  auStack_1c[0] = 0x11;
  uStack_1a = (undefined1)param_1;
  uStack_19 = 0xff;
  uStack_18 = 0xff;
  uStack_17 = 0;
  local_1e = (undefined1)((ushort)param_2 >> 8);
  uStack_16 = local_1e;
  local_15 = 0;
  sendCanSingleFrame(local_12);
  return local_13;
}



/*
 * Function: vp44FuelTempHandler @ 0x0001c538
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FuelTempHandler(can_std_rx_desc_t *rx_msg)

{
  byte *pbVar1;
  byte bVar2;
  byte bVar3;
  undefined1 uVar4;
  undefined1 extraout_var;
  undefined2 in_D0w;
  char cVar5;
  undefined2 local_8;
  word local_6;
  
  pbVar1 = rx_msg->data_ptr;
  bVar2 = pbVar1[6];
  local_6 = (ushort)bVar2 << 8;
  bVar3 = (byte)rx_msg->id;
  local_8 = CONCAT11(pbVar1[2],pbVar1[1]);
  uVar4 = (undefined1)((ushort)in_D0w >> 8);
  if ((((vp44_response_buffer == 1) && (bVar3 != vp44_expected_sequence)) || (bVar2 != 0xef)) ||
     (0x6a4 < local_8)) {
    messageErrorHandler((uint)CONCAT21(CONCAT11(uVar4,bVar3),bVar2) << 8);
  }
  else {
    vp44_response_buffer = 1;
    _vp44_message_data = rx_msg->id;
    vp44_message_id = local_6;
    vp44_sequence_number = pbVar1[3];
    serial_port_config_value = local_8;
                    /* Constant: VP44_FUEL_TEMP_OFFSET = 112 */
    _vp44_timeout_counter = 0x70;
    vp44_retry_flag = 1;
    vp44_retry_count = vp44_sequence_number;
    if (5 < vp44_sequence_number) {
      vp44_retry_count = 5;
    }
    cVar5 = vp44MessageTransmitter(CONCAT22(CONCAT11(uVar4,bVar3),CONCAT11(uVar4,1)),0xef00);
    if (cVar5 != '\0') {
      messageErrorHandler(CONCAT22(CONCAT11(extraout_var,bVar3),vp44_message_id));
      vp44_response_buffer = 0;
    }
  }
  return;
}



/*
 * Function: vp44MultiFrameResponseHandler @ 0x0001c60e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44MultiFrameResponseHandler(int param_1)

{
  byte bVar1;
  byte bVar2;
  undefined1 *puVar3;
  undefined3 uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined4 in_D0;
  char cVar6;
  int iVar5;
  byte bVar7;
  byte bVar8;
  undefined1 *puVar9;
  undefined1 *puVar10;
  
  if (((*(short *)(param_1 + 4) == 8) && (bVar2 = *(byte *)(param_1 + 3), vp44_response_buffer == 1)
      ) && (bVar2 == vp44_expected_sequence)) {
    bVar1 = **(byte **)(param_1 + 6);
    if (bVar1 == vp44_retry_flag) {
      if (bVar1 == vp44_sequence_number) {
        bVar8 = (char)serial_port_config_value + bVar1 * -7 + 7;
      }
      else {
        bVar8 = 7;
      }
      puVar10 = *(undefined1 **)(param_1 + 6);
      puVar3 = (undefined1 *)(serial_buffer_pointer + (uint)bVar1 * 7 + -7);
      puVar9 = puVar3;
      for (bVar7 = 0; puVar10 = puVar10 + 1, bVar7 < bVar8; bVar7 = bVar7 + 1) {
        *puVar9 = *puVar10;
        puVar9 = puVar9 + 1;
      }
      vp44_retry_flag = vp44_retry_flag + 1;
      vp44_retry_count = vp44_retry_count - 1;
      if (vp44_retry_count == 0) {
        if (bVar1 == vp44_sequence_number) {
          vp44CanFrameBuilder(CONCAT22((short)CONCAT31((int3)((uint)puVar3 >> 8),bVar2),
                                       vp44_message_id));
          vp44_response_buffer = 0;
          serial_buffer_pointer = 0x800f78;
          diagnosticServiceDispatcher(&vp44_message_data);
          return;
        }
        iVar5 = ((uint)vp44_sequence_number - (uint)vp44_retry_flag) + 1;
        if (iVar5 < 6) {
          vp44_retry_count = (vp44_sequence_number - vp44_retry_flag) + 1;
          iVar5 = CONCAT31((int3)((uint)iVar5 >> 8),vp44_retry_count);
        }
        else {
          vp44_retry_count = 5;
        }
        uVar4 = (undefined3)((uint)iVar5 >> 8);
        cVar6 = vp44MessageTransmitter
                          (CONCAT22((short)CONCAT31(uVar4,bVar2),
                                    (short)CONCAT31(uVar4,vp44_retry_flag)),vp44_message_id);
        if (cVar6 != '\0') {
          messageErrorHandler(CONCAT22((short)CONCAT31(extraout_var_00,bVar2),vp44_message_id));
          vp44_response_buffer = 0;
          return;
        }
      }
      else {
        _vp44_timeout_counter = 0x19;
      }
    }
    else {
      uVar4 = (undefined3)((uint)in_D0 >> 8);
      cVar6 = vp44MessageTransmitter
                        (CONCAT22((short)CONCAT31(uVar4,bVar2),
                                  (short)CONCAT31(uVar4,vp44_retry_flag)),vp44_message_id);
      if (cVar6 != '\0') {
        messageErrorHandler(CONCAT22((short)CONCAT31(extraout_var,bVar2),vp44_message_id));
        vp44_response_buffer = 0;
        return;
      }
    }
  }
  return;
}



/*
 * Function: diagnosticStatusRequestHandler @ 0x0001c776
 */

void diagnosticStatusRequestHandler(can_std_rx_desc_t *rx_msg)

{
  word local_6;
  
  if ((diag_tp_state_t_00800f34.diag_state == 1) &&
     (diag_tp_state_t_00800f34.expected_id_low == (byte)rx_msg->id)) {
    local_6 = (ushort)rx_msg->data_ptr[6] << 8;
    if (local_6 == diag_tp_state_t_00800f34.expected_guard) {
      *diag_tp_state_t_00800f34.resp_byte_ptr = 9;
      diag_tp_state_t_00800f34.diag_state = 0;
    }
  }
  return;
}



/*
 * Function: diagnosticErrorHandler @ 0x0001c7ca
 */

void diagnosticErrorHandler(can_std_rx_desc_t *rx_msg)

{
  byte bVar1;
  word local_6;
  
  local_6 = (ushort)rx_msg->data_ptr[6] << 8;
  bVar1 = (byte)rx_msg->id;
  if (((diag_tp_state_t_00800f34.diag_state == 1) &&
      (bVar1 == diag_tp_state_t_00800f34.expected_id_low)) &&
     (local_6 == diag_tp_state_t_00800f34.expected_guard)) {
    *diag_tp_state_t_00800f34.resp_byte_ptr = 10;
    diag_tp_state_t_00800f34.diag_state = 0;
  }
  else if (((vp44_response_buffer == 1) && (bVar1 == vp44_expected_sequence)) &&
          (local_6 == vp44_message_id)) {
    vp44_response_buffer = 0;
  }
  return;
}



/*
 * Function: vp44CanMessageDispatcher @ 0x0001c846
 */

void vp44CanMessageDispatcher(can_std_rx_desc_t *rx_msg)

{
  byte bVar1;
  
  if (rx_msg->length == 8) {
    bVar1 = *rx_msg->data_ptr;
                    /* Constant: CAN_MSG_ALT_HANDLER = 17 */
    if (bVar1 == 0x11) {
      diagnosticParamRequestHandler(rx_msg);
      return;
    }
                    /* Constant: CAN_MSG_VP44_FUEL = 16 */
    if (bVar1 == 0x10) {
      vp44FuelTempHandler(rx_msg);
      return;
    }
    if (bVar1 == 0x13) {
      diagnosticStatusRequestHandler(rx_msg);
      return;
    }
                    /* Constant: CAN_MSG_ERROR_DEFAULT = 255 */
    if (bVar1 != 0xff) {
      return;
    }
    diagnosticErrorHandler(rx_msg);
  }
  return;
}



/*
 * Function: diagnosticParamRequestHandlerWrapper @ 0x0001c87e
 */

void diagnosticParamRequestHandlerWrapper(void)

{
  can_std_rx_desc_t *unaff_A2;
  
  diagnosticParamRequestHandler(unaff_A2);
  return;
}



/*
 * Function: vp44FuelTempHandlerWrapper @ 0x0001c88c
 */

void vp44FuelTempHandlerWrapper(void)

{
  can_std_rx_desc_t *unaff_A2;
  
  vp44FuelTempHandler(unaff_A2);
  return;
}



/*
 * Function: diagnosticStatusRequestHandlerWrapper @ 0x0001c89a
 */

void diagnosticStatusRequestHandlerWrapper(void)

{
  can_std_rx_desc_t *unaff_A2;
  
  diagnosticStatusRequestHandler(unaff_A2);
  return;
}



/*
 * Function: diagnosticErrorHandlerWrapper @ 0x0001c8a8
 */

void diagnosticErrorHandlerWrapper(void)

{
  can_std_rx_desc_t *unaff_A2;
  
  diagnosticErrorHandler(unaff_A2);
  return;
}



/*
 * Function: unknownMessageHandler @ 0x0001c8b6
 */

void unknownMessageHandler(uint param_1)

{
  byte *pbVar1;
  uint uVar2;
  int iVar3;
  byte bVar4;
  byte bVar5;
  byte *pbVar6;
  byte *pbVar7;
  
  uVar2 = param_1 >> 0x10 & 0xff;
  iVar3 = uVar2 * 0x20;
  pbVar6 = &debounce_state_flag + iVar3;
  if ((&debounce_countdown_array)[uVar2 * 0x10] != 0) {
    (&debounce_countdown_array)[uVar2 * 0x10] = (&debounce_countdown_array)[uVar2 * 0x10] - 1;
    return;
  }
  if ((&debounce_state_array_current)[iVar3] == (&j1939_multi_frame_debounce_state)[iVar3]) {
    bVar5 = (*(char *)(iVar3 + 0x800ee7) -
            *(char *)((int)&j1939_multi_frame_retry_counter + iVar3 + 1)) + 2;
    (&j1939_multi_frame_timeout_counter)[uVar2 * 0x10] = (ushort)bVar5;
    *pbVar6 = 0;
  }
  else {
    bVar5 = 8;
    (&j1939_multi_frame_timeout_counter)[uVar2 * 0x10] = 8;
    (&j1939_multi_frame_retry_counter)[uVar2 * 0x10] =
         (&j1939_multi_frame_retry_counter)[uVar2 * 0x10] + 7;
    (&debounce_countdown_array)[uVar2 * 0x10] = 5;
  }
  pbVar7 = (byte *)(&j1939_multi_frame_buffer_ptr)[uVar2 * 8];
  bVar4 = (&debounce_state_array_current)[iVar3];
  (&debounce_state_array_current)[iVar3] = (&debounce_state_array_current)[iVar3] + 1;
  *pbVar7 = bVar4;
  for (bVar4 = 0; pbVar7 = pbVar7 + 1, (int)(uint)bVar4 < (int)(bVar5 - 1); bVar4 = bVar4 + 1) {
    pbVar1 = (byte *)(&debounce_buffer_pointer_array)[uVar2 * 8];
    (&debounce_buffer_pointer_array)[uVar2 * 8] = (&debounce_buffer_pointer_array)[uVar2 * 8] + 1;
    *pbVar7 = *pbVar1;
  }
  sendCanSingleFrame((&j1939_multi_frame_pgn_data)[uVar2 * 8]);
  if ((&j1939_multi_frame_sequence_number)[iVar3] == 0) {
    if (*pbVar6 == 1) {
      *(undefined1 *)(&debounce_output_pointer_array)[uVar2 * 8] = 0x11;
      return;
    }
    *(undefined1 *)(&debounce_output_pointer_array)[uVar2 * 8] = 5;
    return;
  }
  *(byte *)(&debounce_output_pointer_array)[uVar2 * 8] = (&j1939_multi_frame_sequence_number)[iVar3]
  ;
  *pbVar6 = 0;
  return;
}



/*
 * Function: diagnosticMessageProcessor @ 0x0001c996
 */

void diagnosticMessageProcessor(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  char cVar4;
  byte bVar5;
  byte bVar6;
  byte *pbVar7;
  byte *pbVar8;
  
  bVar6 = diag_tp_state_t_00800f34.req_count;
  bVar3 = diag_tp_state_t_00800f34.req_start;
  if (diag_tp_state_t_00800f34.req_count == 0) {
    if (diag_tp_state_t_00800f34._18_2_ == 0) {
      *diag_tp_state_t_00800f34.resp_byte_ptr = 6;
      diag_tp_state_t_00800f34.diag_state = 0;
      return;
    }
    diag_tp_state_t_00800f34._18_2_ = diag_tp_state_t_00800f34._18_2_ + -1;
    return;
  }
  if (diag_tp_state_t_00800f34.req_count < 0xb) {
    diag_tp_state_t_00800f34.req_count = 0;
    diag_tp_state_t_00800f34.status_code = 0;
    diag_tp_state_t_00800f34.reserved_0x47 = 0x70;
  }
  else {
    bVar6 = 10;
    diag_tp_state_t_00800f34.req_start = diag_tp_state_t_00800f34.req_start + 10;
    diag_tp_state_t_00800f34.req_count = diag_tp_state_t_00800f34.req_count - 10;
  }
  pbVar8 = diag_tp_state_t_00800f34.src_data_ptr + (uint)bVar3 * 7 + -7;
  bVar5 = 0;
  cVar4 = bVar3 * '\a' + -7;
  while( true ) {
    pbVar7 = diag_tp_state_t_00800f34.tx_cm_buf;
    if (bVar6 <= bVar5) {
      return;
    }
    if (bVar3 == diag_tp_state_t_00800f34.total_packets) {
      bVar2 = ((char)diag_tp_state_t_00800f34.total_bytes - cVar4) + 1;
      diag_tp_state_t_00800f34.tx_length = (word)bVar2;
    }
    else {
      bVar2 = 8;
    }
    cVar4 = cVar4 + '\a';
    *diag_tp_state_t_00800f34.tx_cm_buf = bVar3;
    for (bVar1 = 0; pbVar7 = pbVar7 + 1, (int)(uint)bVar1 < (int)(bVar2 - 1); bVar1 = bVar1 + 1) {
      *pbVar7 = *pbVar8;
      pbVar8 = pbVar8 + 1;
    }
    sendCanSingleFrame(diag_tp_state_t_00800f34.tx_header_id);
    if (diag_tp_state_t_00800f34.pre_status != 0) break;
    *diag_tp_state_t_00800f34.resp_byte_ptr = 0x13;
    bVar5 = bVar5 + 1;
    bVar3 = bVar3 + 1;
  }
  *diag_tp_state_t_00800f34.resp_byte_ptr = 7;
  diag_tp_state_t_00800f34.diag_state = 0;
  return;
}



/*
 * Function: vp44ResponseTimeoutHandler @ 0x0001cabe
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44ResponseTimeoutHandler(void)

{
  if (_vp44_timeout_counter == 0) {
    vp44_response_buffer = 0;
    return;
  }
  _vp44_timeout_counter = _vp44_timeout_counter + -1;
  return;
}



/*
 * Function: messageQueueDispatcher @ 0x0001cad6
 */

void messageQueueDispatcher(void)

{
  ushort in_stack_00000000;
  
  if (debounce_state_flag == 1) {
    unknownMessageHandler((uint)in_stack_00000000);
  }
  if (j1939_multi_frame_active_flag == 1) {
    unknownMessageHandler(CONCAT22(1,in_stack_00000000));
  }
  if (diag_tp_state_t_00800f34.diag_state == 1) {
    diagnosticMessageProcessor();
  }
  if (vp44_response_buffer == 1) {
    vp44ResponseTimeoutHandler();
  }
  return;
}



/*
 * Function: multiPacketBufferAllocator @ 0x0001cb18
 */

undefined4 multiPacketBufferAllocator(undefined4 param_1)

{
  if (param_1._0_2_ < 9) {
    multi_packet_small_data_ptr = 0x800edc;
    multi_packet_small_size = param_1._0_2_;
    multi_packet_small_status_ptr = 0x800eda;
    return 0x800ecc;
  }
  if ((multi_packet_status_byte & 0xf0) != 0) {
    return 0;
  }
  multi_packet_data_ptr = 0x8007c4;
  multi_packet_buffer_size = param_1._0_2_;
  multi_packet_status_ptr = (dword)&multi_packet_status_byte;
  return 0x8007b4;
}



/*
 * Function: vp44DiagnosticBufferPointersInit @ 0x0001cb6e
 */

void vp44DiagnosticBufferPointersInit(void)

{
  j1939_multi_frame_buffer_ptr = 0x800f24;
  vp44_diag_buffer_2_ptr = 0x800f2c;
  diag_tp_state_t_00800f34.tx_cm_buf = (byte *)0x800f56;
  serial_buffer_pointer = 0x800f78;
  coreSystemControlFunction();
  coreSystemControlFunction();
  return;
}



/*
 * Function: fuelArbitratorResetHandler @ 0x0001cbc2
 */

void fuelArbitratorResetHandler(void)

{
  word wVar1;
  undefined4 unaff_A2;
  
  wVar1 = fuel_arbitrator_diag_t_0080cff8.rpm_target;
  fuel_arbitrator_prev_rpm_target = fuel_arbitrator_diag_t_0080cff8.rpm_target;
  fuel_arbitrator_diag_t_0080cff8.rpm_target = 0;
  fuel_arbitrator_diag_t_0080cff8.fuel_mode = 0;
  fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
  j1939MessageTypeCounter(CONCAT22(wVar1,(short)((uint)unaff_A2 >> 0x10)));
  torque_control_mode_timer = 0;
  fuel_arbitrator_response_timer = 0;
  return;
}



/*
 * Function: fuelArbitratorVariablesReset @ 0x0001cbfe
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelArbitratorVariablesReset(void)

{
  fuel_arbitrator_state = 0;
  retarder_mode_can_source_priority = 0;
  _retarder_mode_threshold_result = 0;
  _retarder_mode_table_count = 3;
  fuel_arbitrator_diag_t_0080cff8.throttle_mode = 0;
  retarder_control_mode_timer = 0;
  fuel_arbitrator_status_counter = 0;
  fuel_arbitrator_throttle_override = 0;
  _retarder_mode_override_flag = 0;
  return;
}



/*
 * Function: systemStatusProcessor @ 0x0001cc38
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint systemStatusProcessor(void)

{
  word wVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  ushort uVar5;
  undefined2 uVar6;
  undefined3 uVar7;
  uint uVar8;
  uint uVar9;
  undefined4 unaff_D2;
  bool bVar10;
  bool bVar11;
  bool bVar12;
  bool bVar13;
  
  uVar6 = (undefined2)((uint)unaff_D2 >> 0x10);
  bVar4 = false;
  bVar3 = false;
  bVar2 = false;
  if ((fuel_arbitrator_prev_speed_limit != fuel_arbitrator_diag_t_0080cff8.speed_limit) &&
     (fuel_arbitrator_diag_t_0080cff8.speed_limit == 1)) {
    fuel_arbitrator_status_timer = fuel_arbitrator_status_init + 1;
    bVar2 = true;
  }
  if (fuel_arbitrator_speed_timer != 0) {
    fuel_arbitrator_speed_timer = fuel_arbitrator_speed_timer - 1;
    bVar2 = true;
  }
  bVar10 = fuel_arbitrator_speed_timer == 1;
  if (bVar10) {
    fuel_arbitrator_diag_t_0080cff8.speed_limit = 0;
    _crank_state_transition_flag = 0;
    fuel_arbitrator_speed_timer = 0;
    fuel_arbitrator_status_timer = 0;
  }
  if (fuel_arbitrator_status_timer != 0) {
    fuel_arbitrator_status_timer = fuel_arbitrator_status_timer - 1;
  }
  if (fuel_arbitrator_status_timer == 1) {
    fuel_arbitrator_diag_t_0080cff8.speed_limit = 0;
    _crank_state_transition_flag = 1;
    fuel_arbitrator_speed_timer = io_control_timeout_table_base + 1;
  }
  if (((fuel_arbitrator_session_counter != 0) &&
      (fuel_arbitrator_session_counter = fuel_arbitrator_session_counter - 1,
      fuel_arbitrator_prev_session != fuel_arbitrator_diag_t_0080cff8.session_counter)) &&
     (fuel_arbitrator_diag_t_0080cff8.session_counter == 1)) {
    bVar2 = true;
  }
  bVar11 = fuel_arbitrator_session_counter == 1;
  if (bVar11) {
    fuel_arbitrator_diag_t_0080cff8.session_counter = 0;
    fuel_arbitrator_session_counter = 0;
  }
  if (((fuel_arbitrator_session_timer != 0) &&
      (fuel_arbitrator_session_timer = fuel_arbitrator_session_timer - 1,
      fuel_arbitrator_prev_fuel_limit != fuel_arbitrator_diag_t_0080cff8.fuel_limit)) &&
     (fuel_arbitrator_diag_t_0080cff8.fuel_limit == 1)) {
    bVar2 = true;
  }
  bVar12 = fuel_arbitrator_session_timer == 1;
  if (bVar12) {
    fuel_arbitrator_diag_t_0080cff8.fuel_limit = 0;
    fuel_arbitrator_session_timer = 0;
  }
  if (((fuel_arbitrator_throttle_override != 0) &&
      (fuel_arbitrator_throttle_override = fuel_arbitrator_throttle_override - 1,
      fuel_arbitrator_prev_throttle != fuel_arbitrator_diag_t_0080cff8.throttle_mode)) &&
     (fuel_arbitrator_diag_t_0080cff8.throttle_mode == 1)) {
    bVar2 = true;
  }
  bVar13 = fuel_arbitrator_throttle_override == 1;
  if (bVar13) {
    fuel_arbitrator_diag_t_0080cff8.throttle_mode = 0;
    fuel_arbitrator_throttle_override = 0;
  }
  bVar13 = bVar13 || (bVar12 || (bVar11 || bVar10));
  uVar5 = (short)fuel_arbitrator_diag_t_0080cff8.rpm_target >> 0xf;
  if (((fuel_arbitrator_diag_t_0080cff8.rpm_target == fuel_arbitrator_prev_rpm_target) &&
      (fuel_arbitrator_diag_t_0080cff8._28_2_ == fuel_arbitrator_prev_source)) &&
     ((byte)fuel_arbitrator_diag_t_0080cff8.limited_value == fuel_arbitrator_prev_limited)) {
    if (torque_control_mode_timer != 0) {
      torque_control_mode_timer = torque_control_mode_timer - 1;
    }
    if (fuel_arbitrator_response_timer != 0) {
      fuel_arbitrator_response_timer = fuel_arbitrator_response_timer - 1;
    }
    uVar8 = (uint)(short)fuel_arbitrator_diag_t_0080cff8.rpm_target;
    uVar9 = uVar8;
    if (uVar8 < 4) {
      uVar9 = CONCAT22(uVar5,(&switchD_0001ce60::switchdataD_0001ce64)[uVar8]);
      uVar7 = (undefined3)(uVar9 >> 8);
      switch(uVar8) {
      case 1:
        if (torque_control_mode_timer == 1) {
          uVar9 = fuelArbitratorResetHandler();
          bVar13 = true;
        }
        else if (fuel_arbitrator_response_timer == 1) {
          ioControlEntryAdd(CONCAT22(fuel_arbitrator_diag_t_0080cff8._28_2_,
                                     (short)CONCAT31(uVar7,(byte)fuel_arbitrator_diag_t_0080cff8.
                                                                 limited_value)),CONCAT22(1,uVar6));
          uVar9 = fuelArbitratorResetHandler();
        }
        break;
      case 2:
        if (torque_control_mode_timer == 1) {
          uVar9 = fuelArbitratorResetHandler();
          bVar13 = true;
        }
        else if ((fuel_arbitrator_response_timer == 1) &&
                (fuel_arbitrator_diag_t_0080cff8.fuel_limit == 0)) {
          ioControlEntryAdd(CONCAT22(fuel_arbitrator_diag_t_0080cff8._28_2_,
                                     (short)CONCAT31(uVar7,(byte)fuel_arbitrator_diag_t_0080cff8.
                                                                 limited_value)),CONCAT22(2,uVar6));
          uVar9 = fuelArbitratorResetHandler();
        }
        break;
      case 3:
        if (torque_control_mode_timer == 1) {
          uVar9 = fuelArbitratorResetHandler();
          bVar13 = true;
        }
      }
    }
  }
  else {
    uVar8 = (uint)(short)fuel_arbitrator_diag_t_0080cff8.rpm_target;
    uVar9 = uVar8;
    if (uVar8 < 4) {
      uVar9 = (uint)uVar5 << 0x10;
      switch(uVar8) {
      case 0:
        fuel_arbitrator_response_timer = 0;
        break;
      case 1:
        fuel_arbitrator_response_timer = *(short *)(_timer_capture_value + 6) + 1;
        uVar9 = CONCAT22(uVar5,fuel_arbitrator_response_timer);
        bVar2 = true;
        break;
      case 2:
        fuel_arbitrator_response_timer = *(short *)(_timer_capture_value + 10) + 1;
        uVar9 = CONCAT22(uVar5,fuel_arbitrator_response_timer);
        bVar2 = true;
        break;
      case 3:
        fuel_arbitrator_response_timer = 0;
        bVar2 = true;
      }
    }
    if (fuel_arbitrator_prev_source == 0) {
      uVar9 = j1939MessageTypeCounter(CONCAT22(fuel_arbitrator_prev_rpm_target,uVar6));
    }
  }
  if (bVar13) {
    if (fuel_arbitrator_diag_t_0080cff8._28_2_ == 1) {
      bVar4 = true;
    }
    else {
      bVar3 = true;
    }
  }
  else if (bVar2) {
    if (fuel_arbitrator_diag_t_0080cff8._28_2_ == 1) {
      fuel_arbitrator_source_1_flag = 1;
    }
    else {
      fuel_arbitrator_source_2_flag = 1;
    }
  }
  fuel_arbitrator_prev_rpm_target = fuel_arbitrator_diag_t_0080cff8.rpm_target;
  fuel_arbitrator_prev_source = fuel_arbitrator_diag_t_0080cff8._28_2_;
  fuel_arbitrator_prev_limited = (byte)fuel_arbitrator_diag_t_0080cff8.limited_value;
  fuel_arbitrator_prev_speed_limit = fuel_arbitrator_diag_t_0080cff8.speed_limit;
  fuel_arbitrator_prev_session = fuel_arbitrator_diag_t_0080cff8.session_counter;
  fuel_arbitrator_prev_fuel_limit = fuel_arbitrator_diag_t_0080cff8.fuel_limit;
  fuel_arbitrator_prev_throttle = fuel_arbitrator_diag_t_0080cff8.throttle_mode;
  uVar9 = CONCAT22((short)(uVar9 >> 0x10),fuel_arbitrator_state);
  if (fuel_arbitrator_state == fuel_arbitrator_prev_state) {
    uVar9 = (uint)_retarder_control_can_source;
    if (uVar9 == fuel_arbitrator_prev_byte) {
      if (retarder_control_mode_timer != 0) {
        retarder_control_mode_timer = retarder_control_mode_timer - 1;
      }
      if (fuel_arbitrator_status_counter != 0) {
        fuel_arbitrator_status_counter = fuel_arbitrator_status_counter - 1;
      }
      if (fuel_arbitrator_state == 2) {
        if (retarder_control_mode_timer == 1) {
          uVar9 = fuelArbitratorVariablesReset();
          bVar4 = true;
        }
        else if (fuel_arbitrator_status_counter == 1) {
          ioControlTimeoutEntryAdd(CONCAT22(_retarder_control_can_source,uVar6));
          uVar9 = fuelArbitratorVariablesReset();
        }
      }
      else if ((fuel_arbitrator_state == 3) && (retarder_control_mode_timer == 1)) {
        uVar9 = fuelArbitratorVariablesReset();
        bVar4 = true;
      }
      goto LAB_0001d026;
    }
  }
  if (fuel_arbitrator_state == 2) {
    fuel_arbitrator_status_counter = *(short *)(_retarder_control_mode_state + 0x10) + 1;
    uVar9 = CONCAT22((short)(uVar9 >> 0x10),fuel_arbitrator_status_counter);
    fuel_arbitrator_source_1_flag = 1;
  }
  else {
    fuel_arbitrator_status_counter = 0;
    if (fuel_arbitrator_state == 3) {
      fuel_arbitrator_source_1_flag = 1;
    }
  }
LAB_0001d026:
  fuel_arbitrator_prev_state = fuel_arbitrator_state;
  fuel_arbitrator_prev_byte = retarder_control_source_byte;
  if (bVar3) {
    uVar9 = (uint)fuel_arbitrator_overflow_counter_1;
    if ((int)uVar9 < (int)(io_control_index_limit - 1)) {
      fuel_arbitrator_overflow_counter_1 = fuel_arbitrator_overflow_counter_1 + 1;
    }
    else {
      io_fault_status_reg_4 = io_fault_status_reg_4 | 8;
      io_fault_latch_reg_4 = io_fault_latch_reg_4 | 8;
      fuel_arbitrator_overflow_counter_1 = 0;
    }
    fuel_arbitrator_source_2_flag = 0;
  }
  else if (fuel_arbitrator_source_2_flag == 1) {
    uVar6 = (undefined2)(uVar9 >> 0x10);
    wVar1 = io_fault_status_reg_4;
    if (((io_fault_status_reg_4 & 8) == 0) ||
       (wVar1 = fault_mask_flags_1, (fault_mask_flags_1 & 8) == 0)) {
      uVar9 = CONCAT22(uVar6,wVar1) & 0xffff0008;
      fuel_arbitrator_source_2_flag = 0;
    }
    else {
      uVar9 = CONCAT22(uVar6,io_fault_status_reg_4) & 0xffff0008;
      if ((io_fault_status_reg_4 & 8) != 0) {
        uVar9 = CONCAT22(uVar6,io_fault_latch_reg_4) & 0xffff0008;
        if ((io_fault_latch_reg_4 & 8) == 0) {
          io_fault_status_reg_4 = io_fault_status_reg_4 & 0xfff7;
          fuel_arbitrator_source_2_flag = 0;
          fuel_arbitrator_overflow_counter_1 = 0;
        }
      }
    }
  }
  if (bVar4) {
    uVar9 = (uint)fuel_arbitrator_overflow_counter_2;
    if ((int)uVar9 < (int)(io_control_index_limit - 1)) {
      fuel_arbitrator_overflow_counter_2 = fuel_arbitrator_overflow_counter_2 + 1;
    }
    else {
      io_fault_status_reg_2 = io_fault_status_reg_2 | 0x400;
      io_fault_latch_reg_2 = io_fault_latch_reg_2 | 0x400;
    }
    fuel_arbitrator_source_1_flag = 0;
    return uVar9;
  }
  if (fuel_arbitrator_source_1_flag == 1) {
    uVar6 = (undefined2)(uVar9 >> 0x10);
    wVar1 = io_fault_status_reg_2;
    if (((io_fault_status_reg_2 & 0x400) == 0) ||
       (wVar1 = _engine_mode_output_control_state_68ce,
       (_engine_mode_output_control_state_68ce & 0x400) == 0)) {
      uVar9 = CONCAT22(uVar6,wVar1) & 0xffff0400;
      fuel_arbitrator_source_1_flag = 0;
    }
    else {
      uVar9 = CONCAT22(uVar6,io_fault_status_reg_2) & 0xffff0400;
      if ((io_fault_status_reg_2 & 0x400) != 0) {
        uVar9 = CONCAT22(uVar6,io_fault_latch_reg_2) & 0xffff0400;
        if ((io_fault_latch_reg_2 & 0x400) == 0) {
          io_fault_status_reg_2 = io_fault_status_reg_2 & 0xfbff;
          fuel_arbitrator_source_1_flag = 0;
          fuel_arbitrator_overflow_counter_2 = 0;
          return uVar9;
        }
      }
    }
  }
  return uVar9;
}



/*
 * Function: diagnosticMessageValidator @ 0x0001d19c
 */

uint diagnosticMessageValidator(undefined4 param_1,undefined4 param_2)

{
  uint in_D0;
  byte bVar1;
  word *pwVar2;
  
  pwVar2 = &io_control_entry_table_base;
  bVar1 = 0;
  while( true ) {
    if (scheduler_cycle_counter <= bVar1) {
      return in_D0 & 0xffff0000;
    }
    if (((param_1._0_2_ == *pwVar2) && ((char)param_1 == *(char *)(pwVar2 + 1))) &&
       (param_2._0_2_ == pwVar2[2])) break;
    pwVar2 = pwVar2 + 4;
    bVar1 = bVar1 + 1;
  }
  pwVar2[3] = io_control_timeout_table_base;
  return 1;
}



/*
 * Function: ioControlTimeoutTableLookup @ 0x0001d1ec
 */

uint ioControlTimeoutTableLookup(undefined4 param_1)

{
  uint in_D0;
  byte bVar1;
  byte *pbVar2;
  
  pbVar2 = &diagnostic_queue_data_array;
  bVar1 = 0;
  while( true ) {
    if (scheduler_phase_flag <= bVar1) {
      return in_D0 & 0xffff0000;
    }
    if ((byte)((uint)param_1 >> 0x10) == *pbVar2) break;
    pbVar2 = pbVar2 + 4;
    bVar1 = bVar1 + 1;
  }
  *(word *)(pbVar2 + 2) = io_control_timeout_table_base;
  return 1;
}



/*
 * Function: ioControlEntryAdd @ 0x0001d228
 */

void ioControlEntryAdd(undefined4 param_1,undefined4 param_2)

{
  uint uVar1;
  
  if (scheduler_cycle_counter < 5) {
    uVar1 = (uint)scheduler_cycle_counter;
    scheduler_cycle_counter = scheduler_cycle_counter + 1;
    (&io_control_entry_table_base)[uVar1 * 4] = param_1._0_2_;
    (&io_control_command_array)[uVar1 * 8] = (byte)param_1;
    (&io_control_param_array)[uVar1 * 4] = param_2._0_2_;
    (&io_control_timeout_array)[uVar1 * 4] = io_control_timeout_table_base;
  }
  return;
}



/*
 * Function: ioControlTimeoutEntryAdd @ 0x0001d268
 */

void ioControlTimeoutEntryAdd(undefined4 param_1)

{
  uint uVar1;
  
  if (scheduler_phase_flag < 5) {
    uVar1 = (uint)scheduler_phase_flag;
    scheduler_phase_flag = scheduler_phase_flag + 1;
    (&diagnostic_queue_data_array)[uVar1 * 4] = param_1._1_1_;
    (&io_control_timeout_table_entry)[uVar1 * 2] = io_control_timeout_table_base;
  }
  return;
}



/*
 * Function: phase3_countdown_timer_manager @ 0x0001d29c
 */

void phase3_countdown_timer_manager(void)

{
  word wVar1;
  short sVar2;
  uint uVar3;
  byte bVar4;
  byte *pbVar5;
  word *pwVar6;
  
  if (scheduler_cycle_counter != 0) {
    pwVar6 = &fuel_arbitrator_prev_fuel_limit + (uint)scheduler_cycle_counter * 4;
    for (bVar4 = scheduler_cycle_counter; bVar4 != 0; bVar4 = bVar4 - 1) {
      wVar1 = pwVar6[3] - 1;
      pwVar6[3] = wVar1;
      if (wVar1 == 0) {
        if (bVar4 == scheduler_cycle_counter) {
          scheduler_cycle_counter = scheduler_cycle_counter - 1;
        }
        else {
          scheduler_cycle_counter = scheduler_cycle_counter - 1;
          uVar3 = (uint)scheduler_cycle_counter;
          *pwVar6 = (&io_control_entry_table_base)[uVar3 * 4];
          *(byte *)(pwVar6 + 1) = (&io_control_command_array)[uVar3 * 8];
          pwVar6[2] = (&io_control_param_array)[uVar3 * 4];
          pwVar6[3] = (&io_control_timeout_array)[uVar3 * 4];
        }
      }
      pwVar6 = pwVar6 + -4;
    }
  }
  if (scheduler_phase_flag != 0) {
    pbVar5 = (byte *)((uint)scheduler_phase_flag * 4 + 0x801656);
    for (bVar4 = scheduler_phase_flag; bVar4 != 0; bVar4 = bVar4 - 1) {
      sVar2 = *(short *)(pbVar5 + 2) + -1;
      *(short *)(pbVar5 + 2) = sVar2;
      if (sVar2 == 0) {
        if (bVar4 == scheduler_phase_flag) {
          scheduler_phase_flag = scheduler_phase_flag - 1;
        }
        else {
          scheduler_phase_flag = scheduler_phase_flag - 1;
          uVar3 = (uint)scheduler_phase_flag;
          *pbVar5 = (&diagnostic_queue_data_array)[uVar3 * 4];
          *(word *)(pbVar5 + 2) = (&io_control_timeout_table_entry)[uVar3 * 2];
        }
      }
      pbVar5 = pbVar5 + -4;
    }
  }
  return;
}



/*
 * Function: diagnosticStateInitializer @ 0x0001d34e
 */

void diagnosticStateInitializer(undefined4 param_1)

{
  uint uVar1;
  byte bVar2;
  word *pwVar3;
  
  if (scheduler_cycle_counter != 0) {
    pwVar3 = &fuel_arbitrator_prev_fuel_limit + (uint)scheduler_cycle_counter * 4;
    for (bVar2 = scheduler_cycle_counter; bVar2 != 0; bVar2 = bVar2 - 1) {
      if ((param_1._0_2_ == *pwVar3) && ((char)param_1 == *(char *)(pwVar3 + 1))) {
        if (bVar2 == scheduler_cycle_counter) {
          scheduler_cycle_counter = scheduler_cycle_counter - 1;
        }
        else {
          scheduler_cycle_counter = scheduler_cycle_counter - 1;
          uVar1 = (uint)scheduler_cycle_counter;
          *pwVar3 = (&io_control_entry_table_base)[uVar1 * 4];
          *(byte *)(pwVar3 + 1) = (&io_control_command_array)[uVar1 * 8];
          pwVar3[2] = (&io_control_param_array)[uVar1 * 4];
          pwVar3[3] = (&io_control_timeout_array)[uVar1 * 4];
        }
      }
      pwVar3 = pwVar3 + -4;
    }
  }
  return;
}



/*
 * Function: ioControlEntryRemove @ 0x0001d3b8
 */

void ioControlEntryRemove(undefined4 param_1)

{
  uint uVar1;
  byte bVar2;
  byte *pbVar3;
  
  if (scheduler_phase_flag != 0) {
    pbVar3 = (byte *)((uint)scheduler_phase_flag * 4 + 0x801656);
    for (bVar2 = scheduler_phase_flag; bVar2 != 0; bVar2 = bVar2 - 1) {
      if ((byte)((uint)param_1 >> 0x10) == *pbVar3) {
        if (bVar2 == scheduler_phase_flag) {
          scheduler_phase_flag = scheduler_phase_flag - 1;
        }
        else {
          scheduler_phase_flag = scheduler_phase_flag - 1;
          uVar1 = (uint)scheduler_phase_flag;
          *pbVar3 = (&diagnostic_queue_data_array)[uVar1 * 4];
          *(word *)(pbVar3 + 2) = (&io_control_timeout_table_entry)[uVar1 * 2];
        }
      }
      pbVar3 = pbVar3 + -4;
    }
  }
  return;
}



/*
 * Function: ioControlRegisterBitMapper @ 0x0001d40c
 */

uint ioControlRegisterBitMapper(void)

{
  undefined2 uVar1;
  undefined2 uVar2;
  undefined4 in_D0;
  uint uVar3;
  
  if ((io_control_active_mask & 0x20) == 0) {
    io_control_source_register = io_control_source_register & 0xdf;
  }
  else {
    io_control_source_register = io_control_source_register | 0x20;
  }
  if ((io_control_active_mask & 4) == 0) {
    io_control_source_register = io_control_source_register & 0xef;
  }
  else {
    io_control_source_register = io_control_source_register | 0x10;
  }
  if ((io_control_active_mask & 0x40) == 0) {
    io_control_source_register = io_control_source_register & 0xf7;
  }
  else {
    io_control_source_register = io_control_source_register | 8;
  }
  if ((io_control_active_mask & 1) == 0) {
    io_control_source_register = io_control_source_register & 0xfd;
  }
  else {
    io_control_source_register = io_control_source_register | 2;
  }
  uVar1 = (short)((uint)in_D0 >> 0x10);
  if ((io_control_active_mask & 8) == 0) {
    uVar2 = 0;
    uVar1 = 0;
    if ((output_control_status_byte & 4) == 0) {
      io_control_source_register = io_control_source_register & 0xfe;
      goto LAB_0001d486;
    }
  }
  uVar2 = uVar1;
  io_control_source_register = io_control_source_register | 1;
LAB_0001d486:
  if ((io_control_active_mask & 2) == 0) {
    io_control_source_register = io_control_source_register & 0xbf;
  }
  else {
    io_control_source_register = io_control_source_register | 0x40;
  }
  uVar3 = CONCAT22(uVar2,io_control_active_mask) & 0xffff0010;
  if ((io_control_active_mask & 0x10) == 0) {
    uVar3 = output_control_status_byte & 8;
    if ((output_control_status_byte & 8) == 0) {
      io_control_source_register = io_control_source_register & 0xfb;
      return uVar3;
    }
  }
  io_control_source_register = io_control_source_register | 4;
  return uVar3;
}



/*
 * Function: ioControlStateMachineWithDelay @ 0x0001d4bc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint ioControlStateMachineWithDelay(void)

{
  uint uVar1;
  
  if ((io_control_source_register & 1) == 0) {
    _io_control_bit0_state = 0;
  }
  else if (_io_control_bit0_state == 0) {
    _io_control_bit0_state = 1;
  }
  else if (_io_control_bit0_state == 1) {
    if ((io_control_state_delay & 1) != 0) {
      _io_control_bit0_state = 2;
      io_control_delay_timer = 0;
    }
  }
  else if (_io_control_bit0_state == 2) {
    if (io_control_delay_timer < 10) {
      io_control_delay_timer = io_control_delay_timer + 1;
    }
    else {
      _io_control_bit0_state = 1;
      io_control_delay_timer = 0;
    }
  }
  if ((io_control_source_register & 2) == 0) {
    _io_control_bit1_state = 0;
  }
  else if (_io_control_bit1_state == 0) {
    _io_control_bit1_state = 1;
  }
  else if (_io_control_bit1_state == 1) {
    if ((io_control_state_delay & 2) != 0) {
      _io_control_bit1_state = 2;
      io_control_state_1 = 0;
    }
  }
  else if (_io_control_bit1_state == 2) {
    if (io_control_state_1 < 10) {
      io_control_state_1 = io_control_state_1 + 1;
    }
    else {
      _io_control_bit1_state = 1;
      io_control_state_1 = 0;
    }
  }
  if ((io_control_source_register & 4) == 0) {
    accumulated_backup_eps_period_between_vss_interrupts_0_65535 = 0;
  }
  else if (accumulated_backup_eps_period_between_vss_interrupts_0_65535 == 0) {
    accumulated_backup_eps_period_between_vss_interrupts_0_65535 = 1;
  }
  else if (accumulated_backup_eps_period_between_vss_interrupts_0_65535 == 1) {
    if ((io_control_state_delay & 4) != 0) {
      accumulated_backup_eps_period_between_vss_interrupts_0_65535 = 2;
      io_control_state_2 = 0;
    }
  }
  else if (accumulated_backup_eps_period_between_vss_interrupts_0_65535 == 2) {
    if (io_control_state_2 < 10) {
      io_control_state_2 = io_control_state_2 + 1;
    }
    else {
      accumulated_backup_eps_period_between_vss_interrupts_0_65535 = 1;
      io_control_state_2 = 0;
    }
  }
  if ((io_control_source_register & 0x40) == 0) {
    _io_control_bit6_state = 0;
  }
  else if (_io_control_bit6_state == 0) {
    _io_control_bit6_state = 1;
  }
  else if (_io_control_bit6_state == 1) {
    if ((io_control_state_delay & 0x40) != 0) {
      _io_control_bit6_state = 2;
      io_control_state_3 = 0;
    }
  }
  else if (_io_control_bit6_state == 2) {
    if (io_control_state_3 < 10) {
      io_control_state_3 = io_control_state_3 + 1;
    }
    else {
      _io_control_bit6_state = 1;
      io_control_state_3 = 0;
    }
  }
  if ((io_control_source_register & 0x10) == 0) {
    _io_control_bit4_state = 0;
  }
  else if (_io_control_bit4_state == 0) {
    _io_control_bit4_state = 1;
  }
  else if (_io_control_bit4_state == 1) {
    if ((io_control_state_delay & 0x10) != 0) {
      _io_control_bit4_state = 2;
      io_control_state_4 = 0;
    }
  }
  else if (_io_control_bit4_state == 2) {
    if (io_control_state_4 < 10) {
      io_control_state_4 = io_control_state_4 + 1;
    }
    else {
      _io_control_bit4_state = 1;
      io_control_state_4 = 0;
    }
  }
  if ((io_control_source_register & 0x20) == 0) {
    number_of_backup_eps_interrupts_between_vss_interrupts_0_65535 = 0;
  }
  else if (number_of_backup_eps_interrupts_between_vss_interrupts_0_65535 == 0) {
    number_of_backup_eps_interrupts_between_vss_interrupts_0_65535 = 1;
  }
  else if (number_of_backup_eps_interrupts_between_vss_interrupts_0_65535 == 1) {
    if ((io_control_state_delay & 0x20) != 0) {
      number_of_backup_eps_interrupts_between_vss_interrupts_0_65535 = 2;
      io_control_state_5 = 0;
    }
  }
  else if (number_of_backup_eps_interrupts_between_vss_interrupts_0_65535 == 2) {
    if (io_control_state_5 < 10) {
      io_control_state_5 = io_control_state_5 + 1;
    }
    else {
      number_of_backup_eps_interrupts_between_vss_interrupts_0_65535 = 1;
      io_control_state_5 = 0;
    }
  }
  if ((io_control_source_register & 8) == 0) {
    _io_control_handshake_state = 0;
    return io_control_source_register & 8;
  }
  uVar1 = (uint)_io_control_handshake_state;
  if (_io_control_handshake_state == 0) {
    _io_control_handshake_state = 1;
    return uVar1;
  }
  if (_io_control_handshake_state == 1) {
    if ((io_control_state_delay & 8) != 0) {
      _io_control_handshake_state = 2;
      io_control_state_6 = 0;
      return uVar1;
    }
  }
  else {
    if (_io_control_handshake_state != 2) {
      return uVar1;
    }
    if (9 < io_control_state_6) {
      _io_control_handshake_state = 1;
      io_control_state_6 = 0;
      return uVar1;
    }
    io_control_state_6 = io_control_state_6 + 1;
  }
  return uVar1;
}



/*
 * Function: ioControlPinSwitchingWrapper @ 0x0001d7d2
 */

void ioControlPinSwitchingWrapper(void)

{
  ioControlRegisterBitMapper();
  ioControlStateMachineWithDelay();
  return;
}



/*
 * Function: initIoControlRegister @ 0x0001d7dc
 */

void initIoControlRegister(void)

{
  io_control_source_register = io_control_source_register & 0xfe;
  io_control_delay_timer = 0;
  return;
}



/*
 * Function: initTimerCounterDefaults @ 0x0001d7ec
 */

void initTimerCounterDefaults(void)

{
  io_control_mask_state_active = 1;
  diagnostic_queue_init_flag = 1;
  fault_code_display_state = 0x7d;
  diagnostic_queue_active_flag = 0;
  return;
}



/*
 * Function: ioControlMaskStateMachine @ 0x0001d80c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void ioControlMaskStateMachine(void)

{
  word wVar1;
  word *pwVar2;
  
  if (diagnostic_queue_init_flag != 0) {
    for (pwVar2 = &io_control_mask_state_array; pwVar2 < (word *)0x808787; pwVar2 = pwVar2 + 1) {
      io_control_active_mask = *pwVar2 | io_control_active_mask;
    }
    diagnostic_queue_init_flag = 0;
    io_control_mask_state_1 = 0x28;
    _io_control_mask_state_2 = &io_control_mask_state_array;
    return;
  }
  io_control_mask_toggle = io_control_mask_toggle + 1;
  wVar1 = io_control_mask_state_1;
  if (io_control_mask_toggle == io_control_mask_state_1) {
    io_control_active_mask = ~*_io_control_mask_state_2 & io_control_active_mask;
    _io_control_mask_state_2 = _io_control_mask_state_2 + 1;
    wVar1 = io_control_mask_state_1 + 10;
    if ((*_io_control_mask_state_2 == 0) || ((ushort *)0x808786 < _io_control_mask_state_2)) {
      if (diagnostic_queue_active_flag != 1) {
        diagnostic_queue_active_flag = 1;
        io_control_mask_state_1 = io_control_mask_state_1 + 0x1e;
        return;
      }
      io_control_mask_state_active = 0;
      diagnostic_queue_counter_1 = 0;
      fault_code_display_counter = 0;
      diagnostic_queue_counter_2 = 0;
    }
  }
  io_control_mask_state_1 = wVar1;
  return;
}



/*
 * Function: ioControlToggleCycle @ 0x0001d8cc
 */

uint ioControlToggleCycle(void)

{
  uint in_D0;
  
  if (io_toggle_cycle_counter == 0) {
    io_control_active_mask = io_control_active_mask | 1;
  }
  else if (io_toggle_cycle_counter == 10) {
    io_control_active_mask = io_control_active_mask & 0xfffe;
  }
  else if (io_toggle_cycle_counter == 0x14) {
    io_toggle_cycle_counter = 0;
    return 1;
  }
  io_toggle_cycle_counter = io_toggle_cycle_counter + 1;
  return in_D0 & 0xffffff00;
}



/*
 * Function: ioControlLampStateMachine @ 0x0001d904
 */

undefined1 ioControlLampStateMachine(void)

{
  undefined1 uVar1;
  
  uVar1 = 1;
  if (high_rpm_protection_warning_flag == 0) {
    if (diagnostic_queue_pending_flag_1 != 0) {
      diagnostic_queue_pending_flag_1 = 0;
      lamp_2_blink_counter = 0;
      io_control_active_mask = io_control_active_mask & 0xfffd;
    }
  }
  else {
    uVar1 = 0;
    if (lamp_2_blink_counter == 0) {
      io_control_active_mask = io_control_active_mask | 2;
      lamp_2_blink_counter = 1;
    }
    else if (lamp_2_blink_counter == lamp_blink_on_duration) {
      io_control_active_mask = io_control_active_mask & 0xfffd;
      lamp_2_blink_counter = lamp_2_blink_counter + 1;
    }
    else if (((uint)lamp_blink_on_duration + (uint)lamp_blink_off_duration) - 1 ==
             (uint)lamp_2_blink_counter) {
      lamp_2_blink_counter = 0;
    }
    else {
      lamp_2_blink_counter = lamp_2_blink_counter + 1;
    }
    diagnostic_queue_pending_flag_1 = 1;
  }
  if (lamp_3_blink_trigger == 0) {
    if (diagnostic_queue_pending_flag_2 != 0) {
      diagnostic_queue_pending_flag_2 = 0;
      lamp_3_blink_counter = 0;
      io_control_active_mask = io_control_active_mask & 0xfffb;
    }
  }
  else {
    uVar1 = 0;
    if (lamp_3_blink_counter == 0) {
      io_control_active_mask = io_control_active_mask | 4;
      lamp_3_blink_counter = 1;
    }
    else if (lamp_3_blink_counter == lamp_blink_on_duration) {
      io_control_active_mask = io_control_active_mask & 0xfffb;
      lamp_3_blink_counter = lamp_3_blink_counter + 1;
    }
    else if (((uint)lamp_blink_on_duration + (uint)lamp_blink_off_duration) - 1 ==
             (uint)lamp_3_blink_counter) {
      lamp_3_blink_counter = 0;
    }
    else {
      lamp_3_blink_counter = lamp_3_blink_counter + 1;
    }
    diagnostic_queue_pending_flag_2 = 1;
  }
  return uVar1;
}



/*
 * Function: ioControlDigitDisplaySequencer @ 0x0001d9ea
 */

uint ioControlDigitDisplaySequencer(undefined4 param_1)

{
  ushort uVar1;
  undefined3 uVar2;
  uint in_D0;
  
  if (fault_code_display_value == 0) {
    io_control_active_mask = io_control_active_mask & 0xfffe | 2;
    fault_code_display_value = 1;
    digit_display_hundreds_digit = (byte)(param_1._0_2_ / 100);
    digit_display_tens_digit = (char)(param_1._0_2_ / 10) + digit_display_hundreds_digit * -10;
    uVar1 = (short)(param_1._0_2_ / 10) * 10;
    in_D0 = (uint)uVar1;
    digit_display_ones_digit = (char)((uint)param_1 >> 0x10) - (char)uVar1;
  }
  else {
    uVar2 = (undefined3)(in_D0 >> 8);
    if (fault_code_display_value == 0x28) {
      io_control_active_mask = io_control_active_mask & 0xfffd;
      in_D0 = CONCAT31(uVar2,digit_display_sequencer_state);
      if (digit_display_sequencer_state == digit_display_hundreds_digit) {
        digit_display_sequencer_state = 0;
        fault_code_display_value = 0x29;
      }
      else {
        in_D0 = ioControlToggleCycle();
        if ((char)in_D0 != '\0') {
          digit_display_sequencer_state = digit_display_sequencer_state + 1;
        }
      }
    }
    else if (fault_code_display_value == 0x50) {
      in_D0 = CONCAT31(uVar2,digit_display_sequencer_state);
      if (digit_display_sequencer_state == digit_display_tens_digit) {
        digit_display_sequencer_state = 0;
        fault_code_display_value = 0x51;
      }
      else {
        in_D0 = ioControlToggleCycle();
        if ((char)in_D0 != '\0') {
          digit_display_sequencer_state = digit_display_sequencer_state + 1;
        }
      }
    }
    else if (fault_code_display_value == 0x78) {
      in_D0 = CONCAT31(uVar2,digit_display_sequencer_state);
      if (digit_display_sequencer_state == digit_display_ones_digit) {
        digit_display_sequencer_state = 0;
        fault_code_display_value = 0x79;
      }
      else {
        in_D0 = ioControlToggleCycle();
        if ((char)in_D0 != '\0') {
          digit_display_sequencer_state = digit_display_sequencer_state + 1;
        }
      }
    }
    else {
      if (fault_code_display_value != 0xa0) {
        fault_code_display_value = fault_code_display_value + 1;
        return 1;
      }
      fault_code_display_value = 0;
    }
  }
  return in_D0 & 0xffffff00;
}



/*
 * Function: activeFaultCodeIteratorForward @ 0x0001dae8
 */

byte activeFaultCodeIteratorForward(undefined4 param_1)

{
  byte bVar1;
  
  if (diagnostic_pending_code_count == 0) {
    bVar1 = 0x7d;
  }
  else {
    if ((param_1._1_1_ == '}') ||
       (active_fault_code_iterator = active_fault_code_iterator + 1,
       diagnostic_state_machine_index < active_fault_code_iterator)) {
      active_fault_code_iterator = 1;
    }
    bVar1 = (&diagnostic_pending_code_count)[(short)(ushort)active_fault_code_iterator];
  }
  return bVar1;
}



/*
 * Function: activeFaultCodeIteratorBackward @ 0x0001db2e
 */

byte activeFaultCodeIteratorBackward(undefined4 param_1)

{
  byte bVar1;
  
  if (diagnostic_pending_code_count == 0) {
    bVar1 = 0x7d;
  }
  else {
    if ((param_1._1_1_ == '}') ||
       (active_fault_code_iterator = active_fault_code_iterator - 1, active_fault_code_iterator == 0
       )) {
      active_fault_code_iterator = (byte)diagnostic_state_machine_index;
    }
    bVar1 = (&diagnostic_pending_code_count)[(short)(ushort)active_fault_code_iterator];
  }
  return bVar1;
}



/*
 * Function: faultCodeDisplayController @ 0x0001db66
 */

uint faultCodeDisplayController(void)

{
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  byte bVar2;
  uint uVar1;
  undefined4 unaff_D2;
  undefined2 uVar3;
  
  uVar3 = (undefined2)((uint)unaff_D2 >> 0x10);
  if (((derate_status_byte & 0x80) != 0) && (engine_operating_mode == ENGINE_IDLE)) {
    fault_code_display_mode = 1;
    if (((derate_status_byte & 0x80) == 0) || (diagnostic_queue_counter_2 != 0)) {
      if (((derate_status_byte & 0x20) == 0) || (diagnostic_queue_counter_1 != 0)) {
        uVar1 = 0;
        if (((derate_status_byte & 0x40) != 0) && (fault_code_display_counter == 0)) {
          bVar2 = activeFaultCodeIteratorBackward((uint)CONCAT12(fault_code_display_state,uVar3));
          uVar1 = CONCAT31(extraout_var_01,bVar2);
          if ((bVar2 != 0x7d) &&
             (uVar1 = 0, (*(ushort *)(&dtc_fault_table_base + (uint)bVar2 * 6) & 0x40) == 0)) {
            io_control_active_mask = io_control_active_mask & 0xfffc;
            fault_code_display_value = 0;
            io_toggle_cycle_counter = 0;
            digit_display_sequencer_state = 0;
            fault_code_display_state = bVar2;
          }
        }
      }
      else {
        bVar2 = activeFaultCodeIteratorForward((uint)CONCAT12(fault_code_display_state,uVar3));
        uVar1 = CONCAT31(extraout_var_00,bVar2);
        if ((bVar2 != 0x7d) &&
           (uVar1 = 0, (*(ushort *)(&dtc_fault_table_base + (uint)bVar2 * 6) & 0x40) == 0)) {
          io_control_active_mask = io_control_active_mask & 0xfffc;
          fault_code_display_value = 0;
          io_toggle_cycle_counter = 0;
          digit_display_sequencer_state = 0;
          fault_code_display_state = bVar2;
        }
      }
    }
    else {
      bVar2 = activeFaultCodeIteratorForward((uint)CONCAT12(fault_code_display_state,uVar3));
      uVar1 = CONCAT31(extraout_var,bVar2);
      if ((bVar2 != 0x7d) &&
         (uVar1 = 0, (*(ushort *)(&dtc_fault_table_base + (uint)bVar2 * 6) & 0x40) == 0)) {
        io_control_active_mask = io_control_active_mask & 0xfff8;
        fault_code_display_value = 0;
        io_toggle_cycle_counter = 0;
        digit_display_sequencer_state = 0;
        fault_code_display_state = bVar2;
      }
    }
    if (fault_code_display_state == 0x7d) {
      io_control_active_mask = io_control_active_mask | 3;
    }
    else {
      uVar1 = ioControlDigitDisplaySequencer
                        (CONCAT22((&diagnostic_fault_parameter_array)
                                  [(uint)fault_code_display_state * 3],uVar3));
    }
    return uVar1 & 0xffffff00;
  }
  if (fault_code_display_mode != 0) {
    fault_code_display_mode = 0;
    io_control_active_mask = io_control_active_mask & 0xfffc;
  }
  return 1;
}



/*
 * Function: activeFaultLampStateMachine @ 0x0001dd00
 */

void activeFaultLampStateMachine(void)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  byte bVar7;
  
  bVar6 = false;
  bVar1 = false;
  bVar3 = false;
  bVar2 = false;
  bVar5 = false;
  bVar4 = false;
  for (bVar7 = 1; bVar7 <= diagnostic_pending_code_count; bVar7 = bVar7 + 1) {
    if (((*(ushort *)
           (&dtc_fault_table_base + (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6
           ) & 1) == 0) ||
       ((*(ushort *)
          (&dtc_fault_table_base + (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6)
        & 0x40) != 0)) {
      if (((*(ushort *)
             (&dtc_fault_table_base +
             (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6) & 2) == 0) ||
         ((*(ushort *)
            (&dtc_fault_table_base +
            (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6) & 0x40) != 0)) {
        if (((*(ushort *)
               (&dtc_fault_table_base +
               (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6) & 4) != 0) &&
           ((*(ushort *)
              (&dtc_fault_table_base +
              (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6) & 0x40) == 0)) {
          if ((*(ushort *)
                (&dtc_fault_table_base +
                (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6) & 8) == 0) {
            bVar5 = true;
          }
          else {
            bVar4 = true;
          }
        }
      }
      else if ((*(ushort *)
                 (&dtc_fault_table_base +
                 (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6) & 8) == 0) {
        bVar3 = true;
      }
      else {
        bVar2 = true;
      }
    }
    else if ((*(ushort *)
               (&dtc_fault_table_base +
               (uint)(&diagnostic_pending_code_count)[(short)(ushort)bVar7] * 6) & 8) == 0) {
      bVar6 = true;
    }
    else {
      bVar1 = true;
    }
  }
  if (bVar1) {
    if (lamp_1_blink_counter == 0) {
      io_control_active_mask = io_control_active_mask | 1;
      lamp_1_blink_counter = 1;
    }
    else if (lamp_1_blink_counter == lamp_blink_on_duration) {
      io_control_active_mask = io_control_active_mask & 0xfffe;
      lamp_1_blink_counter = lamp_1_blink_counter + 1;
    }
    else if ((uint)lamp_blink_on_duration + (uint)lamp_blink_off_duration ==
             (uint)lamp_1_blink_counter) {
      lamp_1_blink_counter = 0;
    }
    else {
      lamp_1_blink_counter = lamp_1_blink_counter + 1;
    }
  }
  else if (bVar6) {
    io_control_active_mask = io_control_active_mask | 1;
  }
  else {
    io_control_active_mask = io_control_active_mask & 0xfffe;
  }
  if (bVar2) {
    if (lamp_2_blink_counter == 0) {
      io_control_active_mask = io_control_active_mask | 2;
      lamp_2_blink_counter = 1;
    }
    else if (lamp_2_blink_counter == lamp_blink_on_duration) {
      io_control_active_mask = io_control_active_mask & 0xfffd;
      lamp_2_blink_counter = lamp_2_blink_counter + 1;
    }
    else if ((uint)lamp_blink_on_duration + (uint)lamp_blink_off_duration ==
             (uint)lamp_2_blink_counter) {
      lamp_2_blink_counter = 0;
    }
    else {
      lamp_2_blink_counter = lamp_2_blink_counter + 1;
    }
  }
  else if (bVar3) {
    io_control_active_mask = io_control_active_mask | 2;
  }
  else {
    io_control_active_mask = io_control_active_mask & 0xfffd;
  }
  if (bVar4) {
    if (lamp_3_blink_counter == 0) {
      io_control_active_mask = io_control_active_mask | 4;
      lamp_3_blink_counter = 1;
    }
    else if (lamp_3_blink_counter == lamp_blink_on_duration) {
      io_control_active_mask = io_control_active_mask & 0xfffb;
      lamp_3_blink_counter = lamp_3_blink_counter + 1;
    }
    else if (((uint)lamp_blink_on_duration + (uint)lamp_blink_off_duration) - 1 ==
             (uint)lamp_3_blink_counter) {
      lamp_3_blink_counter = 0;
    }
    else {
      lamp_3_blink_counter = lamp_3_blink_counter + 1;
    }
  }
  else if (bVar5) {
    io_control_active_mask = io_control_active_mask | 4;
  }
  else {
    io_control_active_mask = io_control_active_mask & 0xfffb;
  }
  return;
}



/*
 * Function: faultLampBlinkPatternGenerator @ 0x0001dfc2
 */

void faultLampBlinkPatternGenerator(void)

{
  if (fault_lamp_blink_pattern_state < 5) {
    if (fault_lamp_blink_counter < 6) {
      io_control_active_mask = io_control_active_mask | 4;
    }
    else if ((fault_lamp_blink_counter < 6) || (0xb < fault_lamp_blink_counter)) {
      if ((fault_lamp_blink_counter < 0xc) || (0x11 < fault_lamp_blink_counter)) {
        if ((fault_lamp_blink_counter < 0x12) || (0x17 < fault_lamp_blink_counter)) {
          if ((fault_lamp_blink_counter < 0x18) || (0x1d < fault_lamp_blink_counter)) {
            if ((fault_lamp_blink_counter < 0x1e) || (0x23 < fault_lamp_blink_counter)) {
              fault_lamp_blink_counter = 0;
              fault_lamp_blink_pattern_state = fault_lamp_blink_pattern_state + 1;
              return;
            }
            io_control_active_mask = io_control_active_mask & 0xfffb;
          }
          else {
            io_control_active_mask = io_control_active_mask | 4;
          }
        }
        else {
          io_control_active_mask = io_control_active_mask & 0xfffb;
        }
      }
      else {
        io_control_active_mask = io_control_active_mask | 4;
      }
    }
    else {
      io_control_active_mask = io_control_active_mask & 0xfffb;
    }
    fault_lamp_blink_counter = fault_lamp_blink_counter + 1;
  }
  return;
}



/*
 * Function: waitToStartLampBlinkPattern @ 0x0001e050
 */

void waitToStartLampBlinkPattern(void)

{
  if (lamp_flash_timer_state < 6) {
    io_control_active_mask = io_control_active_mask | 2;
    wait_to_start_lamp_state = 1;
  }
  else if ((lamp_flash_timer_state < 6) || (0x17 < lamp_flash_timer_state)) {
    if ((lamp_flash_timer_state < 0x18) || (0x1d < lamp_flash_timer_state)) {
      if ((lamp_flash_timer_state < 0x1e) || (0x2f < lamp_flash_timer_state)) {
        if ((lamp_flash_timer_state < 0x30) || (0x35 < lamp_flash_timer_state)) {
          if ((lamp_flash_timer_state < 0x36) || (0x47 < lamp_flash_timer_state)) {
            wait_to_start_lamp_state = 0;
          }
          else {
            io_control_active_mask = io_control_active_mask & 0xfffd;
          }
        }
        else {
          io_control_active_mask = io_control_active_mask | 2;
        }
      }
      else {
        io_control_active_mask = io_control_active_mask & 0xfffd;
      }
    }
    else {
      io_control_active_mask = io_control_active_mask | 2;
    }
  }
  else {
    io_control_active_mask = io_control_active_mask & 0xfffd;
  }
  lamp_flash_timer_state = lamp_flash_timer_state + 1;
  return;
}



/*
 * Function: periodicLampFlashController @ 0x0001e0d6
 */

void periodicLampFlashController(void)

{
  if (diagnostic_pending_flag == 0) {
    lamp_flash_controller_state = lamp_flash_controller_state + 1;
    if (36000 < lamp_flash_controller_state) {
      diagnostic_pending_flag = 1;
      lamp_flash_controller_state = 0;
      return;
    }
  }
  else {
    if (lamp_flash_controller_state < 0x14) {
      io_control_active_mask = io_control_active_mask | 4;
    }
    else if ((lamp_flash_controller_state < 0x14) || (0x4f < lamp_flash_controller_state)) {
      lamp_flash_cycle_counter = lamp_flash_cycle_counter + 1;
      lamp_flash_controller_state = 0;
    }
    else {
      io_control_active_mask = io_control_active_mask & 0xfffb;
    }
    lamp_flash_controller_state = lamp_flash_controller_state + 1;
    if (3 < lamp_flash_cycle_counter) {
      diagnostic_pending_flag = 0;
      lamp_flash_controller_state = 0;
      lamp_flash_cycle_counter = 0;
    }
  }
  return;
}



/*
 * Function: epsSignalQualityValidator @ 0x0001e140
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void epsSignalQualityValidator(void)

{
  uint uVar1;
  char cVar2;
  
  if (io_control_mask_state_active != 0) {
    ioControlMaskStateMachine();
    return;
  }
  uVar1 = faultCodeDisplayController();
  if ((char)uVar1 != '\0') {
    cVar2 = ioControlLampStateMachine();
    if (cVar2 != '\0') {
      fault_code_display_state = 0x7d;
      activeFaultLampStateMachine();
    }
  }
  if (io_control_state_0 < 0x191) {
    io_control_state_0 = io_control_state_0 + 1;
  }
  if (((99 < io_control_state_0) && (io_control_state_0 < 400)) &&
     (eps_period_backup_time_between_the_two_most_recent_eps_200_16777216 != 0)) {
    faultLampBlinkPatternGenerator();
  }
  if ((_crank_state_active_flag != 0) || (wait_to_start_lamp_state != 0)) {
    waitToStartLampBlinkPattern();
  }
  if (((eps_signal_quality_threshold != 0) &&
      (eps_period_backup_time_between_the_two_most_recent_eps_200_16777216 != 0)) &&
     (engine_operating_mode == HIGH_RPM_RUNNING)) {
    periodicLampFlashController();
  }
  diagnostic_queue_counter_1 = -((derate_status_byte & 0x20) != 0) & 1;
  fault_code_display_counter = -((derate_status_byte & 0x40) != 0) & 1;
  diagnostic_queue_counter_2 = -((derate_status_byte & 0x80) != 0) & 1;
  return;
}



/*
 * Function: camSyncDiagnosticProcessor @ 0x0001e210
 */

void camSyncDiagnosticProcessor(void)

{
  uint uVar1;
  
  if (diagnostic_status_register == EPS_FAULT_MODE) {
    cam_sync_lost_duration_0_20 = coreTableInterpolation();
    uVar1 = ((uint)cam_sync_scaling_factor * (uint)cam_sync_lost_duration_0_20) / 0x7800;
    if ((uint)cam_sync_upper_limit < (uint)cam_sync_base_offset + (uVar1 & 0xffff)) {
      backup_signal_edge_time_stamp_0_65535 = cam_sync_base_offset;
    }
    else {
      backup_signal_edge_time_stamp_0_65535 = cam_sync_upper_limit - (short)uVar1;
    }
    if (derate_threshold_exceeded == 1) {
      if (cam_sync_derate_previous == 1) {
        main_signal_edge_time_stamp_0_65535 =
             cam_sync_increment_rate + main_signal_edge_time_stamp_0_65535;
        if (backup_signal_edge_time_stamp_0_65535 < main_signal_edge_time_stamp_0_65535) {
          main_signal_edge_time_stamp_0_65535 = backup_signal_edge_time_stamp_0_65535;
        }
      }
      else {
        main_signal_edge_time_stamp_0_65535 = cam_sync_default_value;
      }
    }
    else if (derate_threshold_exceeded == 0) {
      main_signal_edge_time_stamp_0_65535 = mask_used_for_can_msg_object_15_0_ffffffff;
    }
    cached_parameter_value = main_signal_edge_time_stamp_0_65535;
  }
  cam_sync_derate_previous = derate_threshold_exceeded;
  return;
}



/*
 * Function: epsDiagnosticModeChecker @ 0x0001e2d2
 */

void epsDiagnosticModeChecker(undefined4 param_1)

{
  if ((((eps_diagnostic_mode_checker_param != 0) && (diagnostic_status_register == NORMAL_OPERATION)
       ) && ((((engine_fault_register_a & 2) != 0 && ((engine_fault_register_b & 2) != 0)) ||
             (((engine_fault_register_a & 4) != 0 && ((engine_fault_register_b & 4) != 0)))))) &&
     (diagnostic_status_register = EPS_FAULT_MODE, param_1._0_2_ != 6)) {
    epsDiagnosticSnapshotCapture();
  }
  return;
}



/*
 * Function: epsDiagnosticSnapshotCapture @ 0x0001e33a
 */

void epsDiagnosticSnapshotCapture(void)

{
  main_signal_edge_time_stamp_0_65535 = current_fuel_demand_value;
  eps_diagnostic_rpm_snapshot = (uint)current_engine_rpm_raw << 0x10;
  return;
}



/*
 * Function: epsDiagnosticVariablesInit @ 0x0001e358
 */

void epsDiagnosticVariablesInit(void)

{
  eps_diagnostic_rpm_snapshot = 0;
  eps_diagnostic_table_ptr = 0x808788;
  return;
}



/*
 * Function: epsTimingCalculationSlowCycle40Coordinator @ 0x0001e36a
 */

void epsTimingCalculationSlowCycle40Coordinator(void)

{
  eps_timing_rpm_input_1 = current_engine_rpm;
  dzg_pressure_threshold_high =
       lookupTableInterpolation((table_interp_args_t *)&dzg_pressure_lookup_table_arg);
  eps_timing_rpm_input_2 = current_engine_rpm;
  eps_main_lost_duration_0_20 =
       lookupTableInterpolation((table_interp_args_t *)&eps_main_lookup_table_arg);
  return;
}



/*
 * Function: initLookupTablePointers1 @ 0x0001e3a8
 */

void initLookupTablePointers1(void)

{
  eps_timing_table_2_ptr = 0x8087a4;
  eps_timing_table_1_ptr = 0x808796;
  dzg_pressure_lookup_table_arg = 2;
  eps_timing_table_4_ptr = 0x8087b2;
  eps_timing_table_3_ptr = 0x808796;
  eps_main_lookup_table_arg = 2;
  return;
}



/*
 * Function: governorFuelModeBlendCalculator @ 0x0001e3dc
 */

void governorFuelModeBlendCalculator(void)

{
  ushort unaff_D2w;
  ushort unaff_D3w;
  undefined8 uVar1;
  
  if (fuel_timing_mode_blend_factor_965a != 0) {
    governor_blend_table_1_input = governor_rpm_target_adjusted;
    uVar1 = tableInterpolationLookup((short *)&governor_blend_table_1_type);
    unaff_D3w = (ushort)((ulonglong)uVar1 >> 0x20);
  }
  if (fuel_timing_mode_blend_factor_965a < 0x4000) {
    governor_blend_table_2_input = governor_rpm_target_adjusted;
    uVar1 = tableInterpolationLookup((short *)&governor_blend_table_2_type);
    unaff_D2w = (ushort)((ulonglong)uVar1 >> 0x20);
  }
  if (fuel_timing_mode_blend_factor_965a == 0x4000) {
    governor_fuel_blend_output = unaff_D3w;
    return;
  }
  if (fuel_timing_mode_blend_factor_965a == 0) {
    governor_fuel_blend_output = unaff_D2w;
    return;
  }
  governor_fuel_blend_output =
       unaff_D2w +
       (short)((uint)fuel_timing_mode_blend_factor_965a * ((uint)unaff_D3w - (uint)unaff_D2w) >> 0xe
              );
  return;
}



/*
 * Function: governorFuelPidController @ 0x0001e462
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void governorFuelPidController(void)

{
  bool bVar1;
  dword dVar2;
  word wVar3;
  word wVar4;
  short sVar6;
  int iVar5;
  undefined4 local_8;
  
  if (fuel_arbitrator_diag_t_0080cff8.rpm_target == 0) {
    governor_rpm_error_value = fuel_timing_offset_value;
  }
  else {
    governor_rpm_error_value = fuel_timing_offset_min_limit;
  }
  sVar6 = coreTableInterpolation();
  wVar3 = eps_external_lost_duration_0_20;
  governor_rpm_target_adjusted = governor_rpm_error_value + sVar6;
  if (governor_rpm_target_max < governor_rpm_target_adjusted) {
    governor_rpm_target_adjusted = governor_rpm_target_max;
  }
  governor_rpm_target_adjusted = governor_rpm_target_adjusted - governor_pid_min_clamp;
  if ((diagnostic_fuel_control_mode == 0xb) || (current_engine_rpm < fuel_timing_offset_value)) {
    eps_external_lost_duration_0_20 = exponentialMovingAverage();
    wVar4 = eps_control_mode_param_1;
    if ((short)governor_pid_integral_limit_low < (short)eps_external_lost_duration_0_20) {
      eps_external_lost_duration_0_20 = governor_pid_integral_limit_low;
      governor_pid_integral_fractional =
           (short)governor_pid_integral_limit_low * 0x10000 + 0x80000000;
    }
    else if ((short)eps_external_lost_duration_0_20 < (short)governor_pid_integral_limit_high) {
      eps_external_lost_duration_0_20 = governor_pid_integral_limit_high;
      governor_pid_integral_fractional =
           (short)governor_pid_integral_limit_high * 0x10000 + 0x80000000;
    }
    epsControlModeSelector();
    if (((int)((int)(short)governor_pid_error_term + (uint)governor_rpm_error_value) <
         (int)(uint)current_engine_rpm) &&
       (diagnostic_rpm_threshold_status < governor_pid_output_limit)) {
      governor_fuel_pid_integral = (uint)governor_pid_scale_factor << 0x10;
      eps_external_lost_duration_0_20 = 0;
      governor_pid_integral_fractional = 0x80000000;
    }
    else {
      governor_pid_proportional_term_d060 =
           (word)(((int)(short)eps_external_lost_duration_0_20 *
                  (int)(short)eps_control_mode_param_1) / 0x3c0);
      iVar5 = (int)(short)eps_control_mode_param_3 *
              ((int)(short)eps_external_lost_duration_0_20 - (int)(short)wVar3);
      if (iVar5 < 0x783f0f) {
        if (iVar5 < -0x783fff) {
          governor_pid_derivative_term_d062 = 0x8000;
        }
        else {
          governor_pid_derivative_term_d062 =
               (word)((((int)(short)eps_external_lost_duration_0_20 - (int)(short)wVar3) *
                      (int)(short)eps_control_mode_param_3) / 0xf0);
        }
      }
      else {
        governor_pid_derivative_term_d062 = 0x7fff;
      }
      governorFuelModeBlendCalculator();
      eps_raw_period_backup_raw_time_between_teeth_not_norm_d_to_1_200000._2_2_ =
           governor_fuel_blend_output + governor_pid_fuel_sum_previous;
      if ((short)eps_raw_period_backup_raw_time_between_teeth_not_norm_d_to_1_200000._2_2_ < 0) {
        eps_raw_period_backup_raw_time_between_teeth_not_norm_d_to_1_200000._2_2_ = 0;
      }
      cam_sync_backup_lost_duration_duration_in_no_sync_state_0_20 =
           governor_fuel_blend_output + governor_pid_derivative_term_87d0;
      local_8._2_2_ = (word)(((int)(short)eps_control_mode_param_1 - (int)(short)wVar4) * 0x44 >> 3)
      ;
      dVar2 = governor_fuel_pid_integral +
              (int)(short)eps_external_lost_duration_0_20 *
              (int)(short)(eps_control_mode_param_2 << 2) +
              (int)(short)eps_external_lost_duration_0_20 * (int)(short)local_8._2_2_ * -8 +
              _fuel_delivery_offset_correction * -0x10000;
      governor_fuel_pid_integral._0_2_ = (short)(dVar2 >> 0x10);
      if (governor_fuel_pid_integral._0_2_ <
          (short)cam_sync_backup_lost_duration_duration_in_no_sync_state_0_20) {
        bVar1 = governor_fuel_pid_integral._0_2_ < (short)governor_pid_integral_min;
        governor_fuel_pid_integral = dVar2;
        if (bVar1) {
          governor_fuel_pid_integral = (uint)governor_pid_integral_min << 0x10;
        }
      }
      else {
        governor_fuel_pid_integral =
             (uint)cam_sync_backup_lost_duration_duration_in_no_sync_state_0_20 << 0x10;
      }
      eps_raw_period_backup_raw_time_between_teeth_not_norm_d_to_1_200000._0_2_ =
           governor_fuel_pid_integral._0_2_;
      local_8 = (int)governor_fuel_pid_integral._0_2_ +
                (int)(short)governor_pid_derivative_term_d062 +
                (int)(short)governor_pid_proportional_term_d060;
      if ((vp44_flag_register_1 & 0x200) != 0) {
        local_8 = (uint)fsmxthfl_calc_input + local_8;
      }
      if ((int)(uint)eps_raw_period_backup_raw_time_between_teeth_not_norm_d_to_1_200000._2_2_ <
          local_8) {
        _eps_backup_lost_duration_0_20 =
             eps_raw_period_backup_raw_time_between_teeth_not_norm_d_to_1_200000._2_2_;
      }
      else if (local_8 < (int)(uint)eps_backup_duration_init) {
        _eps_backup_lost_duration_0_20 = eps_backup_duration_init;
      }
      else {
        _eps_backup_lost_duration_0_20 = local_8._2_2_;
      }
      if (diagnostic_fuel_control_mode == 0xb) {
        diagnostic_rpm_threshold_status = _eps_backup_lost_duration_0_20;
      }
    }
  }
  return;
}



/*
 * Function: governorPidFuelCalculator @ 0x0001e78e
 */

void governorPidFuelCalculator(void)

{
  word wVar1;
  word *pwVar2;
  word wStack_6;
  
  pwVar2 = (word *)((uint)governor_pid_max_clamp * (uint)active_derate_value);
  if (&governor_pid_fuel_lookup_table < pwVar2) {
    pwVar2 = &governor_pid_fuel_lookup_table;
  }
  governor_pid_fuel_scaled = (int)pwVar2 << 0x10;
  wStack_6 = (word)((int)(short)governor_pid_integral_term *
                    ((int)(short)governor_rpm_target_adjusted - (int)(short)current_engine_rpm) >> 9
                   );
  if ((short)governor_pid_integral_limit_low < (short)wStack_6) {
    wStack_6 = governor_pid_integral_limit_low;
  }
  else if ((short)wStack_6 < (short)governor_pid_integral_limit_high) {
    wStack_6 = governor_pid_integral_limit_high;
  }
  governor_pid_integral_fractional = (short)wStack_6 * 0x10000 + 0x80000000;
  eps_external_lost_duration_0_20 = wStack_6;
  epsInitializationWrapper();
  governorFuelModeBlendCalculator();
  crank_sync_backup_lost_duration_amount_of_time_crank_sync_lost_1_20 =
       governor_fuel_blend_output + governor_pid_proportional_term_87c4;
  governor_fuel_pid_integral._0_2_ =
       current_fuel_demand_value -
       (short)(((int)(short)eps_external_lost_duration_0_20 *
               (int)(short)eps_control_mode_duration_value_8804) / 0x3c0);
  if ((vp44_flag_register_1 & 0x200) != 0) {
    governor_fuel_pid_integral._0_2_ = governor_fuel_pid_integral._0_2_ - fsmxthfl_calc_input;
  }
  wVar1 = crank_sync_backup_lost_duration_amount_of_time_crank_sync_lost_1_20;
  if (((short)governor_fuel_pid_integral._0_2_ <=
       (short)crank_sync_backup_lost_duration_amount_of_time_crank_sync_lost_1_20) &&
     (wVar1 = governor_fuel_pid_integral._0_2_,
     (short)governor_fuel_pid_integral._0_2_ < (short)governor_pid_integral_max)) {
    governor_fuel_pid_integral._0_2_ = governor_pid_integral_max;
    wVar1 = governor_fuel_pid_integral._0_2_;
  }
  governor_fuel_pid_integral._0_2_ = wVar1;
  governor_fuel_pid_integral._2_2_ = 0;
  return;
}



/*
 * Function: intakeTemperatureTablesInit @ 0x0001e8a6
 */

void intakeTemperatureTablesInit(void)

{
  eps_governor_table_ptr_1 = 0x8087e2;
  eps_governor_table_ptr_2 = 0x8087c8;
  epsControlModeInit();
  governor_blend_table_1_x_ptr = 0x807f42;
  governor_blend_table_1_type = 2;
  intake_temp_table_1_count = 400;
  intake_temp_table_1_x_ptr = 0x807f68;
  intake_temp_table_1_type = 2;
  intake_temp_table_1_y_ptr =
       (dword)&lower_limitation_of_intake_manifold_temperature_to_inhibit_50_to_293;
  governor_blend_table_2_x_ptr = 0x808002;
  governor_blend_table_2_type = 2;
  intake_temp_table_2_count = 400;
  intake_temp_table_2_x_ptr = 0x808028;
  intake_temp_table_2_type = 2;
  intake_temp_table_2_y_ptr = 0x808032;
  return;
}



/*
 * Function: epsAccelerationMonitor @ 0x0001e92e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint epsAccelerationMonitor(void)

{
  undefined2 uVar1;
  uint uVar2;
  word wVar3;
  
  wVar3 = eps_external_lost_duration_0_20;
  if ((short)eps_external_lost_duration_0_20 < 0) {
    wVar3 = -eps_external_lost_duration_0_20;
  }
  uVar2 = (uint)(short)wVar3;
  if ((int)(uint)eps_accel_threshold_lower < (int)uVar2) {
    eps_acceleration_timer_1 = 0;
    eps_acceleration_timer_2 = 0;
  }
  else {
    if (eps_acceleration_timer_1 < eps_acceleration_timer_threshold) {
      eps_acceleration_timer_1 = eps_acceleration_timer_1 + 1;
    }
    uVar2 = CONCAT22((short)wVar3 >> 0xf,throttle_position_value);
    if (throttle_position_value < throttle_position_threshold) {
      uVar2 = CONCAT22((short)wVar3 >> 0xf,eps_acceleration_timer_2);
      if (eps_acceleration_timer_2 < eps_acceleration_timer_threshold) {
        eps_acceleration_timer_2 = eps_acceleration_timer_2 + 1;
      }
      else {
        eps_acceleration_timer_2 = 0;
      }
    }
  }
  if (eps_acceleration_active_flag != 0) {
    uVar2 = CONCAT22((short)(uVar2 >> 0x10),eps_acceleration_timer_2);
    if (eps_acceleration_timer_2 == eps_acceleration_timer_threshold) {
      eps_acceleration_active_flag = 0;
      eps_rpm_tracking_state = 0;
    }
    goto LAB_0001ea26;
  }
  if (eps_rpm_tracking_state == 1) {
    uVar2 = (int)(short)eps_accel_duration_counter + (uint)governor_rpm_error_value;
    if (((int)(uint)current_engine_rpm <= (int)uVar2) ||
       (uVar2 = derate_status_byte & 4, (derate_status_byte & 4) != 0)) {
      uVar1 = (undefined2)(uVar2 >> 0x10);
      uVar2 = CONCAT22(uVar1,throttle_position_value);
      if ((throttle_position_value < throttle_position_threshold) ||
         (uVar2 = CONCAT22(uVar1,eps_acceleration_timer_1),
         eps_acceleration_timer_1 != eps_acceleration_timer_threshold)) goto LAB_0001e9f8;
    }
  }
  else {
LAB_0001e9f8:
    uVar2 = CONCAT22((short)(uVar2 >> 0x10),throttle_position_value);
    if (throttle_position_value <= eps_accel_threshold_upper) goto LAB_0001ea26;
  }
  eps_acceleration_active_flag = 1;
LAB_0001ea26:
  if (eps_acceleration_active_flag == 0) {
    if (eps_acceleration_monitor_value == 0) {
      uVar1 = (undefined2)(uVar2 >> 0x10);
      uVar2 = CONCAT22(uVar1,fuel_demand_control_flags) & 0xffff1000;
      if (((fuel_demand_control_flags & 0x1000) != 0) &&
         ((uVar2 = CONCAT22(uVar1,eps_external_lost_duration_0_20),
          (short)eps_duration_upper_limit < (short)eps_external_lost_duration_0_20 ||
          ((uVar2 = CONCAT22(uVar1,eps_external_lost_duration_0_20),
           (short)eps_duration_lower_limit < (short)eps_external_lost_duration_0_20 &&
           (uVar2 = (int)(short)rpm_offset_adjustment + (uint)current_engine_rpm,
           (int)uVar2 < (int)(uint)eps_previous_engine_rpm)))))) {
        eps_acceleration_monitor_value = 1;
      }
    }
    else if ((eps_acceleration_monitor_value == 1) &&
            ((uVar2 = (int)(short)eps_duration_lower_limit - (int)(short)eps_accel_mode_state,
             (int)(short)eps_external_lost_duration_0_20 < (int)uVar2 ||
             ((uVar2 = CONCAT22((short)(uVar2 >> 0x10),eps_external_lost_duration_0_20),
              (short)eps_external_lost_duration_0_20 < (short)eps_duration_upper_limit &&
              (uVar2 = (int)(short)rpm_offset_adjustment + (uint)eps_previous_engine_rpm,
              (int)uVar2 < (int)(uint)current_engine_rpm)))))) {
      eps_acceleration_monitor_value = 0;
    }
  }
  if (eps_acceleration_monitor_value == 1) {
    eps_rpm_tracking_state = 1;
    _eps_acceleration_monitor_state = 0x8087fe;
  }
  eps_previous_engine_rpm = current_engine_rpm;
  return uVar2;
}



/*
 * Function: epsRpmTrackingInit @ 0x0001eade
 */

void epsRpmTrackingInit(void)

{
  eps_previous_engine_rpm = current_engine_rpm;
  eps_acceleration_timer_1 = 0;
  eps_acceleration_timer_2 = 0;
  return;
}



/*
 * Function: epsControlModeReset @ 0x0001eaf6
 */

void epsControlModeReset(void)

{
  eps_rpm_tracking_state = 0;
  return;
}



/*
 * Function: epsOverrideChecker @ 0x0001eafe
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint epsOverrideChecker(undefined4 param_1)

{
  uint in_D0;
  
  if (param_1._0_2_ != 0) {
    return 1;
  }
  if (eps_override_checker_state != 0) {
    eps_override_output_state = eps_override_checker_state;
    _eps_control_mode_selector_state_d08e = &eps_control_mode_init_value_2;
    return 1;
  }
  return in_D0 & 0xffff0000;
}



/*
 * Function: epsControlModeSelector @ 0x0001eb2a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void epsControlModeSelector(void)

{
  int iVar1;
  uint uVar2;
  undefined4 unaff_D2;
  undefined2 uVar3;
  
  uVar3 = (undefined2)((uint)unaff_D2 >> 0x10);
  epsAccelerationMonitor();
  iVar1 = epsRpmTargetModeChecker();
  uVar2 = epsOverrideChecker(CONCAT22((short)iVar1,uVar3));
  if ((short)uVar2 == 0) {
    eps_override_output_state = eps_acceleration_monitor_value;
    if (eps_acceleration_monitor_value == 0) {
      _eps_control_mode_selector_state_d08e = &eps_control_mode_duration_value_8804;
    }
    else {
      _eps_control_mode_selector_state_d08e = _eps_acceleration_monitor_state;
    }
  }
  eps_control_mode_param_1 = *_eps_control_mode_selector_state_d08e;
  eps_control_mode_param_2 = _eps_control_mode_selector_state_d08e[1];
  eps_control_mode_param_3 = _eps_control_mode_selector_state_d08e[2];
  return;
}



/*
 * Function: epsInitializationWrapper @ 0x0001eb86
 */

void epsInitializationWrapper(void)

{
  epsRpmTrackingInit();
  epsCounterReset();
  return;
}



/*
 * Function: epsControlModeInit @ 0x0001eb94
 */

void epsControlModeInit(void)

{
  epsControlModeReset();
  eps_acceleration_monitor_value = 0;
  eps_control_mode_init_value_2 = eps_control_mode_duration_value_8804;
  eps_control_mode_init_value_1 = eps_control_mode_duration_value_8806;
  eps_control_mode_init_state = eps_control_mode_selector_state_8808._0_2_;
  return;
}



/*
 * Function: epsDiagnosticModeHandler @ 0x0001ebcc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void epsDiagnosticModeHandler(void)

{
  undefined2 uStack_6;
  
  if ((diagnostic_fuel_control_mode == 0xb) && (eps_acceleration_active_flag == 1)) {
    if (((short)eps_diagnostic_lower_limit < (short)eps_external_lost_duration_0_20) ||
       (((short)eps_external_lost_duration_0_20 < (short)eps_diagnostic_upper_limit ||
        (fuel_temp_protection_threshold_flag != 0)))) {
      eps_acceleration_monitor_value = 0;
      eps_diagnostic_mode_counter = 0;
    }
    else {
      if (eps_diagnostic_mode_counter < eps_diagnostic_counter_limit) {
        eps_diagnostic_mode_counter = eps_diagnostic_mode_counter + 1;
      }
      uStack_6 = (short)((uint)throttle_position_filtered * (uint)vp44_fault_calc_factor_2 >> 0xb);
      if (eps_control_mode_selector_state_8808._2_2_ < uStack_6) {
        eps_acceleration_monitor_value = 0;
      }
      else if ((((eps_acceleration_monitor_value == 0) &&
                (eps_diagnostic_mode_counter == eps_diagnostic_counter_limit)) &&
               ((fuel_demand_control_flags & 0x4000) != 0)) &&
              ((int)uStack_6 <
               (int)eps_control_mode_selector_state_8808._2_2_ - (int)(short)eps_fuel_demand_delta))
      {
        if (((fuel_demand_control_flags & 0x2000) == 0) ||
           ((short)eps_fuel_demand_threshold < uStack_6)) {
          eps_acceleration_monitor_value = 2;
          _eps_acceleration_monitor_state = 0x80881c;
        }
        else if ((int)uStack_6 <
                 (int)(short)eps_fuel_demand_threshold - (int)(short)eps_fuel_demand_delta) {
          eps_acceleration_monitor_value = 3;
          _eps_acceleration_monitor_state = 0x808816;
        }
      }
    }
  }
  return;
}



/*
 * Function: epsCounterReset @ 0x0001ecee
 */

void epsCounterReset(void)

{
  eps_diagnostic_mode_counter = 0;
  return;
}



/*
 * Function: fuelTimingOffsetCalculator @ 0x0001ecf6
 */

void fuelTimingOffsetCalculator(void)

{
  if (((diagnostic_system_flags_1 & 8) == 0) ||
     (((io_fault_status_reg_4 & 2) != 0 && ((fault_mask_flags_1 & 2) != 0)))) {
    fuel_timing_offset_state = 0;
  }
  else if ((derate_bit5_status_latch == 0) && ((derate_status_byte & 0x20) != 0)) {
    fuel_timing_offset_state = fuel_timing_offset_step + fuel_timing_offset_state;
    if ((short)fuel_timing_offset_max < (short)fuel_timing_offset_state) {
      fuel_timing_offset_state = fuel_timing_offset_max;
    }
  }
  else if (((derate_bit6_status_latch == 0) && ((derate_status_byte & 0x40) != 0)) &&
          (fuel_timing_offset_state = fuel_timing_offset_state - fuel_timing_offset_step,
          (short)fuel_timing_offset_state < (short)fuel_timing_offset_min)) {
    fuel_timing_offset_state = fuel_timing_offset_min;
  }
  fuel_timing_offset_value = fuel_timing_offset_state + governor_rpm_error_init_value;
  if (fuel_timing_offset_limit < fuel_timing_offset_value) {
    fuel_timing_offset_value = fuel_timing_offset_limit;
  }
  else if (fuel_timing_offset_value < fuel_timing_offset_min_limit) {
    fuel_timing_offset_value = fuel_timing_offset_min_limit;
  }
  if ((vp44_status_flags_2 & 1) == 0) {
    fuel_timing_offset_state_backup = 0;
  }
  else {
    fuel_timing_offset_state_backup = fuel_timing_offset_state;
  }
  derate_bit5_status_latch = -((derate_status_byte & 0x20) != 0) & 1;
  derate_bit6_status_latch = -((derate_status_byte & 0x40) != 0) & 1;
  return;
}



/*
 * Function: initVP44StatusFlags @ 0x0001ee02
 */

ushort initVP44StatusFlags(void)

{
  if ((vp44_status_flags_2 & 1) == 0) {
    fuel_timing_offset_state_backup = 0;
  }
  engine_mode_timing_init_flag = 0;
  fuel_timing_offset_state = fuel_timing_offset_state_backup;
  return vp44_status_flags_2 & 1;
}



/*
 * Function: epsRpmTargetModeChecker @ 0x0001ee2c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

int epsRpmTargetModeChecker(void)

{
  ushort uVar1;
  undefined4 in_D0;
  
  uVar1 = (ushort)((uint)in_D0 >> 0x10);
  if ((fuel_arbitrator_diag_t_0080cff8.rpm_target != 0) &&
     (uVar1 = 0, (fuel_demand_control_flags & 0x8000) != 0)) {
    eps_override_output_state = 4;
    _eps_control_mode_selector_state_d08e = 0x808822;
    return 1;
  }
  return (uint)uVar1 << 0x10;
}



/*
 * Function: engineModeTimingAdjuster @ 0x0001ee5c
 */

void engineModeTimingAdjuster(void)

{
  bool bVar1;
  bool bVar2;
  
  bVar2 = throttle_position_raw < engine_mode_timing_adjust_param_1;
  if ((vp44_status_flags_2 & 0x4000) == 0) {
    bVar1 = false;
  }
  else if (engine_mode_timing_init_flag == 0) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (engine_operating_mode == ENGINE_IDLE) {
    fuel_arbitrator_diag_timer = 0;
    if (bVar2) {
      engine_mode_timing_adjuster_state = engine_mode_timing_adjust_param_2;
    }
    else {
      engine_mode_timing_adjuster_state = 0;
    }
  }
  else if (engine_operating_mode != LOW_RPM_RUNNING) {
    if ((bVar2) && (fuel_arbitrator_diag_timer < fuel_arbitrator_timer_threshold)) {
      fuel_arbitrator_diag_timer = fuel_arbitrator_diag_timer + 1;
    }
    if ((engine_operating_mode == HIGH_RPM_RUNNING) &&
       ((fuel_arbitrator_timer_threshold <= fuel_arbitrator_diag_timer || (!bVar2)))) {
      if (engine_timing_decrement_step < engine_mode_timing_adjuster_state) {
        engine_mode_timing_adjuster_state =
             engine_mode_timing_adjuster_state - engine_timing_decrement_step;
      }
      else {
        engine_mode_timing_adjuster_state = 0;
      }
    }
  }
  if ((fuel_timing_offset_value < engine_mode_timing_adjuster_state) && (!bVar1)) {
    fuel_timing_offset_value = engine_mode_timing_adjuster_state;
  }
  return;
}



/*
 * Function: timingOffsetCalculatorWrapper @ 0x0001ef18
 */

void timingOffsetCalculatorWrapper(void)

{
  fuelTimingOffsetCalculator();
  return;
}



/*
 * Function: qadcDataCollectionStateMachine @ 0x0001ef20
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void qadcDataCollectionStateMachine(void)

{
  byte bVar1;
  word *pwVar2;
  
  if (_qadc_collection_state_machine == 2) {
    if (TPU_PRAM_CH1_4 == 5) {
      if ((qadc_qadcivr & 1) == 0) {
        if (circular_buffer_count == 0) {
          _qadc_collection_state_machine = 0;
          qadc_circular_buffer_offset = parameter_circular_buffer_value;
          TPU_PRAM_CH1_4 = 3;
          TPU_PRAM_CH0_2 = 0xbd;
          TPU_PRAM_CH1_6 = parameter_circular_buffer_value;
          TPU_PRAM_CH0_3 = 0xfd;
        }
        else {
          _qadc_collection_state_machine = 1;
        }
      }
    }
    else {
      TPU_PRAM_CH1_4 = 5;
      TPU_PRAM_CH0_2 = 0xbd;
      TPU_PRAM_CH1_6 = 0;
      TPU_PRAM_CH0_3 = 0x3d;
      TPU_PRAM_CH1_8 = 0;
      TPU_PRAM_CH0_4 = 0xfd;
      TPU_PRAM_CH1_10 = 0;
      TPU_PRAM_CH0_5 = 0xfd;
    }
  }
  else if (_qadc_collection_state_machine == 0) {
    pwVar2 = &qadc_portqa;
    bVar1 = 4;
    do {
      if (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 != 0) {
        *(word *)(qadc_circular_buffer_dest_ptr + qadc_circular_buffer_offset) = *pwVar2;
      }
      qadc_circular_buffer_offset = qadc_circular_buffer_offset + 2;
      if (0xfff < qadc_circular_buffer_offset) {
        qadc_circular_buffer_offset = 0;
        qadc_data_collection_ready_flag = 1;
        bVar1 = 0x10;
      }
      pwVar2 = pwVar2 + 1;
      bVar1 = bVar1 + 1;
    } while (bVar1 < 0x10);
    if (circular_buffer_count == 0) {
      TPU_PRAM_CH1_6 = qadc_circular_buffer_offset;
      TPU_PRAM_CH0_3 = 0xfd;
    }
    else {
      _qadc_collection_state_machine = 1;
    }
  }
  if (_qadc_collection_state_machine == 1) {
    TPU_PRAM_CH1_4 = 6;
    TPU_PRAM_CH0_2 = 0x3d;
    TPU_PRAM_CH1_6 = 2;
    TPU_PRAM_CH0_3 = 0xbd;
    TPU_PRAM_CH1_8 = (&circular_buffer_metadata)[(short)circular_buffer_read_index];
    TPU_PRAM_CH0_4 = 0xfd;
    TPU_PRAM_CH1_10 = (word)(&circular_buffer_data)[(short)circular_buffer_read_index];
    TPU_PRAM_CH0_5 = 0x3d;
    _qadc_collection_state_machine = 2;
    circular_buffer_count = circular_buffer_count - 1;
    circular_buffer_read_index = circular_buffer_read_index + 1 & 0x1ff;
  }
  return;
}



/*
 * Function: tpuQadcInterruptHandler @ 0x0001f068
 */

undefined8 tpuQadcInterruptHandler(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  TPU_CFSR1 = TPU_CFSR1 & 0x7f;
  qadcDataCollectionStateMachine();
  tpu_hssr1 = tpu_hssr1 | 0x8000;
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: emptyStubWrapper2 @ 0x0001f08e
 */

void emptyStubWrapper2(void)

{
  return;
}



/*
 * Function: initTPU @ 0x0001f090
 */

/* WARNING: Removing unreachable block (ram,0x0001f19e) */
/* WARNING: Removing unreachable block (ram,0x0001f1b0) */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initTPU(void)

{
  ushort uVar1;
  
  emptyStubWrapper2();
  system_callback_table_t_00808f02.tpu_adc_isr = (dword)tpuQadcInterruptHandler;
  tpu_hsqr1 = 0x7b;
  TPU_HSRR0_H = 0xfe;
  TPU_HSQR1_H = 0xff;
  tpu_hssr0 = 0x8004;
  tpu_cpr0 = tpu_cpr0 & 0xf0f0 | 0xf02;
  tpu_hssr1 = tpu_hssr1 & 0x8000 | 0x1001;
  TPU_PRAM_CH1_0 = 0;
  TPU_PRAM_CH0_0 = 0x7e;
  TPU_PRAM_CH1_2 = 0;
  TPU_PRAM_CH0_1 = 0x7e;
  TPU_PRAM_CH1_4 = 3;
  TPU_PRAM_CH0_2 = 0xbd;
  TPU_PRAM_CH1_6 = qadc_circular_buffer_offset;
  TPU_PRAM_CH0_3 = 0xfd;
  uVar1 = 4;
  do {
    (&TPU_PRAM_CH1_0)[uVar1] = 0;
    (&TPU_PRAM_CH0_0)[uVar1] = 0xfd;
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x10);
  amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 = 1;
  qadc_circular_buffer_dest_ptr = (dword)&can_message_buffer_start;
  _qadc_collection_state_machine = 0;
  if (qadc_data_collection_ready_flag == 0) {
    do {
    } while( true );
  }
  tpu_cpr0 = tpu_cpr0 | 0x8000;
  tpu_hssr1 = tpu_hssr1 & 0xff00 | 0x8023;
  return;
}



/*
 * Function: memcpy @ 0x0001f1e0
 */

void memcpy(undefined1 *param_1,undefined1 *param_2,undefined4 param_3)

{
  ushort uVar1;
  
  for (uVar1 = 0; uVar1 < param_3._0_2_; uVar1 = uVar1 + 1) {
    *param_1 = *param_2;
    param_1 = param_1 + 1;
    param_2 = param_2 + 1;
  }
  return;
}



/*
 * Function: dualTableFuelInterpolationCalculator @ 0x0001f1fa
 */

void dualTableFuelInterpolationCalculator(void)

{
  short sVar1;
  short sVar2;
  
  snapshot_engine_rpm = current_engine_rpm;
  snapshot_throttle_position = throttle_position_raw;
  sVar1 = lookupTableInterpolation((table_interp_args_t *)&rpm_lookup_table_2_arg);
  sVar2 = lookupTableInterpolation((table_interp_args_t *)&rpm_lookup_table_1_arg);
  fsmxthfl_calc_input = sVar1 + sVar2;
  return;
}



/*
 * Function: initRpmLookupTables @ 0x0001f23e
 */

void initRpmLookupTables(void)

{
  snapshot_engine_rpm = current_engine_rpm;
  rpm_lookup_table_1_ptr = 0x80883a;
  rpm_lookup_table_2_ptr = 0x80884e;
  rpm_lookup_table_1_arg = 2;
  snapshot_throttle_position = throttle_position_raw;
  rpm_lookup_table_3_ptr = 0x808862;
  rpm_lookup_table_4_ptr = 0x808876;
  rpm_lookup_table_2_arg = 2;
  return;
}



/*
 * Function: crankStateVariablesReset @ 0x0001f28c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void crankStateVariablesReset(void)

{
  crank_initial_advace_break_speed_0_1000 = 0;
  _crank_state_active_flag = 0;
  crank_initial_fuel_break_speed_0_1000 = 0;
  _crank_fuel_delta_accumulator = 0;
  _crank_timing_delta_accumulator = 0;
  crank_fuel_over_limit_snapshot = 0;
  _DGCLTPLF = 0;
  eps_period_backup_time_between_the_two_most_recent_eps_200_16777216 = 0;
  crank_fuel_status_flags = 0;
  crank_fuel_buffer_index = scheduler_slot_index;
  return;
}



/*
 * Function: crankFuelAndTimingBufferStore @ 0x0001f2ce
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void crankFuelAndTimingBufferStore(void)

{
  byte *pbVar1;
  short sVar2;
  short sVar3;
  
  scheduler_slot_index = (word)((crank_fuel_buffer_index + 2) % 3);
  *(undefined4 *)((short)(scheduler_slot_index * 2) * 8 + 0x80559c) = _crank_fuel_calculation_state;
  *(int *)((short)(scheduler_slot_index * 2) * 8 + 0x8055a0) =
       _fueling_val_to_be_added_to_crank_initial_fuel_val_0_100;
  *(dword *)((short)(scheduler_slot_index * 2) * 8 + 0x8055ce) = crank_timing_state_current;
  *(int *)((short)(scheduler_slot_index * 2) * 8 + 0x8055d2) = _crank_exit_fuel_adjustment_0_100;
  if (crank_fuel_timing_buffer_value != 0) {
    if (crank_fuel_timing_buffer_value == 1) {
      if ((crank_fuel_status_flags & 0xc) == 0) {
        *(undefined2 *)((short)scheduler_slot_index * 2 + 0x805594) = 0;
      }
      else {
        *(undefined2 *)((short)scheduler_slot_index * 2 + 0x805594) = 1;
      }
      *(uint *)((short)(scheduler_slot_index * 2) * 8 + 0x8055a8) =
           (uint)crank_mode_1_calibration_factor * 0x465;
      *(uint *)((short)(scheduler_slot_index * 2) * 8 + 0x8055a4) =
           (uint)crank_mode_1_calibration_factor * 0x465;
      pbVar1 = &DGLOPRLF + (short)(scheduler_slot_index * 2) * 8;
      pbVar1[0] = 0;
      pbVar1[1] = 0;
      pbVar1[2] = 0;
      pbVar1[3] = 0;
      *(undefined4 *)((short)(scheduler_slot_index * 2) * 8 + 0x8055d6) = 0;
      return;
    }
    *(undefined4 *)((short)(scheduler_slot_index * 2) * 8 + 0x8055a8) = 0;
    *(undefined4 *)((short)(scheduler_slot_index * 2) * 8 + 0x8055a4) = 0;
    pbVar1 = &DGLOPRLF + (short)(scheduler_slot_index * 2) * 8;
    pbVar1[0] = 0;
    pbVar1[1] = 0;
    pbVar1[2] = 0;
    pbVar1[3] = 0;
    *(undefined4 *)((short)(scheduler_slot_index * 2) * 8 + 0x8055d6) = 0;
    return;
  }
  *(ushort *)((short)scheduler_slot_index * 2 + 0x805594) = (ushort)(crank_fuel_status_flags != 0);
  *(uint *)((short)(scheduler_slot_index * 2) * 8 + 0x8055a4) = (uint)crank_fuel_divisor * 0x465;
  sVar2 = scheduler_slot_index << 4;
  *(uint *)(sVar2 + 0x8055d6) = (uint)timing_command_before_cranking_is_envoked_0_120 << 7;
  if (0x63ff < crank_adjusted_initial_fuel_0_100) {
    *(dword *)((short)(scheduler_slot_index * 2) * 8 + 0x8055a8) = crank_fuel_over_limit_snapshot;
    *(undefined4 *)(&DGLOPRLF + (short)(scheduler_slot_index * 2) * 8) = _DGCLTPLF;
    return;
  }
  sVar3 = scheduler_slot_index << 4;
  *(int *)(sVar3 + 0x8055a8) =
       _fueling_val_to_be_added_to_crank_initial_fuel_val_0_100 +
       (*(int *)(sVar2 + 0x8055a4) - _crank_fuel_delta_accumulator);
  *(int *)(&DGLOPRLF + (short)(scheduler_slot_index * 2) * 8) =
       _crank_exit_fuel_adjustment_0_100 +
       (*(int *)(sVar3 + 0x8055d6) - _crank_timing_delta_accumulator);
  return;
}



/*
 * Function: crankFuelCalculationAndProtection @ 0x0001f4f8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint crankFuelCalculationAndProtection(void)

{
  undefined4 in_D0;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  ushort uVar4;
  undefined1 *puVar5;
  
  puVar5 = &stack0xffffffe0;
  uVar3 = CONCAT22((short)((uint)in_D0 >> 0x10),vp44_status_flags_2) & 0xffff2000;
  if ((vp44_status_flags_2 & 0x2000) != 0) {
    if ((ushort)(((uint)crank_fuel_threshold_divisor << 8) / 10) <=
        crank_adjusted_initial_fuel_0_100) {
      eps_period_backup_time_between_the_two_most_recent_eps_200_16777216 = 1;
    }
    _fueling_val_to_be_added_to_crank_initial_fuel_val_0_100 =
         _crank_fuel_calculation_state -
         *(int *)((short)(crank_fuel_buffer_index * 2) * 8 + 0x80559c);
    _crank_exit_fuel_adjustment_0_100 =
         crank_timing_state_current - *(int *)((short)(crank_fuel_buffer_index * 2) * 8 + 0x8055ce);
    if ((current_engine_rpm != 0) && (_crank_rpm_condition_flag != 0)) {
      if (crank_debounce_threshold < crank_rpm_debounce_counter) {
        crank_fuel_status_flags = crank_fuel_status_flags | 2;
      }
      else {
        crank_rpm_debounce_counter = crank_rpm_debounce_counter + 1;
      }
    }
    if (((current_engine_rpm != 0) && ((fault_flags_active_base & 0x800) != 0)) &&
       ((fault_flags_enabled_base & 0x800) != 0)) {
      if (crank_debounce_threshold < crank_sensor_fault_debounce_counter) {
        crank_fuel_status_flags = crank_fuel_status_flags | 4;
      }
      else {
        crank_sensor_fault_debounce_counter = crank_sensor_fault_debounce_counter + 1;
      }
    }
    uVar3 = (uint)crank_fuel_timing_buffer_value;
    if (crank_fuel_timing_buffer_value == 0) {
      uVar4 = (short)_crank_fuel_calculation_state - crank_fuel_state_delta_base;
      _crank_fuel_state_previous = _crank_fuel_calculation_state;
      uVar4 = (ushort)((uint)uVar4 * (uint)param_scaling_factor >> 8);
      if (-(uint)uVar4 - 1 < _crank_fuel_delta_accumulator) {
        crank_fuel_status_flags = crank_fuel_status_flags | 8;
      }
      _crank_fuel_delta_accumulator = uVar4 + _crank_fuel_delta_accumulator;
      uVar1 = proportionalCalculation
                        (_crank_fuel_delta_accumulator,0x6400,(uint)crank_fuel_divisor * 0x465);
      uVar4 = (short)crank_timing_state_current - crank_timing_state_delta_base;
      _crank_timing_state_previous = crank_timing_state_current;
      uVar4 = (ushort)((uint)uVar4 * (uint)param_scaling_factor >> 8);
      if (-(uint)uVar4 - 1 < _crank_timing_delta_accumulator) {
        crank_fuel_status_flags = crank_fuel_status_flags | 8;
      }
      _crank_timing_delta_accumulator = uVar4 + _crank_timing_delta_accumulator;
      uVar2 = proportionalCalculation
                        (_crank_timing_delta_accumulator,0x6400,
                         (uint)timing_command_before_cranking_is_envoked_0_120 << 7);
      puVar5 = &stack0xffffffe0;
      if ((uVar1 < uVar2) || (uVar3 = (uint)crank_adjusted_initial_rpm_0_1000, uVar1 < uVar3)) {
        if ((uVar1 < crank_adjusted_initial_rpm_0_1000) &&
           (uVar3 = (uint)crank_adjusted_initial_rpm_0_1000, uVar2 < uVar3)) {
          crank_fuel_limit_source_selector = 3;
          crank_adjusted_initial_fuel_0_100 = crank_adjusted_initial_rpm_0_1000;
        }
        else {
          uVar3 = (uint)crank_adjusted_initial_rpm_0_1000;
          crank_fuel_limit_source_selector = 2;
          crank_adjusted_initial_fuel_0_100 = (word)uVar2;
        }
      }
      else {
        crank_fuel_limit_source_selector = 1;
        crank_adjusted_initial_fuel_0_100 = (word)uVar1;
      }
    }
    else if (crank_fuel_timing_buffer_value == 1) {
      puVar5 = &stack0xffffffd4;
      uVar3 = proportionalCalculation
                        (_crank_fuel_calculation_state -
                         *(int *)((short)(crank_fuel_buffer_index * 2) * 8 + 0x80559c),0x6400,
                         (uint)crank_mode_1_calibration_factor * 0x465);
      crank_adjusted_initial_fuel_0_100 = (word)uVar3;
      crank_fuel_limit_source_selector = 1;
    }
    else {
      crank_adjusted_initial_fuel_0_100 = crank_adjusted_initial_rpm_0_1000;
      crank_fuel_limit_source_selector = 3;
    }
    if (((crank_fuel_over_limit_snapshot == 0) && (_DGCLTPLF == 0)) &&
       (0x63ff < crank_adjusted_initial_fuel_0_100)) {
      crank_fuel_over_limit_snapshot =
           _crank_fuel_calculation_state -
           *(int *)((short)(crank_fuel_buffer_index * 2) * 8 + 0x80559c);
      uVar3 = crank_timing_state_current -
              *(int *)((short)(crank_fuel_buffer_index * 2) * 8 + 0x8055ce);
      _DGCLTPLF = uVar3;
    }
    if ((crank_state_reset_trigger == 1) || (_crank_state_active_flag == 1)) {
      *(undefined4 *)(puVar5 + -4) = 0x1f7b4;
      crankFuelAndTimingBufferStore();
      *(undefined4 *)(puVar5 + -4) = 0x1f7b8;
      uVar3 = crankStateVariablesReset();
    }
    crank_state_reset_trigger = crank_initial_advace_break_speed_0_1000;
  }
  return uVar3;
}



/*
 * Function: initParameterScalingSystem @ 0x0001f7cc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initParameterScalingSystem(void)

{
  table_interp_args_t local_1c;
  table_interp_args_t local_10;
  
  _crank_fuel_state_previous = _crank_fuel_calculation_state;
  _crank_timing_state_previous = crank_timing_state_current;
  param_scaling_factor = 0x100;
  local_1c.current_index = 2;
  local_1c.x_axis_ptr = 0x80888c;
  local_1c.y_axis_ptr = 0x8088a4;
  local_10.current_index = 2;
  local_10.x_axis_ptr = 0x80888c;
  local_10.y_axis_ptr = 0x808898;
  if (crank_fuel_timing_buffer_value == 0) {
    local_1c.input_value = param_scaling_lookup_value;
    timing_command_before_cranking_is_envoked_0_120 = lookupTableInterpolation(&local_1c);
    local_10.input_value = param_scaling_lookup_value;
    crank_fuel_divisor = lookupTableInterpolation(&local_10);
  }
  return;
}



/*
 * Function: pwmOutputInit @ 0x0001f860
 */

void pwmOutputInit(void)

{
  qsm_sci_status_reg =
       (pwm_output_channel_select & 7) << 0xc |
       (ushort)(30000000 / ((uint)pwm_output_period_multiplier * (uint)pwm_output_frequency_divisor)
               ) & 0xfff;
  if (pwm_output_enable_flag == 1) {
    qsm_sci_status_reg = qsm_sci_status_reg | 0x8000;
  }
  return;
}



/*
 * Function: fuelSmokeLimiterCalculator @ 0x0001f8aa
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelSmokeLimiterCalculator(void)

{
  int iVar1;
  uint uVar2;
  ushort uVar3;
  
  if ((fsmxthfl_calc_input < current_fuel_demand_value) &&
     (fsmxthfl_calc_input < calculated_fuel_timing_value)) {
    uVar2 = proportionalCalculation
                      ((uint)current_fuel_demand_value - (uint)fsmxthfl_calc_input,0x6400,
                       (uint)calculated_fuel_timing_value - (uint)fsmxthfl_calc_input);
    if (uVar2 < 0x7f81) {
      smoke_limiter_output_value = (word)uVar2;
    }
    else {
      smoke_limiter_output_value = 0x7f80;
    }
  }
  else {
    smoke_limiter_output_value = 0;
  }
  if (fsmxthfl_calc_input < current_fuel_demand_value) {
    if ((fuel_demand_rate_limit < current_engine_rpm) && (_arbitrator_status_flag != 0)) {
      iVar1 = ((uint)fuel_limit_offset_value + (uint)current_engine_rpm) -
              (uint)fuel_demand_rate_limit;
      uVar2 = iVar1 * 0x1111;
      if ((uint)fuel_limit_comparison_low * (uint)fuel_limit_comparison_high < uVar2 ||
          (uint)fuel_limit_comparison_low * (uint)fuel_limit_comparison_high + iVar1 * -0x1111 == 0)
      {
        uVar3 = 0;
      }
      else {
        uVar3 = fuel_limit_comparison_low - (short)(uVar2 / fuel_limit_comparison_high);
        if (0x1700 < uVar3) {
          uVar3 = 0x1700;
        }
      }
      if (uVar3 <= fsmxthfl_calc_input) {
        asthrfes_calc_input = 0;
        return;
      }
      uVar3 = uVar3 - fsmxthfl_calc_input;
    }
    else {
      if (calculated_fuel_timing_value <= fsmxthfl_calc_input) {
        asthrfes_calc_input = 0;
        return;
      }
      uVar3 = calculated_fuel_timing_value - fsmxthfl_calc_input;
    }
    uVar2 = (uint)(ushort)(current_fuel_demand_value - fsmxthfl_calc_input) * 0x6400;
    if (uVar2 < (uint)uVar3 * 0x7f80) {
      asthrfes_calc_input = (word)(uVar2 / uVar3);
    }
    else {
      asthrfes_calc_input = 0x7f80;
    }
  }
  else {
    asthrfes_calc_input = 0;
  }
  return;
}



/*
 * Function: insiteActiveFaultListBuilder @ 0x0001fa00
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteActiveFaultListBuilder(void)

{
  byte bVar1;
  char cVar3;
  uint uVar2;
  byte bVar4;
  
  if (insite_response_buffer_length < 0x14) {
    *_insite_response_buffer_ptr = insite_command_byte;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    cVar3 = (char)diagnostic_active_fault_counter;
    *_insite_response_buffer_ptr = cVar3;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    bVar4 = 1;
    for (; cVar3 != '\0'; cVar3 = cVar3 + -1) {
      *_insite_response_buffer_ptr = (&diagnostic_pending_code_count)[(short)(ushort)bVar4] | 0x80;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      bVar4 = bVar4 + 1;
    }
    insite_response_buffer_index = insite_response_buffer_length + insite_response_buffer_index;
    insite_bytes_remaining = insite_bytes_remaining - insite_response_buffer_length;
    return;
  }
  uVar2 = insiteMultiFrameResponseBuilder(0xe000f);
  if ((char)uVar2 == '\0') {
    bVar4 = 1;
    while (multi_packet_tx_state <= insite_multi_frame_state) {
      while (bVar1 = multi_packet_sequence_counter - 1, multi_packet_sequence_counter != 0) {
        multi_packet_sequence_counter = bVar1;
        *_insite_response_buffer_ptr = (&diagnostic_pending_code_count)[(short)(ushort)bVar4] & 0x80
        ;
        bVar4 = bVar4 + 1;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      }
      if (multi_packet_tx_state == insite_multi_frame_state) {
        multi_packet_sequence_counter = bVar1;
        responseBufferFinalize();
        insite_response_continuation_ptr = (dword)_insite_response_buffer_ptr;
        multi_packet_tx_state = multi_packet_tx_state + 1;
        insite_response_buffer_index = 0;
      }
      else {
        multi_packet_sequence_counter = bVar1;
        insiteMultiFrameContinuation();
      }
    }
  }
  return;
}



/*
 * Function: insiteFaultDetailBuilder @ 0x0001fafe
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteFaultDetailBuilder(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  word wVar4;
  ushort uVar5;
  ushort uVar6;
  byte bVar7;
  byte *pbVar8;
  byte *pbVar9;
  
  if (insite_response_buffer_length < 0x14) {
    *_insite_response_buffer_ptr = insite_command_byte;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    if (insite_data_valid_flag == 0) {
      *_insite_response_buffer_ptr = (char)insite_fault_detail_state * '\x02';
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      wVar4 = insite_fault_detail_state;
      uVar6 = 1;
      while ((char)wVar4 != '\0') {
        uVar5 = (ushort)(byte)((char)uVar6 + 1);
        iVar2 = (int)(short)((ushort)(&diagnostic_pending_code_count)[(short)uVar6] * 6);
        uVar6 = uVar5;
        if (((*(ushort *)(&dtc_fault_table_base + iVar2) & 0x2000) == 0) &&
           (*(char *)((int)&diagnostic_sensor_data_ptr + iVar2) != '\0')) {
          *_insite_response_buffer_ptr = *(undefined1 *)((int)&diagnostic_sensor_data_ptr + iVar2);
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          *_insite_response_buffer_ptr =
               (byte)((int)(uint)*(ushort *)(&dtc_fault_table_base + iVar2) >> 7) & 0x3f;
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          wVar4 = (word)(byte)((char)wVar4 - 1);
        }
      }
    }
    else {
      *_insite_response_buffer_ptr =
           ((char)insite_fault_detail_index + (char)insite_fault_detail_state) * '\x03';
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      wVar4 = insite_fault_detail_state;
      uVar6 = 1;
      while ((char)wVar4 != '\0') {
        uVar5 = (ushort)(byte)((char)uVar6 + 1);
        bVar7 = (&diagnostic_pending_code_count)[(short)uVar6];
        iVar2 = (int)(short)((ushort)bVar7 * 6);
        uVar6 = uVar5;
        if (((*(ushort *)(&dtc_fault_table_base + iVar2) & 0x2000) == 0) &&
           (*(char *)((int)&diagnostic_sensor_data_ptr + iVar2) != '\0')) {
          *_insite_response_buffer_ptr = *(undefined1 *)((int)&diagnostic_sensor_data_ptr + iVar2);
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          *_insite_response_buffer_ptr =
               (byte)((int)(uint)*(ushort *)(&dtc_fault_table_base + iVar2) >> 7) & 0x3f | 0x80;
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          *_insite_response_buffer_ptr = (&diagnostic_pid_dtc_index)[(short)((ushort)bVar7 * 5) * 2]
          ;
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          wVar4 = (word)(byte)((char)wVar4 - 1);
        }
      }
      wVar4 = insite_fault_detail_index;
      uVar6 = 1;
      while ((char)wVar4 != '\0') {
        uVar5 = (ushort)(byte)((char)uVar6 + 1);
        bVar7 = (&diagnostic_active_code_count)[(short)uVar6];
        iVar2 = (int)(short)((ushort)bVar7 * 6);
        uVar6 = uVar5;
        if (((*(ushort *)(&dtc_fault_table_base + iVar2) & 0x2000) == 0) &&
           (*(char *)((int)&diagnostic_sensor_data_ptr + iVar2) != '\0')) {
          *_insite_response_buffer_ptr = *(undefined1 *)((int)&diagnostic_sensor_data_ptr + iVar2);
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          *_insite_response_buffer_ptr =
               (byte)((int)(uint)*(ushort *)(&dtc_fault_table_base + iVar2) >> 7) & 0x3f | 0xc0;
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          *_insite_response_buffer_ptr = (&diagnostic_pid_dtc_index)[(short)((ushort)bVar7 * 5) * 2]
          ;
          _insite_response_buffer_ptr =
               (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
          wVar4 = (word)(byte)((char)wVar4 - 1);
        }
      }
    }
    insite_response_buffer_index = insite_response_buffer_length + insite_response_buffer_index;
    insite_bytes_remaining = insite_bytes_remaining - insite_response_buffer_length;
    return;
  }
  if (insite_data_valid_flag == 0) {
    uVar3 = insiteMultiFrameResponseBuilder(0xe000e);
    if ((char)uVar3 == '\0') {
      uVar6 = 1;
      while (multi_packet_tx_state <= insite_multi_frame_state) {
        while (multi_packet_sequence_counter != 0) {
          uVar5 = (ushort)(byte)((char)uVar6 + 1);
          iVar2 = (int)(short)((ushort)(&diagnostic_pending_code_count)[(short)uVar6] * 6);
          uVar6 = uVar5;
          if (((*(ushort *)(&dtc_fault_table_base + iVar2) & 0x2000) == 0) &&
             (*(char *)((int)&diagnostic_sensor_data_ptr + iVar2) != '\0')) {
            *_insite_response_buffer_ptr = *(byte *)((int)&diagnostic_sensor_data_ptr + iVar2);
            _insite_response_buffer_ptr =
                 (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
            *_insite_response_buffer_ptr =
                 (byte)((int)(uint)*(ushort *)(&dtc_fault_table_base + iVar2) >> 7) & 0x3f;
            _insite_response_buffer_ptr =
                 (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
            multi_packet_sequence_counter = multi_packet_sequence_counter - 2;
          }
        }
        if (multi_packet_tx_state == insite_multi_frame_state) {
          responseBufferFinalize();
          insite_response_continuation_ptr = (dword)_insite_response_buffer_ptr;
          multi_packet_tx_state = multi_packet_tx_state + 1;
          insite_response_buffer_index = 0;
        }
        else {
          insiteMultiFrameContinuation();
        }
      }
      return;
    }
  }
  else {
    uVar3 = insiteMultiFrameResponseBuilder(0xc000f);
    if ((char)uVar3 == '\0') {
      bVar7 = 0;
      pbVar8 = &diagnostic_pending_code_array;
      wVar4 = insite_fault_detail_state;
      while (multi_packet_tx_state <= insite_multi_frame_state) {
        while (multi_packet_sequence_counter != 0) {
          pbVar9 = pbVar8;
          if ((char)wVar4 == '\0') {
            pbVar9 = &diagnostic_active_code_array;
            bVar7 = 0x40;
            wVar4 = insite_fault_detail_index;
          }
          pbVar8 = pbVar9 + 1;
          bVar1 = *pbVar9;
          iVar2 = (int)(short)((ushort)bVar1 * 6);
          if (((*(ushort *)(&dtc_fault_table_base + iVar2) & 0x2000) == 0) &&
             (*(char *)((int)&diagnostic_sensor_data_ptr + iVar2) != '\0')) {
            *_insite_response_buffer_ptr = *(byte *)((int)&diagnostic_sensor_data_ptr + iVar2);
            _insite_response_buffer_ptr =
                 (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
            *_insite_response_buffer_ptr =
                 bVar7 | (byte)((int)(uint)*(ushort *)(&dtc_fault_table_base + iVar2) >> 7) & 0x3f |
                 0x80;
            _insite_response_buffer_ptr =
                 (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
            *_insite_response_buffer_ptr =
                 (&diagnostic_pid_dtc_index)[(short)((ushort)bVar1 * 5) * 2];
            _insite_response_buffer_ptr =
                 (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
            wVar4 = (word)(byte)((char)wVar4 - 1);
            multi_packet_sequence_counter = multi_packet_sequence_counter - 3;
          }
        }
        if (multi_packet_tx_state == insite_multi_frame_state) {
          responseBufferFinalize();
          insite_response_continuation_ptr = (dword)_insite_response_buffer_ptr;
          multi_packet_tx_state = multi_packet_tx_state + 1;
          insite_response_buffer_index = 0;
        }
        else {
          insiteMultiFrameContinuation();
        }
      }
    }
  }
  return;
}



/*
 * Function: insiteEcuIdResponseBuilder @ 0x0001fec4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteEcuIdResponseBuilder(void)

{
  uint uVar1;
  byte bVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte *pbVar5;
  
  if (insite_response_buffer_length < 0x14) {
    *_insite_response_buffer_ptr = insite_command_byte;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = insite_response_buffer_length - 2;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    bVar2 = 0;
    pbVar4 = &insite_ecu_id_part_1;
    do {
      *_insite_response_buffer_ptr = *pbVar4;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar4 + 1;
    } while (bVar2 < 4);
    *_insite_response_buffer_ptr = 0x2a;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    bVar2 = 0;
    pbVar4 = &insite_ecu_id_part_2;
    do {
      *_insite_response_buffer_ptr = *pbVar4;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar4 + 1;
    } while (bVar2 < 4);
    *_insite_response_buffer_ptr = 0x2a;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    bVar2 = 0;
    pbVar4 = &insite_ecu_id_part_3;
    do {
      *_insite_response_buffer_ptr = *pbVar4;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar4 + 1;
    } while (bVar2 < 0xc);
    insite_response_buffer_index = insite_response_buffer_length + insite_response_buffer_index;
    insite_bytes_remaining = insite_bytes_remaining - insite_response_buffer_length;
    return;
  }
  uVar1 = insiteMultiFrameResponseBuilder(0xe000f);
  if ((char)uVar1 == '\0') {
    bVar2 = 0;
    pbVar4 = &insite_ecu_id_response_buffer;
    pbVar5 = &insite_ecu_id_part_1;
    do {
      pbVar3 = pbVar4;
      *pbVar3 = *pbVar5;
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar3 + 1;
      pbVar5 = pbVar5 + 1;
    } while (bVar2 < 4);
    pbVar3[1] = 0x2a;
    bVar2 = 0;
    pbVar4 = pbVar3 + 2;
    pbVar5 = &insite_ecu_id_part_2;
    do {
      pbVar3 = pbVar4;
      *pbVar3 = *pbVar5;
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar3 + 1;
      pbVar5 = pbVar5 + 1;
    } while (bVar2 < 4);
    pbVar3[1] = 0x2a;
    bVar2 = 0;
    pbVar4 = pbVar3 + 2;
    pbVar5 = &insite_ecu_id_part_3;
    do {
      *pbVar4 = *pbVar5;
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar4 + 1;
      pbVar5 = pbVar5 + 1;
    } while (bVar2 < 0xc);
    pbVar4 = &insite_ecu_id_response_buffer;
    while (multi_packet_tx_state <= insite_multi_frame_state) {
      while (bVar2 = multi_packet_sequence_counter - 1, multi_packet_sequence_counter != 0) {
        multi_packet_sequence_counter = bVar2;
        *_insite_response_buffer_ptr = *pbVar4;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        pbVar4 = pbVar4 + 1;
      }
      if (multi_packet_tx_state == insite_multi_frame_state) {
        multi_packet_sequence_counter = bVar2;
        responseBufferFinalize();
        insite_response_continuation_ptr = (dword)_insite_response_buffer_ptr;
        multi_packet_tx_state = multi_packet_tx_state + 1;
        insite_response_buffer_index = 0;
      }
      else {
        multi_packet_sequence_counter = bVar2;
        insiteMultiFrameContinuation();
      }
    }
  }
  return;
}



/*
 * Function: insiteCapacityResponseBuilder @ 0x0002003c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteCapacityResponseBuilder(void)

{
  uint uVar1;
  byte bVar2;
  char *pcVar3;
  byte *pbVar4;
  
  if (insite_response_buffer_length < 0x14) {
    *_insite_response_buffer_ptr = insite_command_byte;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = 0x14;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    pcVar3 = s_CAPACITY_39442720003948543000394_00004499 + 0x1e;
    for (bVar2 = 0; bVar2 < 0x14; bVar2 = bVar2 + 1) {
      *_insite_response_buffer_ptr = *pcVar3;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      pcVar3 = pcVar3 + 1;
    }
    insite_response_buffer_index = insite_response_buffer_length + insite_response_buffer_index;
    insite_bytes_remaining = insite_bytes_remaining - insite_response_buffer_length;
    return;
  }
  uVar1 = insiteMultiFrameResponseBuilder(0xe000f);
  if ((char)uVar1 == '\0') {
    pbVar4 = (byte *)(s_CAPACITY_39442720003948543000394_00004499 + 0x1e);
    while (multi_packet_tx_state <= insite_multi_frame_state) {
      for (bVar2 = 0; bVar2 < multi_packet_sequence_counter; bVar2 = bVar2 + 1) {
        *_insite_response_buffer_ptr = *pbVar4;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        pbVar4 = pbVar4 + 1;
      }
      if (multi_packet_tx_state == insite_multi_frame_state) {
        responseBufferFinalize();
        insite_response_continuation_ptr = (dword)_insite_response_buffer_ptr;
        multi_packet_tx_state = multi_packet_tx_state + 1;
        insite_response_buffer_index = 0;
      }
      else {
        insiteMultiFrameContinuation();
      }
    }
  }
  return;
}



/*
 * Function: insiteVersionInfoBuilder @ 0x0002011c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void insiteVersionInfoBuilder(void)

{
  uint uVar1;
  byte bVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte *pbVar5;
  
  if (insite_response_buffer_length < 0x14) {
    *_insite_response_buffer_ptr = insite_command_byte;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = insite_response_buffer_length - 2;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    *_insite_response_buffer_ptr = 0x80;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    bVar2 = 0;
    pbVar4 = &insite_version_string_part_1;
    do {
      *_insite_response_buffer_ptr = *pbVar4;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar4 + 1;
    } while (bVar2 < 5);
    *_insite_response_buffer_ptr = 0x2a;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    bVar2 = 0;
    pbVar4 = &insite_version_string_part_2;
    do {
      *_insite_response_buffer_ptr = *pbVar4;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar4 + 1;
    } while (bVar2 < 0x11);
    *_insite_response_buffer_ptr = 0x2a;
    _insite_response_buffer_ptr =
         (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
    bVar2 = 0;
    pbVar4 = &insite_version_string_part_3;
    do {
      *_insite_response_buffer_ptr = *pbVar4;
      _insite_response_buffer_ptr =
           (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar4 + 1;
    } while (bVar2 < 4);
    insite_response_buffer_index = insite_response_buffer_length + insite_response_buffer_index;
    insite_bytes_remaining = insite_bytes_remaining - insite_response_buffer_length;
    return;
  }
  uVar1 = insiteMultiFrameResponseBuilder(0xe000f);
  if ((char)uVar1 == '\0') {
    insite_version_response_buffer = 0x80;
    bVar2 = 0;
    pbVar4 = &insite_version_buffer_start;
    pbVar5 = &insite_version_string_part_1;
    do {
      pbVar3 = pbVar4;
      *pbVar3 = *pbVar5;
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar3 + 1;
      pbVar5 = pbVar5 + 1;
    } while (bVar2 < 5);
    pbVar3[1] = 0x2a;
    bVar2 = 0;
    pbVar4 = pbVar3 + 2;
    pbVar5 = &insite_version_string_part_2;
    do {
      pbVar3 = pbVar4;
      *pbVar3 = *pbVar5;
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar3 + 1;
      pbVar5 = pbVar5 + 1;
    } while (bVar2 < 0x11);
    pbVar3[1] = 0x2a;
    bVar2 = 0;
    pbVar4 = pbVar3 + 2;
    pbVar5 = &insite_version_string_part_3;
    do {
      *pbVar4 = *pbVar5;
      bVar2 = bVar2 + 1;
      pbVar4 = pbVar4 + 1;
      pbVar5 = pbVar5 + 1;
    } while (bVar2 < 4);
    pbVar4 = &insite_version_response_buffer;
    while (multi_packet_tx_state <= insite_multi_frame_state) {
      while (bVar2 = multi_packet_sequence_counter - 1, multi_packet_sequence_counter != 0) {
        multi_packet_sequence_counter = bVar2;
        *_insite_response_buffer_ptr = *pbVar4;
        _insite_response_buffer_ptr =
             (byte *)CONCAT31(_insite_response_buffer_ptr,insite_response_write_offset + 1);
        pbVar4 = pbVar4 + 1;
      }
      if (multi_packet_tx_state == insite_multi_frame_state) {
        multi_packet_sequence_counter = bVar2;
        responseBufferFinalize();
        insite_response_continuation_ptr = (dword)_insite_response_buffer_ptr;
        multi_packet_tx_state = multi_packet_tx_state + 1;
        insite_response_buffer_index = 0;
      }
      else {
        multi_packet_sequence_counter = bVar2;
        insiteMultiFrameContinuation();
      }
    }
  }
  return;
}



/*
 * Function: hourMeterEventLogger @ 0x000202a4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void hourMeterEventLogger(void)

{
  byte bVar1;
  bool bVar2;
  short sVar3;
  int iVar4;
  uint uVar5;
  word wVar6;
  byte bVar7;
  byte *pbVar8;
  byte local_5;
  
  while( true ) {
    uVar5 = circularBufferPop(&time_key_switch_is_on_and_ecm_is_running_boot_or_application_0_2_29,
                              &local_5);
    if ((char)uVar5 != '\0') break;
    iVar4 = (uint)(local_5 & 0x7f) * 6;
    if (((*(char *)((int)&diagnostic_sensor_data_ptr + iVar4) != '\0') &&
        ((*(ushort *)(&dtc_fault_table_base + iVar4) & 0x800) == 0)) &&
       (((uint)_hour_meter_fault_category_mask &
        1 << ((int)(*(ushort *)(&dtc_fault_table_base + iVar4) & 0x780) >> 7)) != 0)) {
      bVar1 = *(byte *)((int)&diagnostic_sensor_data_ptr + iVar4);
      bVar7 = '\x01' << (bVar1 & 7);
      sVar3 = (short)((int)(uint)bVar1 >> 3);
      if ((bVar7 & *(byte *)((int)&
                                  maximum_time_between_tailshaft_pulses_allowed_before_vehicle_0_04_40
                            + (int)sVar3)) != 0) {
        wVar6 = fault_code_active_list_count;
        for (pbVar8 = &hour_meter_event_log_array; (wVar6 != 0 && (bVar1 != *pbVar8));
            pbVar8 = pbVar8 + 2) {
          wVar6 = wVar6 - 1;
        }
        if (wVar6 == 0) {
          if ((local_5 & 0x80) != 0) {
            *pbVar8 = bVar1;
            pbVar8[1] = 1;
            fault_code_active_list_count = fault_code_active_list_count + 1;
            *(byte *)(sVar3 + 0x8055fe) = bVar7 | *(byte *)(sVar3 + 0x8055fe);
          }
        }
        else if ((local_5 & 0x80) == 0) {
          bVar1 = pbVar8[1] - 1;
          pbVar8[1] = bVar1;
          if (bVar1 == 0) {
            *(byte *)(sVar3 + 0x8055fe) = ~bVar7 & *(byte *)(sVar3 + 0x8055fe);
            wVar6 = fault_code_active_list_count - 1;
            bVar2 = 1 < fault_code_active_list_count;
            fault_code_active_list_count = wVar6;
            if (bVar2) {
              *pbVar8 = (&hour_meter_event_log_array)[(short)wVar6 * 2];
              pbVar8[1] = (&hour_meter_event_log_array_1)[(short)fault_code_active_list_count * 2];
            }
          }
        }
        else {
          pbVar8[1] = pbVar8[1] + 1;
        }
      }
    }
  }
  return;
}



/*
 * Function: mainSystemInitialization @ 0x00020462
 */

/* WARNING: This function may have set the stack pointer */

void mainSystemInitialization(void)

{
  char in_XF;
  char cVar1;
  char cVar2;
  char cVar3;
  byte bVar4;
  
  tpu_dscr = 0;
  tpu_cier = 0;
  sim_csor0 = 0;
  sim_csbar1 = 0;
  can1_cantbsel = 0;
  QADC64_QMCR = 0x1201;
  QADC64_QADCTEST = 8;
  QADC64_PORTQA = 0x200;
  tpu_channel_priority_select = 4;
  QADC64_QACR1 = 8;
  QADC64_QACR2 = 0;
  QADC64_QSTAT = 0;
  QADC64_QADCSR = 1;
  QADC64_RJURR = 1;
  QADC64_CCW0 = 1;
  sim_timer_control_register._0_2_ = 0xffff;
  sim_timer_control_register._2_2_ = 0;
  QADC64_QADCINT = 8;
  QADC64_DDRQA = 0xffff;
  QADC64_PQBPAR = 0;
  QADC64_PQAPAR = 8;
  tpu_pwm_channel_3_output._0_2_ = 0xffff;
  tpu_pwm_channel_3_output._2_2_ = 0;
  QADC64_DDRQB = 8;
  tpu_pwm_channel_4_output._0_2_ = 0xffff;
  tpu_pwm_channel_4_output._2_2_ = 0;
  QADC64_LJSRR = 8;
  QADC64_CCW8 = 0x104;
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x576;
  initInternalRamAndCAN1();
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x57c;
  clearWorkingMemory();
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x582;
  firmwareDataCopyToWorkingMemory();
  calibration_checksum_workspace._2_2_ = 0xeeee;
  sim_data_direction_control = sim_data_direction_control | 8;
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x598;
  initVectorTable();
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x5ac;
  initQADC();
  tpu_tpumcr = 5;
  tpu_dscr = 0x13;
  TPU_TICR_H = 0x50;
  cVar1 = '\0';
  cVar2 = '\0';
  cVar3 = '\0';
  bVar4 = 0;
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x5ca;
  initTPU();
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x5d0;
  initMIOS14Timers();
  init_checkpoint_address = (word)(byte)(in_XF << 4 | cVar1 << 3 | cVar2 << 2 | cVar3 << 1 | bVar4);
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x5e0;
  validateRedundantSensors();
  if (loop_termination_flag == 0) {
    fault_flags_active_base = fault_flags_active_base & 0xfbff;
  }
  else {
    fault_flags_active_base = fault_flags_active_base | 0x400;
    fault_flags_history_base = fault_flags_history_base | 0x400;
  }
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x61c;
  initVP44StatusMonitoring();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x622;
  initADCChannelConfiguration();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x628;
  initCANBus();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x62e;
  initLoopCounter();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x634;
  initFuelSystemOutputDriver();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x63a;
  dmaDescriptorSetup2();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x640;
  initDerateSystemPointers();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x646;
  initMultiSystemParameters();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x64c;
  dmaControllerSetup1();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x652;
  engineProtectionSystemInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x658;
  diagnosticProtectionEvaluator();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x65e;
  fuelDeliverySystemInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x664;
  fuelArbitratorInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x66a;
  engineRpmSourceInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x670;
  canBusTimingInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x676;
  canControllerConfigInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x67c;
  canRpmModeConfigInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x682;
  engineOperatingModeInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x688;
  scheduler_init();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x68e;
  emptyInitPlaceholder();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x694;
  initDiagnosticModeSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x69a;
  initDerateSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6a0;
  initBoostProtectionSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6a6;
  initAcControlSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6ac;
  initAncSpeedLimitAndAltitudeDerate();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6b2;
  initVp44BufferAddresses();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6b8;
  initHourMeterSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6be;
  initLoadTrendingSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6c4;
  initOilPressureModeSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6ca;
  initFuelDemandCalculationSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6d0;
  emptyInit2();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6d6;
  initFuelArbitratorThreshold5();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6dc;
  initFuelArbitratorThreshold3();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6e2;
  initTimerCounterDefaults();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6e8;
  initIoControlRegister();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6ee;
  initLookupTablePointers1();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6f4;
  initVP44StatusFlags();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x6fa;
  initRpmLookupTables();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x700;
  initParameterScalingSystem();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x706;
  initOilPressureProtectionPointers();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x70c;
  initOilPressureMonitoring();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x712;
  initSensorDataArrays();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x718;
  initDiagnosticSystemState();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x71e;
  initIntakeManifoldTemperatureLimits();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x724;
  vp44ControlStructureInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x72a;
  hardwareTimerFlagsInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x730;
  intakeTemperatureTablesInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x736;
  masterSubsystemInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x73c;
  fuelTimingModeInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x742;
  canMessageFilterInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x748;
  engineProtectionSystemInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x74e;
  tpuChannelIsrRegister();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x754;
  engineSpeedIsrRegister();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x75a;
  can1ControllerInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x760;
  pwmOutputInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x766;
  serialCommunicationIsrRegister();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x76c;
  canMessageInterruptHandlerSetup();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x772;
  dualCanControllerInit();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x778;
  initDiagnosticProtocol();
  sim_chip_select_option_reg0 = 2;
  sim_chip_select_base_reg0 = 0x77e;
  emptyPlaceholderInit();
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x786;
  initMIOS14Timers();
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x78c;
  engineModeOutputControlInit();
  engine_shutdown_complete_flag = 0;
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x7a4;
  schedulerWaitLoop();
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x7ae;
  boostPressureControlInit();
  sim_chip_select_base_reg0 = 2;
  init_checkpoint_address = 0x7b4;
  vp44CommunicationTestAndInit();
  return;
}



/*
 * Function: phase4InitSequence @ 0x00020780
 */

/* WARNING: This function may have set the stack pointer */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void phase4InitSequence(void)

{
  initMIOS14Timers();
  engineModeOutputControlInit();
  engine_shutdown_complete_flag = 0;
  _sim_chip_select_base_reg0 = 0x207a4;
  schedulerWaitLoop();
  _sim_chip_select_base_reg0 = 0x207ae;
  boostPressureControlInit();
  _sim_chip_select_base_reg0 = 0x207b4;
  vp44CommunicationTestAndInit();
  return;
}



/*
 * Function: dualCanControllerInit @ 0x000207b6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void dualCanControllerInit(void)

{
  byte bVar1;
  byte *pbVar2;
  word *pwVar3;
  
  do {
    serial_port_1_base_register._2_1_ = can_controller_1_status_byte;
  } while ((can_controller_1_status_byte & 0x80) != 0);
  sim_tpu_prescaler = can_controller_1_baud_byte_0;
  sim_tpu_control_2 = can_controller_1_baud_byte_1;
  sim_tpu_timer_high = PTGNQDTB._0_1_;
  sim_tpu_timer_low = (byte)PTGNQDTB;
  _sim_tpu_control_0 = can_controller_1_timing_word;
  sim_tpu_mb1_data_7 = can_controller_1_filter_byte_1;
  sim_tpu_mb2_data_7 = can_controller_1_filter_byte_2;
  sim_tpu_mb3_data_7 = can_controller_1_filter_byte_3;
  sim_tpu_mb0_data_7 = 0;
  serial_port_1_base_register._0_1_ = 0;
  pbVar2 = &can_controller_config_register;
  bVar1 = 1;
  do {
    *pbVar2 = 0x7d;
    pbVar2 = pbVar2 + 0x10;
    bVar1 = bVar1 + 1;
  } while (bVar1 < 0x10);
  serial_port_1_base_register._0_1_ = serial_port_1_base_register._0_1_ & 0xfe;
  do {
    serial_port_2_base_register._2_1_ = can_controller_2_status_byte;
  } while ((can_controller_2_status_byte & 0x80) != 0);
  toucan_prescaler_div = can_controller_2_baud_byte_0;
  toucan_control_reg_2 = can_controller_2_baud_byte_1;
  toucan_free_timer_high = can_controller_2_baud_byte_2;
  toucan_free_timer_low = can_controller_2_baud_byte_3;
  _toucan_control_reg_0 = can_controller_2_timing_word;
  toucan_mb1_data_7 = can_controller_2_filter_byte_1;
  toucan_mb2_data_7 = can_controller_2_filter_byte_2;
  toucan_mb3_data_7 = can_controller_2_filter_byte_3;
  toucan_mb0_data_7 = 0;
  serial_port_2_base_register._0_1_ = 0;
  pwVar3 = &toucan_mb0_control;
  bVar1 = 1;
  do {
    *(undefined1 *)pwVar3 = 0x7d;
    pwVar3 = pwVar3 + 8;
    bVar1 = bVar1 + 1;
  } while (bVar1 < 0x10);
  serial_port_2_base_register._0_1_ = serial_port_2_base_register._0_1_ & 0xfe;
  tpuTimerInitializer();
  canTransmissionScheduler();
  return;
}



/*
 * Function: canTransmissionScheduler @ 0x00020918
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void canTransmissionScheduler(void)

{
  byte bVar1;
  uint uVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  dword *pdVar6;
  byte *pbVar7;
  
  can_transmit_buffer_ptr_1 = 0x80ce60;
  can_transmit_buffer_ptr_2 = 0x80ce60;
  _timer_task_scheduler_state = &average_pulse_period_time_period_over_1_cyl_of_primary_s_1000_65535
  ;
  _serial_receive_buffer_state =
       &average_pulse_period_time_period_over_1_cyl_of_primary_s_1000_65535;
  vp44DiagnosticBufferPointersInit();
  can_transmit_retry_count = 4;
  bVar3 = 0;
  pdVar6 = &can_transmission_scheduler_data;
  do {
    *(undefined1 *)pdVar6 = 0xfe;
    bVar3 = bVar3 + 1;
    pdVar6 = (dword *)((int)pdVar6 + 1);
  } while (bVar3 < 4);
  canBufferSetup1();
  j1939MessageSetup_PGN_65265();
  vp44Command0x100Builder();
  cumminsProprietaryDM_983_Builder();
  secondaryParamPGN_65247_Builder();
  extendedDiagPGN_65251_Builder();
  cumminsProprietaryTSC_PGN_15728640_Builder();
  fuelEconomyPGN_65266_Builder();
  retarderConfigPGN_65249_Builder();
  retarderModeThresholdsSetup();
  ambientConditionsPGN_65269_Builder();
  engineFluidLevelPGN_65263_Builder();
  engineHoursPGN_65252_Builder();
  intakeManifoldPGN_65526_Builder();
  cruiseControlPGN_65264_Builder();
  electronicBrakePGN_65527_Builder();
  engineCoolantPGN_65226_Builder();
  diagnosticDM8PGN_65232_Builder();
  timerSchedulerSetup(0,100);
  timerSchedulerSetup(0,0x14);
  timerSchedulerSetup(0,0x32);
  timerSchedulerSetup(0,0xfa);
  timerSchedulerSetup(0,5000);
  timerSchedulerSetup(1,100);
  timerSchedulerSetup(0,100);
  timerSchedulerSetup(1,5000);
  timerSchedulerSetup(0,1000);
  timerSchedulerSetup(0,500);
  timerSchedulerSetup(0,100);
  timerSchedulerSetup(0,1000);
  timerSchedulerSetup(0,500);
  timerSchedulerSetup(0,1000);
  timerSchedulerSetup(0,1000);
  systemControlFunction1();
  systemControlFunction4();
  systemControlFunction3();
  diagnosticDataDump();
  systemControlFunction2();
  systemFunction5xCaller();
  systemFunction1xCaller();
  systemFunction6xParameterized();
  systemFunction8xMaximum();
  systemFunction4xParameterizedAlt();
  serial_node_address_state = serial_node_address_offset + 1;
  serial_node_address_offset = serial_node_address_offset + 8;
  serial_node_transmit_ptr =
       (dword)(&serial_port_1_base_register + (uint)serial_node_address_state * 4);
  serial_node_address_limit = serial_node_address_offset;
  *(undefined1 *)serial_node_transmit_ptr = 0x55;
  *(undefined1 *)(serial_node_transmit_ptr + 1) = 0xfb;
  *(undefined1 *)serial_node_transmit_ptr = 0xef;
  *(undefined1 *)(serial_node_transmit_ptr + 6) = 4;
  pbVar7 = &can_controller_config_register + (uint)serial_node_address_state * 0x10;
  uVar2 = (uint)_j1939_multiframe_source_address;
  bVar5 = j1939_source_address_primary << 3;
  bVar3 = 0;
  for (bVar4 = 0; bVar4 < _histogram_bin_count_3; bVar4 = bVar4 + 1) {
    *pbVar7 = 0x99;
    pbVar7[6] = 4;
    pbVar7[1] = 0xdf;
    pbVar7[2] = *(byte *)(bVar3 + 0x8088ea);
    pbVar7[3] = (byte)((int)(uVar2 & 0xe0) >> 5) | *(byte *)((byte)(bVar3 + 1) + 0x8088ea) & 0xf8;
    bVar1 = bVar3 + 3;
    pbVar7[4] = bVar5 | *(byte *)((byte)(bVar3 + 2) + 0x8088ea) & 7;
    bVar3 = bVar3 + 4;
    pbVar7[5] = *(byte *)(bVar1 + 0x8088ea);
    pbVar7 = pbVar7 + 0x10;
  }
  for (bVar4 = 0; bVar4 < _histogram_bin_count_0; bVar4 = bVar4 + 1) {
    *pbVar7 = 0x99;
    pbVar7[1] = 0xdf;
    pbVar7[6] = 4;
    pbVar7[2] = *(byte *)(bVar3 + 0x8088ea);
    pbVar7[3] = *(byte *)((byte)(bVar3 + 1) + 0x8088ea);
    bVar5 = bVar3 + 3;
    pbVar7[4] = *(byte *)((byte)(bVar3 + 2) + 0x8088ea);
    bVar3 = bVar3 + 4;
    pbVar7[5] = *(byte *)(bVar5 + 0x8088ea);
    pbVar7 = pbVar7 + 0x10;
  }
  uVar2 = (uint)_can_cpu_interface_address;
  bVar5 = j1939_source_address_secondary << 3;
  for (bVar4 = 0; bVar4 < _histogram_bin_count_1; bVar4 = bVar4 + 1) {
    *pbVar7 = 0x99;
    pbVar7[1] = 0xdf;
    pbVar7[6] = 4;
    pbVar7[2] = *(byte *)(bVar3 + 0x8088ea);
    pbVar7[3] = (byte)((int)(uVar2 & 0xe0) >> 5) | *(byte *)((byte)(bVar3 + 1) + 0x8088ea) & 0xf8;
    bVar1 = bVar3 + 3;
    pbVar7[4] = bVar5 | *(byte *)((byte)(bVar3 + 2) + 0x8088ea) & 7;
    bVar3 = bVar3 + 4;
    pbVar7[5] = *(byte *)(bVar1 + 0x8088ea);
    pbVar7 = pbVar7 + 0x10;
  }
  for (bVar4 = 0; bVar4 < _histogram_bin_count_2; bVar4 = bVar4 + 1) {
    *pbVar7 = 0x99;
    pbVar7[1] = 0xdf;
    pbVar7[6] = 4;
    pbVar7[2] = *(byte *)(bVar3 + 0x8088ea);
    pbVar7[3] = *(byte *)((byte)(bVar3 + 1) + 0x8088ea);
    bVar5 = bVar3 + 3;
    pbVar7[4] = *(byte *)((byte)(bVar3 + 2) + 0x8088ea);
    bVar3 = bVar3 + 4;
    pbVar7[5] = *(byte *)(bVar5 + 0x8088ea);
    pbVar7 = pbVar7 + 0x10;
  }
  serial_port_1_base_register._0_1_ = serial_port_1_base_register._0_1_ | 10;
  return;
}



/*
 * Function: mainCanTransmissionLoop @ 0x00020980
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void mainCanTransmissionLoop(void)

{
  byte bVar1;
  uint uVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte *pbVar6;
  int unaff_A3;
  code *unaff_A4;
  int *unaff_A5;
  
  vp44Command0x100Builder();
  cumminsProprietaryDM_983_Builder();
  secondaryParamPGN_65247_Builder();
  extendedDiagPGN_65251_Builder();
  cumminsProprietaryTSC_PGN_15728640_Builder();
  fuelEconomyPGN_65266_Builder();
  retarderConfigPGN_65249_Builder();
  retarderModeThresholdsSetup();
  ambientConditionsPGN_65269_Builder();
  engineFluidLevelPGN_65263_Builder();
  engineHoursPGN_65252_Builder();
  intakeManifoldPGN_65526_Builder();
  cruiseControlPGN_65264_Builder();
  electronicBrakePGN_65527_Builder();
  engineCoolantPGN_65226_Builder();
  diagnosticDM8PGN_65232_Builder();
  (*unaff_A4)(0,100);
  (*unaff_A4)(0,0x14);
  (*unaff_A4)(0,0x32);
  (*unaff_A4)(0,0xfa);
  (*unaff_A4)(0,5000);
  (*unaff_A4)(1,100);
  (*unaff_A4)(0,100);
  (*unaff_A4)(1,5000);
  (*unaff_A4)(0,1000);
  (*unaff_A4)(0,500);
  (*unaff_A4)(0,100);
  (*unaff_A4)(0,1000);
  (*unaff_A4)(0,500);
  (*unaff_A4)(0,1000);
  (*unaff_A4)(0,1000);
  systemControlFunction1();
  systemControlFunction4();
  systemControlFunction3();
  diagnosticDataDump();
  systemControlFunction2();
  systemFunction5xCaller();
  systemFunction1xCaller();
  systemFunction6xParameterized();
  systemFunction8xMaximum();
  systemFunction4xParameterizedAlt();
  serial_node_address_state = serial_node_address_offset + 1;
  serial_node_address_offset = serial_node_address_offset + 8;
  uVar2 = (uint)serial_node_address_state;
  serial_node_address_limit = serial_node_address_offset;
  *unaff_A5 = (int)(&serial_port_1_base_register + uVar2 * 4);
  *(undefined1 *)(&serial_port_1_base_register + uVar2 * 4) = 0x55;
  *(undefined1 *)(*unaff_A5 + 1) = 0xfb;
  *(undefined1 *)*unaff_A5 = 0xef;
  *(undefined1 *)(*unaff_A5 + 6) = 4;
  pbVar6 = &can_controller_config_register + (uint)serial_node_address_state * 0x10;
  uVar2 = (uint)_j1939_multiframe_source_address;
  bVar5 = j1939_source_address_primary << 3;
  bVar3 = 0;
  for (bVar4 = 0; bVar4 < _histogram_bin_count_3; bVar4 = bVar4 + 1) {
    *pbVar6 = 0x99;
    pbVar6[6] = 4;
    pbVar6[1] = 0xdf;
    pbVar6[2] = *(byte *)(unaff_A3 + (uint)bVar3);
    pbVar6[3] = (byte)((int)(uVar2 & 0xe0) >> 5) |
                *(byte *)(unaff_A3 + (uint)(byte)(bVar3 + 1)) & 0xf8;
    bVar1 = bVar3 + 3;
    pbVar6[4] = bVar5 | *(byte *)(unaff_A3 + (uint)(byte)(bVar3 + 2)) & 7;
    bVar3 = bVar3 + 4;
    pbVar6[5] = *(byte *)(unaff_A3 + (uint)bVar1);
    pbVar6 = pbVar6 + 0x10;
  }
  for (bVar4 = 0; bVar4 < _histogram_bin_count_0; bVar4 = bVar4 + 1) {
    *pbVar6 = 0x99;
    pbVar6[1] = 0xdf;
    pbVar6[6] = 4;
    pbVar6[2] = *(byte *)(unaff_A3 + (uint)bVar3);
    pbVar6[3] = *(byte *)(unaff_A3 + (uint)(byte)(bVar3 + 1));
    bVar5 = bVar3 + 3;
    pbVar6[4] = *(byte *)(unaff_A3 + (uint)(byte)(bVar3 + 2));
    bVar3 = bVar3 + 4;
    pbVar6[5] = *(byte *)(unaff_A3 + (uint)bVar5);
    pbVar6 = pbVar6 + 0x10;
  }
  uVar2 = (uint)_can_cpu_interface_address;
  bVar5 = j1939_source_address_secondary << 3;
  for (bVar4 = 0; bVar4 < _histogram_bin_count_1; bVar4 = bVar4 + 1) {
    *pbVar6 = 0x99;
    pbVar6[1] = 0xdf;
    pbVar6[6] = 4;
    pbVar6[2] = *(byte *)(unaff_A3 + (uint)bVar3);
    pbVar6[3] = (byte)((int)(uVar2 & 0xe0) >> 5) |
                *(byte *)(unaff_A3 + (uint)(byte)(bVar3 + 1)) & 0xf8;
    bVar1 = bVar3 + 3;
    pbVar6[4] = bVar5 | *(byte *)(unaff_A3 + (uint)(byte)(bVar3 + 2)) & 7;
    bVar3 = bVar3 + 4;
    pbVar6[5] = *(byte *)(unaff_A3 + (uint)bVar1);
    pbVar6 = pbVar6 + 0x10;
  }
  for (bVar4 = 0; bVar4 < _histogram_bin_count_2; bVar4 = bVar4 + 1) {
    *pbVar6 = 0x99;
    pbVar6[1] = 0xdf;
    pbVar6[6] = 4;
    pbVar6[2] = *(byte *)(unaff_A3 + (uint)bVar3);
    pbVar6[3] = *(byte *)(unaff_A3 + (uint)(byte)(bVar3 + 1));
    bVar5 = bVar3 + 3;
    pbVar6[4] = *(byte *)(unaff_A3 + (uint)(byte)(bVar3 + 2));
    bVar3 = bVar3 + 4;
    pbVar6[5] = *(byte *)(unaff_A3 + (uint)bVar5);
    pbVar6 = pbVar6 + 0x10;
  }
  serial_port_1_base_register._0_1_ = serial_port_1_base_register._0_1_ | 10;
  return;
}



/*
 * Function: vp44StatusInitAndWait @ 0x00020de4
 */

void vp44StatusInitAndWait(void)

{
  short sVar1;
  ushort uVar2;
  char in_XF;
  char cVar3;
  char cVar4;
  char cVar5;
  byte bVar6;
  ushort uVar7;
  word local_6;
  
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  cVar3 = '\x01';
  cVar4 = '\0';
  cVar5 = '\0';
  bVar6 = 0;
  initVP44StatusMonitoring();
  uVar7 = (ushort)(byte)(in_XF << 4 | cVar3 << 3 | cVar4 << 2 | cVar5 << 1 | bVar6);
  local_6 = redundant_sensor_param_3 + 1;
  parameterCircularBufferWrite(0x80368e,(undefined1 *)&local_6,CONCAT22(2,uVar7));
  uVar2 = 0;
  while ((uVar2 < 1000 && (redundant_sensor_param_3 != local_6))) {
    emptyPlaceholderFunction();
    delayWithWatchdogService(CONCAT22(500,uVar7));
    uVar2 = uVar2 + 1;
  }
  local_6 = redundant_sensor_param_2 + redundant_sensor_param_3;
  parameterCircularBufferWrite(0x803686,(undefined1 *)&local_6,CONCAT22(2,uVar7));
  uVar2 = 0;
  while ((uVar2 < 1000 && (vp44_comm_test_flag != local_6))) {
    emptyPlaceholderFunction();
    sVar1 = 0;
    do {
      uVar7 = 0;
      do {
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        uVar7 = uVar7 + 1;
      } while (uVar7 < 0xa0);
      sVar1 = sVar1 + 1;
    } while (sVar1 == 0);
    uVar2 = uVar2 + 1;
  }
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  phase4InitSequence();
  return;
}



/*
 * Function: vp44CommunicationTestAndInit @ 0x00020f14
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44CommunicationTestAndInit(void)

{
  uint uVar1;
  undefined4 unaff_D2;
  short sVar2;
  short sVar3;
  ushort uVar4;
  ushort uVar5;
  byte bVar6;
  uint unaff_D7;
  word *pwVar7;
  dword *pdVar8;
  char in_XF;
  char cVar9;
  char cVar10;
  char cVar11;
  char cVar12;
  byte bVar13;
  ushort uVar14;
  undefined2 uVar15;
  int local_a;
  word local_6;
  
  uVar15 = (undefined2)((uint)unaff_D2 >> 0x10);
  protectionFlagAccumulator();
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 = 1;
  uVar14 = (ushort)(byte)(in_XF << 4);
  uVar5 = 0;
  while ((uVar5 < 1000 && (uVar1 = circularBufferEmptyCheck(), (char)uVar1 == '\0'))) {
    emptyPlaceholderFunction();
    delayWithWatchdogService(CONCAT22(500,uVar14));
    uVar5 = uVar5 + 1;
  }
  sim_data_direction_control = sim_data_direction_control | 4;
  ioControlAndCanPinSwitching();
  if (points_to_engine_sync_fuel_pressure_fuel_minimun_threshold_0_2_32 != 0) {
    pwVar7 = &can_memory_vp44_comm_ptr;
    if (calibration_checksum_workspace._0_2_ == 2) {
      pdVar8 = &can_memory_pointer_table_entry_2;
    }
    else {
      pdVar8 = &can_memory_pointer_table_entry_1;
    }
    for (; pwVar7 < (word *)0x8062ce; pwVar7 = pwVar7 + 1) {
      *pwVar7 = *(word *)pdVar8;
      pdVar8 = (dword *)((int)pdVar8 + 2);
    }
  }
  sVar2 = calibration_checksum_workspace._0_2_;
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  bVar13 = 1;
  do {
    if (((sVar2 == 2) && (bVar13 == 1)) || ((sVar2 == 1 && (bVar13 == 2)))) {
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
      uVar1 = eepromCalibrationWritePrimary();
      unaff_D7 = uVar1 & 0xffff;
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
    }
    else if (((sVar2 == 1) && (bVar13 == 1)) || ((sVar2 == 2 && (bVar13 == 2)))) {
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
      uVar1 = eepromCalibrationWriteSecondary();
      unaff_D7 = uVar1 & 0xffff;
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
    }
    if ((short)unaff_D7 == 1) {
      vp44StatusInitAndWait();
    }
    if (vp44_comm_test_flag != vp44_comm_test_sensor_value) {
      parameterCircularBufferWrite
                (0x803688,(undefined1 *)&vp44_comm_test_flag,
                 CONCAT22(2,(ushort)(byte)((vp44_comm_test_flag < vp44_comm_test_sensor_value) << 4
                                           | ((short)(vp44_comm_test_flag -
                                                     vp44_comm_test_sensor_value) < 0) << 3 |
                                           SBORROW2(vp44_comm_test_flag,vp44_comm_test_sensor_value)
                                           << 1 | vp44_comm_test_flag < vp44_comm_test_sensor_value)
                         ));
      uVar5 = 0;
      while( true ) {
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        if ((999 < uVar5) || (vp44_comm_test_flag == vp44_comm_test_sensor_value)) break;
        emptyPlaceholderFunction();
        sVar3 = 0;
        do {
          uVar14 = 0;
          do {
            uVar14 = uVar14 + 1;
          } while (uVar14 < 0xa0);
          sVar3 = sVar3 + 1;
        } while (sVar3 == 0);
        uVar5 = uVar5 + 1;
      }
    }
    bVar6 = 0;
    while (bVar6 < 4) {
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
      vp44_status_data_collector();
      delayWithWatchdogService(CONCAT22(10000,uVar15));
      bVar6 = bVar6 + 1;
    }
    if ((vp44_communication_status & 1) != 0) {
      vp44StatusInitAndWait();
    }
    bVar6 = bVar13 + 1;
    cVar12 = bVar13 - 1;
    bVar13 = bVar6;
  } while (bVar6 < 3);
  uVar14 = (ushort)(byte)((bVar6 < 2) << 4 | (cVar12 < '\0') << 3 | (bVar6 == 2) << 2 |
                          SBORROW1(bVar6,'\x02') << 1 | bVar6 < 2);
  local_a = _loopCounter;
  parameterCircularBufferWrite(0x80352c,(undefined1 *)&local_a,CONCAT22(4,uVar14));
  uVar5 = 0;
  while( true ) {
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    if ((999 < uVar5) || (_loop_counter_reference == local_a)) break;
    emptyPlaceholderFunction();
    sVar2 = 0;
    do {
      uVar4 = 0;
      do {
        uVar4 = uVar4 + 1;
      } while (uVar4 < 0xa0);
      sVar2 = sVar2 + 1;
    } while (sVar2 == 0);
    uVar5 = uVar5 + 1;
  }
  local_6 = 0;
  parameterCircularBufferWrite
            (0x80367e,(undefined1 *)&local_6,
             CONCAT22(2,(ushort)(byte)(((uVar14 & 0x10) != 0) << 4 | ((uVar14 & 8) != 0) << 3 |
                                       ((uVar14 & 4) != 0) << 2 | ((uVar14 & 2) != 0) << 1 |
                                      (uVar14 & 1) != 0)));
  uVar5 = 0;
  while ((uVar5 < 1000 && (loop_termination_flag != local_6))) {
    emptyPlaceholderFunction();
    sVar2 = 0;
    do {
      uVar14 = 0;
      do {
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        uVar14 = uVar14 + 1;
      } while (uVar14 < 0xa0);
      sVar2 = sVar2 + 1;
    } while (sVar2 == 0);
    uVar5 = uVar5 + 1;
  }
  flashBootloaderProgrammer();
  sim_data_direction_control = sim_data_direction_control & 0xf3;
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  ioControlAndCanPinSwitching();
  local_6 = 0;
  sVar2 = hardware_timer_register._0_2_;
  do {
    while ((ushort)(hardware_timer_register._0_2_ - sVar2) < 500) {
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
      vp44_status_data_collector();
      if ((vp44_communication_status & 1) != 0) {
        sim_data_direction_control = sim_data_direction_control & 0xfb | 8;
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        ioControlAndCanPinSwitching();
        vp44StatusInitAndWait();
      }
    }
    local_6 = local_6 + 1;
    sVar2 = hardware_timer_register._0_2_;
  } while (local_6 < 0x28);
  sim_data_direction_control = sim_data_direction_control & 0xfb | 8;
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  ioControlAndCanPinSwitching();
  REG_SIM_SWSR = 0xaa;
  qsm_sci_data_reg._1_1_ = 0xaa;
  bVar13 = 0;
  while( true ) {
    cVar12 = bVar13 < 4;
    cVar11 = SBORROW1(bVar13,'\x04');
    cVar9 = (char)(bVar13 - 4) < '\0';
    if (!(bool)cVar12) break;
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    vp44_status_data_collector();
    delayWithWatchdogService(CONCAT22(10000,uVar15));
    bVar13 = bVar13 + 1;
  }
  cVar10 = (vp44_communication_status & 1) == 0;
  bVar13 = cVar12;
  if (!(bool)cVar10) {
    vp44StatusInitAndWait();
  }
  local_6 = 1;
  parameterCircularBufferWrite
            (0x80367e,(undefined1 *)&local_6,
             CONCAT22(2,(ushort)(byte)(cVar12 << 4 | cVar9 << 3 | cVar10 << 2 | cVar11 << 1 | bVar13
                                      )));
  uVar5 = 0;
  while ((uVar5 < 1000 && (loop_termination_flag != local_6))) {
    emptyPlaceholderFunction();
    sVar2 = 0;
    do {
      uVar14 = 0;
      do {
        REG_SIM_SWSR = 0xaa;
        qsm_sci_data_reg._1_1_ = 0xaa;
        uVar14 = uVar14 + 1;
      } while (uVar14 < 0xa0);
      sVar2 = sVar2 + 1;
    } while (sVar2 == 0);
    uVar5 = uVar5 + 1;
  }
  while ((vp44_communication_status & 1) == 0) {
    vp44_status_data_collector();
  }
  vp44StatusInitAndWait();
  return;
}



/*
 * Function: huffmanTreeBuilder @ 0x00024d06
 */

short huffmanTreeBuilder(int param_1)

{
  ushort uVar2;
  uint uVar1;
  ushort uVar3;
  uint uVar4;
  ushort uVar5;
  
  *(undefined2 *)(param_1 + 0xc06) = 0xffff;
  for (uVar2 = 0; uVar2 < 0x100; uVar2 = uVar2 + 1) {
    *(ushort *)(param_1 + (uint)uVar2 * 6) = (ushort)(&huffman_symbol_frequency_table)[(short)uVar2]
    ;
  }
  *(undefined2 *)(param_1 + 0x600) = 1;
  uVar2 = 0x101;
  while( true ) {
    uVar5 = 0x201;
    uVar4 = 0x201;
    uVar1 = 0;
    while( true ) {
      uVar3 = (ushort)uVar1;
      if (uVar2 <= uVar3) break;
      REG_SIM_SWSR = 0xaa;
      qsm_sci_data_reg._1_1_ = 0xaa;
      if (*(short *)(param_1 + uVar1 * 6) != 0) {
        if (*(ushort *)(param_1 + uVar1 * 6) < *(ushort *)(param_1 + (uint)uVar5 * 6)) {
          uVar4 = (uint)uVar5;
          uVar5 = uVar3;
        }
        else if (*(ushort *)(param_1 + uVar1 * 6) < *(ushort *)(param_1 + uVar4 * 6)) {
          uVar4 = uVar1;
        }
      }
      uVar1 = (uint)(ushort)(uVar3 + 1);
    }
    if ((short)uVar4 == 0x201) break;
    *(short *)(param_1 + (uint)uVar2 * 6) =
         *(short *)(param_1 + uVar4 * 6) + *(short *)(param_1 + (uint)uVar5 * 6);
    *(undefined2 *)(param_1 + (uint)uVar5 * 6) = 0;
    *(undefined2 *)(param_1 + uVar4 * 6) = 0;
    *(ushort *)(param_1 + 2 + (uint)uVar2 * 6) = uVar5;
    *(short *)(param_1 + 4 + (uint)uVar2 * 6) = (short)uVar4;
    uVar2 = uVar2 + 1;
  }
  return uVar2 - 1;
}



/*
 * Function: huffmanDecompress @ 0x00024e58
 */

void huffmanDecompress(int param_1,undefined4 param_2)

{
  bool bVar1;
  byte bVar2;
  ushort uVar3;
  byte *pbVar4;
  word *local_8;
  
  bVar2 = 0;
  pbVar4 = &huffman_compressed_data_start;
  local_8 = &rpm_rate_limit_countdown;
  bVar1 = false;
  while( true ) {
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
    uVar3 = param_2._0_2_;
    do {
      bVar2 = (byte)((int)(uint)bVar2 >> 1);
      if (bVar2 == 0) {
        bVar2 = 0x80;
        pbVar4 = pbVar4 + 1;
        if (&huffman_compressed_data_end < pbVar4) {
          bVar1 = true;
        }
      }
      if ((*pbVar4 & bVar2) == 0) {
        uVar3 = *(ushort *)(param_1 + 2 + (uint)uVar3 * 6);
      }
      else {
        uVar3 = *(ushort *)(param_1 + 4 + (uint)uVar3 * 6);
      }
    } while ((0x100 < uVar3) && (!bVar1));
    if (bVar1) break;
    *(char *)local_8 = (char)uVar3;
    local_8 = (word *)((int)local_8 + 1);
  }
  return;
}



/*
 * Function: huffmanDecompressMain @ 0x00024efc
 */

void huffmanDecompressMain(void)

{
  short sVar1;
  undefined4 unaff_A2;
  undefined2 *puVar2;
  undefined2 uVar3;
  undefined2 local_c0a [1539];
  
  uVar3 = (undefined2)((uint)unaff_A2 >> 0x10);
  for (puVar2 = local_c0a; puVar2 < &stack0xfffffffc; puVar2 = puVar2 + 3) {
    *puVar2 = 0;
    puVar2[1] = 0;
    puVar2[2] = 0;
  }
  sVar1 = huffmanTreeBuilder((int)local_c0a);
  huffmanDecompress((int)local_c0a,CONCAT22(sVar1,uVar3));
  return;
}



/*
 * Function: busyWaitDelayLoop @ 0x00024f36
 */

void busyWaitDelayLoop(undefined4 param_1)

{
  ushort uVar1;
  ushort uVar2;
  
  for (uVar2 = 0; uVar2 < param_1._0_2_; uVar2 = uVar2 + 1) {
    for (uVar1 = 0; uVar1 < 0x378; uVar1 = uVar1 + 1) {
    }
  }
  return;
}



/*
 * Function: portPinTestSequence1 @ 0x00024f50
 */

byte portPinTestSequence1(void)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  undefined4 unaff_D2;
  undefined2 uVar4;
  undefined2 uVar5;
  
  QADC_PORTQB = QADC_PORTQB | 0x700;
  QADC_PORTQA = 0x600;
  uVar5 = 1;
  busyWaitDelayLoop(CONCAT22(1,(short)((uint)unaff_D2 >> 0x10)));
  uVar1 = QADC_PORTQA & 1;
  QADC_PORTQB = QADC_PORTQB | 0x700;
  QADC_PORTQA = 0x400;
  uVar4 = 1;
  busyWaitDelayLoop(CONCAT22(1,uVar5));
  uVar2 = QADC_PORTQA & 1;
  QADC_PORTQB = QADC_PORTQB | 0x700;
  QADC_PORTQA = 0x300;
  uVar5 = 1;
  busyWaitDelayLoop(CONCAT22(1,uVar4));
  uVar3 = QADC_PORTQA & 2;
  QADC_PORTQB = QADC_PORTQB | 0x700;
  QADC_PORTQA = 0x200;
  busyWaitDelayLoop(CONCAT22(1,uVar5));
  return -((QADC_PORTQA & 1) != 0) & 1U &
         -(uVar3 != 0) & 1U & -(uVar2 != 0) & 1U & -(uVar1 != 0) & 1U;
}



/*
 * Function: waitForPortPinStable @ 0x00025020
 */

void waitForPortPinStable(void)

{
  undefined4 unaff_D2;
  byte bVar1;
  undefined2 uVar2;
  
  uVar2 = (undefined2)((uint)unaff_D2 >> 0x10);
  bVar1 = 0;
  while (bVar1 < 5) {
    if ((qsm_config_reg_high & 1) == 0) {
      bVar1 = 0;
    }
    else {
      bVar1 = bVar1 + 1;
    }
    busyWaitDelayLoop(CONCAT22(2,uVar2));
  }
  return;
}



/*
 * Function: portPinTestSequence2 @ 0x0002504e
 */

byte portPinTestSequence2(void)

{
  ushort uVar1;
  ushort uVar2;
  undefined4 unaff_D2;
  undefined2 uVar3;
  undefined2 uVar4;
  
  QADC_PORTQB = QADC_PORTQB | 0x700;
  QADC_PORTQA = 0x200;
  uVar4 = 1;
  busyWaitDelayLoop(CONCAT22(1,(short)((uint)unaff_D2 >> 0x10)));
  uVar1 = QADC_PORTQA & 1;
  QADC_PORTQB = QADC_PORTQB | 0x700;
  QADC_PORTQA = 0x300;
  uVar3 = 1;
  busyWaitDelayLoop(CONCAT22(1,uVar4));
  uVar2 = QADC_PORTQA & 2;
  QADC_PORTQB = QADC_PORTQB | 0x700;
  QADC_PORTQA = 0x600;
  busyWaitDelayLoop(CONCAT22(1,uVar3));
  port_pin_test_result =
       -((qsm_config_reg_low & 1) != 0) & 1U &
       -((QADC_PORTQA & 1) != 0) & 1U & -(uVar2 == 0) & 1U & -(uVar1 != 0) & 1U;
  return port_pin_test_result;
}



/*
 * Function: tpuAndQadcVerification @ 0x00025108
 */

undefined4 tpuAndQadcVerification(void)

{
  byte bVar1;
  
  tpu_hssr0 = 0x8004;
  tpu_hsqr1 = 0x7b;
  TPU_HSRR0_H = 0xfe;
  TPU_HSQR1_H = 0xff;
  tpu_hssr1 = tpu_hssr1 & 0x8000 | 0x1028;
  tpu_cpr0 = tpu_cpr0 & 0xf0ff | 0xf00;
  TPU_PRAM_CH1_0 = 3;
  TPU_PRAM_CH0_0 = 0xbd;
  TPU_PRAM_CH1_2 = 0;
  TPU_PRAM_CH0_1 = 0xfd;
  for (bVar1 = 2; bVar1 < 0x10; bVar1 = bVar1 + 1) {
    (&TPU_PRAM_CH1_0)[bVar1] = 0;
    (&TPU_PRAM_CH0_0)[bVar1] = 0xbd;
  }
  tpu_hssr1 = tpu_hssr1 | 0x8000;
  do {
    do {
    } while ((TPU_CFSR1 & 0x80) == 0);
  } while ((TPU_CFSR1 & 0xf) != 0xf);
  if (((uint)qadc_qadcivr | (uint)qadc_qadcilr << 8) != 0x600d) {
    return 1;
  }
  return 0x6000;
}



/*
 * Function: hardwareInitAndStartup @ 0x000251f4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void hardwareInitAndStartup(void)

{
  byte bVar2;
  undefined4 uVar1;
  code *pcVar3;
  
  qsm_sci_control_0_high = 0x40;
  qsm_sci_data_reg._0_1_ = 0x80;
  waitForPortPinStable();
  sim_sypcr = sim_sypcr | 8;
  sim_rsr = sim_rsr | 8;
  TPU_CFSR1 = TPU_CFSR1 & 0x7f;
  tpu_hssr1 = tpu_hssr1 & 0x7fff;
  tpu_cpr0 = tpu_cpr0 & 0x7ff0;
  tpu_cier = 0;
  sim_csor0 = 0;
  sim_csbar1 = 0;
  can1_cantbsel = 0;
  QADC64_QACR1 = 0;
  QADC64_QADCSR = 0;
  QADC64_QADCINT = 0;
  QADC64_PQAPAR = 0;
  QADC64_DDRQB = 0;
  QADC64_LJSRR = 0;
  QADC64_RJURR = 0;
  QADC64_CCW0 = 0;
  QADC64_QMCR = 0x1601;
  QADC64_QADCTEST = 8;
  QADC64_PORTQA = 0;
  tpu_channel_priority_select = 4;
  QADC64_CCW8 = 0x104;
  tpu_tpumcr = 5;
  tpu_dscr = 0x13;
  TPU_TICR_H = 0x50;
  ramClearWithWatchdog();
  bVar2 = portPinTestSequence1();
  if (bVar2 == 0) {
    bVar2 = portPinTestSequence2();
    if (bVar2 == 0) {
      uVar1 = tpuAndQadcVerification();
      if ((char)uVar1 == '\0') {
        if ((_canBufferSetup1 == -0x6789abcd) || (_canBufferSetup1 == -0x6789abce)) {
          pcVar3 = (code *)&SUB_70003002;
        }
        else {
          pcVar3 = (code *)&SUB_b0390080;
        }
        goto LAB_00025350;
      }
    }
  }
  huffmanDecompressMain();
  pcVar3 = (code *)&SUB_00824b32;
LAB_00025350:
  (*pcVar3)();
  return;
}



/*
 * Function: ramClearWithWatchdog @ 0x00025356
 */

void ramClearWithWatchdog(void)

{
  dword *pdVar1;
  word *pwVar2;
  
  pwVar2 = &rpm_rate_limit_countdown;
  while (pwVar2 < &engine_speed_constant_1_backup_conversion_factor_from_tcnts_0_2_29) {
    pdVar1 = (dword *)((int)pwVar2 + 0x100);
    if (&engine_speed_constant_1_backup_conversion_factor_from_tcnts_0_2_29 < pdVar1) {
      pdVar1 = &engine_speed_constant_1_backup_conversion_factor_from_tcnts_0_2_29;
    }
    for (; pwVar2 < pdVar1; pwVar2 = (word *)((int)pwVar2 + 4)) {
      *(dword *)pwVar2 = 0;
    }
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
  }
  return;
}



/*
 * Function: flashBootloaderProgrammer @ 0x000253a6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void flashBootloaderProgrammer(void)

{
  int iVar1;
  undefined4 unaff_D2;
  code *pcVar2;
  byte *pbVar3;
  code *pcVar4;
  undefined2 uVar5;
  undefined1 auStack_104 [256];
  
  uVar5 = (undefined2)((uint)unaff_D2 >> 0x10);
  if ((flash_bootloader_param == 0xbad1) && (_DAT_00000014 < flash_bootloader_code_limit)) {
    sim_data_direction_control = sim_data_direction_control | 2;
    ioControlAndCanPinSwitching();
    iVar1 = flashEraseFromRam(0);
    if (iVar1 == 0) {
      pcVar4 = (code *)0x0;
      pbVar3 = &flash_bootloader_code_start;
      while (pbVar3 < flashBootloaderProgrammer) {
        pcVar2 = (code *)auStack_104;
        for (; (pcVar2 < &stack0xfffffffc && (pbVar3 < flashBootloaderProgrammer));
            pbVar3 = (byte *)((code *)pbVar3 + 1)) {
          *pcVar2 = (code)*pbVar3;
          pcVar2 = pcVar2 + 1;
        }
        flashProgramFromRam((int)pcVar4,auStack_104,
                            CONCAT22((short)pcVar2 - (short)auStack_104,uVar5));
        pcVar4 = pcVar2 + ((int)pcVar4 - (int)auStack_104);
      }
    }
    sim_data_direction_control = sim_data_direction_control & 0xfd;
    ioControlAndCanPinSwitching();
  }
  return;
}



/*
 * Function: dataBufferCopy @ 0x0002544a
 */

void dataBufferCopy(undefined1 *param_1,undefined4 param_2)

{
  ushort uVar1;
  byte *pbVar2;
  
  pbVar2 = &data_buffer_copy_dest;
  for (uVar1 = 0; uVar1 < param_2._0_2_; uVar1 = uVar1 + 1) {
    *pbVar2 = *param_1;
    param_1 = (undefined1 *)CONCAT31(param_1._0_3_,(char)param_1 + '\x01');
    pbVar2 = pbVar2 + 1;
  }
  return;
}



/*
 * Function: diagnosticResponseBuilder @ 0x00025476
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint diagnosticResponseBuilder(undefined4 param_1)

{
  short sVar1;
  uint in_D0;
  uint uVar2;
  byte bVar3;
  byte bVar5;
  ushort uVar4;
  byte bVar6;
  byte bVar7;
  byte *pbVar8;
  undefined1 *puVar9;
  undefined4 local_8;
  
  pbVar8 = &CMSYRSFG;
  bVar3 = 0;
  bVar5 = 0;
  for (bVar6 = 0; bVar7 = (byte)((uint)param_1 >> 0x10), bVar6 < bVar7; bVar6 = bVar6 + 1) {
    if ((pbVar8[9] == 5) || (pbVar8[9] == 3)) {
      bVar5 = bVar5 + 1;
      bVar3 = pbVar8[8] + bVar3;
    }
    in_D0 = 0;
    pbVar8 = pbVar8 + 10;
  }
  if ((bVar5 == 0) ||
     (((uint)bVar5 + (uint)_memory_patch_count < 0xb &&
      (in_D0 = (int)&timer_used_to_disable_rsg_when_gear_ratio_changes_0_100 - can_rx_buffer_ptr,
      (int)(uint)bVar3 <= (int)in_D0)))) {
    pbVar8 = &CMSYRSFG;
    for (bVar5 = 0; bVar5 < bVar7; bVar5 = bVar5 + 1) {
      local_8 = *(undefined1 **)(pbVar8 + 4);
      uVar4 = (ushort)pbVar8[8];
      if ((pbVar8[9] == 5) || (pbVar8[9] == 3)) {
        *(undefined1 **)
         (&timer_used_to_disable_rsg_when_gear_ratio_changes_0_100 +
         (short)(_memory_patch_count * 3)) = *(undefined1 **)pbVar8;
        sVar1 = _memory_patch_count * 3;
        _memory_patch_count = _memory_patch_count + 1;
        *(ushort *)(sVar1 * 2 + 0x80d3aa) = uVar4;
        for (bVar3 = 0; bVar3 < uVar4; bVar3 = bVar3 + 1) {
          *(undefined1 *)can_rx_buffer_ptr = *local_8;
          local_8 = (undefined1 *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
          can_rx_buffer_ptr = can_rx_buffer_ptr + 1;
        }
      }
      else {
        puVar9 = *(undefined1 **)pbVar8;
        for (bVar3 = 0; bVar3 < uVar4; bVar3 = bVar3 + 1) {
          *puVar9 = *local_8;
          local_8 = (undefined1 *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
          puVar9 = puVar9 + 1;
        }
      }
      in_D0 = 0;
      pbVar8 = pbVar8 + 10;
    }
    uVar2 = in_D0 & 0xffffff00;
  }
  else {
    uVar2 = 0xe;
  }
  return uVar2;
}



/*
 * Function: main @ 0x00025596
 */

/* Setting prototype: void main(void) */

void main(void)

{
  sim_mcr = 0x604f;
  sim_avr = 0x7f08;
  sim_rsr = 0xa9;
  sim_sypcr = 0xfe;
  sim_swiv = 1;
  sim_swsr = 0xff;
  sim_swsr2._1_1_ = 0xc9;
  uRam00fffa1f = 0x30;
  sim_csbar0._1_1_ = 0x9e;
  sim_csbarbt = 0x2bbf;
  sim_csorbt = 0;
  sim_csbar10 = 5;
  sim_csor10 = 0x6830;
  uRam00fffa4c = 0x8003;
  uRam00fffa4e = 0x5830;
  uRam00fffa50 = 0x8003;
  uRam00fffa52 = 0x3830;
  uRam00fffa54 = 0xffd0;
  uRam00fffa56 = 0x5830;
  uRam00fffa58 = 5;
  uRam00fffa5a = 0x7030;
  uRam00fffa5c = 0xffd8;
  uRam00fffa5e = 0x5bf0;
  uRam00fffa60 = 0xffc8;
  uRam00fffa62 = 0x5bf0;
  SIM_CSPDR = 0;
  SIM_PORTC = 0;
  SIM_PFPAR = 0xfffb;
  SIM_PEPAR = 0x2801;
  SIM_PORTF = 0;
  SIM_DDRF = 0;
  SIM_PORTE = 0;
  SIM_DDRE = 0;
  SIM_CSPAR0 = 0;
  SIM_CSPAR1 = 0;
  mainSystemInitialization();
  return;
}



/*
 * Function: initDiagnosticProtocol @ 0x000256a4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

word initDiagnosticProtocol(void)

{
  byte bVar1;
  
  diagnostic_data_buffer_ptr = (dword)&tracks_progress_of_fan_on_due_to_ac_0_3600;
  diagnostic_iteration_limit_count = 200;
  memory_patch_buffer_base_ptr = (dword)&timer_used_to_disable_rsg_when_gear_ratio_changes_0_100;
  _memory_patch_count = 0;
  can_rx_buffer_ptr = (dword)&tracks_progress_of_fan_on_due_to_ac_0_3600;
  diagnosticBufferPointerInit();
  tpu_transmission_state = 0;
  tpu_diagnostic_retry_counter = 0;
  tpu_channel_state_value = 1;
  tpu_channel_enable_state = 0;
  diagnostic_protocol_init_state._0_1_ = 0;
  diag_multipacket_transmit_pending = 0;
  multi_packet_receive_state = 0;
  diagnostic_command_state = diagnostic_command_state_init;
  insite_parameter_checksum_ptr = (dword)&insite_parameter_checksum_buffer;
  insite_parameter_table_ptr = (dword)&insite_parameter_table_start;
  for (bVar1 = 0; (*(char *)insite_parameter_table_ptr != '\0' && (bVar1 < 0x1e)); bVar1 = bVar1 + 1
      ) {
    *(char *)insite_parameter_checksum_ptr =
         *(char *)(insite_parameter_table_ptr + 2) + *(char *)(insite_parameter_table_ptr + 1);
    insite_parameter_checksum_ptr = insite_parameter_checksum_ptr + 1;
    insite_parameter_table_ptr = insite_parameter_table_ptr + 3;
  }
  tpu_ticr = 0x34;
  tpu_cier = 0x102c;
  return tpu_cfsr0;
}



/*
 * Function: systemControl64 @ 0x00025768
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void systemControl64(void)

{
  undefined1 uVar1;
  char cVar2;
  int iVar3;
  undefined4 unaff_D2;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  undefined4 local_8;
  
  if (diag_multipacket_transmit_pending != 0) {
    if (diag_transfer_state_t_0080d3f8.byte_count < 0x10) {
      bVar6 = (byte)diag_transfer_state_t_0080d3f8.byte_count + 4;
      diag_multipacket_transmit_pending = 0;
      bVar5 = (byte)diag_transfer_state_t_0080d3f8.byte_count;
    }
    else {
      bVar6 = 0x13;
      bVar5 = 0xf;
    }
    if ((int)can_transmit_buffer_ptr < _can_transmit_length) {
      iVar3 = (_can_transmit_length - can_transmit_buffer_ptr) + -2;
    }
    else {
      iVar3 = (_can_transmit_length - can_transmit_buffer_ptr) + 0xfe;
    }
    if ((int)(uint)bVar6 < iVar3) {
      local_8._3_1_ = (char)can_transmit_buffer_ptr;
      cVar2 = (char)local_8;
      local_8._0_3_ = (undefined3)(can_transmit_buffer_ptr >> 8);
      local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
      *local_8 = 7;
      local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x02');
      *local_8 = bVar5 | 0xb0;
      local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x03');
      *local_8 = (undefined1)diag_transfer_state_t_0080d3f8.target_address;
      local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x04');
      *local_8 = diag_transfer_state_t_0080d3f8.target_address._0_1_;
      local_8 = (byte *)CONCAT31(local_8._0_3_,cVar2 + '\x05');
      for (bVar4 = 0; bVar4 < bVar5; bVar4 = bVar4 + 1) {
        uVar1 = *(undefined1 *)diag_transfer_state_t_0080d3f8.data_pointer;
        diag_transfer_state_t_0080d3f8.data_pointer =
             diag_transfer_state_t_0080d3f8.data_pointer + 1;
        *local_8 = uVar1;
        local_8 = (byte *)CONCAT31(local_8._0_3_,(char)local_8 + '\x01');
      }
      diag_transfer_state_t_0080d3f8.byte_count = diag_transfer_state_t_0080d3f8.byte_count - bVar5;
      *(byte *)can_transmit_buffer_ptr = bVar6;
      *local_8 = 0;
      can_transmit_buffer_ptr = (dword)local_8;
      tpuTransmissionTrigger();
    }
    else {
      diag_multipacket_transmit_pending = 0;
      diagnosticMessageQueueWrite(CONCAT22(4,(short)((uint)unaff_D2 >> 0x10)));
      io_fault_status_reg_4 = io_fault_status_reg_4 | 4;
      io_fault_latch_reg_4 = io_fault_latch_reg_4 | 4;
    }
  }
  return;
}



/*
 * Function: systemControl74 @ 0x0002588c
 */

void systemControl74(void)

{
  if (multi_packet_receive_state != 0) {
    memoryPatchCountDecrement();
  }
  diag_multipacket_transmit_pending = 0;
  multi_packet_receive_state = 0;
  return;
}



/*
 * Function: systemControl75 @ 0x000258aa
 */

void systemControl75(void)

{
  if (multi_packet_receive_state != 0) {
    memoryPatchCountDecrement();
  }
  diag_multipacket_transmit_pending = 0;
  multi_packet_receive_state = 0;
  return;
}



/*
 * Function: memoryPatchBufferInit @ 0x000258c8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void memoryPatchBufferInit(void)

{
  can_rx_buffer_ptr = (dword)&tracks_progress_of_fan_on_due_to_ac_0_3600;
  memory_patch_pending_flag = 0;
  _memory_patch_count = 0;
  return;
}



/*
 * Function: memoryPatchingSystem @ 0x000258e0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint memoryPatchingSystem(void)

{
  byte *pbVar1;
  byte bVar2;
  byte *pbVar3;
  byte bVar4;
  uint in_D0;
  undefined4 uVar5;
  char cVar7;
  uint uVar6;
  byte bVar8;
  byte bVar9;
  word *pwVar10;
  uint *puVar11;
  word *pwVar13;
  uint *puVar12;
  
  if (_memory_patch_count == 0) {
    return in_D0 & 0xffffff00;
  }
  if ((system_logging_state == 1) &&
     (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 != 0)) {
    puVar12 = (uint *)((int)&timer_used_to_disable_rsg_when_gear_ratio_changes_0_100 +
                      (int)(short)((_memory_patch_count & 0xff) * 6));
    bVar9 = memory_patch_iteration_counter;
    while( true ) {
      puVar11 = (uint *)((int)puVar12 + -6);
      bVar4 = bVar9 - 1;
      if (bVar9 == 0) break;
      pbVar1 = (byte *)*puVar11;
      pbVar3 = (byte *)((int)puVar12 + -1);
      if ((((byte *)0xffffff < pbVar1) ||
          ((&system_protected_range_start < pbVar1 && (pbVar1 < &system_protected_range_end)))) ||
         ((puVar12 = puVar11, bVar9 = bVar4, &system_protected_range_start < pbVar1 + *pbVar3 &&
          (pbVar1 + *pbVar3 < &system_protected_range_end)))) {
        memoryPatchBufferInit();
        return 7;
      }
    }
  }
  if ((water_in_fuel_detection_flag == 0) &&
     ((memory_patch_pending_flag == 0 ||
      (uVar5 = memoryPatchCrcCalculate(), (word)uVar5 != memory_patch_crc_expected)))) {
    memoryPatchBufferInit();
    return 0x14;
  }
  if (10 < _memory_patch_count) {
    memoryPatchBufferInit();
    return 4;
  }
  can_rx_buffer_ptr = (dword)&tracks_progress_of_fan_on_due_to_ac_0_3600;
  bVar9 = 0;
  pwVar13 = &timer_used_to_disable_rsg_when_gear_ratio_changes_0_100;
  do {
    if (_memory_patch_count <= bVar9) {
      uVar6 = memoryPatchBufferInit();
      return uVar6 & 0xffffff00;
    }
    pwVar10 = *(word **)pwVar13;
    bVar4 = *(byte *)((int)pwVar13 + 5);
    if (pwVar10 < &indicator_as_to_the_calibration_status_of_the_ecm_see_ces15005) {
      for (bVar8 = 0; bVar8 < bVar4; bVar8 = bVar8 + 1) {
        if (((&system_protected_range_start < pwVar10) && (pwVar10 < &system_protected_range_end))
           && (water_in_fuel_detection_flag == 0)) {
          points_to_engine_sync_fuel_pressure_fuel_minimun_threshold_0_2_32 = 0;
        }
        bVar2 = *(byte *)can_rx_buffer_ptr;
        can_rx_buffer_ptr = can_rx_buffer_ptr + 1;
        *(byte *)pwVar10 = bVar2;
        pwVar10 = (word *)((int)pwVar10 + 1);
      }
    }
    else {
      if ((amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 == 1) &&
         (cVar7 = circularBufferWrite((short)(can_rx_buffer_ptr >> 0x10),bVar4), cVar7 == '\x01')) {
        memoryPatchBufferInit();
        return 4;
      }
      pwVar10 = pwVar10 + -0x3fe584;
      for (bVar8 = 0; bVar8 < bVar4; bVar8 = bVar8 + 1) {
        bVar2 = *(byte *)can_rx_buffer_ptr;
        can_rx_buffer_ptr = can_rx_buffer_ptr + 1;
        *(byte *)pwVar10 = bVar2;
        pwVar10 = (word *)((int)pwVar10 + 1);
      }
    }
    pwVar13 = (word *)((int)pwVar13 + 6);
    bVar9 = bVar9 + 1;
  } while( true );
}



/*
 * Function: advanced_oil_pressure_protection_system @ 0x00025a90
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void advanced_oil_pressure_protection_system(void)

{
  ushort uVar1;
  int iVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  word wVar6;
  uint uVar7;
  ushort uVar8;
  ushort local_10;
  ushort local_c;
  ushort uStack_6;
  
  if (oil_pressure_protection_enabled == 1) {
    if (_oil_pressure_protection_state != 1) {
      fuelDemandProportionalCalculator();
    }
    wVar6 = oil_pressure_fuel_min_threshold_high;
    sVar3 = _oil_pressure_calculated_value;
    if (_oil_pressure_previous_threshold != pointer_to_oil_pressure_fuel_max_threshold_0_2_32) {
      uStack_6 = (ushort)((uint)_oil_pressure_cal_factor_1 *
                          (uint)pointer_to_oil_pressure_fuel_max_threshold_0_2_32 >> 10);
      uVar7 = (uint)_oil_pressure_cal_factor_2 * (uint)(ushort)(uStack_6 + 0x200);
      if (uVar7 < 0xf99999) {
        if (uVar7 < 0x41894) {
          _oil_pressure_calculated_limit = 0x20c;
        }
        else {
          uStack_6 = (ushort)(uVar7 >> 9);
          _oil_pressure_calculated_limit = uStack_6;
        }
      }
      else {
        _oil_pressure_calculated_limit = 0x7ccc;
      }
    }
    _oil_pressure_previous_threshold = pointer_to_oil_pressure_fuel_max_threshold_0_2_32;
    _oil_pressure_calculated_value = exponentialMovingAverage();
    if (_oil_pressure_max_threshold < _oil_pressure_calculated_value) {
      _oil_pressure_calculated_value = _oil_pressure_max_threshold;
    }
    if (_oil_pressure_calculated_value < _oil_pressure_min_threshold) {
      _oil_pressure_calculated_value = _oil_pressure_min_threshold;
    }
    uVar7 = (uint)_oil_pressure_protection_multiplier *
            ((uint)_oil_pressure_calculated_limit * (uint)_oil_pressure_cal_factor_3 >> 10 & 0xffff)
    ;
    if (uVar7 < 0x1000000) {
      uStack_6 = (ushort)(uVar7 >> 10);
      uVar8 = uStack_6;
    }
    else {
      uVar8 = 0x4000;
    }
    mask_for_input_of_the_oil_pressure_input_0_65535 =
         (word)(((int)_oil_pressure_calculated_value *
                (int)(short)_oil_pressure_protection_multiplier) / 0x3c0);
    if (0x1700 < (short)mask_for_input_of_the_oil_pressure_input_0_65535) {
      mask_for_input_of_the_oil_pressure_input_0_65535 = 0x1700;
    }
    if ((short)mask_for_input_of_the_oil_pressure_input_0_65535 < -0x1700) {
      mask_for_input_of_the_oil_pressure_input_0_65535 = 0xe900;
    }
    amount_of_time_since_oil_pressure_failure_was_detected_0_65535 =
         (word)(((int)_oil_pressure_timing_factor *
                ((int)_oil_pressure_calculated_value - (int)sVar3)) / 0xf0);
    if (0x1c4a < (short)amount_of_time_since_oil_pressure_failure_was_detected_0_65535) {
      amount_of_time_since_oil_pressure_failure_was_detected_0_65535 = 0x1c4a;
    }
    if ((short)amount_of_time_since_oil_pressure_failure_was_detected_0_65535 < -0x1c4a) {
      amount_of_time_since_oil_pressure_failure_was_detected_0_65535 = 0xe3b6;
    }
    oil_pressure_fuel_min_threshold_high =
         amount_of_time_since_oil_pressure_failure_was_detected_0_65535 +
         mask_for_input_of_the_oil_pressure_input_0_65535;
    if (0x1700 < (short)oil_pressure_fuel_min_threshold_high) {
      oil_pressure_fuel_min_threshold_high = 0x1700;
    }
    if ((short)oil_pressure_fuel_min_threshold_high < -0x1700) {
      oil_pressure_fuel_min_threshold_high = 0xe900;
    }
    if (fsmxthfl_calc_input < _oil_pressure_rpm_limit_reference) {
      uStack_6 = (ushort)((uint)uVar8 *
                          ((uint)_oil_pressure_rpm_limit_reference - (uint)fsmxthfl_calc_input) >>
                         0xe);
      pointer_to_oil_pressure_fuel_min_threshold_0_2_32 = uStack_6;
    }
    else {
      pointer_to_oil_pressure_fuel_min_threshold_0_2_32 = 0;
    }
    uStack_6 = (ushort)((uint)uVar8 * (0x7fff - (uint)oil_pressure_protection_threshold) >> 0xe);
    uVar1 = uStack_6 + oil_pressure_protection_threshold;
    iVar4 = (uint)rpm_multiplier_0 * (uint)uVar1 * 2;
    iVar5 = (uint)rpm_multiplier_1 * (uint)uVar1 * 2;
    if (vp44_engine_state != 4) {
      oil_pressure_fuel_min_threshold_high = mask_for_input_of_the_oil_pressure_input_0_65535;
      if (fsmxthfl_calc_input < current_fuel_demand_value) {
        uStack_6 = (ushort)((uint)uVar8 *
                            ((uint)current_fuel_demand_value - (uint)fsmxthfl_calc_input) >> 0xe);
        pointer_to_oil_pressure_fuel_min_threshold_0_2_32 = uStack_6;
      }
      else {
        pointer_to_oil_pressure_fuel_min_threshold_0_2_32 = 0;
      }
      iVar2 = (uint)current_fuel_demand_value * (uint)uVar1 * 2;
      oil_pressure_fuel_calculation = (word)((uint)iVar2 >> 0x10);
      oil_pressure_fuel_calc_low_word = (word)iVar2;
      _oil_pressure_fuel_calculation =
           CONCAT22((_fuel_delivery_offset_correction + oil_pressure_fuel_calculation) -
                    pointer_to_oil_pressure_fuel_min_threshold_0_2_32,
                    oil_pressure_fuel_calc_low_word);
    }
    iVar2 = ((int)(short)wVar6 - (int)(short)pointer_to_oil_pressure_fuel_min_threshold_0_2_32) *
            (0x7fff - (short)oil_pressure_protection_threshold) * 2 + _oil_pressure_fuel_calculation
    ;
    oil_pressure_fuel_calculation = (word)((uint)iVar2 >> 0x10);
    sVar3 = oil_pressure_fuel_calculation - _fuel_delivery_offset_correction;
    oil_pressure_fuel_calc_low_word = (word)iVar2;
    _oil_pressure_fuel_calculation = CONCAT22(sVar3,oil_pressure_fuel_calc_low_word);
    local_c = (ushort)((uint)iVar4 >> 0x10);
    if (sVar3 < (short)local_c) {
      local_10 = (ushort)((uint)iVar5 >> 0x10);
      if (sVar3 < (short)local_10) {
        _oil_pressure_fuel_calculation = (uint)local_10 << 0x10;
      }
    }
    else {
      _oil_pressure_fuel_calculation = (uint)local_c << 0x10;
    }
    time_duration_since_oil_pressure_fault_was_detected_0_65535 = oil_pressure_fuel_calculation;
    uVar7 = ((int)(short)oil_pressure_fuel_calculation +
            (int)(short)oil_pressure_fuel_min_threshold_high) * 0x8000;
    if (iVar5 >> 1 < (int)uVar7) {
      if ((int)uVar7 < iVar4 >> 1) {
        _oil_pressure_rpm_limit_reference = (ushort)(uVar7 / uVar1);
      }
      else {
        _oil_pressure_rpm_limit_reference = rpm_multiplier_0;
      }
    }
    else {
      _oil_pressure_rpm_limit_reference = rpm_multiplier_1;
    }
    if ((oil_pressure_protection_enabled == 1) &&
       (oil_pressure_fuel_max_threshold_high < shutdown_limit_accumulator)) {
      shutdown_limit_accumulator = oil_pressure_fuel_max_threshold_high;
      shutdown_minimum_selector_value = OIL_PRESSURE_PROTECTION;
    }
  }
  else {
    _oil_pressure_rpm_limit_reference = 0;
  }
  _oil_pressure_protection_state = oil_pressure_protection_enabled;
  return;
}



/*
 * Function: fuelDemandProportionalCalculator @ 0x00025ece
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelDemandProportionalCalculator(void)

{
  int iVar1;
  uint uVar2;
  undefined2 uStack_6;
  
  oil_pressure_fuel_min_threshold_high = 0;
  rpmSnapshotCapture();
  fuel_demand_proportional_calc_result = 0x80000000;
  _oil_pressure_calculated_value = 0;
  uVar2 = proportionalCalculation
                    ((uint)_oil_pressure_cal_factor_2,
                     ((uint)_oil_pressure_cal_factor_1 *
                      (uint)pointer_to_oil_pressure_fuel_max_threshold_0_2_32 >> 10) + 0x200,1);
  if (uVar2 < 0xf99999) {
    uStack_6 = (ushort)(uVar2 >> 9);
    _oil_pressure_calculated_limit = uStack_6;
  }
  else {
    _oil_pressure_calculated_limit = 0x7ccc;
  }
  uVar2 = ((uint)_oil_pressure_calculated_limit * (uint)_oil_pressure_cal_factor_3 >> 10 & 0xffff) *
          (int)_oil_pressure_protection_multiplier;
  if (uVar2 < 0x1000000) {
    uStack_6 = (ushort)(uVar2 >> 10);
  }
  else {
    uStack_6 = 0x4000;
  }
  uStack_6 = (ushort)((uint)uStack_6 * (0x7fff - (uint)oil_pressure_protection_threshold) >> 0xe);
  _oil_pressure_fuel_calculation =
       (uint)current_fuel_demand_value *
       (uint)(ushort)(uStack_6 + oil_pressure_protection_threshold) * 2;
  iVar1 = _oil_pressure_fuel_calculation;
  oil_pressure_fuel_calculation = (word)((uint)_oil_pressure_fuel_calculation >> 0x10);
  time_duration_since_oil_pressure_fault_was_detected_0_65535 = oil_pressure_fuel_calculation;
  _oil_pressure_rpm_limit_reference = current_fuel_demand_value;
  _oil_pressure_fuel_calculation = iVar1;
  return;
}



/*
 * Function: fuelDemandScaleFactorCalculator @ 0x00025fda
 */

void fuelDemandScaleFactorCalculator(void)

{
  undefined4 local_8;
  
  if (param_scale_factor < param_ref_base) {
    local_8 = 0;
  }
  else {
    local_8 = (uint)param_scale_factor - (uint)param_ref_base;
  }
  oil_pressure_fuel_max_threshold_high =
       param_ref_base +
       (short)(((uint)fuel_demand_scale_multiplier * (local_8 & 0xffff)) /
              (uint)the_deceleration_value_where_e_braking_will_be_removed_1_0_01);
  fuel_demand_proportional_calc_result = 0x80000000;
  fuel_demand_scale_table_ptr = 0x808916;
  fuelDemandTablePointerInit();
  return;
}



/*
 * Function: oil_pressure_protection_controller @ 0x0002604e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void oil_pressure_protection_controller(void)

{
  ushort uVar1;
  
  if (pointer_to_oil_pressure_fuel_max_threshold_0_2_32 <
      pointer_to_oil_pressure_rpm_limit_threshold_0_2_32) {
    uVar1 = pointer_to_oil_pressure_rpm_limit_threshold_0_2_32 -
            pointer_to_oil_pressure_fuel_max_threshold_0_2_32;
  }
  else {
    uVar1 = pointer_to_oil_pressure_fuel_max_threshold_0_2_32 -
            pointer_to_oil_pressure_rpm_limit_threshold_0_2_32;
  }
  if (uVar1 <= oil_pressure_rate_limit_step) {
    pointer_to_oil_pressure_fuel_max_threshold_0_2_32 =
         pointer_to_oil_pressure_rpm_limit_threshold_0_2_32;
    return;
  }
  _oil_pressure_calculation_buffer = (uint)pointer_to_oil_pressure_fuel_max_threshold_0_2_32 << 0x10
  ;
  uVar1 = coreTableInterpolation();
  if (uVar1 <= pointer_to_oil_pressure_fuel_max_threshold_0_2_32) {
    if ((int)(uint)oil_pressure_rate_limit_step <
        (int)((uint)pointer_to_oil_pressure_fuel_max_threshold_0_2_32 - (uint)uVar1)) {
      pointer_to_oil_pressure_fuel_max_threshold_0_2_32 = uVar1;
      return;
    }
    pointer_to_oil_pressure_fuel_max_threshold_0_2_32 =
         pointer_to_oil_pressure_fuel_max_threshold_0_2_32 - oil_pressure_rate_limit_step;
    return;
  }
  if ((int)(uint)oil_pressure_rate_limit_step <=
      (int)((uint)uVar1 - (uint)pointer_to_oil_pressure_fuel_max_threshold_0_2_32)) {
    pointer_to_oil_pressure_fuel_max_threshold_0_2_32 = uVar1;
    return;
  }
  pointer_to_oil_pressure_fuel_max_threshold_0_2_32 =
       oil_pressure_rate_limit_step + pointer_to_oil_pressure_fuel_max_threshold_0_2_32;
  return;
}



/*
 * Function: rpmSnapshotCapture @ 0x000260ec
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void rpmSnapshotCapture(void)

{
  pointer_to_oil_pressure_fuel_max_threshold_0_2_32 = current_engine_rpm;
  _oil_pressure_calculation_buffer = 0;
  return;
}



/*
 * Function: fuelDemandTablePointerInit @ 0x000260fe
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelDemandTablePointerInit(void)

{
  _oil_pressure_calculation_buffer = 0;
  fuel_demand_scale_table_2_ptr = 0x808928;
  return;
}



/*
 * Function: oil_pressure_shutdown_controller @ 0x00026110
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint oil_pressure_shutdown_controller(void)

{
  uint in_D0;
  uint uVar1;
  
  if ((((diagnostic_status_register == FUEL_ARBITRATOR_SOURCE) ||
       (diagnostic_status_register == DERATE_CONDITION_2)) ||
      (diagnostic_status_register == DERATE_CONDITION_30)) ||
     (diagnostic_status_register == DERATE_CONDITION_3)) {
    delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 = diagnostic_status_register;
    amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 = cached_parameter_value;
    amount_of_time_over_oil_pressure_fuel_shutdown_threshold_0_65535 = 0;
    true_oil_pressure_precrank_error_1_true_0_false = oil_pressure_precrank_status;
    return in_D0;
  }
  if (oil_pressure_protection_enabled == 1) {
    in_D0 = diagnostic_system_flags_1 & 0x10;
    if ((diagnostic_system_flags_1 & 0x10) != 0) {
      if ((diagnostic_status_register == DIAGNOSTIC_MODE_7) ||
         (diagnostic_status_register == DEFAULT_DIAGNOSTIC)) {
        uVar1 = (uint)cached_parameter_value;
        if (_oil_pressure_rpm_limit_reference <= cached_parameter_value) {
          uVar1 = diagnostic_system_flags_2 & 0x2000;
          if ((diagnostic_system_flags_2 & 0x2000) != 0) {
            amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 = cached_parameter_value
            ;
            delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 =
                 diagnostic_status_register;
            true_oil_pressure_precrank_error_1_true_0_false = oil_pressure_error_status;
            amount_of_time_over_oil_pressure_fuel_shutdown_threshold_0_65535 = 1;
            return uVar1;
          }
        }
        amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 =
             _oil_pressure_rpm_limit_reference;
        delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 = 4;
        amount_of_time_over_oil_pressure_fuel_shutdown_threshold_0_65535 = 0;
        true_oil_pressure_precrank_error_1_true_0_false = oil_pressure_precrank_status;
        return uVar1;
      }
      if ((diagnostic_status_register != EPS_FAULT_MODE) &&
         (diagnostic_status_register != ENGINE_FLAGS_SOURCE)) {
        return in_D0;
      }
      amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 =
           _oil_pressure_rpm_limit_reference;
      delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 = 4;
      amount_of_time_over_oil_pressure_fuel_shutdown_threshold_0_65535 = 0;
      true_oil_pressure_precrank_error_1_true_0_false = oil_pressure_precrank_status;
      return in_D0;
    }
  }
  delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 = diagnostic_status_register;
  amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 = cached_parameter_value;
  amount_of_time_over_oil_pressure_fuel_shutdown_threshold_0_65535 = 0;
  true_oil_pressure_precrank_error_1_true_0_false = oil_pressure_precrank_status;
  return in_D0;
}



/*
 * Function: initOilPressureMonitoring @ 0x0002621c
 */

void initOilPressureMonitoring(void)

{
  amount_of_time_over_oil_pressure_fuel_shutdown_threshold_0_65535 = 0;
  true_oil_pressure_precrank_error_1_true_0_false = oil_pressure_precrank_status;
  return;
}



/*
 * Function: initMIOS14Timers @ 0x0002622e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint initMIOS14Timers(void)

{
  uint uVar1;
  
  QADC64_QADCINT = 8;
  QADC64_PQAPAR = 8;
  QADC64_DDRQB = 8;
  QADC64_LJSRR = 8;
  QADC64_QADCMCR = -(short)(((uint)PTGNQPTB * 8000) / 1000) - 1;
  QADC64_QACR1 = QADC64_QACR1 & 0xf | 9;
  uVar1 = 0x7fff0000;
  if ((dtc_active_fault_count & 1) == 0) {
    sim_timer_control_register = sim_timer_control_register & 0xffff0000;
  }
  else {
    uVar1 = ((((uint)pwm_output_scaling_factor *
              (uint)delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535) / 0x6400 &
             0xffff) * 8000) / 1000 & 0xffff |
            ((uint)pwm_output_scaling_factor * 8000) / 1000 << 0x10;
    sim_timer_control_register = uVar1;
  }
  uVar1 = uVar1 & 0xffff0000;
  if ((dtc_active_fault_count & 2) == 0) {
    _QADC64_DDRQA = _QADC64_DDRQA & 0xffff0000;
  }
  else {
    uVar1 = ((((uint)pwm_output_2_scaling_factor *
              (uint)time_since_rpm_crossed_oil_pres_start_mon_rpm_0_65535) / 0x6400 & 0xffff) * 8000
            ) / 1000 & 0xffff | ((uint)pwm_output_2_scaling_factor * 8000) / 1000 << 0x10;
    _QADC64_DDRQA = uVar1;
  }
  if (5 < amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535) {
    uVar1 = uVar1 & 0xffff0000;
    if ((dtc_active_fault_count & 4) == 0) {
      tpu_pwm_channel_3_output = tpu_pwm_channel_3_output & 0xffff0000;
    }
    else {
      uVar1 = ((((uint)pwm_output_3_scaling_factor *
                (uint)errors_allowed_timer_running_flag_for_oil_pres_0_1) / 0x6400 & 0xffff) * 8000)
              / 1000 & 0xffff | ((uint)pwm_output_3_scaling_factor * 8000) / 1000 << 0x10;
      tpu_pwm_channel_3_output = uVar1;
    }
  }
  if (5 < amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535) {
    uVar1 = uVar1 & 0xffff0000;
    if ((dtc_active_fault_count & 8) == 0) {
      tpu_pwm_channel_4_output = tpu_pwm_channel_4_output & 0xffff0000;
    }
    else {
      uVar1 = ((((uint)pwm_output_4_scaling_factor *
                (uint)pointer_to_oil_pressure_fuel_fault_log_data_0_2_32) / 0x6400 & 0xffff) * 8000)
              / 1000 & 0xffff | ((uint)pwm_output_4_scaling_factor * 8000) / 1000 << 0x10;
      tpu_pwm_channel_4_output = uVar1;
    }
  }
  uVar1 = CONCAT22((short)(uVar1 >> 0x10),dtc_active_fault_count) & 0xffff0010;
  if (((dtc_active_fault_count & 0x10) == 0) || (oil_pressure_rpm_fault_delay == 0)) {
    _QADC64_QACR2 = 0x7fff;
  }
  else if (oil_pressure_rpm_fault_delay < 0x6400) {
    QADC64_QADCMCR = -(short)(((uint)PTGNQPTB * 8000) / 1000) - 1;
    uVar1 = (QADC64_QADCMCR & 0x7fff) +
            (((((uint)PTGNQPTB * (uint)oil_pressure_rpm_fault_delay) / 0x6400 & 0xffff) * 8000) /
             1000 & 0xffff) | 0x7fff0000;
    _QADC64_QACR2 = uVar1;
  }
  else {
    uVar1 = ((uint)PTGNQPTB * 8000) / 1000;
    QADC64_QADCMCR = -(short)uVar1 - 1;
    _QADC64_QACR2 = 0x7fff8000;
  }
  dtc_active_fault_count = dtc_active_fault_count | 0x1f;
  return uVar1;
}



/*
 * Function: hardwareTimerFlagsInit @ 0x000265a4
 */

void hardwareTimerFlagsInit(void)

{
  QADC64_CCW0 = 1;
  QADC64_RJURR = 1;
  QADC64_QADCSR = 1;
  return;
}



/*
 * Function: oilPressureRpmFaultMonitor @ 0x000265be
 */

uint oilPressureRpmFaultMonitor(void)

{
  uint in_D0;
  uint uVar1;
  
  if (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 < 6) {
    amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 =
         amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 + 1;
    in_D0 = waterInFuelDiagnosticHandler();
  }
  if (pwm_output_scaling_factor != 0) {
    if ((QADC64_CCW0 & 0x8000) == 0) {
      if ((delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535 == 0) ||
         ((dtc_active_fault_count & 1) == 0)) {
        if ((QADC64_CCW0 & 0x80) == 0) {
          in_D0 = io_fault_status_reg_4 & 0xffff0010;
          if (((io_fault_status_reg_4 & 0x10) != 0) &&
             (in_D0 = io_fault_latch_reg_4 & 0xffff0010, (io_fault_latch_reg_4 & 0x10) == 0)) {
            pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 = 0;
            io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffef;
          }
        }
        else {
          in_D0 = (uint)pointer_to_oil_pressure_rpm_fault_log_data_0_2_32;
          if (pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 <
              oil_pressure_fault_debounce_threshold) {
            pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 =
                 pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 + 1;
          }
          else {
            io_fault_status_reg_4 = io_fault_status_reg_4 | 0x10;
            io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x10;
          }
        }
      }
      else if (delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535 < 0x6400) {
        in_D0 = QADC64_QADCINT & 0xffff8000;
        if ((((QADC64_QADCINT & 0x8000) != 0) &&
            (in_D0 = io_fault_status_reg_4 & 0xffff0010, (io_fault_status_reg_4 & 0x10) != 0)) &&
           (in_D0 = io_fault_latch_reg_4 & 0xffff0010, (io_fault_latch_reg_4 & 0x10) == 0)) {
          QADC64_QADCINT = QADC64_QADCINT & 0x7fff;
          pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 = 0;
          io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffef;
        }
      }
      else if ((QADC64_CCW0 & 0x80) == 0) {
        in_D0 = (uint)pointer_to_oil_pressure_rpm_fault_log_data_0_2_32;
        if (pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 <
            oil_pressure_fault_debounce_threshold) {
          pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 =
               pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 + 1;
        }
        else {
          io_fault_status_reg_4 = io_fault_status_reg_4 | 0x10;
          io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x10;
        }
      }
      else {
        in_D0 = io_fault_status_reg_4 & 0xffff0010;
        if (((io_fault_status_reg_4 & 0x10) != 0) &&
           (in_D0 = io_fault_latch_reg_4 & 0xffff0010, (io_fault_latch_reg_4 & 0x10) == 0)) {
          pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 = 0;
          io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffef;
        }
      }
    }
    else {
      in_D0 = io_fault_status_reg_4 & 0xffff0010;
      if (((io_fault_status_reg_4 & 0x10) != 0) &&
         (in_D0 = io_fault_latch_reg_4 & 0xffff0010, (io_fault_latch_reg_4 & 0x10) == 0)) {
        QADC64_CCW0 = QADC64_CCW0 & 0x7fff;
        io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffef;
        pointer_to_oil_pressure_rpm_fault_log_data_0_2_32 = 0;
      }
    }
  }
  if (pwm_output_2_scaling_factor != 0) {
    if ((QADC64_RJURR & 0x8000) == 0) {
      if ((time_since_rpm_crossed_oil_pres_start_mon_rpm_0_65535 == 0) ||
         ((dtc_active_fault_count & 2) == 0)) {
        if ((QADC64_RJURR & 0x80) == 0) {
          in_D0 = io_fault_status_reg_4 & 0xffff0020;
          if ((io_fault_status_reg_4 & 0x20) != 0) {
            in_D0 = io_fault_latch_reg_4 & 0xffff0020;
            if ((io_fault_latch_reg_4 & 0x20) == 0) {
              io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffdf;
              oil_pressure_fuel_fault_counter = 0;
            }
          }
        }
        else {
          in_D0 = (uint)oil_pressure_fuel_fault_counter;
          if (oil_pressure_fuel_fault_counter < oil_pressure_rpm_fault_threshold) {
            oil_pressure_fuel_fault_counter = oil_pressure_fuel_fault_counter + 1;
          }
          else {
            io_fault_status_reg_4 = io_fault_status_reg_4 | 0x20;
            io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x20;
          }
        }
      }
      else if (time_since_rpm_crossed_oil_pres_start_mon_rpm_0_65535 < 0x6400) {
        in_D0 = QADC64_PQAPAR & 0xffff8000;
        if ((((QADC64_PQAPAR & 0x8000) != 0) &&
            (in_D0 = io_fault_status_reg_4 & 0xffff0020, (io_fault_status_reg_4 & 0x20) != 0)) &&
           (in_D0 = io_fault_latch_reg_4 & 0xffff0020, (io_fault_latch_reg_4 & 0x20) == 0)) {
          QADC64_PQAPAR = QADC64_PQAPAR & 0x7fff;
          io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffdf;
          oil_pressure_fuel_fault_counter = 0;
        }
      }
      else if ((QADC64_RJURR & 0x80) == 0) {
        in_D0 = (uint)oil_pressure_fuel_fault_counter;
        if (oil_pressure_rpm_fault_threshold < oil_pressure_fuel_fault_counter) {
          io_fault_status_reg_4 = io_fault_status_reg_4 | 0x20;
          io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x20;
        }
        else {
          oil_pressure_fuel_fault_counter = oil_pressure_fuel_fault_counter + 1;
        }
      }
      else {
        in_D0 = io_fault_status_reg_4 & 0xffff0020;
        if ((io_fault_status_reg_4 & 0x20) != 0) {
          in_D0 = io_fault_latch_reg_4 & 0xffff0020;
          if ((io_fault_latch_reg_4 & 0x20) == 0) {
            io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffdf;
            oil_pressure_fuel_fault_counter = 0;
          }
        }
      }
    }
    else {
      in_D0 = io_fault_status_reg_4 & 0xffff0020;
      if (((io_fault_status_reg_4 & 0x20) != 0) &&
         (in_D0 = io_fault_latch_reg_4 & 0xffff0020, (io_fault_latch_reg_4 & 0x20) == 0)) {
        QADC64_RJURR = QADC64_RJURR & 0x7fff;
        io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffdf;
        oil_pressure_fuel_fault_counter = 0;
      }
    }
  }
  if (PTGNQPTB != 0) {
    if ((QADC64_QADCSR & 0x8000) == 0) {
      if ((oil_pressure_rpm_fault_delay == 0) || ((dtc_active_fault_count & 0x10) == 0)) {
        if ((QADC64_QADCSR & 0x80) != 0) {
          uVar1 = (uint)mask_for_input_of_water_in_fuel_0_65535;
          if (water_in_fuel_fault_threshold <= mask_for_input_of_water_in_fuel_0_65535) {
            io_fault_status_reg_4 = io_fault_status_reg_4 | 0x100;
            io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x100;
            return uVar1;
          }
          mask_for_input_of_water_in_fuel_0_65535 = mask_for_input_of_water_in_fuel_0_65535 + 1;
          return uVar1;
        }
        in_D0 = io_fault_status_reg_4 & 0xffff0100;
        if (((io_fault_status_reg_4 & 0x100) != 0) &&
           (in_D0 = io_fault_latch_reg_4 & 0xffff0100, (io_fault_latch_reg_4 & 0x100) == 0)) {
          mask_for_input_of_water_in_fuel_0_65535 = 0;
          io_fault_status_reg_4 = io_fault_status_reg_4 & 0xfeff;
          return in_D0;
        }
      }
      else if (oil_pressure_rpm_fault_delay < 0x6400) {
        in_D0 = QADC64_QACR1 & 0xffff8000;
        if ((((QADC64_QACR1 & 0x8000) != 0) &&
            (in_D0 = io_fault_status_reg_4 & 0xffff0100, (io_fault_status_reg_4 & 0x100) != 0)) &&
           (in_D0 = io_fault_latch_reg_4 & 0xffff0100, (io_fault_latch_reg_4 & 0x100) == 0)) {
          QADC64_QACR1 = QADC64_QACR1 & 0x7fff;
          io_fault_status_reg_4 = io_fault_status_reg_4 & 0xfeff;
          mask_for_input_of_water_in_fuel_0_65535 = 0;
          return in_D0;
        }
      }
      else {
        if ((QADC64_QADCSR & 0x80) == 0) {
          uVar1 = (uint)mask_for_input_of_water_in_fuel_0_65535;
          if (water_in_fuel_fault_threshold <= mask_for_input_of_water_in_fuel_0_65535) {
            io_fault_status_reg_4 = io_fault_status_reg_4 | 0x100;
            io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x100;
            return uVar1;
          }
          mask_for_input_of_water_in_fuel_0_65535 = mask_for_input_of_water_in_fuel_0_65535 + 1;
          return uVar1;
        }
        in_D0 = io_fault_status_reg_4 & 0xffff0100;
        if ((io_fault_status_reg_4 & 0x100) != 0) {
          in_D0 = io_fault_latch_reg_4 & 0xffff0100;
          if ((io_fault_latch_reg_4 & 0x100) == 0) {
            io_fault_status_reg_4 = io_fault_status_reg_4 & 0xfeff;
            mask_for_input_of_water_in_fuel_0_65535 = 0;
            return in_D0;
          }
        }
      }
    }
    else {
      in_D0 = io_fault_status_reg_4 & 0xffff0100;
      if (((io_fault_status_reg_4 & 0x100) != 0) &&
         (in_D0 = io_fault_latch_reg_4 & 0xffff0100, (io_fault_latch_reg_4 & 0x100) == 0)) {
        QADC64_QADCSR = QADC64_QADCSR & 0x7fff;
        io_fault_status_reg_4 = io_fault_status_reg_4 & 0xfeff;
        mask_for_input_of_water_in_fuel_0_65535 = 0;
      }
    }
  }
  return in_D0;
}



/*
 * Function: waterInFuelDiagnosticHandler @ 0x00026aca
 */

uint waterInFuelDiagnosticHandler(void)

{
  uint uVar1;
  dword dVar2;
  
  if (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 == 1) {
    uVar1 = 0;
    if ((dtc_active_fault_count & 4) == 0) {
      tpu_pwm_channel_3_output = tpu_pwm_channel_3_output & 0xffff0000;
    }
    else {
      uVar1 = ((((uint)pwm_output_3_scaling_factor * 0x6400) / 0x6400 & 0xffff) * 8000) / 1000 &
              0xffff | ((uint)pwm_output_3_scaling_factor * 8000) / 1000 << 0x10;
      tpu_pwm_channel_3_output = uVar1;
    }
    if ((dtc_active_fault_count & 8) != 0) {
      tpu_pwm_channel_4_output =
           ((((uint)pwm_output_4_scaling_factor * 0x6400) / 0x6400 & 0xffff) * 8000) / 1000 & 0xffff
           | ((uint)pwm_output_4_scaling_factor * 8000) / 1000 << 0x10;
      return tpu_pwm_channel_4_output;
    }
    tpu_pwm_channel_4_output = tpu_pwm_channel_4_output & 0xffff0000;
    return CONCAT22((short)(uVar1 >> 0x10),dtc_active_fault_count) & 0xffff0008;
  }
  if ((amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 != 3) &&
     (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 != 5)) {
    return (uint)amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535;
  }
  if ((((QADC64_DDRQB & 0x80) == 0) || ((sim_swsr & 2) == 0)) &&
     (((QADC64_DDRQB & 0x80) != 0 || ((sim_swsr & 2) != 0)))) {
    io_fault_status_reg_4 = io_fault_status_reg_4 | 0x40;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x40;
  }
  else if (((io_fault_status_reg_4 & 0x40) != 0) && ((io_fault_latch_reg_4 & 0x40) == 0)) {
    io_fault_status_reg_4 = io_fault_status_reg_4 & 0xffbf;
  }
  if (((QADC64_LJSRR & 0x80) == 0) || ((sim_swsr & 4) == 0)) {
    if ((QADC64_LJSRR & 0x80) == 0) {
      if ((sim_swsr & 4) == 0) goto LAB_00026cc4;
    }
    io_fault_status_reg_4 = io_fault_status_reg_4 | 0x80;
    io_fault_latch_reg_4 = io_fault_latch_reg_4 | 0x80;
  }
  else {
LAB_00026cc4:
    if (((io_fault_status_reg_4 & 0x100) != 0) && ((io_fault_latch_reg_4 & 0x100) == 0)) {
      io_fault_status_reg_4 = io_fault_status_reg_4 & 0xff7f;
    }
  }
  dVar2 = 0;
  if ((dtc_active_fault_count & 4) == 0) {
    tpu_pwm_channel_3_output = tpu_pwm_channel_3_output & 0xffff0000;
  }
  else {
    dVar2 = ((uint)pwm_output_3_scaling_factor * 8000) / 1000 << 0x10;
    tpu_pwm_channel_3_output = dVar2;
  }
  if ((dtc_active_fault_count & 8) != 0) {
    tpu_pwm_channel_4_output = ((uint)pwm_output_4_scaling_factor * 8000) / 1000 << 0x10;
    return tpu_pwm_channel_4_output;
  }
  tpu_pwm_channel_4_output = tpu_pwm_channel_4_output & 0xffff0000;
  return CONCAT22((short)(dVar2 >> 0x10),dtc_active_fault_count) & 0xffff0008;
}



/*
 * Function: ioOutputFlagMappingSlowCycle40Coordinator @ 0x00026d98
 */

void ioOutputFlagMappingSlowCycle40Coordinator(void)

{
  if ((io_control_flags & 1) == 0) {
    io_output_flag_byte_1 = io_output_flag_byte_1 | 8;
  }
  else {
    io_output_flag_byte_1 = io_output_flag_byte_1 & 0xf7;
  }
  if ((output_control_status_byte & 1) == 0) {
    io_output_flag_byte_1 = io_output_flag_byte_1 | 0x40;
  }
  else {
    io_output_flag_byte_1 = io_output_flag_byte_1 & 0xbf;
  }
  if ((io_control_flags & 0x80) == 0) {
    io_output_flag_byte_1 = io_output_flag_byte_1 & 0xef;
  }
  else {
    io_output_flag_byte_1 = io_output_flag_byte_1 | 0x10;
  }
  if ((can_pin_switching_control_flags & 0x20) == 0) {
    io_output_flag_byte_1 = io_output_flag_byte_1 & 0xdf;
  }
  else {
    io_output_flag_byte_1 = io_output_flag_byte_1 | 0x20;
  }
  if ((io_control_source_register & 1) == 0) {
    io_output_flag_byte_0 = io_output_flag_byte_0 & 0xef;
  }
  else {
    io_output_flag_byte_0 = io_output_flag_byte_0 | 0x10;
  }
  if ((io_control_source_register & 2) == 0) {
    io_output_flag_byte_0 = io_output_flag_byte_0 & 0xdf;
  }
  else {
    io_output_flag_byte_0 = io_output_flag_byte_0 | 0x20;
  }
  if ((io_control_source_register & 4) == 0) {
    io_output_flag_byte_0 = io_output_flag_byte_0 & 0xbf;
  }
  else {
    io_output_flag_byte_0 = io_output_flag_byte_0 | 0x40;
  }
  if ((io_control_source_register & 0x10) != 0) {
    io_output_flag_byte_0 = io_output_flag_byte_0 | 0x80;
    return;
  }
  io_output_flag_byte_0 = io_output_flag_byte_0 & 0x7f;
  return;
}



/*
 * Function: initQADC @ 0x00026e7e
 */

void initQADC(void)

{
  byte bVar1;
  byte *pbVar2;
  word *pwVar3;
  
  QADC_QADCMCR = 0;
  QADC_PORTQA = 0;
  QADC_QACR1 = 0x81f7;
  QADC_QACR2 = 0;
  QADC_QSTAT = 0x1100;
  bVar1 = 0;
  pbVar2 = &qadc_channel_config_table;
  pwVar3 = &QADC_CCW0;
  do {
    *pwVar3 = *pbVar2 & 0x3f | 0xc0;
    bVar1 = bVar1 + 1;
    pbVar2 = pbVar2 + 1;
    pwVar3 = pwVar3 + 1;
  } while (bVar1 < 0x28);
  return;
}



/*
 * Function: clearWorkingMemory @ 0x00026ec4
 */

void clearWorkingMemory(void)

{
  byte *pbVar1;
  word *pwVar2;
  
  pwVar2 = &rpm_rate_limit_countdown;
  while (pwVar2 < &byte_16_sent_from_secondary_processor_to_main_processor_0_255) {
    pbVar1 = (byte *)(pwVar2 + 0x80);
    if (&byte_16_sent_from_secondary_processor_to_main_processor_0_255 < pbVar1) {
      pbVar1 = &byte_16_sent_from_secondary_processor_to_main_processor_0_255;
    }
    for (; pwVar2 <= pbVar1; pwVar2 = pwVar2 + 2) {
      pwVar2[0] = 0;
      pwVar2[1] = 0;
    }
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
  }
  return;
}



/*
 * Function: canMemoryPointerTableInit @ 0x00026f10
 */

/* WARNING: Restarted to delay deadcode elimination for space: ram */

void canMemoryPointerTableInit(void)

{
  dword dVar1;
  dword dVar2;
  ushort uVar3;
  dword *pdVar4;
  dword *pdVar5;
  
  can_mem_table_start_ptr_1 = (dword)&can_memory_table_start;
  can_mem_table_end_ptr_1 = 0x808ab2;
  can_mem_table_src_ptr_1 = (dword)&firmware_data_source;
  can_mem_table_start_ptr_2 = (dword)&can_memory_vp44_comm_ptr;
  can_mem_table_end_ptr_2 = 0x8062ce;
  if (calibration_checksum_workspace._0_2_ == 2) {
    can_mem_table_src_ptr_2 = (dword)&can_memory_pointer_table_entry_2;
  }
  else {
    can_mem_table_src_ptr_2 = (dword)&can_memory_pointer_table_entry_1;
  }
  uVar3 = 0;
  pdVar5 = &can_mem_table_end_ptr_1;
  for (pdVar4 = &can_mem_table_start_ptr_1; pdVar4 < &can_memory_sync_pointer; pdVar4 = pdVar4 + 3)
  {
    dVar1 = *pdVar4;
    if ((int)dVar1 < 0) {
      dVar1 = dVar1 + 1;
    }
    dVar2 = *pdVar5;
    if ((int)dVar2 < 0) {
      dVar2 = dVar2 + 1;
    }
    uVar3 = ((short)((int)dVar2 >> 1) - (short)((int)dVar1 >> 1)) + uVar3;
    pdVar5 = pdVar5 + 3;
  }
  can_memory_sync_chunk_size = uVar3 / 0x14 + 1;
  can_memory_sync_pointer = (dword)&can_mem_table_start_ptr_1;
  can_memory_sync_dest_ptr = (dword)&can_memory_table_start;
  can_memory_sync_src_ptr = (dword)&firmware_data_source;
  can_memory_sync_dirty_flag = 0;
  amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 = 1;
  points_to_engine_sync_fuel_pressure_fuel_minimun_threshold_0_2_32 = 1;
  can_memory_sync_enable_prev = 1;
  return;
}



/*
 * Function: canMessageMemorySyncController @ 0x00026ff4
 */

void canMessageMemorySyncController(void)

{
  dword *pdVar1;
  short *psVar2;
  
  if ((can_memory_sync_enable_prev == 0) &&
     (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 != 0)) {
    canMemoryPointerTableInit();
  }
  if (calibration_checksum_workspace._0_2_ == 0) {
    amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 = 0;
  }
  if (amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535 != 0) {
    if ((*(uint *)(can_memory_sync_pointer + 4) <= can_memory_sync_dest_ptr) ||
       (((dword *)can_memory_sync_pointer == &can_mem_table_start_ptr_2 &&
        (points_to_engine_sync_fuel_pressure_fuel_minimun_threshold_0_2_32 == 0)))) {
      pdVar1 = (dword *)(can_memory_sync_pointer + 0xc);
      if ((pdVar1 == &can_mem_table_start_ptr_2) &&
         (points_to_engine_sync_fuel_pressure_fuel_minimun_threshold_0_2_32 == 0)) {
        pdVar1 = (dword *)(can_memory_sync_pointer + 0x18);
      }
      can_memory_sync_pointer = (dword)pdVar1;
      if (0x8018c5 < can_memory_sync_pointer) {
        can_memory_sync_pointer = (dword)&can_mem_table_start_ptr_1;
        if (can_memory_sync_dirty_flag == 0) {
          if (((fault_flags_active_base & 2) != 0) && ((fault_flags_history_base & 2) == 0)) {
            fault_flags_active_base = fault_flags_active_base & 0xfffd;
          }
        }
        else {
          fault_flags_active_base = fault_flags_active_base | 2;
          fault_flags_history_base = fault_flags_history_base | 2;
        }
        can_memory_sync_dirty_flag = 0;
      }
      can_memory_sync_dest_ptr = *(dword *)can_memory_sync_pointer;
      can_memory_sync_src_ptr = *(dword *)(can_memory_sync_pointer + 8);
    }
    psVar2 = (short *)(can_memory_sync_dest_ptr + (uint)can_memory_sync_chunk_size * 2);
    if (*(short **)(can_memory_sync_pointer + 4) < psVar2) {
      psVar2 = *(short **)(can_memory_sync_pointer + 4);
    }
    for (; can_memory_sync_dest_ptr < psVar2;
        can_memory_sync_dest_ptr = can_memory_sync_dest_ptr + 2) {
      if (*(short *)can_memory_sync_dest_ptr != *(short *)can_memory_sync_src_ptr) {
        *(short *)can_memory_sync_dest_ptr = *(short *)can_memory_sync_src_ptr;
        can_memory_sync_dirty_flag = 1;
      }
      can_memory_sync_src_ptr = can_memory_sync_src_ptr + 2;
    }
  }
  can_memory_sync_enable_prev = amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535;
  return;
}



/*
 * Function: insiteParameterParser @ 0x00027168
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

char insiteParameterParser(void)

{
  char cVar1;
  
  if (insite_command_byte < 0x80) {
    cVar1 = '\x02';
  }
  else if (insite_command_byte < 0xc0) {
    cVar1 = '\x03';
  }
  else if (insite_command_byte < 0xfe) {
    if (*_insite_data_read_ptr < 0x13) {
      cVar1 = *_insite_data_read_ptr + 2;
    }
    else {
      cVar1 = '\x14';
    }
  }
  else {
    cVar1 = '\0';
  }
  return cVar1;
}



/*
 * Function: parameterLookupForInsite @ 0x000271b0
 */

undefined2 parameterLookupForInsite(void)

{
  short sVar1;
  
  if (insite_command_byte < 0x80) {
    return 2;
  }
  if (insite_command_byte < 0xc0) {
    return 3;
  }
  if (insite_command_byte == 0xc1) {
    return CONCAT11((char)(diagnostic_active_fault_counter >> 8),
                    (char)diagnostic_active_fault_counter + '\x02');
  }
  if (insite_command_byte == 0xc2) {
    if (insite_data_valid_flag == 0) {
      return CONCAT11((char)(insite_fault_detail_state >> 8),
                      (char)insite_fault_detail_state * '\x02' + '\x02');
    }
    sVar1 = (insite_fault_detail_index + insite_fault_detail_state) * 3;
    return CONCAT11((char)((ushort)sVar1 >> 8),(char)sVar1 + '\x02');
  }
  if (insite_command_byte == 0xc4) {
    if ((insite_live_data_parameter_index & 0xc0) != 0) {
      return 4;
    }
    if (insite_parameter_lookup_state == 0) {
      return 2;
    }
    return 7;
  }
  if (insite_command_byte == 0xea) {
    return 0x18;
  }
  if (insite_command_byte != 0xed) {
    if (insite_command_byte != 0xf3) {
      return 6;
    }
    return 0x1f;
  }
  return 0x16;
}



/*
 * Function: coreSystemFunction @ 0x0002725a
 */
/* ERROR: Failed to decompile */
void coreSystemFunction(void) {
    /* Decompilation failed */
}


/*
 * Function: diagnosticServiceDispatcher @ 0x0002729a
 */

void diagnosticServiceDispatcher(byte *param_1)

{
  undefined4 in_D0;
  undefined4 unaff_D2;
  byte bVar1;
  char cVar2;
  dword *pdVar3;
  undefined2 uVar4;
  
  uVar4 = (undefined2)((uint)unaff_D2 >> 0x10);
  pdVar3 = &diagnostic_service_dispatch_ptr;
  cVar2 = '\x18';
  bVar1 = 0;
  do {
    if (diagnostic_service_state_counter <= bVar1) {
LAB_000272e6:
      if (cVar2 != -1) {
        diagnosticMultiPacketResponseBuilder
                  (param_1,CONCAT22((short)CONCAT31((int3)((uint)in_D0 >> 8),cVar2),uVar4));
      }
      return;
    }
    in_D0 = CONCAT31((int3)((uint)in_D0 >> 8),*(char *)pdVar3);
    if (*(char *)pdVar3 == **(char **)(param_1 + 6)) {
      in_D0 = diagnosticServiceSecurityValidator((int)param_1);
      cVar2 = (char)in_D0;
      if (cVar2 == -1) {
        in_D0 = (**(code **)((int)pdVar3 + 2))((short)param_1);
        cVar2 = (char)in_D0;
      }
      goto LAB_000272e6;
    }
    pdVar3 = (dword *)((int)pdVar3 + 6);
    bVar1 = bVar1 + 1;
  } while( true );
}



/*
 * Function: systemControlFunction1 @ 0x00027300
 */

void systemControlFunction1(void)

{
  coreSystemControlFunction();
  return;
}



/*
 * Function: diagnosticResponseHandler2 @ 0x00027314
 */

void diagnosticResponseHandler2(int param_1)

{
  ushort in_stack_00000000;
  
  fault_flag_scanner_state = 2;
  diagnosticCanResponseSender(param_1,(uint)in_stack_00000000);
  return;
}



/*
 * Function: canTransmissionTrigger @ 0x0002732e
 */

void canTransmissionTrigger(void)

{
  canTransmissionController();
  return;
}



/*
 * Function: diagnosticServiceByteHandler @ 0x00027342
 */

void diagnosticServiceByteHandler(int param_1)

{
  undefined2 in_D0w;
  undefined4 unaff_A2;
  undefined2 uVar1;
  
  uVar1 = (undefined2)((uint)unaff_A2 >> 0x10);
  diagnostic_security_access_mode = **(byte **)(param_1 + 6);
  diagnosticByteResponseSender
            (CONCAT22(CONCAT11((char)((ushort)in_D0w >> 8),diagnostic_security_access_mode),0x32));
  if ((diagnostic_security_access_mode == 0) && ((diagnostic_status_flags_word & 0x100) != 0)) {
    diagnosticByteResponseSender(CONCAT22(diagnostic_status_flags_word & 0x100,0x32));
    return;
  }
  if ((diagnostic_security_access_mode == 1) && ((diagnostic_status_flags_word & 0x200) != 0)) {
    diagnosticByteResponseSender
              (CONCAT22(CONCAT11((char)((diagnostic_status_flags_word & 0x200) >> 8),1),0x32));
    return;
  }
  diagnosticCanResponseSender(param_1,CONCAT22(1,uVar1));
  return;
}



/*
 * Function: systemControlFunction2 @ 0x000273c0
 */

void systemControlFunction2(void)

{
  coreSystemControlFunction();
  return;
}



/*
 * Function: fuelArbitratorMessageHandler @ 0x000273d4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelArbitratorMessageHandler(int param_1)

{
  if (((*(byte *)(param_1 + 3) == the_can_bus_configuration_register_0_255) ||
      (the_can_bus_configuration_register_0_255 == 0xff)) && (*(short *)(param_1 + 4) == 8)) {
    torque_control_message_flags = **(byte **)(param_1 + 6);
    torque_control_status_byte_19a6 = *(byte *)(*(int *)(param_1 + 6) + 4);
    if (_crank_state_transition_flag == 0) {
      if ((torque_control_status_byte_19a6 & 3) == 1) {
        if ((fuel_arbitrator_diag_t_0080cff8.rpm_target == 1) &&
           (fuel_arbitrator_diag_t_0080cff8.fuel_mode == 1)) {
          fuel_arbitrator_diag_t_0080cff8.speed_limit = 1;
          fuel_arbitrator_speed_timer = fuel_arbitrator_message_param + 1;
        }
      }
      else if ((torque_control_status_byte_19a6 & 3) != 3) {
        fuel_arbitrator_diag_t_0080cff8.speed_limit = 0;
        fuel_arbitrator_speed_timer = 0;
        fuel_arbitrator_status_timer = 0;
      }
    }
    if ((torque_control_status_byte_19a6 & 0xc) == 4) {
      fuel_arbitrator_diag_t_0080cff8.session_counter = 1;
      fuel_arbitrator_session_counter = fuel_arbitrator_session_init + 1;
    }
    else if ((torque_control_status_byte_19a6 & 0xc) != 0xc) {
      fuel_arbitrator_diag_t_0080cff8.session_counter = 0;
      fuel_arbitrator_session_counter = 0;
    }
    if (((torque_control_message_flags & 0x30) == 0x10) || ((torque_control_message_flags & 3) == 1)
       ) {
      fuel_arbitrator_diag_t_0080cff8.fuel_limit = 0;
      fuel_arbitrator_session_timer = 0;
      return;
    }
    fuel_arbitrator_diag_t_0080cff8.fuel_limit = 1;
    fuel_arbitrator_session_timer = fuel_arbitrator_timeout_param + 1;
    fuel_arbitrator_diag_t_0080cff8._30_2_ = 1;
  }
  return;
}



/*
 * Function: systemControlFunction3 @ 0x00027514
 */

void systemControlFunction3(void)

{
  coreSystemControlFunction();
  return;
}



/*
 * Function: torqueControlModeHandler @ 0x00027528
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void torqueControlModeHandler(int param_1)

{
  char cVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  undefined3 uVar5;
  undefined4 in_D0;
  uint uVar6;
  undefined4 uVar7;
  undefined4 unaff_D2;
  undefined2 uVar8;
  
  uVar8 = (undefined2)((uint)unaff_D2 >> 0x10);
  if (*(short *)(param_1 + 4) == 8) {
    torque_control_mode_byte = **(byte **)(param_1 + 6);
    bVar4 = torque_control_mode_byte & 3;
    bVar3 = torque_control_mode_byte & 3;
    bVar2 = torque_control_mode_byte & 0x30;
    torque_control_source_address = *(byte *)(*(int *)(param_1 + 6) + 1);
    torque_control_priority_high_byte = *(byte *)(*(int *)(param_1 + 6) + 2);
    torque_control_message_byte_4 = *(byte *)(*(int *)(param_1 + 6) + 3);
    cVar1 = *(char *)(param_1 + 3);
    uVar5 = (undefined3)((uint)in_D0 >> 8);
    if ((torque_control_mode_byte & 3) == 0) {
      uVar6 = diagnosticStateInitializer(CONCAT22(1,(short)CONCAT31(uVar5,cVar1)));
    }
    else {
      uVar6 = diagnosticMessageValidator
                        (CONCAT22(1,(short)CONCAT31(uVar5,cVar1)),
                         CONCAT12(torque_control_mode_byte,uVar8) & 0x3ffff);
      if ((short)uVar6 != 0) {
        return;
      }
    }
    uVar5 = (undefined3)(uVar6 >> 8);
    if (fuel_arbitrator_diag_t_0080cff8.rpm_target == 0) {
      uVar6 = diagnosticSessionValidator(CONCAT22(1,(short)CONCAT31(uVar5,cVar1)));
      if ((short)uVar6 != 0) {
        return;
      }
      _timer_capture_value = _fuel_arbitrator_control_mode;
    }
    else if (fuel_arbitrator_diag_t_0080cff8._28_2_ == 1) {
      if (cVar1 != (char)fuel_arbitrator_diag_t_0080cff8.limited_value) {
        if (bVar4 == 0) {
          return;
        }
        uVar6 = diagnosticSessionValidator(CONCAT22(1,(short)CONCAT31(uVar5,cVar1)));
        if ((short)uVar6 != 0) {
          return;
        }
        if (torque_control_comparison_byte < bVar2) {
          return;
        }
        if (bVar2 == torque_control_comparison_byte) {
          if (fuel_arbitrator_diag_t_0080cff8.rpm_target != 3) {
            return;
          }
          if (bVar3 == 3) {
            if (torque_control_priority_byte < torque_control_message_byte_4) {
              return;
            }
            if ((torque_control_priority_byte == torque_control_message_byte_4) &&
               (torque_control_priority_value <=
                CONCAT11(torque_control_priority_high_byte,torque_control_source_address))) {
              return;
            }
          }
        }
        _timer_capture_value = _fuel_arbitrator_control_mode;
      }
    }
    else {
      uVar6 = diagnosticSessionValidator(CONCAT22(1,(short)CONCAT31(uVar5,cVar1)));
      if ((short)uVar6 != 0) {
        return;
      }
      if (_timer_capture_value < _fuel_arbitrator_control_mode) {
        return;
      }
      _timer_capture_value = _fuel_arbitrator_control_mode;
    }
    fuel_arbitrator_diag_t_0080cff8.control_flags = (word)torque_control_mode_byte;
    torque_control_comparison_byte = bVar2;
    fuel_arbitrator_diag_t_0080cff8._28_2_ = 1;
    fuel_arbitrator_diag_t_0080cff8.limited_value._1_1_ = cVar1;
    switch(bVar3) {
    case 0:
      torque_control_mode_timer = 0;
      fuel_arbitrator_diag_t_0080cff8.rpm_target = 0;
      fuel_arbitrator_diag_t_0080cff8.fuel_mode = 0;
      fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
      return;
    case 1:
      torque_control_mode_timer = *(short *)(_timer_capture_value + 4) + 1;
      fuel_arbitrator_diag_t_0080cff8.rpm_target = 1;
      uVar7 = canBusConfigTypeSelector
                        (CONCAT22(CONCAT11((char)(torque_control_mode_timer >> 8),
                                           *(undefined1 *)(param_1 + 3)),uVar8));
      fuel_arbitrator_diag_t_0080cff8.fuel_mode = (word)uVar7;
      fuel_arbitrator_diag_t_0080cff8._20_2_ = 1;
      fuel_arbitrator_diag_t_0080cff8.state_pointer._1_2_ =
           CONCAT11(torque_control_priority_high_byte,torque_control_source_address);
      torque_control_priority_value = fuel_arbitrator_diag_t_0080cff8.state_pointer._1_2_;
      if (24000 < fuel_arbitrator_diag_t_0080cff8.state_pointer._1_2_) {
        fuel_arbitrator_diag_t_0080cff8.state_pointer._1_2_ = 24000;
      }
      fuel_arbitrator_diag_t_0080cff8._26_2_ = (short)((int)(torque_control_mode_byte & 0xc) >> 2);
      return;
    case 2:
      torque_control_mode_timer = *(short *)(_timer_capture_value + 8) + 1;
      fuel_arbitrator_diag_t_0080cff8.rpm_target = 2;
      uVar7 = canBusConfigTypeSelector
                        (CONCAT22(CONCAT11((char)(torque_control_mode_timer >> 8),
                                           *(undefined1 *)(param_1 + 3)),uVar8));
      fuel_arbitrator_diag_t_0080cff8.fuel_mode = (word)uVar7;
      fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
      torque_control_priority_byte = torque_control_message_byte_4;
      fuel_arbitrator_diag_t_0080cff8._16_2_ =
           (ushort)torque_control_message_byte_4 * 0x100 + -32000;
      fuel_arbitrator_diag_t_0080cff8._24_2_ =
           param_ref_base +
           (short)(((int)(short)fuel_arbitrator_diag_t_0080cff8._16_2_ *
                   ((int)(short)param_scale_factor - (int)(short)param_ref_base)) / 0x6400);
      if ((short)fuel_arbitrator_diag_t_0080cff8._24_2_ < 0) {
        fuel_arbitrator_diag_t_0080cff8._24_2_ = 0;
        return;
      }
      return;
    case 3:
      torque_control_mode_timer = *(short *)(_timer_capture_value + 0xc) + 1;
      fuel_arbitrator_diag_t_0080cff8.rpm_target = 3;
      uVar7 = canBusConfigTypeSelector
                        (CONCAT22(CONCAT11((char)(torque_control_mode_timer >> 8),
                                           *(undefined1 *)(param_1 + 3)),uVar8));
      fuel_arbitrator_diag_t_0080cff8.fuel_mode = (word)uVar7;
      fuel_arbitrator_diag_t_0080cff8._20_2_ = 0;
      torque_control_priority_value =
           CONCAT11(torque_control_priority_high_byte,torque_control_source_address);
      fuel_arbitrator_diag_t_0080cff8.command_counter = torque_control_priority_value;
      torque_control_priority_byte = torque_control_message_byte_4;
      fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ =
           param_ref_base +
           (short)(((int)(short)((ushort)torque_control_message_byte_4 * 0x100 + -32000) *
                   ((int)(short)param_scale_factor - (int)(short)param_ref_base)) / 0x6400);
      if (fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ < 0) {
        fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ = 0;
        return;
      }
    }
  }
  return;
}



/*
 * Function: canTransmissionController @ 0x0002787e
 */
/* ERROR: Failed to decompile */
void canTransmissionController(void) {
    /* Decompilation failed */
}


/*
 * Function: diagnosticServiceDispatcherByPgn @ 0x000278be
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticServiceDispatcherByPgn(int param_1)

{
  undefined4 unaff_D2;
  byte bVar1;
  dword *pdVar2;
  undefined2 uVar3;
  
  uVar3 = (undefined2)((uint)unaff_D2 >> 0x10);
  pdVar2 = &diag_service_pgn_dispatch_ptr;
  if ((*(byte *)(param_1 + 2) == _j1939_multiframe_source_address) || (*(char *)(param_1 + 2) == -1)
     ) {
    for (bVar1 = 0; bVar1 < can_transmission_active_count; bVar1 = bVar1 + 1) {
      if ((*(char *)((int)pdVar2 + 1) == **(char **)(param_1 + 6)) &&
         (*(char *)(*(int *)(param_1 + 6) + 1) == *(char *)pdVar2)) {
        (**(code **)((int)pdVar2 + 2))((short)param_1);
        break;
      }
      pdVar2 = (dword *)((int)pdVar2 + 6);
    }
    if ((bVar1 == can_transmission_active_count) && (*(char *)(param_1 + 2) != -1)) {
      diagnosticCanResponseSender(param_1,CONCAT22(1,uVar3));
    }
  }
  return;
}



/*
 * Function: diagnosticDataDump @ 0x0002793e
 */

void diagnosticDataDump(void)

{
  coreSystemControlFunction();
  engineSerialNumberPGN_65259_Builder();
  engineTemperaturePGN_65262_Builder();
  intakeExhaustConditionsPGN_65257_Builder();
  ioControlPGN_65244_Builder();
  vehicleDistancePGN_65248_Builder();
  vehicleHoursPGN_65255_Builder();
  canTransmissionController();
  canTransmissionController();
  canTransmissionController();
  canTransmissionController();
  canTransmissionController();
  canTransmissionController();
  engineCoolantPGN_65226_Builder();
  diagnosticDM2PGN_65227_Builder();
  canTransmissionTrigger();
  diagnosticDM4PGN_65229_Builder();
  diagnosticDM5PGN_65230_Builder();
  diagnosticDM11PGN_65234_Builder();
  return;
}



/*
 * Function: retarderModeThresholdCalculator @ 0x000279ee
 */

uint retarderModeThresholdCalculator(undefined4 param_1)

{
  uint in_D0;
  ushort uVar2;
  ushort uVar3;
  uint uVar1;
  
  if (param_1._0_2_ == 0) {
    return in_D0 & 0xffffff00;
  }
  if (retarder_mode_threshold_value_37d4 != 1) {
    retarder_mode3_rpm_input = current_engine_rpm;
    uVar3 = lookupTableInterpolation((table_interp_args_t *)&retarder_mode3_threshold_table);
    uVar1 = ((uint)param_1._0_2_ * (uint)retarder_mode_threshold_value_7996) / 0x6400;
    if (uVar3 < (ushort)uVar1) {
      if (retarder_mode_threshold_value_37d4 == 3) {
        return 1;
      }
      return 3;
    }
    if (retarder_mode_threshold_value_37d4 == 3) {
      return uVar1 & 0xffffff00;
    }
    return 1;
  }
  retarder_mode1_rpm_input = current_engine_rpm;
  uVar2 = lookupTableInterpolation((table_interp_args_t *)&retarder_mode1_threshold_table);
  uVar3 = (ushort)(((uint)param_1._0_2_ * (uint)ADO2ESTB) / 0x6400);
  if (uVar3 < uVar2) {
    return 1;
  }
  retarder_mode2_rpm_input = current_engine_rpm;
  uVar2 = lookupTableInterpolation((table_interp_args_t *)&retarder_mode2_threshold_table);
  if (uVar3 < uVar2) {
    return 2;
  }
  return 3;
}



/*
 * Function: retarderPercentageScaler @ 0x00027aca
 */

short retarderPercentageScaler(undefined4 param_1)

{
  byte bVar1;
  
  bVar1 = (byte)((uint)param_1 >> 0x10);
  if (bVar1 < 0x19) {
    return 0x6400;
  }
  if (0x7c < bVar1) {
    return 0;
  }
  return (0x7d - (param_1._0_2_ & 0xff)) * 0x100;
}



/*
 * Function: retarderControlModeHandler @ 0x00027afa
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void retarderControlModeHandler(int param_1)

{
  byte bVar1;
  RETARDER_MODE_STATE RVar2;
  RETARDER_MODE_STATE RVar3;
  uint uVar4;
  word wVar6;
  ushort uVar7;
  undefined4 uVar5;
  undefined2 uVar8;
  short sVar9;
  undefined4 unaff_D2;
  bool bVar10;
  undefined2 uVar11;
  
  uVar8 = (undefined2)((uint)unaff_D2 >> 0x10);
  if ((retarder_mode_threshold_value_37d4 != 0) && (*(short *)(param_1 + 4) == 8)) {
    retarder_mode_control_byte_mirror = **(RETARDER_MODE_STATE **)(param_1 + 6);
    RVar3 = retarder_mode_control_byte_mirror & RETARDER_PROPORTIONAL;
    if (RVar3 != RETARDER_SPEED_SYNC) {
      RVar2 = retarder_mode_control_byte_mirror & 0x30;
      retarder_control_priority_byte = *(byte *)(*(int *)(param_1 + 6) + 3);
      bVar1 = *(byte *)(param_1 + 3);
      if (RVar3 == RETARDER_DISABLED) {
        uVar4 = ioControlEntryRemove((uint)CONCAT12(bVar1,uVar8));
      }
      else {
        uVar4 = ioControlTimeoutTableLookup((uint)CONCAT12(bVar1,uVar8));
        if ((short)uVar4 != 0) {
          return;
        }
      }
      if (fuel_arbitrator_state == 0) {
        uVar4 = diagnosticSessionValidator(CONCAT22(1,(short)CONCAT31((int3)(uVar4 >> 8),bVar1)));
        if ((short)uVar4 != 0) {
          return;
        }
        _retarder_control_mode_state = _fuel_arbitrator_control_mode;
      }
      else if (bVar1 != _retarder_control_can_source) {
        if (RVar3 == RETARDER_DISABLED) {
          return;
        }
        uVar4 = diagnosticSessionValidator(CONCAT22(1,(ushort)bVar1));
        if ((short)uVar4 != 0) {
          return;
        }
        if (retarder_mode_priority_level < RVar2) {
          return;
        }
        if (RVar2 == retarder_mode_priority_level) {
          if (fuel_arbitrator_state == 2) {
            return;
          }
          if ((RVar3 == RETARDER_PROPORTIONAL) &&
             (retarder_control_priority_byte <= retarder_control_priority_prev)) {
            return;
          }
        }
        _retarder_control_mode_state = _fuel_arbitrator_control_mode;
      }
      retarder_mode_priority_level = RVar2;
      retarder_control_priority_prev = retarder_control_priority_byte;
      _retarder_control_can_source = (ushort)bVar1;
      retarder_mode_control_byte_cached = (word)retarder_mode_control_byte_mirror;
      if (RVar3 == RETARDER_DISABLED) {
        retarder_control_mode_timer = 0;
        fuel_arbitrator_state = 0;
        retarder_mode_can_source_priority = 0;
        _retarder_mode_threshold_result = 0;
        _retarder_mode_table_count = 3;
        fuel_arbitrator_diag_t_0080cff8.throttle_mode = 0;
        return;
      }
      if (RVar3 == RETARDER_LOAD_BASED) {
        wVar6 = retarderPercentageScaler((uint)CONCAT12(retarder_control_priority_byte,uVar8));
        retarder_percentage_scaled_output = wVar6;
        if (((((diagnostic_system_flags_2 & 0x1000) == 0) ||
             (bVar1 != the_can_bus_configuration_register_0_255)) ||
            (fuel_arbitrator_diag_t_0080cff8.rpm_target != 1)) ||
           (((fuel_arbitrator_diag_t_0080cff8.fuel_mode != 1 ||
             (cached_parameter_value < cached_parameter_upper_limit)) || (wVar6 == 0)))) {
          retarder_control_mode_timer = *(short *)(_retarder_control_mode_state + 0xe) + 1;
          fuel_arbitrator_state = 2;
          uVar11 = CONCAT11((char)(retarder_control_mode_timer >> 8),*(undefined1 *)(param_1 + 3));
          uVar5 = canBusConfigTypeSelector(CONCAT22(uVar11,uVar8));
          retarder_mode_can_source_priority = (word)uVar5;
          _retarder_mode_table_count = 3;
          uVar4 = retarderModeThresholdCalculator(CONCAT22(wVar6,uVar11));
          _retarder_mode_threshold_result = (ushort)uVar4 & 0xff;
          if ((uVar4 & 0xff) == 0) {
            fuel_arbitrator_diag_t_0080cff8.throttle_mode = 1;
            fuel_arbitrator_throttle_override = *(short *)(_retarder_control_mode_state + 0xe) + 1;
          }
          else {
            fuel_arbitrator_diag_t_0080cff8.throttle_mode = 0;
            fuel_arbitrator_throttle_override = 0;
          }
        }
        else {
          retarder_control_mode_timer = 0;
          fuel_arbitrator_state = 0;
          retarder_mode_can_source_priority = 0;
          _retarder_mode_threshold_result = 0;
          _retarder_mode_table_count = 3;
          fuel_arbitrator_diag_t_0080cff8.throttle_mode = 0;
          fuel_arbitrator_throttle_override = 0;
        }
        _retarder_mode_override_flag = 0;
        return;
      }
      if (RVar3 != RETARDER_PROPORTIONAL) {
        return;
      }
      fuel_arbitrator_state = 3;
      uVar7 = (ushort)*(byte *)(param_1 + 3);
      uVar5 = canBusConfigTypeSelector((uint)CONCAT12(*(byte *)(param_1 + 3),uVar8));
      retarder_mode_can_source_priority = (word)uVar5;
      _retarder_mode_threshold_result = 0;
      uVar8 = (undefined2)CONCAT31((int3)((uint)uVar5 >> 8),retarder_control_priority_byte);
      sVar9 = retarderPercentageScaler(CONCAT22(uVar8,uVar7));
      retarder_control_mode_timer = *(short *)(_retarder_control_mode_state + 0x12) + 1;
      uVar4 = retarderModeThresholdCalculator(CONCAT22(sVar9,uVar8));
      _retarder_mode_table_count = (ushort)uVar4 & 0xff;
      bVar10 = (uVar4 & 0xff) != 0;
      if (bVar10) {
        fuel_arbitrator_throttle_override = 0;
      }
      else {
        fuel_arbitrator_throttle_override = *(short *)(_retarder_control_mode_state + 0x12) + 1;
      }
      fuel_arbitrator_diag_t_0080cff8.throttle_mode = (word)!bVar10;
      _retarder_mode_override_flag = 0;
    }
  }
  return;
}



/*
 * Function: retarderModeThresholdsSetup @ 0x00027dd4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void retarderModeThresholdsSetup(void)

{
  _retarder_mode_table_count = 3;
  retarder_mode1_data_ptr = 0x807952;
  retarder_mode1_output_ptr = 0x807998;
  retarder_mode1_threshold_table = 2;
  retarder_mode2_data_ptr = 0x807952;
  retarder_mode2_output_ptr = 0x8079a2;
  retarder_mode2_threshold_table = 2;
  retarder_mode3_data_ptr = 0x80797a;
  retarder_mode3_output_ptr = 0x8079ac;
  retarder_mode3_threshold_table = 2;
  return;
}



/*
 * Function: torqueControlAddressDispatcher @ 0x00027e3e
 */

void torqueControlAddressDispatcher(int param_1)

{
  byte bVar1;
  
  bVar1 = *(byte *)(param_1 + 2);
  if ((bVar1 != j1939_source_address_primary) && (bVar1 != 0xff)) {
    if ((bVar1 == j1939_source_address_secondary) || (bVar1 == 0xff)) {
      retarderControlModeHandler(param_1);
    }
    return;
  }
  torqueControlModeHandler(param_1);
  return;
}



/*
 * Function: systemControlFunction4 @ 0x00027e86
 */

void systemControlFunction4(void)

{
  coreSystemControlFunction();
  return;
}



/*
 * Function: systemSecurityCheckStub_AlwaysPasses @ 0x00027e98
 */

undefined1 systemSecurityCheckStub_AlwaysPasses(void)

{
  return 0;
}



/*
 * Function: diagnosticTableEntryRemover @ 0x00027e9c
 */

void diagnosticTableEntryRemover(undefined4 param_1)

{
  bool bVar1;
  short sVar2;
  short unaff_D3w;
  
  bVar1 = false;
  sVar2 = unaff_D3w * 0x30;
  while ((unaff_D3w < 0x14 && (!bVar1))) {
    if (param_1._0_2_ == *(short *)((int)&dtc_timestamp_array + (int)sVar2)) {
      *(undefined2 *)((int)&dtc_timestamp_array + (int)sVar2) = 0x7d;
      *(undefined2 *)((int)&diagnostic_fault_status_array + (int)sVar2) = 0x7d;
      bVar1 = true;
    }
    sVar2 = sVar2 + 0x30;
    unaff_D3w = unaff_D3w + 1;
  }
  return;
}



/*
 * Function: diagnosticTableEntryClear @ 0x00027ef0
 */

void diagnosticTableEntryClear(undefined4 param_1)

{
  short sVar1;
  undefined4 unaff_D2;
  
  sVar1 = param_1._0_2_ * 10;
  (&diagnostic_pid_dtc_index)[sVar1] = 0;
  *(undefined4 *)(sVar1 + 0x804fc4) = 0;
  *(undefined4 *)
   ((int)&ivs_switch_status_when_throttle_validation_process_error_true_false + (int)sVar1) = 0;
  if (*(char *)(sVar1 + 0x804fcc) == '\x02') {
    diagnosticTableEntryRemover(CONCAT22(param_1._0_2_,(short)((uint)unaff_D2 >> 0x10)));
  }
  *(undefined1 *)(sVar1 + 0x804fcc) = 0;
  return;
}



/*
 * Function: diagnosticTableSnapshotCapture @ 0x00027f4c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticTableSnapshotCapture(undefined4 param_1)

{
  short sVar1;
  
  if ((*(ushort *)(&dtc_fault_table_base + (short)(param_1._2_2_ * 3) * 2) & 0x10) != 0) {
    sVar1 = param_1._0_2_ * 0x30;
    *(short *)((int)&diagnostic_fault_status_array + (int)sVar1) = param_1._2_2_;
    *(word *)((int)&diagnostic_snapshot_fuel_value + (int)sVar1) = asthrfes_calc_input;
    *(word *)((int)&diagnostic_snapshot_throttle_value + (int)sVar1) = throttle_position_value;
    *(word *)(sVar1 + 0x805a3a) = current_engine_rpm_raw;
    *(word *)(sVar1 + 0x805a40) = active_derate_value;
    *(word *)((int)&diagnostic_snapshot_sensor_reading + (int)sVar1) = diagnostic_sensor_reading;
    *(undefined4 *)(sVar1 + 0x805a32) = _loopCounter;
    *(word *)((int)&diagnostic_snapshot_throttle_raw + (int)sVar1) = throttle_position_raw;
    *(word *)(sVar1 + 0x805a46) = intake_manifold_temp_raw;
    *(word *)(sVar1 + 0x805a48) = insite_parameter_display_value;
    *(undefined2 *)(sVar1 + 0x805a3c) = _fault_flag_snapshot_register_3;
    *(undefined2 *)(sVar1 + 0x805a4a) = _fault_flag_snapshot_register_2;
    *(undefined4 *)(sVar1 + 0x805a4c) = _engineRunCounter;
    *(VP44_ENGINE_STATE *)(sVar1 + 0x805a50) = vp44_engine_state;
    *(word *)(sVar1 + 0x805a52) = retarder_input_value;
    *(word *)(sVar1 + 0x805a54) = current_fuel_demand_value;
    *(word *)(sVar1 + 0x805a56) = diagnostic_fuel_arbitration_output;
    *(undefined2 *)(sVar1 + 0x805a58) = _vp44_can_msg_100_status_flags;
    *(word *)(sVar1 + 0x805a5a) = fso_monitoring_command_value;
    *(VP44_STATE *)(sVar1 + 0x805a5c) = vp44_state_debounce_value_938c;
    *(word *)(sVar1 + 0x805a5e) = vp44_timing_mode_selector;
    *(undefined2 *)(sVar1 + 0x805a60) = _fault_flag_snapshot_register_1;
  }
  sVar1 = param_1._0_2_ * 0x30;
  if (param_1._2_2_ != *(short *)((int)&dtc_timestamp_array + (int)sVar1)) {
    *(short *)((int)&dtc_timestamp_array + (int)sVar1) = param_1._2_2_;
    *(word *)(sVar1 + 0x80567e) = asthrfes_calc_input;
    *(word *)((int)&dtc_timestamp_array + sVar1 + 2) = throttle_position_value;
    *(word *)(sVar1 + 0x80567a) = current_engine_rpm_raw;
    *(word *)(sVar1 + 0x805680) = active_derate_value;
    *(word *)(sVar1 + 0x805682) = diagnostic_sensor_reading;
    *(undefined4 *)(sVar1 + 0x805672) = _loopCounter;
    *(word *)(sVar1 + 0x805684) = throttle_position_raw;
    *(word *)(sVar1 + 0x805686) = intake_manifold_temp_raw;
    *(word *)(sVar1 + 0x805688) = insite_parameter_display_value;
    *(undefined2 *)(sVar1 + 0x80567c) = _fault_flag_snapshot_register_3;
    *(undefined2 *)(sVar1 + 0x80568a) = _fault_flag_snapshot_register_2;
    *(undefined4 *)(sVar1 + 0x80568c) = _engineRunCounter;
    *(VP44_ENGINE_STATE *)(sVar1 + 0x805690) = vp44_engine_state;
    *(word *)(sVar1 + 0x805692) = retarder_input_value;
    *(word *)(sVar1 + 0x805694) = current_fuel_demand_value;
    *(word *)(sVar1 + 0x805696) = diagnostic_fuel_arbitration_output;
    *(undefined2 *)(sVar1 + 0x805698) = _vp44_can_msg_100_status_flags;
    *(word *)(sVar1 + 0x80569a) = fso_monitoring_command_value;
    *(VP44_STATE *)(sVar1 + 0x80569c) = vp44_state_debounce_value_938c;
    *(word *)(sVar1 + 0x80569e) = vp44_timing_mode_selector;
    *(undefined2 *)(sVar1 + 0x8056a0) = _fault_flag_snapshot_register_1;
  }
  return;
}



/*
 * Function: initSensorDataArrays @ 0x000281e8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initSensorDataArrays(void)

{
  char cVar1;
  short sVar2;
  
  cVar1 = '\0';
  if (_loopCounter == 0) {
    sVar2 = 0;
    for (; cVar1 != '\x14'; cVar1 = cVar1 + '\x01') {
      *(undefined2 *)((int)&dtc_timestamp_array + (int)sVar2) = 0x7d;
      *(undefined2 *)((int)&diagnostic_fault_status_array + (int)sVar2) = 0x7d;
      sVar2 = sVar2 + 0x30;
    }
  }
  return;
}



/*
 * Function: tpuChannelStateMachine @ 0x00028220
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 tpuChannelStateMachine(void)

{
  char cVar1;
  undefined4 in_D0;
  int iVar2;
  undefined4 in_D1;
  
  tpu_channel_enable_state = 0;
  tpu_channel_priority_select = tpu_channel_priority_select & 0xfff;
  if (((tpu_channel_state_value == 1) && (*_can_tx_message_type != 0)) &&
     (tpu_transmission_active_flag == 0)) {
    if (*_can_tx_message_type < 3) {
      _dummy_variable_0_65535 =
           (byte *)CONCAT31(_dummy_variable_0_65535,(char)dummy_variable_0_65535 + '\x01');
      *_can_tx_message_type = 0;
      tpu_transmission_state = 0;
    }
    else if (tpu_transmission_state == 0) {
      *_can_tx_message_type = *_can_tx_message_type - 1;
      _can_tx_message_type =
           (byte *)CONCAT31(_can_tx_message_type,flag_indicating_eps_sensor_not_used_0_1 - 1);
      *_can_tx_message_type = 0;
    }
    else {
      _dummy_variable_0_65535 =
           (byte *)CONCAT31(_dummy_variable_0_65535,(char)dummy_variable_0_65535 + '\x01');
      if (*_dummy_variable_0_65535 < 7) {
        if ((int)_can_tx_message_type < _enables_input_of_eps_period_data_to_pptb_0_1) {
          iVar2 = (_enables_input_of_eps_period_data_to_pptb_0_1 - (int)_can_tx_message_type) + -2;
        }
        else {
          iVar2 = (_enables_input_of_eps_period_data_to_pptb_0_1 - (int)_can_tx_message_type) + 0xfe
          ;
        }
        if (3 < iVar2) {
          tpu_diagnostic_retry_counter = tpu_diagnostic_retry_counter + 1;
          *_can_tx_message_type = 2;
          _can_tx_message_type =
               (byte *)CONCAT31(_can_tx_message_type,(char)dummy_variable_0_65535 + '\x01');
          *_can_tx_message_type = 6;
          _can_tx_message_type =
               (byte *)CONCAT31(_can_tx_message_type,(char)dummy_variable_0_65535 + '\x01');
          *_can_tx_message_type = 0x74;
          cVar1 = (char)dummy_variable_0_65535;
          _can_tx_message_type =
               (byte *)CONCAT31(_can_tx_message_type,(char)dummy_variable_0_65535 + '\x01');
          _dummy_variable_0_65535 = (byte *)CONCAT31(_dummy_variable_0_65535,cVar1 + '\x02');
        }
      }
      *_can_tx_message_type = 0;
      tpu_transmission_state = 0;
    }
  }
  if (tpu_channel_state_value == 0) {
    tpu_transmission_state = 0;
    tpu_channel_state_value = 1;
    flag_shows_posibility_of_esp_transitioning_between_normal_false_true._1_1_ =
         (char)_can_transmit_length;
    _track_the_time_when_throttle_is_less_than_a_threshold_0_30 =
         (byte *)CONCAT31((int3)(_can_transmit_length >> 8),
                          (char)flag_shows_posibility_of_esp_transitioning_between_normal_false_true
                          + '\x01');
    tpu_channel_enable_state = 1;
    tpu_channel_int_select = 0xfcbe;
    tpu_channel_priority_select = tpu_channel_priority_select & 0x7fff | 0x4000;
  }
  else if (can_transmit_buffer_ptr != _can_transmit_length) {
    if ((tpu_cfsr0 & 0x20) == 0) {
      tpu_cfsr1 = (word)*_track_the_time_when_throttle_is_less_than_a_threshold_0_30;
      tpu_channel_state_value = 0;
      _tpu_transmission_state_machine = 0;
      tpu_transmission_byte_counter = 1;
      tpu_transmission_state = *_track_the_time_when_throttle_is_less_than_a_threshold_0_30;
      tpu_cier = tpu_cier | 0x20;
    }
    else {
      tpu_channel_enable_state = 1;
      tpu_channel_int_select = 0xfc8a;
      tpu_channel_priority_select = tpu_channel_priority_select & 0x7fff | 0x4000;
    }
  }
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: engineSpeedIsrRegister @ 0x000283c0
 */

void engineSpeedIsrRegister(void)

{
  engine_speed_isr_register_address = (dword)tpuChannelStateMachine;
  tpu_channel_priority_select = tpu_channel_priority_select & 0xfff;
  return;
}



/*
 * Function: engineRpmHardwareTimerSetup @ 0x000283dc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineRpmHardwareTimerSetup(void)

{
  uint uVar1;
  uint uVar2;
  ushort uVar3;
  undefined4 local_8;
  
  uVar3 = current_engine_rpm;
  if (retarder_rpm_override_active == 1) {
    uVar3 = retarder_override_rpm_value;
  }
  if ((uVar3 != 0) && (uVar3 < retarder_mode_timeout_value)) {
    uVar3 = retarder_mode_timeout_value;
  }
  if ((uVar3 == 0) ||
     (0x10c5 < mask_used_by_a_tool_to_id_the_trip_faults_found_in_the_trip_in_0_03f)) {
    retarder_proportion_calc_workspace = 0x4230bdc0;
    local_8 = proportionalCalculation(16000000,0x4230bdc0,32000000);
    local_8 = local_8 & 0xffff;
  }
  else {
    retarder_proportion_calc_workspace =
         ((uint)mask_used_by_a_tool_to_id_the_trip_faults_found_in_the_trip_in_0_03f * 1000000) /
         (uint)uVar3;
    uVar2 = proportionalCalculation(16000000,retarder_proportion_calc_workspace,32000000);
    local_8 = uVar2 & 0xffff;
    uVar1 = local_8;
    local_8 = CONCAT22((short)((int)uVar1 >> 1),(short)uVar2);
  }
  _IMB_CSBAR3 = local_8;
  return;
}



/*
 * Function: can1ControllerInit @ 0x000284aa
 */

/* WARNING: Removing unreachable block (ram,0x00028528) */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void can1ControllerInit(void)

{
  can1_cantbsel = can1_cantbsel & 0xefff;
  can1_canidmr2 = can1_canidmr2 & 0xefff;
  can1_canidac = can1_canidac & 0xfff0 | 0xb;
  IMB_CSBAR2 = 0x92;
  _IMB_CSBAR3 = 0xffff;
  can1_canidar2 = can1_canidar2 & 0xfcff | 0x200;
  can1_canidmr0 = can1_canidmr0 & 0xfcff | 0x100;
  retarder_mode_timeout_value =
       (word)((int)((uint)mask_used_by_a_tool_to_id_the_trip_faults_found_in_the_trip_in_0_03f *
                   0x1e84) >> 10);
  if (retarder_mode_timeout_value < road_speed_below_which_esp_distance_does_not_accumulate_0_10) {
    retarder_mode_timeout_value = road_speed_below_which_esp_distance_does_not_accumulate_0_10;
  }
  return;
}



/*
 * Function: emptyStubFunction9 @ 0x0002853c
 */

undefined8 emptyStubFunction9(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: emptyInitPlaceholder @ 0x00028546
 */

void emptyInitPlaceholder(void)

{
  return;
}



/*
 * Function: engineStatisticsAccumulator @ 0x00028548
 */

undefined4 engineStatisticsAccumulator(uint *param_1,uint *param_2)

{
  dword dVar1;
  uint uVar2;
  ushort uVar3;
  
  dVar1 = engine_runtime_statistics_accumulator;
  uVar3 = 0;
  *param_1 = engine_runtime_statistics_accumulator + *param_1;
  if (0xfffff < *param_1) {
    uVar2 = *param_1 >> 0x14;
    uVar3 = (ushort)(-uVar2 - 1 <= *param_2);
    *param_2 = uVar2 + *param_2;
    dVar1 = uVar2 * 0x100000;
    *param_1 = *param_1 + uVar2 * -0x100000;
  }
  return CONCAT22((short)(dVar1 >> 0x10),uVar3);
}



/*
 * Function: runTimeCountersUpdate @ 0x00028588
 */

void runTimeCountersUpdate(void)

{
  insite_runtime_hours_accumulator = runtime_hours_accumulator + 1;
  runtime_counter_accumulator_1 = runtime_counter_accumulator_1 + 1;
  runtime_hours_accumulator = insite_runtime_hours_accumulator;
  if (engine_runtime_statistics_accumulator != 0) {
    engineStatisticsAccumulator(&runtime_counter_update_arg_1,&runtime_counter_update_arg_2);
    engineStatisticsAccumulator((uint *)0x805f58,&insite_command_base_value);
  }
  return;
}



/*
 * Function: runTimeCountersUpdateAlt @ 0x000285c8
 */

void runTimeCountersUpdateAlt(void)

{
  runtime_counter_accumulator_2 = runtime_counter_accumulator_2 + 1;
  insite_idle_hours_accumulator = idle_hours_accumulator + 1;
  idle_hours_accumulator = insite_idle_hours_accumulator;
  if (engine_runtime_statistics_accumulator != 0) {
    engineStatisticsAccumulator(&OCHRRSHS,&runtime_counter_update_alt_arg);
    engineStatisticsAccumulator((uint *)0x805f5c,(uint *)0x805f60);
  }
  return;
}



/*
 * Function: fuelDemandFaultCounterIncrement @ 0x0002860c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

byte fuelDemandFaultCounterIncrement(void)

{
  byte bVar1;
  
  bVar1 = io_control_flags & 1;
  if (((io_control_flags & 1) == 0) &&
     (bVar1 = output_control_status_byte & 1, (output_control_status_byte & 1) == 0)) {
    return bVar1;
  }
  _general_increment_counter = _general_increment_counter + 1;
  fuel_demand_fault_counter = fuel_demand_fault_counter + 1;
  return bVar1;
}



/*
 * Function: rpmHistogramAndAveragingStatistics @ 0x00028638
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void rpmHistogramAndAveragingStatistics(void)

{
  ushort uVar1;
  
  if (current_engine_rpm_raw != 0) {
    if (rpm_histogram_max_rpm < current_engine_rpm_raw) {
      rpm_histogram_max_rpm = current_engine_rpm_raw;
    }
    if ((current_engine_rpm_raw < rpm_histogram_base_rpm) || (rpm_histogram_bin_size == 0)) {
      uVar1 = 0;
    }
    else {
      uVar1 = (short)((int)((uint)current_engine_rpm_raw - (uint)rpm_histogram_base_rpm) /
                     (int)(uint)rpm_histogram_bin_size) + 1;
      if (0x18 < uVar1) {
        uVar1 = 0x18;
      }
    }
    (&rpm_histogram_buffer_start)[(short)uVar1] = (&rpm_histogram_buffer_start)[(short)uVar1] + 1;
  }
  rpm_histogram_sample_divider = rpm_histogram_sample_divider + 1;
  if (rpm_histogram_sample_divider == 10) {
    rpm_histogram_sample_divider = 0;
    if (current_engine_rpm_raw != 0) {
      if (rpm_histogram_accumulator != 0xffffffff) {
        rpm_histogram_accumulator = rpm_histogram_accumulator + 1;
      }
      if (rpm_histogram_sample_counter_2 != 0xffffffff) {
        rpm_histogram_sample_counter_2 = rpm_histogram_sample_counter_2 + 1;
      }
      rpm_averaging_accumulator_1 =
           rpm_averaging_accumulator_1 -
           (short)((int)((uint)rpm_averaging_accumulator_1 - (uint)smoke_limiter_output_value) /
                  (int)rpm_histogram_accumulator);
      rpm_averaging_accumulator_2 =
           rpm_averaging_accumulator_2 -
           (short)((int)((uint)rpm_averaging_accumulator_2 - (uint)smoke_limiter_output_value) /
                  (int)rpm_histogram_sample_counter_2);
      rpm_histogram_filtered_value = rpm_averaging_accumulator_2;
      rpm_histogram_average_value = rpm_averaging_accumulator_1;
    }
  }
  if (vp44_engine_state == 0xb) {
    if (high_speed_idle_cooldown_timer != 0) {
      high_speed_idle_cooldown_timer = high_speed_idle_cooldown_timer - 1;
    }
    if (high_load_idle_cooldown_timer != 0) {
      high_load_idle_cooldown_timer = high_load_idle_cooldown_timer - 1;
    }
    if (high_temp_idle_cooldown_timer != 0) {
      high_temp_idle_cooldown_timer = high_temp_idle_cooldown_timer - 1;
    }
    _non_idle_time_counter = 0;
  }
  else {
    _non_idle_time_counter = _non_idle_time_counter + 1;
    if (rpm_histogram_temp_threshold < rpm_histogram_temp_value) {
      if (if_the_engine_load_exceeds_this_threshold_the_engine_is_deemed_0_127_5 <
          smoke_limiter_output_value) {
        high_load_idle_cooldown_timer =
             minimum_time_the_engine_must_idle_before_shutdown_if_high_loa_0_1800;
      }
      if (rpm_histogram_high_speed_threshold < current_engine_rpm_raw) {
        high_speed_idle_cooldown_timer =
             minimum_idle_time_if_the_engine_was_at_high_speed_to_avoid_ho_0_1800;
      }
      if (_rpm_histogram_non_idle_threshold_8a5c < _non_idle_time_counter) {
        high_temp_idle_cooldown_timer =
             minimum_time_the_engine_must_idle_before_shutdown_if_at_high_0_1800;
      }
    }
  }
  if (((engine_operating_mode == FAULT_EMERGENCY) && (_engine_mode_previous_state_1a7e != 8)) &&
     ((high_speed_idle_cooldown_timer != 0 || high_load_idle_cooldown_timer != 0 ||
      (high_temp_idle_cooldown_timer != 0)))) {
    _rpm_histogram_sum = _rpm_histogram_sum + 1;
    high_load_idle_cooldown_timer = 0;
    high_speed_idle_cooldown_timer = 0;
    high_temp_idle_cooldown_timer = 0;
  }
  _engine_mode_previous_state_1a7e = engine_operating_mode;
  if (vp44_engine_state == 0x12) {
    rpm_histogram_count = rpm_histogram_count + 1;
  }
  return;
}



/*
 * Function: fuelStatisticsTracker @ 0x0002880e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort fuelStatisticsTracker(void)

{
  uint uVar1;
  undefined4 uVar2;
  ushort uVar3;
  dword *pdVar4;
  
  if (fuel_statistics_secondary_accumulator == 1) {
    fuel_statistics_secondary_accumulator = 0;
    fuel_statistics_init_flag = 1;
    uVar3 = 0;
    pdVar4 = &rpm_histogram_buffer_start;
    do {
      *pdVar4 = 0;
      uVar3 = uVar3 + 1;
      pdVar4 = pdVar4 + 1;
    } while (uVar3 < 0x19);
    fuel_total_when_the_weighted_fuel_value_reaches_the_fu_0_0_1000000_0 = 0;
    fuel_statistics_accumulator_1 = 0;
    runtime_counter_update_arg_1 = 0;
    OCHRRSHS = 0;
    fuel_statistics_accumulator_2 = 0;
    clutch_operating_stats_value = 0;
    runtime_counter_update_arg_2 = 0;
    runtime_counter_update_alt_arg = 0;
    _crank_rpm_condition_flag = 0;
    runtime_counter_accumulator_1 = 0;
    runtime_counter_accumulator_2 = 0;
    fuel_demand_fault_counter = 0;
    fuel_statistics_counter = 0;
    fuel_timing_control_counter_1 = 0;
    rpm_histogram_average_value = 0;
    rpm_histogram_accumulator = 0;
    rpm_histogram_count = 0;
    _rpm_histogram_sum = 0;
    rpm_histogram_max_rpm = 0;
    clutch_operating_stats_output = 0;
  }
  uVar3 = diagnostic_system_flags_1 & 0x200;
  if (uVar3 != 0) {
    if (current_engine_rpm_raw == 0) {
      fuel_statistics_accumulator = 0;
    }
    else if ((vp44_engine_state == 0xb) && (throttle_position_value == 0)) {
      fuel_statistics_accumulator = 1;
    }
    else if (oil_pressure_protection_enabled == 1) {
      fuel_statistics_accumulator = 2;
    }
    else {
      fuel_statistics_accumulator = 3;
    }
    if (fuel_statistics_accumulator == 0) {
      fuel_statistics_command_value = 0;
      fuel_economy_statistics_value = 0;
      fuel_statistics_fault_counter = 0;
    }
    else {
      if (0xfffffffd < _crank_fuel_calculation_state) {
        _crank_rpm_condition_flag = _crank_rpm_condition_flag | 0x10;
      }
      _crank_fuel_calculation_state = _crank_fuel_calculation_state + 1;
      if (0xfffffffd < fuel_statistics_counter) {
        _crank_rpm_condition_flag = _crank_rpm_condition_flag | 0x400;
      }
      fuel_statistics_counter = fuel_statistics_counter + 1;
      if (_crank_fuel_calculation_state < -fuel_statistics_base_offset_3814 - 1) {
        vehicle_hours_statistics_value =
             fuel_statistics_base_offset_3814 + _crank_fuel_calculation_state;
      }
      else {
        vehicle_hours_statistics_value = 0xffffffff;
      }
      if (fuel_statistics_mode_selector == 0) {
        engine_runtime_statistics_accumulator =
             proportionalCalculation
                       (vp44_fuel_demand_accumulator - vp44_fuel_demand_previous,0x800000,
                        _fuel_statistics_divisor);
        vp44_fuel_demand_previous = vp44_fuel_demand_accumulator;
      }
      else {
        engine_runtime_statistics_accumulator =
             proportionalCalculation((uint)fuel_statistics_alt_value,0x5000000,0x39c2c30);
      }
      if (engine_runtime_statistics_accumulator == 0) {
        fuel_statistics_command_value = 0;
        fuel_economy_statistics_value = 0;
      }
      else {
        fuel_statistics_status_byte = fuel_statistics_previous_status;
        uVar1 = proportionalCalculation(engine_runtime_statistics_accumulator,0x232893,0x800000);
        if (uVar1 < 0x10000) {
          fuel_economy_statistics_value = (word)uVar1;
        }
        else {
          fuel_economy_statistics_value = 0xffff;
        }
        if (fuel_economy_sample_toggle == 0) {
          fuel_economy_sample_1 = fuel_economy_statistics_value;
          fuel_economy_sample_toggle = 1;
        }
        else {
          uVar1 = (((uint)fuel_economy_sample_1 + (uint)fuel_economy_statistics_value >> 1) +
                  (uint)fuel_economy_sample_2 + (uint)fuel_economy_sample_3) / 3;
          if (uVar1 < 0x10000) {
            fuel_statistics_command_value = (word)uVar1;
          }
          else {
            fuel_statistics_command_value = 0xffff;
          }
          fuel_economy_sample_3 = fuel_economy_sample_2;
          fuel_economy_sample_2 = fuel_statistics_command_value;
          fuel_economy_sample_toggle = 0;
        }
        uVar2 = engineStatisticsAccumulator((uint *)0x805f1c,&crank_timing_state_current);
        if ((short)uVar2 != 0) {
          _crank_rpm_condition_flag = _crank_rpm_condition_flag | 0x20;
        }
        uVar2 = engineStatisticsAccumulator
                          (&fuel_statistics_accumulator_1,&clutch_operating_stats_value);
        if ((short)uVar2 != 0) {
          _crank_rpm_condition_flag = _crank_rpm_condition_flag | 0x800;
        }
        insite_fuel_statistics_output = crank_timing_state_current;
        clutch_operating_stats_output = clutch_operating_stats_value;
        if (fuel_statistics_status_byte == 0) {
          fuel_statistics_fault_counter = 0;
        }
        else if (the_minimum_time_a_fault_must_be_present_before_logged_in_trip_in_0_30 <
                 fuel_statistics_fault_counter) {
          _crank_rpm_condition_flag = _crank_rpm_condition_flag | 0x41;
        }
        else {
          fuel_statistics_fault_counter = fuel_statistics_fault_counter + 1;
        }
      }
      if (fuel_statistics_accumulator == 3) {
        engineStatisticsAccumulator
                  (&fuel_total_when_the_weighted_fuel_value_reaches_the_fu_0_0_1000000_0,
                   &fuel_statistics_accumulator_2);
      }
      else if (fuel_statistics_accumulator == 1) {
        runTimeCountersUpdate();
      }
      else if (fuel_statistics_accumulator == 2) {
        runTimeCountersUpdateAlt();
      }
      fuelDemandFaultCounterIncrement();
      if (fuel_timing_control_value != 0) {
        fuel_timing_control_counter_1 = fuel_timing_control_counter_1 + 1;
        fuel_timing_control_counter_2 = fuel_timing_control_counter_2 + 1;
      }
    }
    uVar3 = rpmHistogramAndAveragingStatistics();
  }
  return uVar3;
}



/*
 * Function: protectionFlagAccumulator @ 0x00028b78
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort protectionFlagAccumulator(void)

{
  if ((diagnostic_system_flags_1 & 0x200) != 0) {
    if (protection_flag_source_1 != 0) {
      _crank_rpm_condition_flag = _crank_rpm_condition_flag | 0x82;
    }
    if (redundant_sensor_param_1 != 0) {
      _crank_rpm_condition_flag = _crank_rpm_condition_flag | 0x208;
    }
    if (protection_flag_source_2 != 0) {
      _crank_rpm_condition_flag = _crank_rpm_condition_flag | 0x104;
    }
  }
  return diagnostic_system_flags_1 & 0x200;
}



/*
 * Function: initDiagnosticSystemState @ 0x00028bda
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initDiagnosticSystemState(void)

{
  fuel_statistics_accumulator = 0;
  fuel_statistics_status_byte = 0;
  vp44_fuel_demand_previous = vp44_fuel_demand_accumulator;
  fuel_economy_sample_1 = 0;
  _non_idle_time_counter = 0;
  rpm_averaging_accumulator_2 = 0;
  rpm_averaging_accumulator_1 = 0;
  _engine_mode_previous_state_1a7e = 0;
  return;
}



/*
 * Function: initInternalRamAndCAN1 @ 0x0002939c
 */

void initInternalRamAndCAN1(void)

{
  dword *pdVar1;
  dword *pdVar2;
  dword *pdVar3;
  
  if ((can1_canmcr & 0x400) != 0x400) {
    qsm_qilr = 0xffe0;
    pdVar1 = &internal_ram_init_data_block_1;
    pdVar2 = (dword *)&EBI_EBIMCR;
    do {
      pdVar3 = pdVar2 + 1;
      *pdVar2 = *pdVar1;
      pdVar1 = pdVar1 + 1;
      pdVar2 = pdVar3;
    } while (pdVar3 < (dword *)0xffe68c);
    do {
      pdVar1 = pdVar3 + 1;
      *pdVar3 = 0;
      pdVar3 = pdVar1;
    } while (pdVar1 < (dword *)0xffe6ff);
    pdVar2 = &internal_ram_init_data_block_2;
    do {
      pdVar3 = pdVar1 + 1;
      *pdVar1 = *pdVar2;
      pdVar2 = pdVar2 + 1;
      pdVar1 = pdVar3;
    } while (pdVar3 < (dword *)0xffe7ff);
    can1_canmcr = 0x407;
    can1_cantbsel = 0;
    can1_cantaak = 0x440;
  }
  return;
}



/*
 * Function: diagnosticSessionValidator @ 0x00029422
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint diagnosticSessionValidator(undefined4 param_1)

{
  uint in_D0;
  byte bVar1;
  word *pwVar2;
  
  pwVar2 = &diagnostic_session_validator_param;
  bVar1 = 0;
  while (((param_1._0_2_ != *pwVar2 || ((char)param_1 != *(char *)((int)pwVar2 + 3))) &&
         ((param_1._0_2_ != 1 || ((*pwVar2 != 1 || (*(char *)((int)pwVar2 + 3) != -1))))))) {
    in_D0 = 0;
    pwVar2 = pwVar2 + 10;
    bVar1 = bVar1 + 1;
    if (4 < bVar1) {
      return 1;
    }
  }
  _fuel_arbitrator_control_mode = pwVar2;
  return in_D0 & 0xffff0000;
}



/*
 * Function: diagnosticCanResponseSender @ 0x00029476
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticCanResponseSender(int param_1,undefined4 param_2)

{
  diagnostic_can_response_header = CONCAT13((char)((_can_priority_table_start & 7) << 2),0xe8ff00);
  diagnostic_can_response_header._2_2_ =
       CONCAT11(*(undefined1 *)(param_1 + 3),*(undefined1 *)(param_1 + 2));
  can_buffer_setup1_data = (byte)((uint)param_2 >> 0x10);
  diag_can_response_data_0 = **(byte **)(param_1 + 6);
  diag_can_response_data_1 = *(byte *)(*(int *)(param_1 + 6) + 1);
  diag_can_response_data_2 = *(byte *)(*(int *)(param_1 + 6) + 2);
  sendCanMessage((j1939_header_t *)&diagnostic_can_response_header);
  return;
}



/*
 * Function: canBufferSetup1 @ 0x000294ea
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void canBufferSetup1(void)

{
  _can_buffer_setup1_size = 8;
  can_buffer_setup1_data_ptr = (dword)&can_buffer_setup1_data;
  can_buffer_setup1_unused_ptr = 0x801a9c;
  can_buffer_1_reserved_0 = 0xff;
  can_buffer_1_reserved_1 = 0xff;
  can_buffer_1_reserved_2 = 0xff;
  can_buffer_1_reserved_3 = 0xff;
  return;
}



/*
 * Function: ambientConditionsDataBuilder @ 0x00029522
 */

void ambientConditionsDataBuilder(void)

{
  ambient_conditions_data_start =
       (byte)((((uint)insite_diagnostic_reading * 2 >> 7) * 0x1afa) / 1000);
  sendCanMessage((j1939_header_t *)&ambient_conditions_msg_header);
  return;
}



/*
 * Function: ambientConditionsPGN_65269_Builder @ 0x0002956a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void ambientConditionsPGN_65269_Builder(void)

{
  ambient_conditions_msg_header = CONCAT13((char)((_j1939_priority_pgn65269 & 7) << 2),0xfef500);
  ambient_conditions_msg_length = 8;
  ambient_conditions_data_ptr = (dword)&ambient_conditions_data_start;
  ambient_conditions_unused_ptr = (dword)&ambient_conditions_buffer_end;
  ambient_conditions_msg_header =
       CONCAT31(ambient_conditions_msg_header._0_3_,j1939_source_address_primary);
  ambient_barometric_pressure = 0xff;
  ambient_cab_interior_temp = 0xff;
  ambient_air_temp = 0xff;
  engine_air_inlet_temp = 0xff;
  road_surface_temp = 0xff;
  ambient_conditions_reserved = 0xffff;
  return;
}



/*
 * Function: ambientConditionsDataBuilder @ 0x000295d4
 */

void ambientConditionsDataBuilder(void)

{
  uint uVar1;
  undefined2 local_6;
  
  if ((vp44_communication_status & 0x20) == 0) {
    j1939_pgn_65265_data_byte1 = 0xf3;
  }
  else {
    j1939_pgn_65265_data_byte1 = 0xf7;
  }
  if ((-(8 < throttle_position_value) & 1U) < 0x9d) {
    local_6 = throttle_position_value;
  }
  else {
    local_6 = 0x9c00;
  }
  uVar1 = (uint)local_6;
  local_6._1_1_ = (byte)(uVar1 * 0x19c >> 8);
  ambient_temp_calc_low = (byte)local_6;
  local_6._0_1_ = (byte)(uVar1 * 0x19c >> 0x10);
  ambient_temp_calc_high = local_6._0_1_;
  if ((derate_status_byte & 4) == 0) {
    ambient_sensor_status1 = 0;
  }
  else {
    ambient_sensor_status1 = 4;
  }
  if ((derate_status_byte & 8) != 0) {
    ambient_sensor_status1 = ambient_sensor_status1 | 0x10;
  }
  if ((sensor_status_register & 0x10) != 0) {
    ambient_sensor_status1 = ambient_sensor_status1 | 4;
  }
  if (protection_system_enable_flag == 1) {
    ambient_sensor_status1 = ambient_sensor_status1 | 1;
  }
  if ((sensor_status_register & 2) == 0) {
    ambient_sensor_status2 = 0;
  }
  else {
    ambient_sensor_status2 = 0x40;
  }
  if ((sensor_status_register & 1) != 0) {
    ambient_sensor_status2 = ambient_sensor_status2 | 0x10;
  }
  if ((sensor_status_register & 8) != 0) {
    ambient_sensor_status2 = ambient_sensor_status2 | 4;
  }
  if ((sensor_status_register & 4) != 0) {
    ambient_sensor_status2 = ambient_sensor_status2 | 1;
  }
  ambient_temp_processed = (byte)((uint)target_boost_pressure_base * 0x19c >> 0x10);
  if (protection_system_enable_flag == 1) {
    ambient_status_final = 0x3f;
  }
  else {
    ambient_status_final = 0x1f;
  }
  sendCanMessage((j1939_header_t *)&j1939_pgn_65265_header);
  return;
}



/*
 * Function: j1939MessageSetup_PGN_65265 @ 0x00029796
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void j1939MessageSetup_PGN_65265(void)

{
  j1939_pgn_65265_header = CONCAT13((char)((_j1939_priority_pgn65265 & 7) << 2),0xfef100);
  j1939_pgn_65265_header = CONCAT31(j1939_pgn_65265_header._0_3_,j1939_source_address_primary);
  _j1939_pgn_65265_size = 7;
  j1939_pgn_65265_data_ptr = (dword)&j1939_pgn_65265_data_byte1;
  j1939_pgn_65265_unused_ptr = 0x801acc;
  j1939_pgn_65265_data_byte1 = 0xf3;
  j1939_pgn65265_reserved_byte = 0xff;
  canTransmissionController();
  return;
}



/*
 * Function: engineSerialNumberDataBuilder @ 0x000297fc
 */

void engineSerialNumberDataBuilder(void)

{
  byte bVar1;
  byte *pbVar2;
  byte *pbVar3;
  
  bVar1 = 0;
  pbVar2 = &engine_serial_number_buffer;
  pbVar3 = &insite_version_string_part_1;
  do {
    *pbVar2 = *pbVar3;
    bVar1 = bVar1 + 1;
    pbVar2 = pbVar2 + 1;
    pbVar3 = pbVar3 + 1;
  } while (bVar1 < 5);
  engine_serial_separator_1 = 0x2a;
  bVar1 = 0;
  pbVar2 = &engine_serial_part2_start;
  pbVar3 = &insite_version_string_part_2;
  do {
    *pbVar2 = *pbVar3;
    bVar1 = bVar1 + 1;
    pbVar2 = pbVar2 + 1;
    pbVar3 = pbVar3 + 1;
  } while (bVar1 < 0x11);
  engine_serial_separator_2 = 0x2a;
  bVar1 = 0;
  pbVar2 = &engine_serial_part3_start;
  pbVar3 = &insite_version_string_part_3;
  do {
    *pbVar2 = *pbVar3;
    bVar1 = bVar1 + 1;
    pbVar2 = pbVar2 + 1;
    pbVar3 = pbVar3 + 1;
  } while (bVar1 < 4);
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65259);
  return;
}



/*
 * Function: engineSerialNumberPGN_65259_Builder @ 0x00029868
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineSerialNumberPGN_65259_Builder(void)

{
  j1939_message_buffer_pgn65259 = CONCAT13((char)((_j1939_priority_pgn65259 & 7) << 2),0xfeeb00);
  j1939_pgn65259_msg_size = 0x1c;
  j1939_pgn65259_data_ptr = (dword)&engine_serial_number_buffer;
  j1939_pgn65259_unused_ptr = 0x801af8;
  j1939_message_buffer_pgn65259 =
       CONCAT31(j1939_message_buffer_pgn65259._0_3_,j1939_source_address_primary);
  canTransmissionController();
  return;
}



/*
 * Function: diagnosticMultiPacketResponseBuilder @ 0x000298d8
 */

byte * diagnosticMultiPacketResponseBuilder(byte *param_1,undefined4 param_2)

{
  undefined4 in_D0;
  undefined2 uVar1;
  byte bVar2;
  j1939_header_t *msg_header;
  undefined4 unaff_D2;
  char cVar3;
  byte bVar4;
  short sVar5;
  undefined1 *puVar6;
  undefined1 *puVar7;
  
  uVar1 = (undefined2)CONCAT31((int3)((uint)in_D0 >> 8),**(undefined1 **)(param_1 + 6));
  bVar2 = messageTypeToChannelMapper(CONCAT22(uVar1,(short)((uint)unaff_D2 >> 0x10)));
  cVar3 = (char)((uint)param_2 >> 0x10);
  if (cVar3 == '\0') {
    sVar5 = bVar2 + 1;
  }
  else {
    sVar5 = bVar2 + 2;
  }
  msg_header = (j1939_header_t *)multiPacketBufferAllocator(CONCAT22(sVar5,uVar1));
  if (msg_header != (j1939_header_t *)0x0) {
    msg_header->id = 0xef0000;
    bVar4 = *param_1;
    *(byte *)&msg_header->id = *(byte *)&msg_header->id & 0xe3;
    *(byte *)&msg_header->id = bVar4 & 0x1c | *(byte *)&msg_header->id;
    *(byte *)((int)&msg_header->id + 2) = param_1[3];
    *(byte *)((int)&msg_header->id + 3) = param_1[2];
    puVar7 = (undefined1 *)msg_header[1].id;
    if (cVar3 == '\0') {
      puVar6 = puVar7 + 1;
      *puVar7 = 0xc;
    }
    else {
      *puVar7 = 0xd;
      puVar6 = puVar7 + 2;
      puVar7[1] = (&diag_multi_packet_status_code_table)[(short)(param_2._0_2_ & 0xff)];
    }
    puVar7 = *(undefined1 **)(param_1 + 6);
    for (bVar4 = 0; bVar4 < bVar2; bVar4 = bVar4 + 1) {
      *puVar6 = *puVar7;
      puVar6 = puVar6 + 1;
      puVar7 = puVar7 + 1;
    }
    msg_header = (j1939_header_t *)sendCanMessage(msg_header);
  }
  return (byte *)msg_header;
}



/*
 * Function: activeDtcListBuilder @ 0x00029976
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

byte activeDtcListBuilder(void)

{
  byte bVar1;
  uint uVar2;
  byte bVar3;
  byte bVar4;
  uint *puVar5;
  
  active_dtc_list_header_ptr = (dword)&j1939_transport_protocol_header;
  bVar3 = j1939_transport_protocol_header & 0xf0;
  if (bVar3 == 0) {
    diagnostic_pending_response_offset = 2;
    if (diagnostic_pending_code_count == 0) {
      j1939_transport_sequence_counter._0_1_ = 0;
      _active_dtc_list_data_buffer = 0xffffffff;
      diagnostic_pending_response_offset = 6;
    }
    else {
      uVar2 = ioControlBitMapper();
      j1939_transport_sequence_counter._0_1_ = (undefined1)uVar2;
      puVar5 = (uint *)&active_dtc_list_data_buffer;
      for (bVar3 = 1; bVar3 <= diagnostic_pending_code_count; bVar3 = bVar3 + 1) {
        bVar1 = (&diagnostic_pending_code_count)[(short)(ushort)bVar3];
        if ((*(ushort *)(&dtc_fault_table_base + (short)((ushort)bVar1 * 3) * 2) & 0x4000) == 0) {
          if ((&diagnostic_pid_dtc_index)[(short)((ushort)bVar1 * 10)] < 0x80) {
            bVar4 = (&diagnostic_pid_dtc_index)[(short)((ushort)bVar1 * 10)];
          }
          else {
            bVar4 = 0x7f;
          }
          uVar2 = *(uint *)((short)(ushort)bVar1 * 4 + 0x8084ce) & 0xffffe000;
          *puVar5 = CONCAT22((short)(uVar2 >> 0x10),
                             (ushort)bVar4 |
                             (*(byte *)((short)(ushort)bVar1 * 4 + 0x8084d0) & 0x1f) * 2 |
                             (ushort)uVar2) | 0x80;
          diagnostic_pending_response_offset = diagnostic_pending_response_offset + 4;
        }
        puVar5 = puVar5 + 1;
      }
    }
    bVar3 = sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65226);
  }
  return bVar3;
}



/*
 * Function: engineCoolantPGN_65226_Builder @ 0x00029a86
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineCoolantPGN_65226_Builder(void)

{
  j1939_message_buffer_pgn65226 = CONCAT13((char)((_j1939_priority_pgn65226 & 7) << 2),0xfeca00);
  j1939_pgn65226_data_ptr = (dword)&j1939_transport_sequence_counter;
  active_dtc_list_header_ptr = (dword)&j1939_transport_protocol_header;
  j1939_message_buffer_pgn65226 =
       CONCAT31(j1939_message_buffer_pgn65226._0_3_,j1939_source_address_primary);
  j1939_transport_sequence_counter._1_1_ = 0xff;
  engine_coolant_pgn65226_status = engine_coolant_pgn65226_status & 0x7f;
  canTransmissionController();
  return;
}



/*
 * Function: previousDtcListBuilder @ 0x00029ae4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

byte previousDtcListBuilder(void)

{
  byte bVar1;
  uint uVar2;
  byte bVar3;
  byte bVar4;
  uint *puVar5;
  
  bVar3 = dm2_pgn65227_unused_byte & 0xf0;
  if (bVar3 == 0) {
    throttle_fault_handler_state = 2;
    uVar2 = ioControlBitMapper();
    dm2_pgn65227_data_byte = (byte)uVar2;
    if (diagnostic_active_code_count == 0) {
      _dm2_pgn65227_data_buffer = 0xffffffff;
      throttle_fault_handler_state = throttle_fault_handler_state + 4;
    }
    else {
      puVar5 = (uint *)&dm2_pgn65227_data_buffer;
      for (bVar3 = 1; bVar3 <= diagnostic_active_code_count; bVar3 = bVar3 + 1) {
        if ((*(ushort *)
              (&dtc_fault_table_base +
              (short)((ushort)(&diagnostic_active_code_count)[(short)(ushort)bVar3] * 3) * 2) &
            0x4000) == 0) {
          bVar1 = (&diagnostic_active_code_count)[(short)(ushort)bVar3];
          if ((&diagnostic_pid_dtc_index)[(short)((ushort)bVar1 * 10)] < 0x80) {
            bVar4 = (&diagnostic_pid_dtc_index)[(short)((ushort)bVar1 * 10)];
          }
          else {
            bVar4 = 0x7f;
          }
          uVar2 = *(uint *)((short)(ushort)bVar1 * 4 + 0x8084ce) & 0xffffe000;
          *puVar5 = CONCAT22((short)(uVar2 >> 0x10),
                             (ushort)bVar4 |
                             (*(byte *)((short)(ushort)bVar1 * 4 + 0x8084d0) & 0x1f) * 2 |
                             (ushort)uVar2) | 0x80;
          throttle_fault_handler_state = throttle_fault_handler_state + 4;
        }
        puVar5 = puVar5 + 1;
      }
    }
    bVar3 = sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65227);
  }
  return bVar3;
}



/*
 * Function: diagnosticDM2PGN_65227_Builder @ 0x00029bf4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticDM2PGN_65227_Builder(void)

{
  j1939_message_buffer_pgn65227 = CONCAT13((char)((_j1939_priority_pgn65227 & 7) << 2),0xfecb00);
  dm2_pgn65227_data_ptr = (dword)&dm2_pgn65227_data_byte;
  dm2_pgn65227_unused_ptr = (dword)&dm2_pgn65227_unused_byte;
  j1939_message_buffer_pgn65227 =
       CONCAT31(j1939_message_buffer_pgn65227._0_3_,j1939_source_address_primary);
  dm2_pgn65227_reserved = 0xff;
  dm2_pgn65227_control_byte = dm2_pgn65227_control_byte & 0x7f;
  canTransmissionController();
  return;
}



/*
 * Function: buildCanMessage @ 0x00029c52
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

byte buildCanMessage(void)

{
  undefined4 uVar1;
  int iVar2;
  short sVar3;
  undefined2 uVar4;
  byte bVar5;
  ushort uVar6;
  byte bVar7;
  int iVar8;
  short sVar9;
  uint uVar10;
  dword *pdVar11;
  undefined2 local_6;
  
  bVar5 = dm4_pgn65229_status_byte & 0xf0;
  if (bVar5 == 0) {
    diagnostic_dtc_response_length = 0;
    if ((diagnostic_pending_code_count == 0) && (diagnostic_active_code_count == 0)) {
      j1939_multiframe_data_buffer._0_1_ = 0;
      j1939_multiframe_data_buffer._1_1_ = 0;
      j1939_multiframe_data_buffer._2_1_ = 0;
      j1939_multiframe_data_buffer._3_1_ = 0;
      dtc_response_spn_high_byte = 0;
      dtc_response_spn_mid_byte = 0xff;
      dtc_response_spn_low_byte = 0xff;
      dtc_response_fmi_byte = 0xff;
      diagnostic_dtc_response_length = 8;
    }
    else {
      bVar5 = 0;
      pdVar11 = &j1939_multiframe_data_buffer;
      iVar8 = 0;
      do {
        sVar9 = (short)iVar8;
        if (*(short *)((int)&dtc_timestamp_array + (int)sVar9) != 0x7d) {
          iVar2 = (uint)(*(short *)((int)&diagnostic_fault_status_array + (int)sVar9) != 0x7d) *
                  0x3c0;
          sVar3 = (short)iVar2;
          uVar6 = (ushort)((uint)(((int)(uint)*(ushort *)((short)(sVar9 + sVar3) + 0x805682) >> 7) *
                                 0x1afa) / 1000);
          if (500 < uVar6) {
            uVar6 = 500;
          }
          *(char *)((int)pdVar11 + 6) = (char)((int)(uint)uVar6 >> 1);
          uVar4 = byteSwap16((undefined2 *)(iVar8 + iVar2 + 0x80567a));
          *(char *)(pdVar11 + 2) = (char)uVar4;
          *(char *)((int)pdVar11 + 7) = (char)((ushort)uVar4 >> 8);
          *(char *)((int)pdVar11 + 9) =
               (char)((ushort)*(undefined2 *)((short)(sVar9 + sVar3) + 0x80567e) >> 8);
          *(char *)((int)pdVar11 + 10) =
               (char)(((short)((int)(uint)*(ushort *)((short)(sVar9 + sVar3) + 0x805684) >> 7) * 5 +
                      -0xa0) / 9) + '(';
          if (_dtc_timestamp_format_flag == 1) {
            local_6 = (undefined2)
                      ((uint)*(ushort *)((int)&dtc_timestamp_array + (short)(sVar9 + sVar3) + 2) *
                       0x19c >> 8);
            uVar4 = byteSwap16(&local_6);
            *(char *)(pdVar11 + 3) = (char)uVar4;
            *(char *)((int)pdVar11 + 0xb) = (char)((ushort)uVar4 >> 8);
          }
          else {
            *(undefined1 *)((int)pdVar11 + 0xb) = 0xff;
            *(undefined1 *)(pdVar11 + 3) = 0xff;
          }
          *(char *)((int)pdVar11 + 0xd) =
               (char)*(undefined2 *)((int)&dtc_timestamp_array + (int)(short)(sVar9 + sVar3));
          *(char *)((int)pdVar11 + 0xe) =
               (char)((ushort)*(undefined2 *)
                               ((int)&dtc_timestamp_array + (int)(short)(sVar9 + sVar3)) >> 8);
          *(undefined1 *)((int)pdVar11 + 0xf) = 0;
          *(byte *)(pdVar11 + 4) = dtc_conversion_mode_flag;
          bVar7 = 0;
          do {
            uVar10 = (uint)bVar7;
            iVar2 = uVar10 * 0x1c;
            uVar1 = *(undefined4 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x805672);
            *(char *)(pdVar11 + uVar10 * 7 + 5) = (char)uVar1;
            *(char *)((int)pdVar11 + iVar2 + 0x13) = (char)((uint)uVar1 >> 8);
            *(char *)((int)pdVar11 + iVar2 + 0x12) = (char)((uint)uVar1 >> 0x10);
            *(char *)((int)pdVar11 + iVar2 + 0x11) = (char)((uint)uVar1 >> 0x18);
            uVar4 = *(undefined2 *)
                     ((int)&dtc_timestamp_array + (int)(short)(sVar9 + (ushort)bVar7 * 0x3c0));
            *(char *)((int)pdVar11 + iVar2 + 0x16) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x15) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)
                     ((int)&dtc_timestamp_array + (short)(sVar9 + (ushort)bVar7 * 0x3c0) + 2);
            *(char *)(pdVar11 + uVar10 * 7 + 6) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x17) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x80567a);
            *(char *)((int)pdVar11 + iVar2 + 0x1a) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x19) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x80567c);
            *(char *)(pdVar11 + uVar10 * 7 + 7) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x1b) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x80567e);
            *(char *)((int)pdVar11 + iVar2 + 0x1e) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x1d) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x805680);
            *(char *)(pdVar11 + uVar10 * 7 + 8) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x1f) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x805682);
            *(char *)((int)pdVar11 + iVar2 + 0x22) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x21) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x805684);
            *(char *)(pdVar11 + uVar10 * 7 + 9) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x23) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x805686);
            *(char *)((int)pdVar11 + iVar2 + 0x26) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x25) = (char)((ushort)uVar4 >> 8);
            *(undefined1 *)((int)pdVar11 + iVar2 + 0x27) = 0;
            *(undefined1 *)(pdVar11 + uVar10 * 7 + 10) = 0;
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x805688);
            *(char *)((int)pdVar11 + iVar2 + 0x2a) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x29) = (char)((ushort)uVar4 >> 8);
            uVar4 = *(undefined2 *)((short)(sVar9 + (ushort)bVar7 * 0x3c0) + 0x80568a);
            *(char *)(pdVar11 + uVar10 * 7 + 0xb) = (char)uVar4;
            *(char *)((int)pdVar11 + iVar2 + 0x2b) = (char)((ushort)uVar4 >> 8);
            bVar7 = bVar7 + 1;
          } while (bVar7 < 2);
        }
        diagnostic_dtc_response_length = diagnostic_dtc_response_length + 0x49;
        iVar8 = iVar8 + 0x30;
        pdVar11 = (dword *)((int)pdVar11 + 0x49);
        bVar5 = bVar5 + 1;
      } while (bVar5 < 0x14);
    }
    bVar5 = sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65229);
  }
  return bVar5;
}



/*
 * Function: diagnosticDM4PGN_65229_Builder @ 0x0002a090
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticDM4PGN_65229_Builder(void)

{
  byte bVar1;
  dword *pdVar2;
  
  j1939_message_buffer_pgn65229 = CONCAT13((char)((_j1939_priority_pgn65229 & 7) << 2),0xfecd00);
  dm4_pgn65229_data_ptr = (dword)&j1939_multiframe_data_buffer;
  dm4_pgn65229_unused_ptr = (dword)&dm4_pgn65229_status_byte;
  j1939_message_buffer_pgn65229 =
       CONCAT31(j1939_message_buffer_pgn65229._0_3_,j1939_source_address_primary);
  bVar1 = 0;
  pdVar2 = &j1939_multiframe_data_buffer;
  do {
    *(undefined1 *)pdVar2 = 0x49;
    *(undefined1 *)((int)pdVar2 + 5) = 0xff;
    pdVar2 = (dword *)((int)pdVar2 + 0x49);
    bVar1 = bVar1 + 1;
  } while (bVar1 < 0x14);
  canTransmissionController();
  return;
}



/*
 * Function: diagnosticDM5DataBuilder @ 0x0002a100
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticDM5DataBuilder(void)

{
  ushort local_6;
  
  local_6 = 0;
  dm5_pgn65230_pending_code_count = diagnostic_pending_code_count;
  dm5_active_code_count = diagnostic_active_code_count;
  dm5_obd_compliance = dm5_active_code_count_byte;
  dm5_obd_compliance_2 = dm5_pending_code_count_byte;
  dm5_status_flags_swapped = byteSwap16(&diagnostic_status_flags_word);
  if (_diagnostic_mode_state == 1) {
    local_6 = local_6 & 0xfeff;
  }
  else if ((diagnostic_status_flags_word & 0x100) == 0) {
    local_6 = local_6 | 0x100;
  }
  else if ((_diagnostic_mode_state == 0) && ((diagnostic_status_flags_word & 0x100) != 0)) {
    local_6 = local_6 | 0x100;
  }
  dm5_status_flags_2_swapped = byteSwap16(&local_6);
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65230);
  return;
}



/*
 * Function: diagnosticDM5PGN_65230_Builder @ 0x0002a1a0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticDM5PGN_65230_Builder(void)

{
  j1939_message_buffer_pgn65230 = CONCAT13((char)((_j1939_priority_pgn65230 & 7) << 2),0xfece00);
  dm5_pgn65230_msg_size = 8;
  dm5_pgn65230_data_ptr = (dword)&dm5_pgn65230_pending_code_count;
  dm5_pgn65230_unused_ptr = 0x803004;
  j1939_message_buffer_pgn65230 =
       CONCAT31(j1939_message_buffer_pgn65230._0_3_,j1939_source_address_primary);
  canTransmissionController();
  return;
}



/*
 * Function: diagnosticByteResponseSender @ 0x0002a1f6
 */

void diagnosticByteResponseSender(undefined4 param_1)

{
  dm8_pgn65232_data_byte = param_1._1_1_;
  diagnostic_byte_response_word = byteSwap16((undefined2 *)((int)&param_1 + 2));
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65232);
  return;
}



/*
 * Function: diagnosticDM8PGN_65232_Builder @ 0x0002a222
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticDM8PGN_65232_Builder(void)

{
  j1939_message_buffer_pgn65232 = CONCAT13((char)((_j1939_priority_pgn65232 & 7) << 2),0xfed000);
  dm8_pgn65232_msg_size = 8;
  dm8_pgn65232_data_ptr = (dword)&dm8_pgn65232_data_byte;
  dm8_pgn65232_unused_ptr = 0x80301c;
  j1939_message_buffer_pgn65232 =
       CONCAT31(j1939_message_buffer_pgn65232._0_3_,j1939_source_address_primary);
  dm8_reserved_byte = 0xff;
  dm8_reserved_word_1 = 0xffff;
  dm8_reserved_word_2 = 0xffff;
  return;
}



/*
 * Function: diagnosticDM11PGN_65234_Builder @ 0x0002a29c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticDM11PGN_65234_Builder(void)

{
  j1939_message_buffer_pgn65234 = CONCAT13((char)((_j1939_priority_pgn65234 & 7) << 2),0xfed200);
  _dm11_pgn65234_data_ptr = 2;
  dm11_pgn65234_unused_ptr = (dword)&dm11_pgn65234_unused_buffer;
  dm11_pgn65234_data_buffer_ptr = 0x803034;
  j1939_message_buffer_pgn65234 =
       CONCAT31(j1939_message_buffer_pgn65234._0_3_,j1939_source_address_primary);
  canTransmissionController();
  return;
}



/*
 * Function: buildPgn61444_ProprietarySpeed @ 0x0002a2f2
 */

void buildPgn61444_ProprietarySpeed(void)

{
  byte local_6;
  byte bStack_5;
  
  if (fuel_arbitrator_diag_t_0080cff8.rpm_target == 0) {
    switch(vp44_engine_state) {
    case 3:
    case 7:
    case 8:
      j1939_tx_msg_buffer = 0xf1;
      break;
    case 4:
      j1939_tx_msg_buffer = 0xf3;
      break;
    default:
      j1939_tx_msg_buffer = 0xfe;
      break;
    case 9:
      j1939_tx_msg_buffer = 0xf2;
      break;
    case 10:
      j1939_tx_msg_buffer = 0xf4;
      break;
    case 0xb:
      j1939_tx_msg_buffer = 0xf0;
      break;
    case 0xc:
      j1939_tx_msg_buffer = 0xf9;
      break;
    case 0xd:
    case 0xe:
    case 0xf:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
      j1939_tx_msg_buffer = 0xf8;
      break;
    case VP44_ACTIVE_MODE:
      j1939_tx_msg_buffer = 0xfa;
    }
  }
  else if (fuel_arbitrator_diag_t_0080cff8.fuel_mode == 1) {
    j1939_tx_msg_buffer = 0xf6;
  }
  else if (fuel_arbitrator_diag_t_0080cff8.fuel_mode == 3) {
    j1939_tx_msg_buffer = 0xf5;
  }
  else if (fuel_arbitrator_diag_t_0080cff8.fuel_mode == 2) {
    j1939_tx_msg_buffer = 0xf7;
  }
  else {
    j1939_tx_msg_buffer = 0xfe;
  }
  paramSystemModeController();
                    /* Constant: VP44_FUEL_OFFSET = 125 */
  j1939_vp44_fuel_high = (char)(param_table_aux >> 8) + 0x7d;
  param_lookup_1();
  j1939_vp44_fuel_low = (char)(param_table_main >> 8) + 0x7d;
  bStack_5 = (byte)current_engine_rpm;
  j1939_vp44_rpm_low = bStack_5;
  local_6 = (byte)(current_engine_rpm >> 8);
  j1939_vp44_rpm_high = local_6;
  sendCanMessage((j1939_header_t *)&vp44_cmd_msg_buffer);
  return;
}



/*
 * Function: vp44Command0x100Builder @ 0x0002a418
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44Command0x100Builder(void)

{
                    /* Constant: VP44_MSG_HEADER = 0xF00400 */
  _vp44_cmd_msg_buffer = CONCAT13((char)((_j1939_priority_vp44_cmd_256 & 7) << 2),0xf00400);
  _vp44_cmd_msg_buffer = CONCAT31(_vp44_cmd_msg_buffer,j1939_source_address_primary);
  _vp44_timing_byte4 = 5;
  _vp44_timing_byte6 = &j1939_tx_msg_buffer;
  vp44_cmd_0x100_data_ptr = 0x80304c;
  return;
}



/*
 * Function: buildProprietaryLoadStatusMessage @ 0x0002a45c
 */

void buildProprietaryLoadStatusMessage(void)

{
  bool bVar1;
  
  if (((engine_fault_register_a & 0x20) == 0) || ((engine_fault_register_b & 0x20) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    if (((engine_fault_register_a & 8) == 0) || ((engine_fault_register_b & 8) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (proprietary_load_threshold < active_derate_value) {
        diagnostic_status_buffer = 0xf4;
      }
      else {
        diagnostic_status_buffer = 0xf0;
      }
      diagnostic_load_data_byte =
           (char)((int)(uint)active_derate_value >> 1) + (char)((int)(uint)active_derate_value >> 3)
      ;
      goto LAB_0002a4ea;
    }
  }
  diagnostic_status_buffer = 0xf8;
  diagnostic_load_data_byte = 0xfe;
LAB_0002a4ea:
  if (derate_threshold_exceeded == 0) {
    diagnostic_status_buffer = diagnostic_status_buffer | 1;
  }
  param_lookup_2();
  diagnostic_param_ctrl_byte = (byte)(param_table_ctrl >> 8);
  sendCanMessage((j1939_header_t *)&can_param_msg_buf_2);
  return;
}



/*
 * Function: cumminsProprietaryDM_983_Builder @ 0x0002a51e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void cumminsProprietaryDM_983_Builder(void)

{
  _can_param_msg_buf_2 = CONCAT13((char)((_can_priority_dm983 & 7) << 2),0xf00300);
  _can_param_msg_buf_2 = CONCAT31(_can_param_msg_buf_2,j1939_source_address_primary);
  _dm983_proprietary_msg_size = 3;
  dm983_diagnostic_status_ptr = (dword)&diagnostic_status_buffer;
  dm983_diagnostic_unused_ptr = (dword)&diagnostic_unused_buffer;
  diagnosticDataBufferSetup();
  canTransmissionController();
  return;
}



/*
 * Function: configParamCanBuilder @ 0x0002a57e
 */

void configParamCanBuilder(void)

{
  byte local_6;
  byte bStack_5;
  
  param_lookup_3();
  can_param_msg_buf_1 = (char)(param_table_ext >> 8) + 0x7d;
  bStack_5 = (byte)param_limit_value;
  config_param_can_byte_0 = bStack_5;
  local_6 = (byte)(param_limit_value >> 8);
  config_param_can_byte_1 = local_6;
  config_param_can_byte_2 = param_config_byte;
  sendCanMessage((j1939_header_t *)&can_param_msg_buf_3);
  return;
}



/*
 * Function: secondaryParamPGN_65247_Builder @ 0x0002a5da
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void secondaryParamPGN_65247_Builder(void)

{
  _can_param_msg_buf_3 = CONCAT13((char)((_j1939_priority_pgn65247 & 7) << 2),0xfedf00);
  _can_param_msg_buf_3 = CONCAT31(_can_param_msg_buf_3,j1939_source_address_primary);
  _secondary_param_pgn65247_size = 4;
  secondary_param_pgn65247_data_ptr = (dword)&can_param_msg_buf_1;
  secondary_param_pgn65247_unused_ptr = 0x80307c;
  return;
}



/*
 * Function: fuelParameterCanMessageBuilder @ 0x0002a61e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

byte fuelParameterCanMessageBuilder(void)

{
  byte bVar1;
  ushort uVar2;
  word *pwVar3;
  undefined2 local_6;
  
  bVar1 = extended_diag_pgn65251_status & 0xf0;
  if (bVar1 == 0) {
    fuelModeSelectionCalculator();
    local_6._1_1_ = (byte)governor_rpm_error_value;
    extended_diag_pgn65251_data_start = (byte)local_6;
    local_6._0_1_ = (byte)(governor_rpm_error_value >> 8);
    fuel_param_gov_rpm_error_high = local_6._0_1_;
    fuel_param_calc_param_offset = (char)(param_table_calc >> 8) + 0x7d;
    local_6._1_1_ = (byte)fuel_offset_blend_value;
    fuel_param_offset_blend_low = (byte)local_6;
    local_6._0_1_ = (byte)(fuel_offset_blend_value >> 8);
    fuel_param_offset_blend_high = local_6._0_1_;
    fuel_param_calculated_2_offset = (char)(calculated_2 >> 8) + 0x7d;
    local_6._1_1_ = (byte)fuel_table_blend_param_1;
    fuel_param_table_blend_1_low = (byte)local_6;
    local_6._0_1_ = (byte)(fuel_table_blend_param_1 >> 8);
    fuel_param_table_blend_1_high = local_6._0_1_;
    fuel_param_calculated_3_offset = (char)(calculated_3 >> 8) + 0x7d;
    local_6._1_1_ = (byte)fuel_table_blend_param_2;
    fuel_param_table_blend_2_low = (byte)local_6;
    local_6._0_1_ = (byte)(fuel_table_blend_param_2 >> 8);
    fuel_param_table_blend_2_high = local_6._0_1_;
    fuel_param_calculated_4_offset = (char)(calculated_4 >> 8) + 0x7d;
    local_6._1_1_ = (byte)fuel_mode_selection_offset;
    fuel_param_mode_offset_low = (byte)local_6;
    local_6._0_1_ = (byte)(fuel_mode_selection_offset >> 8);
    fuel_param_mode_offset_high = local_6._0_1_;
    fuel_param_result_buffer_offset = (char)(result_buffer >> 8) + 0x7d;
    if (fuel_limit_comparison_high == 0) {
      local_6 = arbitrated_fuel_limit;
    }
    else {
      local_6 = (short)(((uint)fuel_limit_comparison_high *
                        ((uint)fuel_limit_comparison_low - (uint)param_ref_base)) / 0x1111) -
                (fuel_limit_offset_value - arbitrated_fuel_limit);
      if (0xfaff < local_6) {
        local_6 = 0xfaff;
      }
    }
    fuel_param_limit_calc_low = (byte)local_6;
    fuel_param_limit_calc_high = local_6._0_1_;
    local_6._1_1_ = (byte)fuel_arbitrator_output_value;
    fuel_param_arbitrator_low = (byte)local_6;
    local_6._0_1_ = (byte)(fuel_arbitrator_output_value >> 8);
    fuel_param_arbitrator_high = local_6._0_1_;
    local_6._1_1_ = (byte)_diagnostic_mode_parameter;
    fuel_param_diag_mode_low = (byte)local_6;
    local_6._0_1_ = (byte)((ushort)_diagnostic_mode_parameter >> 8);
    fuel_param_diag_mode_high = local_6._0_1_;
    fuel_param_arb_status_scaled = (byte)(fuel_arbitrator_status_init / 10);
    fuel_param_timing_offset_scaled = (byte)(fuel_timing_offset_min_limit / 0x50);
    if (allowed_rate_of_torque_limit_change_0_2000 < 0x4e21) {
      extended_diag_torque_limit_byte = (byte)(allowed_rate_of_torque_limit_change_0_2000 / 0x50);
    }
    else {
      extended_diag_torque_limit_byte = 0x20;
    }
    uVar2 = param_table_calc;
    for (pwVar3 = &calculated_2; pwVar3 < (ushort *)((int)&result_buffer + 1); pwVar3 = pwVar3 + 1)
    {
      if (uVar2 < *pwVar3) {
        uVar2 = *pwVar3;
      }
    }
    fuel_param_max_calc_offset = (char)(uVar2 >> 8) + 0x7d;
    bVar1 = sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65251);
  }
  return bVar1;
}



/*
 * Function: extendedDiagPGN_65251_Builder @ 0x0002a7f8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void extendedDiagPGN_65251_Builder(void)

{
  j1939_message_buffer_pgn65251 = CONCAT13((char)((_j1939_priority_pgn65251 & 7) << 2),0xfee300);
  j1939_message_buffer_pgn65251 =
       CONCAT31(j1939_message_buffer_pgn65251._0_3_,j1939_source_address_primary);
  _extended_diag_pgn65251_size = 0x1c;
  extended_diag_pgn65251_data_ptr = (dword)&extended_diag_pgn65251_data_start;
  extended_diag_pgn65251_unused_ptr = (dword)&extended_diag_pgn65251_status;
  fuel_param_reserved_ff_0 = 0xff;
  fuel_param_reserved_ff_1 = 0xff;
  fuel_param_reserved_7d = 0x7d;
  fuelBlendTablePointerSetup();
  return;
}



/*
 * Function: engineFluidLevelDataBuilder @ 0x0002a856
 */

void engineFluidLevelDataBuilder(void)

{
  coolant_level =
       (byte)((int)((uint)(((int)(uint)rpm_histogram_temp_value >> 7) * 0x1afa) / 1000) >> 1);
  engine_oil_level =
       (byte)((int)((uint)(((int)(uint)insite_parameter_display_value >> 7) * 0x1afa) / 1000) >> 2);
  sendCanMessage((j1939_header_t *)&engine_fluid_level_msg_header);
  return;
}



/*
 * Function: engineFluidLevelPGN_65263_Builder @ 0x0002a8da
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineFluidLevelPGN_65263_Builder(void)

{
  engine_fluid_level_msg_header = CONCAT13((char)((_j1939_priority_pgn65263 & 7) << 2),0xfeef00);
  engine_fluid_level_msg_length = 8;
  engine_fluid_level_data_ptr = (dword)&fuel_delivery_pressure;
  engine_fluid_level_unused_ptr = (dword)&engine_fluid_level_buffer_end;
  engine_fluid_level_msg_header =
       CONCAT31(engine_fluid_level_msg_header._0_3_,j1939_source_address_primary);
  fuel_delivery_pressure = 0xff;
  coolant_pressure = 0xffff;
  extended_crankcase_pressure = 0xff;
  engine_oil_pressure = 0xff;
  return;
}



/*
 * Function: engineFluidLevelDataBuilder @ 0x0002a93a
 */

void engineFluidLevelDataBuilder(void)

{
  int iVar1;
  short sVar2;
  undefined2 local_6;
  
  iVar1 = ((short)((short)throttle_position_raw + -0x1900 >> 7) * 5 + -0xa0) / 9;
  sVar2 = (short)iVar1;
  if (sVar2 < -0x28) {
    engine_temp_processed1 = 0;
  }
  else if (sVar2 < 0xd2) {
    local_6._1_1_ = (char)iVar1;
    engine_temp_processed1 = (char)local_6 + 0x28;
  }
  else {
    engine_temp_processed1 = 0xfa;
  }
  iVar1 = ((short)((short)engine_fluid_level_temp_data + -0x1900 >> 7) * 5 + -0xa0) / 9;
  sVar2 = (short)iVar1;
  if (sVar2 < -0x28) {
    engine_temp_processed2 = 0;
  }
  else if (sVar2 < 0xd2) {
    local_6._1_1_ = (char)iVar1;
    engine_temp_processed2 = (char)local_6 + 0x28;
  }
  else {
    engine_temp_processed2 = 0xfa;
  }
  local_6 = (short)(((short)((short)rpm_histogram_temp_value + -0x1900 >> 7) * 5 + -0xa0) / 9);
  if (local_6 < -0x111) {
    engine_fluid_calc_result = 0;
  }
  else if (local_6 < 0x6c7) {
    local_6 = (local_6 + 0x111) * 0x20;
    engine_fluid_calc_result = byteSwap16(&local_6);
  }
  else {
    local_6 = -0x500;
    engine_fluid_calc_result = byteSwap16(&local_6);
  }
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65262);
  return;
}



/*
 * Function: engineTemperaturePGN_65262_Builder @ 0x0002aa74
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineTemperaturePGN_65262_Builder(void)

{
  j1939_message_buffer_pgn65262 = CONCAT13((char)((_j1939_priority_pgn65262 & 7) << 2),0xfeee00);
  _engine_temp_pgn65262_size = 8;
  engine_temp_pgn65262_data_ptr = (dword)&engine_temp_processed1;
  engine_temp_pgn65262_unused_ptr = 0x8030d8;
  j1939_message_buffer_pgn65262 =
       CONCAT31(j1939_message_buffer_pgn65262._0_3_,j1939_source_address_primary);
  engine_temp_reserved_ffff = 0xffff;
  engine_temp_reserved_ff_0 = 0xff;
  engine_temp_reserved_ff_1 = 0xff;
  canTransmissionController();
  return;
}



/*
 * Function: torqueControlDataBuilder @ 0x0002aade
 */

void torqueControlDataBuilder(void)

{
  if ((diagnostic_system_flags_2 & 0x1000) == 0) {
    torque_control_status_byte = 0;
  }
  else {
    torque_control_status_byte = 0x40;
  }
  if (retarder_input_flags != 0) {
    torque_control_status_byte = torque_control_status_byte | 0x10;
  }
  switch(fuel_demand_limit_source) {
  case OVERRIDE_STATE_ACTIVE:
  case RETARDER_MODE_TABLE:
    if (fuel_mode_state_selector == 1) {
      torque_control_status_byte = torque_control_status_byte | 6;
    }
    else if (fuel_mode_state_selector == 3) {
      torque_control_status_byte = torque_control_status_byte | 5;
    }
    else if (fuel_mode_state_selector == 2) {
      torque_control_status_byte = torque_control_status_byte | 7;
    }
    else {
      torque_control_status_byte = torque_control_status_byte | 0xe;
    }
    break;
  case VP44_DIAGNOSTIC_FAULT:
    torque_control_status_byte = torque_control_status_byte | 2;
    break;
  case RETARDER_INPUT_LIMIT:
    torque_control_status_byte = torque_control_status_byte | 1;
  }
  if (retarder_mode_threshold_value_37d4 == 0) {
    torque_control_data_byte2 = 0xff;
  }
  else {
    ioControlBasedFuelCalculator();
    torque_control_data_byte2 = 0x7d - (char)(retarder_scaled_percentage_output >> 8);
  }
  sendCanMessage((j1939_header_t *)&cummins_tsc_msg_header);
  return;
}



/*
 * Function: cumminsProprietaryTSC_PGN_15728640_Builder @ 0x0002aba4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void cumminsProprietaryTSC_PGN_15728640_Builder(void)

{
  cummins_tsc_msg_header = CONCAT13((char)((_j1939_priority_pgn15728640 & 7) << 2),0xf00000);
  cummins_tsc_msg_header = CONCAT31(cummins_tsc_msg_header._0_3_,j1939_source_address_secondary);
  throttleTablePointerSetup();
  cummins_tsc_msg_length = 2;
  cummins_tsc_data_ptr = (dword)&torque_control_status_byte;
  cummins_tsc_unused_ptr = (dword)&torque_control_buffer_end;
  return;
}



/*
 * Function: intakeExhaustConditionsDataBuilder @ 0x0002abf2
 */

void intakeExhaustConditionsDataBuilder(void)

{
  uint local_8;
  
  local_8 = proportionalCalculation(clutch_operating_stats_output,0x39c2c3,1000000);
  local_8 = proportionalCalculation(local_8,2,8);
  intake_exhaust_clutch_stat_dword = byteSwap32(&local_8);
  local_8 = insite_fuel_statistics_output >> 2;
  local_8 = proportionalCalculation(local_8,0x39c2c3,1000000);
  intake_exhaust_fuel_stat_dword = byteSwap32(&local_8);
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65257);
  return;
}



/*
 * Function: intakeExhaustConditionsPGN_65257_Builder @ 0x0002ac7a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void intakeExhaustConditionsPGN_65257_Builder(void)

{
  j1939_message_buffer_pgn65257 = CONCAT13((char)((_j1939_priority_pgn65257 & 7) << 2),0xfee900);
  _intake_exhaust_pgn65257_size = 8;
  intake_exhaust_pgn65257_data_ptr = (dword)&intake_exhaust_clutch_stat_dword;
  intake_exhaust_pgn65257_unused_ptr = 0x803108;
  j1939_message_buffer_pgn65257 =
       CONCAT31(j1939_message_buffer_pgn65257._0_3_,j1939_source_address_primary);
  canTransmissionController();
  return;
}



/*
 * Function: fuelEconomyDataBuilder @ 0x0002acd0
 */

void fuelEconomyDataBuilder(void)

{
  uint uVar1;
  short sVar2;
  byte local_6;
  byte bStack_5;
  
  uVar1 = proportionalCalculation((uint)fuel_economy_statistics_value,0xe10,8000);
  uVar1 = uVar1 / 10;
  if (0xc8c < uVar1) {
    uVar1 = 0xc8c;
  }
  sVar2 = (short)uVar1 * 0x14;
  bStack_5 = (byte)sVar2;
  fuel_economy_data_byte1 = bStack_5;
  local_6 = (byte)((ushort)sVar2 >> 8);
  fuel_economy_data_byte2 = local_6;
  uVar1 = ((uint)fuel_economy_statistics_output * 0x2136) / 10000;
  bStack_5 = (byte)uVar1;
  fuel_economy_data_byte3 = bStack_5;
  local_6 = (byte)(uVar1 >> 8);
  fuel_economy_data_byte4 = local_6;
  uVar1 = ((uint)clutch_transitions_per_distance * 0x2136) / 10000;
  bStack_5 = (byte)uVar1;
  fuel_economy_data_byte5 = bStack_5;
  local_6 = (byte)(uVar1 >> 8);
  fuel_economy_data_byte6 = local_6;
  sendCanMessage((j1939_header_t *)&fuel_economy_msg_header);
  return;
}



/*
 * Function: fuelEconomyPGN_65266_Builder @ 0x0002ada8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelEconomyPGN_65266_Builder(void)

{
  fuel_economy_msg_header = CONCAT13((char)((_j1939_priority_pgn65266 & 7) << 2),0xfef200);
  fuel_economy_msg_header = CONCAT31(fuel_economy_msg_header._0_3_,j1939_source_address_primary);
  fuel_economy_msg_length = 6;
  fuel_economy_data_ptr = (dword)&fuel_economy_data_byte1;
  fuel_economy_unused_ptr = (dword)&fuel_economy_buffer_end;
  return;
}



/*
 * Function: ioControlDataBuilder @ 0x0002adec
 */

void ioControlDataBuilder(void)

{
  uint local_8;
  
  local_8 = insite_command_base_value >> 2;
  local_8 = proportionalCalculation(local_8,0x39c2c3,1000000);
  io_control_pgn_data_dword = byteSwap32(&local_8);
  local_8 = proportionalCalculation(insite_runtime_hours_accumulator,0x14,0x40);
  io_control_runtime_hours_dword = byteSwap32(&local_8);
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65244);
  return;
}



/*
 * Function: ioControlPGN_65244_Builder @ 0x0002ae60
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void ioControlPGN_65244_Builder(void)

{
  j1939_message_buffer_pgn65244 = CONCAT13((char)((_j1939_priority_pgn65244 & 7) << 2),0xfedc00);
  _io_control_pgn65244_size = 8;
  io_control_pgn65244_data_ptr = (dword)&io_control_pgn_data_dword;
  io_control_pgn65244_unused_ptr = 0x80313e;
  j1939_message_buffer_pgn65244 =
       CONCAT31(j1939_message_buffer_pgn65244._0_3_,j1939_source_address_primary);
  canTransmissionController();
  return;
}



/*
 * Function: engineHoursPGN_65252_Builder @ 0x0002aee2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineHoursPGN_65252_Builder(void)

{
  j1939_message_buffer_pgn65252 = CONCAT13((char)((_j1939_priority_pgn65252 & 7) << 2),0xfee400);
  _engine_hours_pgn65252_size = 8;
  engine_hours_pgn65252_data_ptr = (dword)&engine_hours_data_byte_0;
  engine_hours_pgn65252_unused_ptr = 0x803156;
  j1939_message_buffer_pgn65252 =
       CONCAT31(j1939_message_buffer_pgn65252._0_3_,j1939_source_address_primary);
  engine_hours_reserved_ff_0 = 0xff;
  engine_hours_reserved_ff_1 = 0xff;
  engine_hours_reserved_ff_2 = 0xff;
  engine_hours_reserved_ff_3 = 0xff;
  engine_hours_reserved_ff_4 = 0xff;
  engine_hours_reserved_ff_5 = 0xff;
  engine_hours_reserved_3f = 0x3f;
  return;
}



/*
 * Function: intakeManifoldDataBuilder @ 0x0002af52
 */

void intakeManifoldDataBuilder(void)

{
  intake_manifold_data_byte_1 =
       (byte)((short)((((short)diagnostic_sensor_reading >> 7) * 0x1afa) / 1000) >> 1);
  intake_manifold_data_byte_2 =
       (char)((((short)intake_manifold_temp_raw >> 7) * 5 + -0xa0) / 9) + 0x28;
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65270);
  return;
}



/*
 * Function: intakeManifoldPGN_65526_Builder @ 0x0002afca
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void intakeManifoldPGN_65526_Builder(void)

{
  j1939_message_buffer_pgn65270 = CONCAT13((char)((_j1939_priority_pgn65526 & 7) << 2),0xfef600);
  _intake_manifold_pgn65526_size = 8;
  intake_manifold_pgn65526_data_ptr = (dword)&intake_manifold_pgn65526_data;
  intake_manifold_pgn65526_unused_ptr = 0x80316e;
  j1939_message_buffer_pgn65270 =
       CONCAT31(j1939_message_buffer_pgn65270._0_3_,j1939_source_address_primary);
  intake_manifold_pgn65526_data = 0xff;
  intake_manifold_reserved_ff_0 = 0xff;
  intake_manifold_reserved_ff_1 = 0xff;
  intake_manifold_reserved_ff_2 = 0xff;
  intake_manifold_reserved_ff_3 = 0xff;
  intake_manifold_reserved_ff_4 = 0xff;
  return;
}



/*
 * Function: cruiseControlPGN_65264_Builder @ 0x0002b060
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void cruiseControlPGN_65264_Builder(void)

{
  j1939_message_buffer_pgn65264 = CONCAT13((char)((_j1939_priority_pgn65264 & 7) << 2),0xfef000);
  _cruise_control_pgn65264_size = 8;
  cruise_control_pgn65264_data_ptr = (dword)&cruise_control_pgn65264_data;
  cruise_control_pgn65264_unused_ptr = 0x803186;
  j1939_message_buffer_pgn65264 =
       CONCAT31(j1939_message_buffer_pgn65264._0_3_,j1939_source_address_primary);
  cruise_control_pgn65264_data = 0xff;
  cruise_control_reserved_ff_0 = 0xff;
  cruise_control_reserved_ff_1 = 0xff;
  cruise_control_reserved_ff_2 = 0xff;
  cruise_control_reserved_ff_3 = 0xff;
  cruise_control_reserved_ff_4 = 0xff;
  return;
}



/*
 * Function: retarderConfigDataBuilder @ 0x0002b0cc
 */

byte retarderConfigDataBuilder(void)

{
  byte bVar1;
  byte local_6;
  byte bStack_5;
  
  bVar1 = retarder_config_buffer_end & 0xf0;
  if (bVar1 == 0) {
    if (retarder_mode_threshold_value_37d4 == 3) {
      retarder_steps_at_idle = 0x14;
    }
    else {
      retarder_steps_at_idle = 3;
    }
    if (retarder_mode_threshold_value_37d4 == 0) {
      retarder_percent_torque_idle = 0xff;
    }
    else if (retarder_mode_threshold_value_37d4 == 1) {
      retarder_percent_torque_idle = 3;
    }
    else {
      retarder_percent_torque_idle = 2;
    }
    bStack_5 = (byte)vp44_sensor_value_3;
    retarder_speed_point2_low = bStack_5;
    local_6 = (byte)(vp44_sensor_value_3 >> 8);
    retarder_speed_point2_high = local_6;
    retarder_percent_torque_point2 = 0x7d - (char)(retarder_torque_point_2_value >> 8);
    bStack_5 = (byte)vp44_sensor_value_2;
    retarder_speed_point3_low = bStack_5;
    local_6 = (byte)(vp44_sensor_value_2 >> 8);
    retarder_speed_point3_high = local_6;
    retarder_percent_torque_point3 = 0x7d - (char)(retarder_torque_point_3_value >> 8);
    bStack_5 = (byte)vp44_sensor_value_5;
    retarder_speed_point4_low = bStack_5;
    local_6 = (byte)(vp44_sensor_value_5 >> 8);
    retarder_speed_point4_high = local_6;
    retarder_percent_torque_point4 = 0x7d - (char)(retarder_torque_point_4_value >> 8);
    bStack_5 = (byte)vp44_sensor_value_1;
    retarder_speed_point5_low = bStack_5;
    local_6 = (byte)(vp44_sensor_value_1 >> 8);
    retarder_speed_point5_high = local_6;
    retarder_percent_torque_point5 = 0x7d - (char)(retarder_torque_point_5_value >> 8);
    bStack_5 = (byte)vp44_sensor_value_4;
    retarder_reference_torque_low = bStack_5;
    local_6 = (byte)(vp44_sensor_value_4 >> 8);
    retarder_reference_torque_high = local_6;
    bStack_5 = (byte)vp44_fuel_temperature_raw;
    retarder_config_byte17 = bStack_5;
    local_6 = (byte)(vp44_fuel_temperature_raw >> 8);
    retarder_config_byte18 = local_6;
    bVar1 = sendCanMessage((j1939_header_t *)&retarder_config_msg_header);
  }
  return bVar1;
}



/*
 * Function: retarderConfigPGN_65249_Builder @ 0x0002b1f6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void retarderConfigPGN_65249_Builder(void)

{
  retarder_config_msg_header = CONCAT13((char)((_j1939_priority_pgn65249 & 7) << 2),0xfee100);
  retarder_config_msg_header =
       CONCAT31(retarder_config_msg_header._0_3_,j1939_source_address_secondary);
  retarder_config_msg_length = 0x12;
  retarder_config_data_ptr = (dword)&retarder_steps_at_idle;
  retarder_config_unused_ptr = (dword)&retarder_config_buffer_end;
  return;
}



/*
 * Function: vehicleDistanceDataBuilder @ 0x0002b23a
 */

void vehicleDistanceDataBuilder(void)

{
  undefined4 local_8;
  
  local_8 = proportionalCalculation(vehicle_distance_clutch_value,0x3268,10000);
  vehicle_distance_pgn_data_dword = byteSwap32(&local_8);
  local_8 = proportionalCalculation(vehicle_distance_statistics_value,0x3268,10000);
  vehicle_distance_data_dword = byteSwap32(&local_8);
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65248);
  return;
}



/*
 * Function: vehicleDistancePGN_65248_Builder @ 0x0002b29e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vehicleDistancePGN_65248_Builder(void)

{
  j1939_message_buffer_pgn65248 = CONCAT13((char)((_j1939_priority_pgn65248 & 7) << 2),0xfee000);
  _vehicle_distance_pgn65248_size = 8;
  vehicle_distance_pgn65248_data_ptr = (dword)&vehicle_distance_pgn_data_dword;
  vehicle_distance_pgn65248_unused_ptr = 0x8031c0;
  j1939_message_buffer_pgn65248 =
       CONCAT31(j1939_message_buffer_pgn65248._0_3_,j1939_source_address_primary);
  canTransmissionController();
  return;
}



/*
 * Function: retarderDataBuilder @ 0x0002b2f4
 */

void retarderDataBuilder(void)

{
  undefined2 local_6;
  
  local_6 = (undefined2)((uint)retarder_input_value * 0x14 >> 3);
  electronic_brake_data_word = byteSwap16(&local_6);
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65271);
  return;
}



/*
 * Function: electronicBrakePGN_65527_Builder @ 0x0002b338
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void electronicBrakePGN_65527_Builder(void)

{
  j1939_message_buffer_pgn65271 = CONCAT13((char)((_j1939_priority_pgn65527 & 7) << 2),0xfef700);
  _electronic_brake_pgn65527_size = 8;
  electronic_brake_pgn65527_data_ptr = (dword)&electronic_brake_pgn65527_data;
  electronic_brake_pgn65527_unused_ptr = 0x8031d8;
  j1939_message_buffer_pgn65271 =
       CONCAT31(j1939_message_buffer_pgn65271._0_3_,j1939_source_address_primary);
  electronic_brake_pgn65527_data = 0xff;
  electronic_brake_reserved_ff = 0xff;
  electronic_brake_reserved_ffff_0 = 0xffff;
  electronic_brake_reserved_ffff_1 = 0xffff;
  return;
}



/*
 * Function: vehicleHoursDataBuilder @ 0x0002b398
 */

void vehicleHoursDataBuilder(void)

{
  undefined4 local_8;
  
  local_8 = proportionalCalculation(vehicle_hours_statistics_value,0x14,0x40);
  vehicle_hours_pgn_data_dword = byteSwap32(&local_8);
  local_8 = proportionalCalculation(insite_idle_hours_accumulator,0x14,0x40);
  vehicle_hours_idle_hours_dword = byteSwap32(&local_8);
  sendCanMessage((j1939_header_t *)&j1939_message_buffer_pgn65255);
  return;
}



/*
 * Function: vehicleHoursPGN_65255_Builder @ 0x0002b3fc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vehicleHoursPGN_65255_Builder(void)

{
  j1939_message_buffer_pgn65255 = CONCAT13((char)((_j1939_priority_pgn65255 & 7) << 2),0xfee700);
  _vehicle_hours_pgn65255_size = 8;
  vehicle_hours_pgn65255_data_ptr = (dword)&vehicle_hours_pgn_data_dword;
  vehicle_hours_pgn65255_unused_ptr = 0x8031f0;
  j1939_message_buffer_pgn65255 =
       CONCAT31(j1939_message_buffer_pgn65255._0_3_,j1939_source_address_primary);
  canTransmissionController();
  return;
}



/*
 * Function: incrementCounters @ 0x0002b452
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void incrementCounters(void)

{
  _loopCounter = _loopCounter + 1;
  if (engine_operating_mode != ENGINE_IDLE) {
    _engineRunCounter = _engineRunCounter + 1;
  }
  return;
}



/*
 * Function: initLoopCounter @ 0x0002b46a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initLoopCounter(void)

{
  _loopCounter = _loop_counter_reference;
  return;
}



/*
 * Function: setDiagnosticSourceFromFuelArbitrator @ 0x0002b476
 */

void setDiagnosticSourceFromFuelArbitrator(void)

{
  if ((diagnostic_status_register == NORMAL_OPERATION) &&
     (fuel_arbitrator_diag_t_0080cff8.rpm_target == 2)) {
    diagnostic_status_register = FUEL_ARBITRATOR_SOURCE;
    cached_parameter_value = fuel_arbitrator_diag_t_0080cff8._24_2_;
  }
  return;
}



/*
 * Function: setDiagnosticSourceFromEngineFlags @ 0x0002b49a
 */

void setDiagnosticSourceFromEngineFlags(void)

{
  if ((diagnostic_status_register == NORMAL_OPERATION) && ((diagnostic_status_flags & 1) != 0)) {
    diagnostic_status_register = ENGINE_FLAGS_SOURCE;
    cached_parameter_value = diagnostic_source_5_param_value;
  }
  return;
}



/*
 * Function: engine_protection_coordinator @ 0x0002b4c2
 */

void engine_protection_coordinator(void)

{
  DIAGNOSTIC_STATUS DVar1;
  undefined4 unaff_D2;
  DIAGNOSTIC_STATUS DVar2;
  undefined2 uVar3;
  
  DVar1 = diagnostic_status_register;
  uVar3 = (undefined2)((uint)unaff_D2 >> 0x10);
  diagnostic_status_register = NORMAL_OPERATION;
  diagnosticStatus30Setter();
  setDiagnosticSourceFromFuelArbitrator();
  DVar2 = DVar1;
  diagnosticStatus2Initializer(CONCAT22(DVar1,uVar3));
  setDiagnosticSourceFromEngineFlags();
  epsDiagnosticModeChecker(CONCAT22(DVar1,DVar2));
  diagnosticStatus7Initializer(CONCAT22(DVar1,DVar2));
  diagnosticStatusDefaultSetter();
  return;
}



/*
 * Function: initMultiSystemParameters @ 0x0002b4fe
 */

void initMultiSystemParameters(void)

{
  diagnosticTablePointerSetup();
  epsDiagnosticVariablesInit();
  fuelDemandScaleFactorCalculator();
  return;
}



/*
 * Function: addressRangeValidator @ 0x0002b544
 */

undefined4 addressRangeValidator(uint param_1,uint param_2)

{
  undefined3 uVar1;
  uint uVar2;
  byte bVar3;
  uint uVar4;
  word *pwVar5;
  
  uVar2 = param_2 >> 0x10;
  uVar4 = (param_1 + uVar2) - 1;
  if (uVar4 < param_1) {
    return 9;
  }
  pwVar5 = &address_range_validation_table;
  bVar3 = 0;
  while ((param_1 < *(uint *)pwVar5 || (*(uint *)((int)pwVar5 + 4) < uVar4))) {
    uVar2 = 0;
    pwVar5 = (word *)((int)pwVar5 + 10);
    bVar3 = bVar3 + 1;
    if (4 < bVar3) {
      return 9;
    }
  }
  uVar1 = (undefined3)(uVar2 >> 8);
  if (water_in_fuel_detection_flag == 1) {
    return CONCAT31(uVar1,*(undefined1 *)((int)pwVar5 + 8));
  }
  return CONCAT31(uVar1,*(undefined1 *)((int)pwVar5 + 9));
}



/*
 * Function: pwmTimerMode0Init @ 0x0002b5aa
 */

void pwmTimerMode0Init(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  word *pwVar4;
  
  if ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 == '\0') {
    state_machine_return_address = (dword)&LAB_00015946;
    can1_cantxerr = can1_cantxerr & 0xfff0 | 0xc;
    QSM_QSMCR = can1_timer_callback_state / 6;
    QSM_QTEST = 0xe;
    QSM_QMCR = 0xb;
    can1_canidar1 = can1_canidar1 & 0xfffc | 1;
    can1_canidar3 = can1_canidar3 & 0xfffc | 1;
    can1_canidmr1 = can1_canidmr1 & 0xfffc | 2;
    can1_cantbsel = can1_cantbsel & 0xfffe | 1;
    can1_canidmr2 = can1_canidmr2 & 0xfffe;
    return;
  }
  if ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 != '\x01') {
    return;
  }
  pwm_timer_cycle_advance_state = pwm_timing_cycle_count - CYCLE_PHASE_1;
  iVar1 = 0;
  iVar2 = 0;
  uVar3 = (uint)intake_manifold_temperature_at_maximum_fueling_condition_50_293._0_1_;
  pwVar4 = &pwm_timing_advance_lookup_table;
  do {
    *(int *)pwVar4 = iVar2 / 6;
    iVar2 = uVar3 * 0x10000 + iVar2;
    iVar1 = iVar1 + 1;
    pwVar4 = pwVar4 + 2;
  } while (iVar1 < 6);
  pwm_temperature_shifted_workspace =
       (uint)intake_manifold_temperature_at_maximum_fueling_condition_50_293._0_1_ << 0x10;
  pwmTimerMode1Update();
  return;
}



/*
 * Function: pwmTimerMode0Reset @ 0x0002b6c2
 */

void pwmTimerMode0Reset(void)

{
  if ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 == '\0') {
    can1_canidmr2 = can1_canidmr2 & 0xfffe;
    can1_cantxerr = can1_cantxerr & 0xfff0 | 0xc;
    QSM_QSMCR = 1;
    QSM_QTEST = 0xe;
    QSM_QMCR = 0xb;
    can1_canidar1 = can1_canidar1 & 0xfffc | 1;
    can1_canidar3 = can1_canidar3 & 0xfffc | 1;
    can1_cantbsel = can1_cantbsel & 0xfffe | 1;
    can1_canidmr1 = can1_canidmr1 & 0xfffc | 2;
  }
  return;
}



/*
 * Function: pwmTimerMode1ChannelSetup @ 0x0002b744
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void pwmTimerMode1ChannelSetup(void)

{
  int iVar1;
  ushort uVar2;
  ushort uVar3;
  uint uVar4;
  
  pwm_timer_cycle_advance_state = pwm_timing_cycle_count - CYCLE_PHASE_1;
  iVar1 = pwm_temperature_shifted_workspace +
          _user_specified_number_of_engine_data_samples_taken_by_trending_f_0_100 +
          _enable_flag_that_indicates_presence_of_an_ambient_air_press_true_false +
          *(int *)(&pwm_timing_advance_lookup_table +
                  (short)(ushort)(byte)(pwm_timing_cycle_count - CYCLE_PHASE_1) * 2) + 0x100;
  uVar4 = (iVar1 >> 0x10 & 0xffffU) % (maximum_allowed_timing_advance_for_this_algorithm_0_20 + 2);
  uVar3 = (ushort)uVar4;
  uVar2 = (ushort)(iVar1 >> 1) & 0x7f00;
  if (uVar4 == maximum_allowed_timing_advance_for_this_algorithm_0_20 + 1) {
    QSM_SCCR1 = uVar3 - 1 | uVar2 | 0x8000;
  }
  else {
    QSM_SCCR1 = uVar3 | uVar2;
  }
  uVar4 = (_time_that_trigger_must_be_satisfied_to_allow_trending_data_co_0_3600 + iVar1 >> 0x10 &
          0xffffU) % (maximum_allowed_timing_advance_for_this_algorithm_0_20 + 2);
  uVar3 = (ushort)uVar4;
  uVar2 = (ushort)(_time_that_trigger_must_be_satisfied_to_allow_trending_data_co_0_3600 + iVar1 >>
                  1) & 0x7f00;
  if (maximum_allowed_timing_advance_for_this_algorithm_0_20 + 1 == uVar4) {
    QSM_SCCR2 = uVar3 - 1 | uVar2 | 0x8000;
  }
  else {
    QSM_SCCR2 = uVar3 | uVar2;
  }
  can1_canidmr2 = can1_canidmr2 & 0xfff7;
  can1_cantxerr = can1_cantxerr & 0xfff | 0x8000;
  QSM_SPSR = 0x880;
  can1_canidar1 = can1_canidar1 & 0xff3f;
  can1_canidar3 = can1_canidar3 & 0xff3f | 0x80;
  can1_canidmr1 = can1_canidmr1 & 0xff3f | 0x40;
  can1_cantbsel = can1_cantbsel & 0xfff7 | 8;
  return;
}



/*
 * Function: pwmTimerMode1Update @ 0x0002b880
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void pwmTimerMode1Update(void)

{
  int iVar1;
  ushort uVar2;
  ushort uVar3;
  uint uVar4;
  
  iVar1 = pwm_temperature_shifted_workspace +
          _user_specified_number_of_engine_data_samples_taken_by_trending_f_0_100 +
          _enable_flag_that_indicates_presence_of_an_ambient_air_press_true_false +
          *(int *)(&pwm_timing_advance_lookup_table +
                  (short)(ushort)pwm_timer_cycle_advance_state * 2) + 0x100;
  uVar4 = (iVar1 >> 0x10 & 0xffffU) % (maximum_allowed_timing_advance_for_this_algorithm_0_20 + 2);
  uVar3 = (ushort)uVar4;
  uVar2 = (ushort)(iVar1 >> 1) & 0x7f00;
  if (uVar4 == maximum_allowed_timing_advance_for_this_algorithm_0_20 + 1) {
    QSM_SCCR1 = uVar3 - 1 | uVar2 | 0x8000;
  }
  else {
    QSM_SCCR1 = uVar3 | uVar2;
  }
  uVar4 = (_time_that_trigger_must_be_satisfied_to_allow_trending_data_co_0_3600 + iVar1 >> 0x10 &
          0xffffU) % (maximum_allowed_timing_advance_for_this_algorithm_0_20 + 2);
  uVar3 = (ushort)uVar4;
  uVar2 = (ushort)(_time_that_trigger_must_be_satisfied_to_allow_trending_data_co_0_3600 + iVar1 >>
                  1) & 0x7f00;
  if (maximum_allowed_timing_advance_for_this_algorithm_0_20 + 1 == uVar4) {
    QSM_SCCR2 = uVar3 - 1 | uVar2 | 0x8000;
  }
  else {
    QSM_SCCR2 = uVar3 | uVar2;
  }
  can1_canidmr2 = can1_canidmr2 & 0xfff7;
  can1_cantxerr = can1_cantxerr & 0xfff | 0x8000;
  QSM_SPSR = 0x880;
  can1_canidar1 = can1_canidar1 & 0xff3f;
  can1_canidar3 = can1_canidar3 & 0xff3f | 0x80;
  can1_canidmr1 = can1_canidmr1 & 0xff3f | 0x40;
  pwm_timer_mode_1_update_address = (dword)pwmTimerCycleAdvance;
  can1_cantbsel = can1_cantbsel & 0xfff7 | 8;
  return;
}



/*
 * Function: pwmTimerModeDispatcher @ 0x0002b9b8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void pwmTimerModeDispatcher(void)

{
  if ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 == '\0') {
    QSM_QSMCR = can1_timer_callback_state / 6;
    can1_cantbsel = can1_cantbsel & 0xfff7;
    can1_canidmr2 = can1_canidmr2 & 0xfff7;
    can1_cantxerr = can1_cantxerr & 0xfff | 0xa000;
    _QSM_SPCR0 = 0;
    _QSM_SCCR1 = 0x19b;
    QSM_SPSR = 0x8e;
    can1_canidar1 = can1_canidar1 & 0xff3f;
    can1_canidar3 = can1_canidar3 & 0xff3f | 0x80;
    can1_canidmr1 = can1_canidmr1 & 0xff3f | 0x40;
  }
  if ((pwm_timer_mode_dispatch_state != 0) &&
     ((char)time_fault_conditions_must_exist_before_logging_a_throttle_faul_0_2000 == '\x01')) {
    pwmTimerMode1ChannelSetup();
  }
  return;
}



/*
 * Function: pwmTimerCycleAdvance @ 0x0002ba56
 */

undefined8 pwmTimerCycleAdvance(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  uint uVar1;
  
  if (rpm_timer_capture_state == CAPTURING) {
    switch(pwm_timer_cycle_advance_state) {
    case CYCLE_PHASE_0:
    case CYCLE_PHASE_4:
    case CYCLE_PHASE_5:
      if ((char)pwm_timer_calc_value_1 == '\0') {
        pwm_timer_cycle_advance_state =
             (PWM_TIMER_CYCLE_STATE)((pwm_timer_cycle_advance_state + 3) % 6);
      }
      break;
    case CYCLE_PHASE_1:
    case CYCLE_PHASE_2:
    case CYCLE_PHASE_3:
      if ((char)pwm_timer_calc_value_1 != '\0') {
        pwm_timer_cycle_advance_state =
             (PWM_TIMER_CYCLE_STATE)((pwm_timer_cycle_advance_state + 3) % 6);
      }
    }
  }
  uVar1 = (pwm_timer_cycle_advance_state + 1) % 6;
  pwm_timer_cycle_advance_state = (PWM_TIMER_CYCLE_STATE)uVar1;
  vp44_timing_table_index = (char)((pwm_timer_cycle_advance_param + uVar1) % 6) + 1;
  pwmTimerMode1Update();
  can1_canidmr2 = can1_canidmr2 & 0xfff7;
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: delayWithWatchdogService @ 0x0002baf0
 */

void delayWithWatchdogService(undefined4 param_1)

{
  while (param_1._0_2_ != 0) {
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
  }
  return;
}



/*
 * Function: watchdogServiceLoop @ 0x0002bb2e
 */

void watchdogServiceLoop(undefined4 param_1)

{
  while (param_1._0_2_ != 0) {
    REG_SIM_SWSR = 0xaa;
    qsm_sci_data_reg._1_1_ = 0xaa;
  }
  return;
}



/*
 * Function: engineDataTrendingSlowCycle40Coordinator @ 0x0002bb6c
 */

void engineDataTrendingSlowCycle40Coordinator(void)

{
  engine_data_trending_state = 2;
  engine_trending_load_threshold_ptr =
       (dword)&lower_limit_at_which_loading_trigger_is_satisfied_in_trendin_0_127_5;
  engine_trending_intake_temp_value = intake_manifold_temp_raw;
  engine_trending_count_min_ptr = (dword)&count_minimum_for_percent_load_to_be_low_0_100;
  if (upper_limit_at_which_loading_trigger_is_satisfied_in_trendin_0_127_5 <
      current_fuel_demand_value) {
    fuel_demand_rpm_based_limit = 0;
    return;
  }
  fuel_demand_rpm_lookup_result =
       lookupTableInterpolation((table_interp_args_t *)&engine_data_trending_state);
  return;
}



/*
 * Function: trendingDataTableLookup @ 0x0002bbac
 */

void trendingDataTableLookup(void)

{
  table_interp_args_t *unaff_A2;
  
  fuel_demand_rpm_lookup_result = lookupTableInterpolation(unaff_A2);
  return;
}



/*
 * Function: fuelDemandBasedParameterCalculator @ 0x0002bbc0
 */

void fuelDemandBasedParameterCalculator(void)

{
  if (upper_limit_at_which_loading_trigger_is_satisfied_in_trendin_0_127_5 <
      current_fuel_demand_value) {
    fuel_demand_rpm_based_limit = 0;
    return;
  }
  fuel_demand_rpm_based_limit =
       current_engine_rpm / rpm_divisor_value + (fuel_demand_rpm_lookup_result - 0xc4);
  if ((short)fuel_demand_rpm_based_limit < 0) {
    fuel_demand_rpm_based_limit = 0;
  }
  return;
}



/*
 * Function: fuelDemandLimitMinimumUpdater @ 0x0002bc06
 */

void fuelDemandLimitMinimumUpdater(void)

{
  fuel_demand_limit_snapshot = fuel_limit_minimum_value;
  if (fuel_limit_minimum_value < fuel_demand_rpm_based_limit) {
    fuel_limit_minimum_value = fuel_demand_rpm_based_limit;
    fuel_demand_source_id = RPM_BASED_LIMIT;
  }
  return;
}



/*
 * Function: vp44_rpm_derate_monitor @ 0x0002bc2a
 */

ushort vp44_rpm_derate_monitor(void)

{
  word wVar1;
  ushort uVar2;
  
  wVar1 = rpm_derate_timer;
  uVar2 = vp44_status_flags_2 & 0x80;
  if ((((vp44_status_flags_2 & 0x80) != 0) &&
      (uVar2 = derate_status_byte & 2, (derate_status_byte & 2) == 0)) &&
     (uVar2 = wVar1,
     rpm_derate_timer <= time_duration_from_overlimit_reached_to_starting_rpm_derate_0_65535)) {
    rpm_derate_timer = time_duration_from_overlimit_reached_to_starting_rpm_derate_0_65535;
    rpm_derate_status = 0;
  }
  return uVar2;
}



/*
 * Function: diagnostic_protection_coordinator @ 0x0002bc62
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnostic_protection_coordinator(void)

{
  diagnosticRpmBasedFuelLimitCalculator();
  diagnosticFuelLimitInterpolator();
  engineStateFuelLimitInterpolator();
  if (((diagnostic_fuel_control_mode == 7) || (diagnostic_fuel_control_mode == 8)) ||
     (diagnostic_fuel_control_mode == 9)) {
    diagnostic_mode_buffer = diagnostic_fuel_control_mode;
  }
  switch(diagnostic_fuel_control_mode) {
  case 9:
    if ((protection_system_enable_flag == 0) ||
       ((((current_fuel_demand_value <
           amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 &&
          (amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 <
           protection_fuel_limit_mode_based)) &&
         ((amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 <
           protection_fuel_limit_rpm_based && (active_derate_value != 0)))) ||
        (((delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 2 ||
          (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 1)) ||
         (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 5)))))) {
      diagnostic_rpm_threshold_status =
           amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535;
      diagnostic_fuel_control_mode = delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535
      ;
      return;
    }
    if ((current_engine_rpm <= governor_rpm_error_value) &&
       ((uint)protection_threshold_offset + (uint)target_boost_pressure_base <
        (uint)boost_pressure_feedback)) {
      diagnostic_fuel_control_mode = 0xb;
      timing_protection_counter_2 = 1;
      governorPidFuelCalculator();
    }
    if ((((protection_fuel_limit_mode_based == protection_fuel_limit_alternate) &&
         (((current_fuel_demand_value <=
            amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 &&
           (0xc < active_derate_value)) || (boost_pressure_max_target <= target_boost_pressure_base)
          ))) || (protection_fuel_limit_mode_based < protection_fuel_limit_alternate)) &&
       ((protection_fuel_limit_mode_based < protection_fuel_limit_rpm_based &&
        (protection_fuel_limit_mode_based < diagnostic_rpm_threshold_status)))) {
      diagnostic_fuel_control_mode = 10;
      diagnosticMode10FuelController();
      return;
    }
    if ((((protection_fuel_limit_rpm_based < diagnostic_rpm_threshold_status) ||
         (protection_fuel_limit_rpm_based <=
          amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535)) &&
        (protection_fuel_limit_rpm_based < protection_fuel_limit_mode_based)) &&
       (protection_fuel_limit_rpm_based < protection_fuel_limit_alternate)) {
      diagnostic_fuel_control_mode = 0xc;
      return;
    }
    break;
  case 10:
    if (((((current_engine_rpm < 8000) ||
          (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 2)) ||
         (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 1)) ||
        (fuel_temp_protection_threshold_flag != 0)) ||
       ((amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 < current_fuel_demand_value
        && (((protection_system_enable_flag == 0 || (diagnostic_mode_buffer == 7)) ||
            ((diagnostic_mode_buffer == 8 ||
             (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 5)))))))) {
      diagnostic_rpm_threshold_status =
           amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535;
      diagnostic_fuel_control_mode = delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535
      ;
      return;
    }
    if ((protection_fuel_limit_rpm_based < diagnostic_rpm_threshold_status) &&
       (protection_fuel_limit_rpm_based <= protection_fuel_limit_mode_based)) {
      diagnostic_fuel_control_mode = 0xc;
      return;
    }
    if ((((((protection_system_enable_flag != 0) && (diagnostic_mode_buffer == 9)) &&
          (amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 <
           current_fuel_demand_value)) &&
         ((protection_fuel_limit_alternate < protection_fuel_limit_mode_based ||
          ((protection_fuel_limit_alternate == protection_fuel_limit_mode_based &&
           (target_boost_pressure_base < boost_pressure_max_target)))))) &&
        (protection_fuel_limit_alternate < protection_fuel_limit_rpm_based)) &&
       (protection_fuel_limit_alternate < diagnostic_rpm_threshold_status)) {
      diagnostic_fuel_control_mode = 9;
      diagnosticMode10FuelController();
      return;
    }
    break;
  case 0xb:
    if ((((uint)amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 <=
          diagnostic_rpm_threshold_status + 0xe) &&
        (((uint)current_engine_rpm <=
          (uint)time_duration_to_warn_driver_before_shutdown_due_to_intake_t_0_65535 +
          (uint)governor_rpm_error_value || (active_derate_value != 0)))) ||
       (((_diagnostic_condition_flag != 0 ||
         ((active_derate_value == 0 &&
          (((delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 7 ||
            (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 8)) &&
           (protection_system_enable_flag == 0)))))) ||
        ((fuel_arbitrator_diag_t_0080cff8.rpm_target == 3 &&
         (fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ <=
          diagnostic_rpm_threshold_status)))))) {
      if ((protection_system_enable_flag != 0) &&
         ((((uint)boost_pressure_feedback <
            (uint)protection_threshold_offset + (uint)target_boost_pressure_base ||
           ((uint)time_duration_to_warn_driver_before_shutdown_due_to_intake_t_0_65535 +
            (uint)governor_rpm_error_value < (uint)current_engine_rpm)) &&
          ((_diagnostic_condition_flag == 0 &&
           ((fuel_arbitrator_diag_t_0080cff8.rpm_target != 3 ||
            (diagnostic_rpm_threshold_status <
             fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_)))))))) {
        diagnostic_fuel_control_mode = 9;
        diagnosticMode10FuelController();
      }
      diagnostic_state_transition_counter = 0;
      return;
    }
    diagnostic_state_transition_counter = diagnostic_state_transition_counter + 1;
    if (diagnostic_transition_limit == 0) {
      diagnostic_rpm_threshold_status =
           amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535;
      diagnostic_fuel_control_mode = delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535
      ;
      diagnostic_state_transition_counter = 0;
      return;
    }
    if (diagnostic_state_transition_counter == diagnostic_transition_limit) {
      diagnostic_rpm_threshold_status =
           amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535;
      diagnostic_fuel_control_mode = delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535
      ;
      diagnostic_state_transition_counter = 0;
      return;
    }
    break;
  case 0xc:
    if ((amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 <
         diagnostic_rpm_threshold_status) &&
       (((protection_system_enable_flag == 0 ||
         (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 2)) ||
        (((delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 1 ||
          ((delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 5 ||
           (diagnostic_mode_buffer == 7)))) || (diagnostic_mode_buffer == 8)))))) {
      diagnostic_state_exit_counter = diagnostic_state_exit_counter + 1;
      if (diagnostic_exit_limit == 0) {
        diagnostic_rpm_threshold_status =
             amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535;
        diagnostic_fuel_control_mode =
             delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535;
        diagnostic_state_exit_counter = 0;
        return;
      }
      if (diagnostic_state_exit_counter == diagnostic_exit_limit) {
        diagnostic_rpm_threshold_status =
             amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535;
        diagnostic_fuel_control_mode =
             delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535;
        diagnostic_state_exit_counter = 0;
        return;
      }
    }
    else {
      diagnostic_state_exit_counter = 0;
      if ((protection_fuel_limit_mode_based < diagnostic_rpm_threshold_status) &&
         (protection_fuel_limit_mode_based < protection_fuel_limit_rpm_based)) {
        diagnostic_fuel_control_mode = 10;
        diagnosticMode10FuelController();
        return;
      }
      if ((((amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 <=
             current_fuel_demand_value) && (diagnostic_mode_buffer == 9)) &&
          (protection_fuel_limit_alternate < diagnostic_rpm_threshold_status)) &&
         ((protection_fuel_limit_alternate < protection_fuel_limit_rpm_based &&
          (protection_system_enable_flag != 0)))) {
        diagnostic_fuel_control_mode = 9;
        diagnosticMode10FuelController();
        return;
      }
    }
    break;
  default:
    if (((current_engine_rpm <= governor_rpm_error_value) &&
        (diagnostic_rpm_threshold_status < _eps_backup_lost_duration_0_20)) ||
       ((((uint)current_engine_rpm <=
          (uint)fuel_limit_rpm_error_offset + (uint)governor_rpm_error_value &&
         ((active_derate_value == 0 &&
          (diagnostic_rpm_threshold_status < _eps_backup_lost_duration_0_20)))) &&
        ((delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 7 ||
         (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 == 8)))))) {
      diagnostic_fuel_control_mode = 0xb;
      timing_protection_counter_2 = 1;
      governorPidFuelCalculator();
      return;
    }
    if ((protection_fuel_limit_rpm_based <=
         amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535) &&
       (protection_fuel_limit_rpm_based <= protection_fuel_limit_mode_based)) {
      diagnostic_fuel_control_mode = 0xc;
      fuelRpmDeviationCalculator();
      return;
    }
    if ((((protection_fuel_limit_mode_based <
           amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535) &&
         (protection_fuel_limit_mode_based <= protection_fuel_limit_rpm_based)) &&
        (7999 < current_engine_rpm)) &&
       (((fuel_temp_protection_threshold_flag == 0 &&
         (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 != 2)) &&
        (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 != 1)))) {
      diagnostic_fuel_control_mode = 10;
      diagnosticMode10FuelController();
      return;
    }
    if (((protection_system_enable_flag != 0) &&
        (amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 <=
         protection_fuel_limit_alternate)) &&
       ((amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535 <=
         current_fuel_demand_value &&
        (((delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 != 2 &&
          (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 != 1)) &&
         (delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535 != 5)))))) {
      diagnostic_fuel_control_mode = 9;
      diagnosticMode10FuelController();
      return;
    }
    diagnostic_rpm_threshold_status =
         amount_of_time_over_oil_pressure_rpm_shutdown_threshold_0_65535;
    diagnostic_fuel_control_mode = delay_before_warning_about_shutdown_from_oil_press_fuel_0_65535;
  }
  return;
}



/*
 * Function: initDiagnosticModeSystem @ 0x0002c240
 */

void initDiagnosticModeSystem(void)

{
  diagnostic_fuel_control_mode = 0xb;
  diagnostic_mode_buffer = 7;
  return;
}



/*
 * Function: fuelTimingTransitionStateMachine @ 0x0002c252
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint fuelTimingTransitionStateMachine(void)

{
  short sVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
  if (fuel_timing_oil_pressure_timer < _software_padding_0_255) {
    intake_temp_protection_accumulator = shutdown_threshold_for_intake_temp_rpm_0_65535;
  }
  else {
    intake_temp_protection_accumulator =
         fault_index_indicating_epf_imt_rpm_error_found_0_ffff + intake_temp_protection_accumulator;
    if (shutdown_threshold_for_intake_temp_fuel_0_65535 < intake_temp_protection_accumulator) {
      intake_temp_protection_accumulator = shutdown_threshold_for_intake_temp_fuel_0_65535;
    }
  }
  if (protection_system_enable_flag == 0) {
    if (intake_temp_derate_timer <
        time_to_reach_full_derate_during_intake_temp_engine_prote_0_0039_256) {
      intake_temp_derate_timer = intake_temp_derate_timer + 1;
    }
  }
  else {
    intake_temp_derate_timer = 0;
  }
  if (fuel_pressure_filtered < throttle_position_value) {
    fuel_pressure_filtered = coreTableInterpolation();
  }
  if ((determines_how_engine_position_is_sync_d_to_cam_0 <= fuel_timing_oil_pressure_state) &&
     (time_to_reach_full_derate_during_intake_temp_engine_prote_0_0039_256 <=
      intake_temp_derate_timer)) {
    fuel_pressure_filtered = throttle_position_value;
  }
  if ((oil_pressure_mode_previous == 2) && (oil_pressure_mode_selector == 0)) {
    fuel_pressure_filtered = throttle_position_value;
  }
  oil_pressure_mode_previous = oil_pressure_mode_selector;
  if (protection_system_enable_flag == 0) {
    if (fuel_timing_transition_limit < fuel_pressure_filtered) {
      fuel_pressure_filtered = fuel_timing_transition_limit;
    }
  }
  else if (target_boost_pressure_base < fuel_pressure_filtered) {
    fuel_pressure_filtered = target_boost_pressure_base;
  }
  iVar2 = rpmFuelCalculation((uint)fuel_timing_transition_limit - (uint)fuel_pressure_filtered,
                             (uint)
                             time_to_reach_full_derate_during_intake_temp_engine_prote_0_0039_256,
                             0x80);
  uVar4 = (uint)shutdown_delay_for_intake_temperature_shutdown_0_255 - iVar2;
  if ((int)(uint)shutdown_delay_for_intake_temperature_shutdown_0_255 < (int)uVar4) {
    uVar4 = (uint)shutdown_delay_for_intake_temperature_shutdown_0_255;
  }
  else if ((int)uVar4 < (int)(uint)delay_after_rpm_reached_before_intake_temp_errors_0_255) {
    uVar4 = (uint)delay_after_rpm_reached_before_intake_temp_errors_0_255;
  }
  fuel_timing_transition_state_968e = (word)uVar4;
  sVar1 = (short)oil_pressure_mode_selector >> 0xf;
  if (oil_pressure_mode_selector == 0) {
    if (((((vp44_status_flags_2 & 0x20) == 0) ||
         (throttle_position_filtered < minimum_threshold_for_intake_temperature_rpm_limiting_50_293)
         ) || (maximum_temperature_threshold_for_imt_tvo_limiting_50_to_293 <
               throttle_position_filtered)) ||
       (intake_temp_protection_accumulator < throttle_position_value)) {
      fuel_timing_transition_value_2 = 0;
    }
    else {
      fuel_timing_transition_value_2 = 1;
    }
    uVar3 = (uint)throttle_position_value;
    if (((fault_index_indicating_epf_imt_fuel_error_found_0_ffff <= throttle_position_value) &&
        ((uVar3 = (uint)fuel_pressure_filtered - (uVar4 & 0xffff),
         (int)(uint)throttle_position_value < (int)uVar3 ||
         (uVar3 = CONCAT22((short)(uVar3 >> 0x10),_fuel_timing_oil_pressure_mode_state),
         crank_exited_initial_fueling_offset_100_100 <= _fuel_timing_oil_pressure_mode_state)))) &&
       (uVar3 = CONCAT22((short)(uVar3 >> 0x10),throttle_position_filtered),
       throttle_position_filtered <= rpm_to_reach_before_imt_errors_0_8000)) {
      fuel_timing_transition_value_1 = 1;
      return uVar3;
    }
    fuel_timing_transition_value_1 = 0;
    return uVar3;
  }
  if (oil_pressure_mode_selector == 1) {
    uVar4 = vp44_status_flags_2 & 0x20;
    if (((vp44_status_flags_2 & 0x20) != 0) &&
       (((uVar4 = (uint)throttle_position_filtered,
         throttle_position_filtered < minimum_threshold_for_intake_temperature_rpm_limiting_50_293
         || (uVar4 = (uint)throttle_position_filtered,
            maximum_temperature_threshold_for_imt_tvo_limiting_50_to_293 <
            throttle_position_filtered)) ||
        (uVar4 = (uint)throttle_position_value,
        intake_temp_protection_accumulator < throttle_position_value)))) {
      fuel_timing_transition_value_2 = 1;
      return uVar4;
    }
    fuel_timing_transition_value_2 = 0;
    return uVar4;
  }
  if (oil_pressure_mode_selector != 2) {
    return (int)(short)oil_pressure_mode_selector;
  }
  uVar4 = CONCAT22(sVar1,throttle_position_value);
  if ((((throttle_position_value < fuel_pressure_filtered) &&
       (uVar4 = CONCAT22(sVar1,throttle_position_value),
       fault_index_indicating_epf_imt_fuel_error_found_0_ffff <= throttle_position_value)) &&
      (uVar4 = CONCAT22(sVar1,throttle_position_filtered),
      throttle_position_filtered <= rpm_to_reach_before_imt_errors_0_8000)) &&
     ((uVar4 = CONCAT22(sVar1,fuel_timing_oil_pressure_state),
      fuel_timing_oil_pressure_state < determines_how_engine_position_is_sync_d_to_cam_0 ||
      (uVar4 = CONCAT22(sVar1,intake_temp_derate_timer),
      intake_temp_derate_timer <
      time_to_reach_full_derate_during_intake_temp_engine_prote_0_0039_256)))) {
    fuel_timing_transition_value_1 = 0;
    return uVar4;
  }
  fuel_timing_transition_value_1 = 1;
  return uVar4;
}



/*
 * Function: initProtectionTablePointer @ 0x0002c4de
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void initProtectionTablePointer(void)

{
  _protection_table_init_value = 0;
  protection_imt_threshold_ptr =
       (dword)&minimum_temperature_threshold_for_imt_fuel_limiting_50_to_293;
  return;
}



/*
 * Function: diagnosticFlagResetHandler @ 0x0002c4f0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort diagnosticFlagResetHandler(void)

{
  if ((fuel_temp_control_flags & 0x8000) == 0) {
    _fuel_demand_limit_source_2_flag = 0;
  }
  return fuel_temp_control_flags & 0x8000;
}



/*
 * Function: fuelTempControlFlagChecker @ 0x0002c506
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort fuelTempControlFlagChecker(void)

{
  if ((fuel_temp_control_flags & 0x8000) != 0) {
    _fuel_demand_limit_source_2_flag = 0;
  }
  return fuel_temp_control_flags & 0x8000;
}



/*
 * Function: diagnosticModeFuelAdjustmentCalculator @ 0x0002c51a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticModeFuelAdjustmentCalculator(undefined4 param_1)

{
  ushort uVar1;
  short sVar2;
  word wStack_6;
  
  fuel_temp_limit_snapshot = fuel_temp_calculated_limit_971c;
  diagnostic_fuel_gain_factor_96c6 =
       lookupTableInterpolation((table_interp_args_t *)&protection_table_size);
  if (diagnostic_fuel_control_mode == 9) {
    if ((((vp44_diagnostic_mode_state == BOOST_PRESSURE_INIT) ||
         (vp44_diagnostic_mode_state == SENSOR_BIT8_TRIGGERED)) ||
        (vp44_diagnostic_mode_state == BOOST_PRESSURE_MONITOR)) ||
       (vp44_diagnostic_mode_state == SENSOR_BIT2_PROTECTION)) {
      _water_in_fuel_protection_active = 0;
    }
    else {
      if (target_boost_pressure_base < boost_pressure_feedback) {
        uVar1 = boost_pressure_feedback - target_boost_pressure_base;
      }
      else {
        uVar1 = target_boost_pressure_base - boost_pressure_feedback;
      }
      if (((uVar1 < time_from_overlimit_reached_to_starting_fuel_derate_0_65535) &&
          (param_1._0_2_ <= _selected_oil_pressure_threshold)) &&
         (shutdown_threshold_for_intake_temp_rpm_20_255 <= param_1._0_2_)) {
        _water_in_fuel_protection_active = 1;
      }
    }
  }
  if ((_water_in_fuel_protection_active == 0) && (diagnostic_fuel_control_mode == 9)) {
    boost_pressure_protection_active = 0;
  }
  else if (_selected_oil_pressure_threshold < param_1._0_2_) {
    uVar1 = _boost_pressure_monitor_value;
    if (diagnostic_fuel_control_mode == 9) {
      uVar1 = _oil_pressure_monitor_value;
    }
    wStack_6 = (word)((uint)uVar1 * ((uint)param_1._0_2_ - (uint)_selected_oil_pressure_threshold)
                     >> 10);
    if ((short)wStack_6 < 0xa01) {
      boost_pressure_protection_active = wStack_6;
    }
    else {
      boost_pressure_protection_active = 0xa00;
    }
  }
  else if (param_1._0_2_ < shutdown_threshold_for_intake_temp_rpm_20_255) {
    sVar2 = _intake_temp_protection_calc2;
    if (diagnostic_fuel_control_mode == 9) {
      sVar2 = _intake_temp_protection_calc1;
    }
    wStack_6 = (word)((int)sVar2 *
                      ((int)(short)param_1._0_2_ -
                      (int)(short)shutdown_threshold_for_intake_temp_rpm_20_255) >> 10);
    if ((short)wStack_6 < -0xa00) {
      boost_pressure_protection_active = 0xf600;
    }
    else {
      boost_pressure_protection_active = wStack_6;
    }
  }
  else {
    boost_pressure_protection_active = 0;
  }
  if ((short)boost_pressure_control_output < 1) {
    if (-(int)(short)boost_pressure_control_output ==
        (int)(short)EPO2SRRP + (int)(short)shutdown_delay_for_oil_pressure_shutdown_0_255 ||
        -((int)(short)EPO2SRRP + (int)(short)shutdown_delay_for_oil_pressure_shutdown_0_255) <
        (int)(short)boost_pressure_control_output) {
      if (-((int)(short)shutdown_delay_for_oil_pressure_shutdown_0_255 - (int)(short)EPO2SRRP) <
          (int)(short)boost_pressure_control_output) {
        _protection_status_flag1 = 0;
      }
    }
    else {
      _protection_status_flag1 = 1;
    }
  }
  else if ((int)(short)EPO2SRRP + (int)(short)shutdown_delay_for_oil_pressure_shutdown_0_255 <
           (int)(short)boost_pressure_control_output) {
    _protection_status_flag1 = 1;
  }
  else if ((int)(short)boost_pressure_control_output <
           (int)(short)shutdown_delay_for_oil_pressure_shutdown_0_255 - (int)(short)EPO2SRRP) {
    _protection_status_flag1 = 0;
  }
  if (_protection_status_flag1 != 0) {
    if (_protection_status_flag2 == 0) {
      if ((uint)current_fuel_demand_value < shutdown_threshold_for_intake_temp_rpm_20_255 + 0x3a) {
        _protection_status_flag1 = 0;
      }
    }
    else if (current_fuel_demand_value < shutdown_threshold_for_intake_temp_rpm_20_255) {
      _protection_status_flag1 = 0;
    }
  }
  if (_protection_status_flag1 == 0) {
    protection_table_pointer =
         (dword)&time_duration_from_overlimit_reached_to_starting_rpm_derate_0_65535;
  }
  else {
    protection_table_pointer =
         (dword)&dont_log_oil_pressure_faults_until_running_and_time_expired_0_255;
  }
  protection_param_0 = *(word *)protection_table_pointer;
  protection_param_1 = *(word *)(protection_table_pointer + 2);
  protection_param_2 = *(word *)(protection_table_pointer + 4);
  protection_param_3 = *(word *)(protection_table_pointer + 6);
  if (_protection_status_flag1 != _protection_status_flag2) {
    _oil_pressure_protection_active = 1;
  }
  _protection_status_flag2 = _protection_status_flag1;
  return;
}



/*
 * Function: update_engine_protection_thresholds @ 0x0002c7e0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void update_engine_protection_thresholds(void)

{
  _intake_temp_calc_result = _intake_temp_protection_calc2;
  _boost_pressure_calc_result = _boost_pressure_monitor_value;
  if ((_water_in_fuel_protection_active == 1) && (protection_system_enable_flag == 1)) {
    _oil_pressure_timer = _oil_pressure_monitor_value;
    _boost_pressure_timer = _intake_temp_protection_calc1;
  }
  else {
    _oil_pressure_timer = 0;
    _boost_pressure_timer = 0;
  }
  if (oil_pressure_mode_selector == 0) {
    _selected_oil_pressure_threshold = minimum_threshold_for_oil_pressure_rpm_limiting_0_65535;
  }
  else if (oil_pressure_mode_selector == 2) {
    _selected_oil_pressure_threshold =
         time_to_shutdown_after_low_oil_pressure_error_declared_0_65535;
  }
  else if (oil_pressure_mode_selector == 1) {
    _selected_oil_pressure_threshold = _custom_oil_pressure_threshold;
  }
  _oil_pressure_threshold_active = _selected_oil_pressure_threshold;
  _oil_pressure_threshold_backup = _selected_oil_pressure_threshold;
  return;
}



/*
 * Function: engineProtectionTimeoutCalculator @ 0x0002c870
 */

undefined4 engineProtectionTimeoutCalculator(undefined4 param_1)

{
  uint uVar1;
  word *pwVar2;
  ushort local_8;
  ushort uStack_6;
  
  uVar1 = (((uint)vp44_fault_calc_factor_1 * (uint)vp44_boost_pressure_reference) / 0x3c & 0xffff) *
          (uint)vp44_fault_calc_factor_2;
  local_8 = (ushort)(uVar1 >> 0x17);
  if (local_8 == 0) {
    pwVar2 = (word *)((uVar1 >> 7 & 0xffff) * (uint)param_1._0_2_);
    local_8 = (ushort)((uint)pwVar2 >> 0x10);
    uStack_6 = local_8;
    if (local_8 < 0x1f41) {
      uStack_6 = 8000;
    }
  }
  else {
    pwVar2 = (word *)((uint)param_1._0_2_ * (uVar1 >> 0xb & 0xffff) >> 0xc);
    if (pwVar2 < &hour_meter_conversion_table) {
      uStack_6 = (ushort)pwVar2;
      if (uStack_6 < 0x1f41) {
        uStack_6 = 8000;
      }
    }
    else {
      uStack_6 = 36000;
    }
  }
  return CONCAT22((short)((uint)pwVar2 >> 0x10),uStack_6);
}



/*
 * Function: engineProtectionScaledValueCalculator @ 0x0002c8fe
 */
/* ERROR: Failed to decompile */
void engineProtectionScaledValueCalculator(void) {
    /* Decompilation failed */
}


/*
 * Function: protectionThresholdDivider @ 0x0002c968
 */
/* ERROR: Failed to decompile */
void protectionThresholdDivider(void) {
    /* Decompilation failed */
}


/*
 * Function: engine_protection_init @ 0x0002c99a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engine_protection_init(void)

{
  ushort uVar1;
  undefined4 uVar2;
  undefined4 unaff_D2;
  word wVar3;
  undefined2 local_18;
  undefined4 local_16;
  undefined2 local_12;
  undefined2 local_10;
  undefined4 local_e;
  undefined2 local_a;
  undefined4 local_8;
  
  _protection_table_size = 2;
  protection_shutdown_time_ptr =
       (dword)&time_to_shutdown_after_low_oil_pressure_error_declared_0_100;
  protection_water_in_fuel_ptr = (dword)&min_threshold_for_water_in_fuel_fuel_limiting_0_3;
  _oil_pressure_protection_active = 0;
  boost_pressure_protection_active = 0;
  _water_in_fuel_protection_active = 0;
  local_16 = 0x808002;
  local_18 = 2;
  local_a = 400;
  local_e = 0x808028;
  local_10 = 2;
  local_8 = 0x808032;
  uVar2 = engineProtectionTimeoutCalculator
                    (CONCAT22(fuel_timing_transition_limit - fuel_timing_transition_offset,
                              (short)((uint)unaff_D2 >> 0x10)));
  local_12 = (undefined2)uVar2;
  wVar3 = fuel_timing_transition_offset;
  _oil_pressure_monitor_value = engineProtectionScaledValueCalculator();
  uVar2 = engineProtectionTimeoutCalculator
                    (CONCAT22(boost_pressure_target_pointer - protection_init_timing_param_2,wVar3))
  ;
  local_12 = (undefined2)uVar2;
  _boost_pressure_monitor_value =
       engineProtectionScaledValueCalculator((short)((uint)&local_18 >> 0x10));
  if (shutdown_duration_threshold_for_boost_pressure_fuel_0_65535 <
      shutdown_threshold_for_intake_temp_rpm_20_255) {
    uVar1 = shutdown_threshold_for_intake_temp_rpm_20_255 -
            shutdown_duration_threshold_for_boost_pressure_fuel_0_65535;
    _intake_temp_protection_calc1 = protectionThresholdDivider();
    _intake_temp_protection_calc2 =
         protectionThresholdDivider((short)((uint)uVar1 * 0x1164 >> 0x10),uVar1);
  }
  else {
    _intake_temp_protection_calc1 = 0;
    _intake_temp_protection_calc2 = 0;
  }
  _oil_pressure_threshold_active = minimum_threshold_for_oil_pressure_rpm_limiting_0_65535;
  _oil_pressure_threshold_backup = minimum_threshold_for_oil_pressure_rpm_limiting_0_65535;
  _intake_temp_threshold_active = shutdown_threshold_for_intake_temp_rpm_20_255;
  _intake_temp_threshold_backup = shutdown_threshold_for_intake_temp_rpm_20_255;
  _oil_pressure_timer = 0;
  _boost_pressure_timer = 0;
  _intake_temp_calc_result = _intake_temp_protection_calc2;
  _boost_pressure_calc_result = _boost_pressure_monitor_value;
  _protection_status_flag1 = 0;
  _protection_status_flag2 = 0;
  return;
}



/*
 * Function: diagnosticFuelGainCalculator @ 0x0002cb08
 */

undefined4 diagnosticFuelGainCalculator(void)

{
  int iVar1;
  undefined2 uStack_6;
  
  iVar1 = (uint)fuel_gain_multiplier *
          (int)(short)(((int)(short)boost_pressure_control_output *
                       (int)(short)diagnostic_fuel_gain_factor_96c6) / 1000);
  if (iVar1 < 0x138800) {
    if (iVar1 < -0x1387ff) {
      uStack_6 = 0xd8f0;
    }
    else {
      iVar1 = iVar1 >> 7;
      uStack_6 = (undefined2)iVar1;
    }
  }
  else {
    uStack_6 = 10000;
  }
  return CONCAT22((short)((uint)iVar1 >> 0x10),uStack_6);
}



/*
 * Function: boost_pressure_control_and_diagnostics @ 0x0002cb6a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void boost_pressure_control_and_diagnostics(void)

{
  bool bVar1;
  ushort uVar2;
  short sVar4;
  int iVar3;
  undefined4 unaff_D2;
  short sVar5;
  word wVar6;
  undefined2 uVar7;
  undefined2 uVar8;
  word wStack_a;
  int local_8;
  
  uVar8 = (undefined2)((uint)unaff_D2 >> 0x10);
  uVar7 = 0x322a;
  wVar6 = current_fuel_demand_value;
  _boost_pressure_raw_reading = coreTableInterpolation(0x80);
  _boost_pressure_filtered_value = coreTableInterpolation(0x80,wVar6,uVar7);
  sVar5 = _boost_pressure_current_delta;
  _boost_pressure_current_delta = unsignedLinearInterpolation();
  uVar2 = _boost_pressure_command;
  sVar5 = _boost_pressure_current_delta - sVar5;
  if (sVar5 < 0x67) {
    if (sVar5 < -0x66) {
      sVar5 = -0x66;
    }
  }
  else {
    sVar5 = 0x66;
  }
  if ((((short)fault_when_epf_boost_pressure_fuel_error_found_0_65535 < sVar5) ||
      ((int)sVar5 < -(int)(short)fault_when_epf_boost_pressure_fuel_error_found_0_65535)) ||
     (_epf_fault_timer == 0)) {
    _epf_fault_timer = fault_when_epf_engine_boost_pressure_rpm_error_found_0_65535;
  }
  else {
    if (_epf_fault_timer == fault_when_epf_engine_boost_pressure_rpm_error_found_0_65535) {
      _boost_pressure_baseline = _boost_pressure_filtered_value;
    }
    if (_epf_fault_timer != 0) {
      _epf_fault_timer = _epf_fault_timer - 1;
    }
  }
  if ((_epf_fault_timer == 0) &&
     (shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535 <= _boost_pressure_current_delta)) {
    boost_pressure_control_active = '\x01';
    _boost_pressure_target = _boost_pressure_baseline;
  }
  else if (boost_pressure_control_active == '\0') {
    _boost_pressure_target = current_fuel_demand_value;
  }
  if ((diagnostic_fuel_control_mode == 9) || (diagnostic_fuel_control_mode == 10)) {
    if (_diagnostic_boost_mode_flag == 1) {
      diagnosticMode10FuelController();
    }
    else {
      if (diagnostic_fuel_control_mode == 9) {
        _boost_pressure_command = target_boost_pressure_base;
        if (uVar2 < target_boost_pressure_base) {
          if ((ushort)(delay_after_rpm_is_reached_before_water_in_fuel_errors_0_8000 + uVar2) <
              target_boost_pressure_base) {
            _boost_pressure_command =
                 delay_after_rpm_is_reached_before_water_in_fuel_errors_0_8000 + uVar2;
          }
        }
        else if ((target_boost_pressure_base < uVar2) &&
                ((uint)fault_when_epf_water_in_fuel_fuel_error_found_0_65535 +
                 (uint)target_boost_pressure_base < (uint)uVar2)) {
          _boost_pressure_command = uVar2 - fault_when_epf_water_in_fuel_fuel_error_found_0_65535;
        }
        boost_pressure_setpoint = _boost_pressure_command;
        if (((_water_in_fuel_sensor_flag1 == 1) && ((sensor_status_register & 2) == 0)) ||
           ((_water_in_fuel_sensor_flag2 == 1 && ((sensor_status_register & 8) == 0)))) {
          diagnosticMode10FuelController();
        }
      }
      else {
        boost_pressure_setpoint = boost_pressure_max_target;
      }
      boost_pressure_error = boost_pressure_setpoint - boost_pressure_feedback;
      if ((short)max_threshold_for_boost_pressure_fuel_limiting_0_100 < (short)boost_pressure_error)
      {
        boost_pressure_error = max_threshold_for_boost_pressure_fuel_limiting_0_100;
      }
      else if ((short)boost_pressure_error <
               (short)min_threshold_for_boost_fuel_pressure_rpm_limiting_0_65535) {
        boost_pressure_error = min_threshold_for_boost_fuel_pressure_rpm_limiting_0_65535;
      }
      diagnosticModeFuelAdjustmentCalculator(CONCAT22(_boost_pressure_raw_reading,uVar8));
      if ((int)(short)boost_pressure_error < (short)boost_pressure_protection_active + 0xa00) {
        if ((short)boost_pressure_protection_active + -0xa00 < (int)(short)boost_pressure_error) {
          boost_pressure_control_output = boost_pressure_error - boost_pressure_protection_active;
        }
        else {
          boost_pressure_control_output = 0xf600;
        }
      }
      else {
        boost_pressure_control_output = 0xa00;
      }
      diagnosticFuelGainCalculator();
      sVar4 = signedLinearInterpolation(0x80);
      if (sVar4 < 12000) {
        if (sVar4 < -12000) {
          sVar4 = -12000;
        }
      }
      else {
        sVar4 = 12000;
      }
      wStack_a = (word)((int)sVar5 * (int)(short)diagnostic_fuel_gain_factor_96c6 >> 5);
      iVar3 = (uint)fuel_gain_multiplier * (int)(short)wStack_a;
      wVar6 = shutdown_severity_threshold_for_water_in_fuel_fueling_0_3;
      if ((iVar3 < (short)shutdown_severity_threshold_for_water_in_fuel_fueling_0_3 * 0x16) &&
         (wVar6 = shutdown_severity_threshold_for_water_in_fuel_rpm_0_3,
         (short)shutdown_severity_threshold_for_water_in_fuel_rpm_0_3 * 0x16 < iVar3)) {
        wVar6 = (word)(iVar3 / 0x16);
      }
      iVar3 = (int)sVar4 * (int)(short)protection_param_0 >> 0xc;
      if (iVar3 < 0x7fff) {
        if (iVar3 < -0x7fff) {
          boost_pressure_diagnostic_state = 0x8000;
        }
        else {
          wStack_a = (word)iVar3;
          boost_pressure_diagnostic_state = wStack_a;
        }
      }
      else {
        boost_pressure_diagnostic_state = 0x7fff;
      }
      wStack_a = (word)((int)(short)wVar6 * (int)(short)protection_param_2 >> 0xf);
      protection_scaling_factor = wStack_a;
      local_8 = (int)(short)min_threshold_for_boost_pressure_fuel_limiting_0_100 *
                ((int)(short)current_fuel_demand_value - (int)(short)diagnostic_fuel_baseline) * 2;
      if (local_8 < 0x6e66667) {
        if (local_8 < -0x6e66666) {
          local_8 = -0x6e66666;
        }
      }
      else {
        local_8 = 0x6e66666;
      }
      boost_pressure_control_state = local_8._0_2_;
      if (_oil_pressure_protection_active != 0) {
        _oil_pressure_protection_active = 0;
        iVar3 = ((int)(short)wStack_a +
                ((int)(short)diagnostic_fuel_baseline - (int)(short)boost_pressure_diagnostic_state)
                ) - (int)(short)boost_pressure_control_output;
        if ((int)(uint)start_duration_for_boost_pressure_rpm_derate_0_65535 < iVar3) {
          diagnostic_fuel_demand_limit = start_duration_for_boost_pressure_rpm_derate_0_65535;
        }
        else if (iVar3 < (int)(uint)shutdown_duration_threshold_for_boost_pressure_fuel_0_65535) {
          diagnostic_fuel_demand_limit = shutdown_duration_threshold_for_boost_pressure_fuel_0_65535
          ;
        }
        else {
          diagnostic_fuel_demand_limit = (word)iVar3;
        }
        _diagnostic_fuel_demand_limit = (uint)diagnostic_fuel_demand_limit << 0x10;
      }
      local_8 = local_8 + (((int)sVar4 * (int)(short)protection_param_1 * 4 +
                           _diagnostic_fuel_demand_limit) -
                          ((int)(short)wVar6 * (int)(short)protection_param_3 >> 4));
      diagnostic_fuel_demand_limit = (word)((uint)local_8 >> 0x10);
      if ((short)diagnostic_fuel_demand_limit <
          (short)start_duration_for_boost_pressure_rpm_derate_0_65535) {
        bVar1 = (short)diagnostic_fuel_demand_limit <
                (short)shutdown_duration_threshold_for_boost_pressure_fuel_0_65535;
        _diagnostic_fuel_demand_limit = local_8;
        if (bVar1) {
          _diagnostic_fuel_demand_limit =
               (uint)shutdown_duration_threshold_for_boost_pressure_fuel_0_65535 << 0x10;
        }
      }
      else {
        _diagnostic_fuel_demand_limit =
             (uint)start_duration_for_boost_pressure_rpm_derate_0_65535 << 0x10;
      }
      boost_pressure_diagnostic_timer = diagnostic_fuel_demand_limit;
      if (boost_diagnostic_cooldown == 0) {
        boost_diagnostic_delta_calc =
             sVar5 * 0x20 -
             (short)(((int)(short)start_duration_for_engine_sync_fuel_pressure_rpm_derate_0_65535 *
                     (int)(short)boost_pressure_control_output) / 0x19);
        if (((short)boost_diagnostic_threshold < (short)boost_diagnostic_delta_calc) &&
           ((short)boost_pressure_control_output <
            (short)start_duration_for_engine_sync_fuel_pressure_fueling_derate_0_65535)) {
          if (diagnostic_mode_countdown == 0) {
            boost_diagnostic_trigger_flag = 1;
          }
          else {
            boost_diagnostic_trigger_flag = 0;
            diagnostic_mode_countdown = diagnostic_mode_countdown - 1;
          }
        }
        else {
          diagnostic_mode_countdown = 4;
          boost_diagnostic_trigger_flag = 0;
        }
        if (boost_diagnostic_trigger_flag != 0) {
          boost_diagnostic_adjustment =
               time_duration_to_warn_driver_before_shutdown_due_to_boost_pres_0_65535 * sVar5;
          if ((short)boost_diagnostic_adjustment < 0x6e6) {
            if ((short)boost_diagnostic_adjustment < -0x6e6) {
              boost_diagnostic_adjustment = 0xf91a;
            }
          }
          else {
            boost_diagnostic_adjustment = 0x6e6;
          }
          boost_pressure_diagnostic_timer =
               diagnostic_fuel_demand_limit - boost_diagnostic_adjustment;
          _diagnostic_fuel_demand_limit =
               _diagnostic_fuel_demand_limit + (short)boost_diagnostic_adjustment * -0x10000;
          boost_diagnostic_cooldown = shutdown_severity_threshold_for_boost_pressure_fueling_0_100;
          boost_pressure_control_output = boost_diagnostic_adjustment;
          diagnostic_mode_countdown = 4;
        }
      }
      else {
        boost_diagnostic_cooldown = boost_diagnostic_cooldown - 1;
      }
      if ((short)boost_pressure_control_output < 1) {
        if ((short)boost_pressure_control_output < 0) {
          if (-(int)(short)shutdown_severity_threshold_for_boost_pressure_rpm_0_100 <
              (int)(short)boost_pressure_control_output) {
            boost_pressure_control_output = 0;
          }
          else {
            boost_pressure_control_output =
                 shutdown_severity_threshold_for_boost_pressure_rpm_0_100 +
                 boost_pressure_control_output;
          }
        }
      }
      else if ((short)boost_pressure_control_output <
               (short)shutdown_severity_threshold_for_boost_pressure_rpm_0_100) {
        boost_pressure_control_output = 0;
      }
      else {
        boost_pressure_control_output =
             boost_pressure_control_output -
             shutdown_severity_threshold_for_boost_pressure_rpm_0_100;
      }
      iVar3 = (int)(short)boost_pressure_control_output +
              (((int)(short)boost_pressure_diagnostic_timer +
               (int)(short)boost_pressure_diagnostic_state) - (int)(short)wStack_a);
      if (iVar3 < 0x2e00) {
        if (iVar3 < -0x24b) {
          diagnostic_fuel_baseline = 0xfdb4;
        }
        else {
          wStack_a = (word)iVar3;
          diagnostic_fuel_baseline = wStack_a;
        }
      }
      else {
        diagnostic_fuel_baseline = 0x2e00;
      }
      if ((short)diagnostic_fuel_baseline <
          (short)start_duration_for_boost_pressure_rpm_derate_0_65535) {
        if ((short)time_to_reach_full_derate_during_boost_press_eng_prote_1_256_65535_256 <
            (short)diagnostic_fuel_baseline) {
          diagnostic_rpm_limit_clamped = diagnostic_fuel_baseline;
        }
        else {
          diagnostic_rpm_limit_clamped =
               time_to_reach_full_derate_during_boost_press_eng_prote_1_256_65535_256;
        }
      }
      else {
        diagnostic_rpm_limit_clamped = start_duration_for_boost_pressure_rpm_derate_0_65535;
      }
      diagnostic_rpm_threshold_status = diagnostic_rpm_limit_clamped;
    }
  }
  diagnostic_mode_previous_326a = diagnostic_fuel_control_mode;
  update_engine_protection_thresholds();
  _water_in_fuel_sensor_flag1 = (byte)-((sensor_status_register & 2) != 0) & 1;
  _water_in_fuel_sensor_flag2 = (byte)-((sensor_status_register & 8) != 0) & 1;
  return;
}



/*
 * Function: diagnosticMode10FuelController @ 0x0002d210
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticMode10FuelController(void)

{
  undefined4 uVar1;
  short sVar2;
  undefined4 unaff_D2;
  undefined4 local_8;
  
  if (diagnostic_fuel_control_mode == 10) {
    boost_pressure_error = boost_pressure_max_target - boost_pressure_feedback;
    if ((short)boost_pressure_error < (short)max_threshold_for_boost_pressure_fuel_limiting_0_100) {
      if ((short)boost_pressure_error <
          (short)min_threshold_for_boost_fuel_pressure_rpm_limiting_0_65535) {
        boost_pressure_error = min_threshold_for_boost_fuel_pressure_rpm_limiting_0_65535;
      }
    }
    else {
      boost_pressure_error = max_threshold_for_boost_pressure_fuel_limiting_0_100;
    }
  }
  else {
    _boost_pressure_command = boost_pressure_feedback;
    boost_pressure_setpoint = boost_pressure_feedback;
    boost_pressure_error = 0;
  }
  boost_pressure_control_output = boost_pressure_error;
  diagnosticModeFuelAdjustmentCalculator
            (CONCAT22(_boost_pressure_raw_reading,(short)((uint)unaff_D2 >> 0x10)));
  if ((int)(short)boost_pressure_error < (short)boost_pressure_protection_active + 0xa00) {
    if ((short)boost_pressure_protection_active + -0xa00 < (int)(short)boost_pressure_error) {
      boost_pressure_control_output = boost_pressure_error - boost_pressure_protection_active;
    }
    else {
      boost_pressure_control_output = 0xf600;
    }
  }
  else {
    boost_pressure_control_output = 0xa00;
  }
  uVar1 = diagnosticFuelGainCalculator();
  sVar2 = (short)uVar1;
  _diagnostic_fuel_output_scaled_hi = (int)sVar2 << 0x10;
  _diagnostic_fuel_output_scaled_lo = (int)sVar2 << 0x10;
  _boost_feedback_scaled_hi = (uint)boost_pressure_feedback << 0x10;
  _boost_feedback_scaled_lo = (uint)boost_pressure_feedback << 0x10;
  _boost_pressure_current_delta = boost_pressure_feedback;
  local_8 = (int)sVar2 * (int)(short)protection_param_0 >> 0xc;
  if (local_8 < 0x1700) {
    if (local_8 < -0x16ff) {
      local_8 = 0xe900;
    }
  }
  else {
    local_8 = 0x1700;
  }
  if ((diagnostic_mode_previous_326a == 7) || (diagnostic_mode_previous_326a == 8)) {
    sVar2 = _boost_pressure_target;
    if (diagnostic_fuel_control_mode == 10) {
      sVar2 = current_fuel_demand_value - shutdown_delay_for_boost_pressure_shutdown_0_255;
    }
    boost_pressure_control_output = current_fuel_demand_value - sVar2;
    diagnostic_fuel_demand_limit = sVar2 - local_8._2_2_;
  }
  else {
    boost_pressure_control_output = 0;
    diagnostic_fuel_demand_limit = current_fuel_demand_value - local_8._2_2_;
  }
  if ((short)diagnostic_fuel_demand_limit <
      (short)start_duration_for_boost_pressure_rpm_derate_0_65535) {
    if ((short)diagnostic_fuel_demand_limit <
        (short)shutdown_duration_threshold_for_boost_pressure_fuel_0_65535) {
      diagnostic_fuel_demand_limit = shutdown_duration_threshold_for_boost_pressure_fuel_0_65535;
    }
  }
  else {
    diagnostic_fuel_demand_limit = start_duration_for_boost_pressure_rpm_derate_0_65535;
  }
  diagnostic_mode_10_temp_var = 0;
  boost_pressure_diagnostic_timer = diagnostic_fuel_demand_limit;
  diagnostic_fuel_baseline = current_fuel_demand_value;
  _diagnostic_boost_mode_flag = 0;
  diagnostic_mode_countdown = 4;
  return;
}



/*
 * Function: diagnosticParameterPointersInit @ 0x0002d3fa
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticParameterPointersInit(void)

{
  _diagnostic_boost_mode_flag = 0;
  diagnostic_boost_table_ptr = 0x8070e6;
  diagnostic_boost_start_ptr = (dword)&start_duration_for_boost_pressure_fueling_derate_0_65535;
  diagnostic_water_fault_ptr = (dword)&fault_when_epf_water_in_fuel_rpm_error_found_0_65535;
  diagnostic_water_warn_ptr =
       (dword)&time_duration_to_warn_driver_before_shutdown_due_to_water_in_f_0_65535;
  diagnostic_oil_pressure_max_ptr =
       (dword)&maximum_threshold_for_oil_pressure_fueling_limiting_0_100;
  diagnostic_boost_delay_ptr =
       (dword)&delay_after_rpm_is_reached_before_boost_pressure_errors_0_8000;
  return;
}



/*
 * Function: vp44DiagnosticModeStateMachine @ 0x0002d43e
 */

ushort vp44DiagnosticModeStateMachine(void)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  ushort uVar4;
  bool bVar5;
  
  bVar5 = (sensor_status_register & 4) != 0;
  if ((vp44_sensor_bit2_prev_state == 0) && (bVar5)) {
    bVar3 = true;
  }
  else {
    bVar3 = false;
  }
  vp44_sensor_bit2_prev_state = bVar5;
  bVar5 = (sensor_status_register & 1) != 0;
  if ((vp44_sensor_bit0_prev_state == 0) && (bVar5)) {
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
  vp44_sensor_bit0_prev_state = -bVar5 & 1;
  if ((vp44_operating_condition_prev == TRANSITION_STATE_4) ||
     (vp44_operating_condition_value != TRANSITION_STATE_4)) {
    bVar5 = false;
  }
  else {
    bVar5 = true;
  }
  if ((vp44_operating_condition_prev == TRANSITION_STATE_3) ||
     (vp44_operating_condition_value != TRANSITION_STATE_3)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  vp44_operating_condition_prev = vp44_operating_condition_value;
  if ((bVar5 || bVar2) || (bVar1)) {
    bVar5 = true;
  }
  else {
    bVar5 = false;
  }
  vp44_diagnostic_mode_state = UNINITIALIZED;
  if ((diagnostic_system_flags_1 & 0x40) == 0) {
    vp44_diagnostic_mode_state = INACTIVE;
    uVar4 = diagnostic_system_flags_1 & 0x40;
  }
  else {
    if ((fuel_temp_limit_delta == 0) ||
       (shutdown_delay_for_engine_sync_fuel_pressure_shutdown_0_255 == 0)) {
      bVar2 = false;
    }
    else {
      bVar2 = true;
    }
    if ((vp44_operating_condition_value == FUEL_CONTROL_B) ||
       (vp44_operating_condition_value == FUEL_CONTROL_A)) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
    }
    uVar4 = sensor_status_register & 0x10;
    if (((((((sensor_status_register & 0x10) == 0) ||
           (uVar4 = boost_pressure_feedback, boost_pressure_feedback < insite_fuel_timing_display))
          || (uVar4 = derate_status_byte & 4, (derate_status_byte & 4) != 0)) ||
         ((uVar4 = current_engine_rpm_raw,
          current_engine_rpm_raw < shutdown_threshold_for_intake_temp_fuel_50_293 ||
          (uVar4 = derate_status_byte & 8, (derate_status_byte & 8) != 0)))) || ((bVar2 || (bVar1)))
        ) || ((fuel_arbitrator_diag_t_0080cff8.fuel_limit != 0 &&
              (fuel_arbitrator_diag_t_0080cff8._30_2_ == 1)))) {
      if (vp44_diagnostic_mode_state_2 == INACTIVE) {
        vp44_diagnostic_mode_state = INACTIVE;
      }
      else {
        vp44_diagnostic_mode_state = EXIT_DISABLED;
      }
    }
    else if (bVar3) {
      if ((active_derate_value < 0xc) || (diagnostic_fuel_control_mode == 9)) {
        bVar5 = false;
      }
      else {
        bVar5 = true;
      }
      if ((protection_system_enable_flag == 0) || (bVar5)) {
        uVar4 = boost_pressure_feedback;
        if (shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535 <= boost_pressure_feedback) {
          vp44_diagnostic_mode_state = BOOST_PRESSURE_INIT;
        }
      }
      else if (vp44_sensor_type_selector == 0) {
        vp44_diagnostic_mode_state = SENSOR_TYPE_0_MODE;
      }
      else {
        vp44_diagnostic_mode_state = SENSOR_TYPE_1_MODE;
      }
    }
    else if ((sensor_status_register & 8) == 0) {
      if (bVar5) {
        if (protection_system_enable_flag == 0) {
          uVar4 = boost_pressure_feedback;
          if ((shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535 <= boost_pressure_feedback)
             && (vp44_diagnostic_mode_state_2 != INACTIVE)) {
            vp44_diagnostic_mode_state = BOOST_PRESSURE_MONITOR;
          }
        }
        else if (vp44_sensor_type_selector == 0) {
          vp44_diagnostic_mode_state = SENSOR_TYPE_1_MODE;
        }
        else {
          vp44_diagnostic_mode_state = SENSOR_TYPE_0_MODE;
        }
      }
      else if (((sensor_status_register & 2) != 0) && (protection_system_enable_flag != 0)) {
        vp44_diagnostic_mode_state = SENSOR_BIT2_PROTECTION;
      }
    }
    else if (protection_system_enable_flag != 0) {
      vp44_diagnostic_mode_state = SENSOR_BIT8_TRIGGERED;
    }
  }
  if (vp44_diagnostic_mode_state == UNINITIALIZED) {
    if (protection_system_enable_flag != 0) {
      vp44_diagnostic_mode_state = PROTECTION_CONTINUE;
      return uVar4;
    }
    if (vp44_diagnostic_mode_state_2 != INACTIVE) {
      vp44_diagnostic_mode_state = EXIT_DISABLED;
      return uVar4;
    }
    vp44_diagnostic_mode_state = INACTIVE;
  }
  return uVar4;
}



/*
 * Function: vp44ControlVariablesReset @ 0x0002d688
 */

void vp44ControlVariablesReset(void)

{
  vp44_sensor_bit2_prev_state = 0;
  vp44_sensor_bit0_prev_state = 0;
  vp44_operating_condition_value = RESET_INACTIVE;
  vp44_operating_condition_prev = RESET_INACTIVE;
  return;
}



/*
 * Function: boostPressureFeedbackController @ 0x0002d6a2
 */

void boostPressureFeedbackController(void)

{
  uint uVar1;
  
  if (boost_pressure_override_enable != 0) {
    boost_pressure_feedback = throttle_position_value;
    return;
  }
  uVar1 = ((uint)current_engine_rpm << 0x10) /
          ((uint)boost_pressure_scale_divisor_3830 * (uint)fuel_temp_calculated_limit_971c >> 10) >>
          2;
  if (uVar1 < 0x8001) {
    boost_pressure_feedback = (word)uVar1;
  }
  else {
    boost_pressure_feedback = 0x8000;
  }
  if (boost_pressure_feedback_previous < boost_pressure_feedback) {
    if ((int)(uint)time_to_reach_full_derate_during_fuel_press_eng_protec_1_256_65535_256 <
        (int)((uint)boost_pressure_feedback - (uint)boost_pressure_feedback_previous)) {
      boost_pressure_feedback =
           time_to_reach_full_derate_during_fuel_press_eng_protec_1_256_65535_256 +
           boost_pressure_feedback_previous;
    }
  }
  else if ((boost_pressure_feedback < boost_pressure_feedback_previous) &&
          ((int)(uint)time_to_reach_full_derate_during_fuel_press_eng_protec_1_256_65535_256 <
           (int)((uint)boost_pressure_feedback_previous - (uint)boost_pressure_feedback))) {
    boost_pressure_feedback =
         boost_pressure_feedback_previous -
         time_to_reach_full_derate_during_fuel_press_eng_protec_1_256_65535_256;
  }
  boost_pressure_feedback_previous = boost_pressure_feedback;
  return;
}



/*
 * Function: minimumOfTwoValues @ 0x0002d74a
 */

ushort minimumOfTwoValues(undefined4 param_1)

{
  if (param_1._0_2_ < param_1._2_2_) {
    return param_1._0_2_;
  }
  return param_1._2_2_;
}



/*
 * Function: fuelLimitDecreaseWithFloor @ 0x0002d75e
 */

void fuelLimitDecreaseWithFloor(undefined4 param_1)

{
  if (target_boost_pressure_base < param_1._0_2_) {
    target_boost_pressure_base = shutdown_duration_threshold_for_fuel_pressure_fuel_0_65535;
    return;
  }
  target_boost_pressure_base = target_boost_pressure_base - param_1._0_2_;
  if (target_boost_pressure_base < shutdown_duration_threshold_for_fuel_pressure_fuel_0_65535) {
    target_boost_pressure_base = shutdown_duration_threshold_for_fuel_pressure_fuel_0_65535;
  }
  return;
}



/*
 * Function: fuelLimitIncreaseWithCeiling @ 0x0002d782
 */

void fuelLimitIncreaseWithCeiling(undefined4 param_1)

{
  if ((int)(uint)target_boost_pressure_base <
      (int)((uint)fuel_timing_transition_limit - (uint)param_1._0_2_)) {
    target_boost_pressure_base = param_1._0_2_ + target_boost_pressure_base;
    return;
  }
  target_boost_pressure_base = fuel_timing_transition_limit;
  return;
}



/*
 * Function: boostPressureProtectionStateMachine @ 0x0002d7b4
 */

void boostPressureProtectionStateMachine(void)

{
  undefined4 unaff_A2;
  undefined2 uVar1;
  
  uVar1 = (undefined2)((uint)unaff_A2 >> 0x10);
  switch(vp44_diagnostic_mode_state) {
  case INACTIVE:
    protection_system_enable_flag = 0;
    vp44_diagnostic_mode_state_2 = INACTIVE;
    return;
  case BOOST_PRESSURE_INIT:
    target_boost_pressure_base =
         minimumOfTwoValues(CONCAT22(boost_pressure_feedback,fuel_timing_transition_limit));
    protection_system_enable_flag = 1;
    vp44_diagnostic_mode_state_2 = BOOST_PRESSURE_INIT;
    boost_pressure_protection_state_96fa = target_boost_pressure_base;
    break;
  case BOOST_PRESSURE_MONITOR:
    protection_system_enable_flag = 1;
    target_boost_pressure_base = boost_pressure_protection_state_96fa;
    break;
  case SENSOR_BIT8_TRIGGERED:
    fuelLimitDecreaseWithFloor
              (CONCAT22(min_threshold_for_engine_sync_fuel_pressure_rpm_limiting_0_65535,uVar1));
    break;
  case SENSOR_BIT2_PROTECTION:
    fuelLimitIncreaseWithCeiling
              (CONCAT22(time_to_reach_full_derate_during_fuel_press_eng_protec_1_256_65535_256,uVar1
                       ));
    break;
  case SENSOR_TYPE_0_MODE:
    fuelLimitDecreaseWithFloor(CONCAT22(EPFPMNTD,uVar1));
    break;
  case SENSOR_TYPE_1_MODE:
    fuelLimitIncreaseWithCeiling(CONCAT22(EPFPMXTD,uVar1));
    break;
  case EXIT_DISABLED:
    protection_system_enable_flag = 0;
    return;
  }
  if ((vp44_diagnostic_mode_state == SENSOR_BIT8_TRIGGERED) ||
     (boost_pressure_protection_mode_prev != 3)) {
    if ((vp44_diagnostic_mode_state != SENSOR_BIT2_PROTECTION) &&
       (boost_pressure_protection_mode_prev == 4)) {
      if (boost_pressure_protection_state_96fa < boost_pressure_feedback) {
        target_boost_pressure_base =
             minimumOfTwoValues(CONCAT22(boost_pressure_feedback,fuel_timing_transition_limit));
      }
      else {
        target_boost_pressure_base = boost_pressure_protection_state_96fa;
      }
    }
  }
  else if (boost_pressure_feedback < boost_pressure_protection_state_96fa) {
    if (boost_pressure_feedback < shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535) {
      protection_system_enable_flag = 0;
    }
    else {
      target_boost_pressure_base = boost_pressure_feedback;
    }
  }
  else {
    target_boost_pressure_base = boost_pressure_protection_state_96fa;
  }
  if (vp44_diagnostic_mode_state == PROTECTION_CONTINUE) {
    boost_pressure_protection_state_96fa = target_boost_pressure_base;
  }
  if ((fuel_timing_transition_limit < boost_pressure_protection_state_96fa) ||
     (boost_pressure_protection_state_96fa <
      shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535)) {
    vp44_diagnostic_mode_state_2 = INACTIVE;
  }
  else {
    vp44_diagnostic_mode_state_2 = BOOST_PRESSURE_INIT;
  }
  boost_pressure_protection_mode_prev = vp44_diagnostic_mode_state;
  return;
}



/*
 * Function: fuelLimitEngineStateCapture @ 0x0002d90c
 */

ushort fuelLimitEngineStateCapture(void)

{
  ushort uVar1;
  
  uVar1 = diagnostic_system_flags_1 & 0x8000;
  if ((diagnostic_system_flags_1 & 0x8000) != 0) {
    fuel_limit_engine_state_capture = target_boost_pressure_base;
    return uVar1;
  }
  fuel_limit_engine_state_capture = 0;
  return uVar1;
}



/*
 * Function: fuelLimitRestoreFromCapture @ 0x0002d92c
 */

void fuelLimitRestoreFromCapture(void)

{
  boost_pressure_protection_mode_prev = 0;
  if ((shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535 < fuel_limit_engine_state_capture)
     && (fuel_limit_engine_state_capture < fuel_timing_transition_limit)) {
    vp44_diagnostic_mode_state_2 = BOOST_PRESSURE_INIT;
    target_boost_pressure_base = fuel_limit_engine_state_capture;
    boost_pressure_protection_state_96fa = fuel_limit_engine_state_capture;
  }
  return;
}



/*
 * Function: diagnosticRpmBasedFuelLimitCalculator @ 0x0002d96a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticRpmBasedFuelLimitCalculator(void)

{
  uint uVar1;
  
  if (current_engine_rpm < arbitrated_fuel_limit) {
    protection_fuel_limit_rpm_based = 0x1700;
  }
  else if (fuel_limit_comparison_high == 0) {
    protection_fuel_limit_rpm_based = 0;
  }
  else {
    _rpm_fuel_calculation_scratch =
         (uint)(ushort)((fuel_limit_offset_value + current_engine_rpm) - arbitrated_fuel_limit) <<
         0x10;
    uVar1 = _rpm_fuel_calculation_scratch / ((uint)fuel_limit_comparison_high * 0xf);
    _rpm_fuel_calculation_scratch = (short)(uVar1 >> 0x10);
    _rpm_fuel_calculation_scratch = uVar1;
    if ((_rpm_fuel_calculation_scratch == 0) &&
       (rpm_fuel_calculation_remainder = (word)uVar1,
       rpm_fuel_calculation_remainder < fuel_limit_comparison_low)) {
      protection_fuel_limit_rpm_based = fuel_limit_comparison_low - rpm_fuel_calculation_remainder;
      if (0x1700 < protection_fuel_limit_rpm_based) {
        protection_fuel_limit_rpm_based = 0x1700;
      }
    }
    else {
      protection_fuel_limit_rpm_based = 0;
    }
  }
  return;
}



/*
 * Function: diagnosticFuelLimitInterpolator @ 0x0002da0e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticFuelLimitInterpolator(void)

{
  int iVar1;
  
  if (protection_system_enable_flag != 1) {
    protection_fuel_limit_alternate = 0x1700;
    return;
  }
  if (target_boost_pressure_base < boost_pressure_feedback) {
    if (_boost_pressure_timer == 0) {
      protection_fuel_limit_alternate = 0;
      return;
    }
    fuel_limit_interpolator_result = 1;
    fuel_limit_timer_divisor = _boost_pressure_timer;
    iVar1 = (uint)boost_pressure_feedback - (uint)target_boost_pressure_base;
  }
  else {
    if (_oil_pressure_timer == 0) {
      protection_fuel_limit_alternate = 0x1700;
      return;
    }
    fuel_limit_interpolator_result = 0;
    fuel_limit_timer_divisor = _oil_pressure_timer;
    iVar1 = (uint)target_boost_pressure_base - (uint)boost_pressure_feedback;
  }
  _rpm_fuel_calculation_scratch = iVar1 * 0x400;
  if (fuel_limit_interpolator_result == 0) {
    _rpm_fuel_calculation_scratch =
         (uint)_oil_pressure_threshold_backup +
         _rpm_fuel_calculation_scratch / fuel_limit_timer_divisor;
  }
  else {
    _rpm_fuel_calculation_scratch =
         (uint)_intake_temp_threshold_backup -
         _rpm_fuel_calculation_scratch / fuel_limit_timer_divisor;
  }
  if (0x1700 < (int)_rpm_fuel_calculation_scratch) {
    protection_fuel_limit_alternate = 0x1700;
    return;
  }
  if ((int)_rpm_fuel_calculation_scratch < 0) {
    protection_fuel_limit_alternate = 0;
    return;
  }
  protection_fuel_limit_alternate = rpm_fuel_calculation_remainder;
  return;
}



/*
 * Function: engineStateFuelLimitInterpolator @ 0x0002db10
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint engineStateFuelLimitInterpolator(void)

{
  int iVar1;
  uint uVar2;
  
  if (((diagnostic_system_flags_1 & 0x80) == 0) || (fuel_temp_protection_threshold_flag != 0)) {
    protection_fuel_limit_mode_based = 0x1700;
    return diagnostic_system_flags_1 & 0x80;
  }
  if (boost_pressure_max_target < boost_pressure_feedback) {
    if (_intake_temp_calc_result == 0) {
      protection_fuel_limit_mode_based = 0;
      return (uint)boost_pressure_feedback;
    }
    fuel_limit_interpolator_result = 1;
    fuel_limit_timer_divisor = _intake_temp_calc_result;
    iVar1 = (uint)boost_pressure_feedback - (uint)boost_pressure_max_target;
  }
  else {
    if (_boost_pressure_calc_result == 0) {
      protection_fuel_limit_mode_based = 0x1700;
      return (uint)boost_pressure_feedback;
    }
    fuel_limit_interpolator_result = 0;
    fuel_limit_timer_divisor = _boost_pressure_calc_result;
    iVar1 = (uint)boost_pressure_max_target - (uint)boost_pressure_feedback;
  }
  _rpm_fuel_calculation_scratch = iVar1 * 0x400;
  if (fuel_limit_interpolator_result == 0) {
    uVar2 = (uint)_oil_pressure_threshold_active;
    _rpm_fuel_calculation_scratch = uVar2 + _rpm_fuel_calculation_scratch / fuel_limit_timer_divisor
    ;
  }
  else {
    uVar2 = (uint)_intake_temp_threshold_active -
            _rpm_fuel_calculation_scratch / fuel_limit_timer_divisor;
    _rpm_fuel_calculation_scratch = uVar2;
  }
  if (0x1700 < (int)_rpm_fuel_calculation_scratch) {
    protection_fuel_limit_mode_based = 0x1700;
    return uVar2;
  }
  if ((int)_rpm_fuel_calculation_scratch < 0) {
    protection_fuel_limit_mode_based = 0;
    return uVar2;
  }
  protection_fuel_limit_mode_based = rpm_fuel_calculation_remainder;
  return uVar2;
}



/*
 * Function: fuelTempProtectionLimitCalculator @ 0x0002dc1e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelTempProtectionLimitCalculator(void)

{
  ushort uVar1;
  
  if ((fuel_temp_throttle_threshold <= throttle_position_value) &&
     (engine_operating_mode != ENGINE_IDLE)) {
    if (_timer_capture_average == 0) {
      fuel_temp_protection_limit_3292 = 0xffff;
    }
    else {
      fuel_temp_protection_limit_3292 =
           (word)((_timer_capture_raw * (uint)fuel_temp_calc_multiplier) / _timer_capture_average);
    }
    if (throttle_position_filtered < fuel_temp_protection_limit_3292) {
      uVar1 = fuel_temp_protection_limit_3292 - throttle_position_filtered;
    }
    else {
      uVar1 = throttle_position_filtered - fuel_temp_protection_limit_3292;
    }
    if (((fault_index_indicating_fuel_temperature_rpm_error_detected_0_ffff <
          fuel_temp_protection_limit_3292) &&
        (fuel_temp_protection_limit_3292 <
         time_duration_to_warn_driver_before_shutdown_due_to_fuel_tem_0_65535)) &&
       (uVar1 <= fault_index_indicating_temperature_fueling_error_detected_0_ffff)) {
      fuel_temp_protection_current = fuel_temp_protection_limit_3292;
      fuel_temp_limit_delta = 0;
      if (fuel_temp_protection_timer_9722 != 0) {
        fuel_temp_protection_timer_9722 = fuel_temp_protection_timer_9722 - 1;
      }
      throttle_position_filtered = coreTableInterpolation();
      fuel_temp_calculated_limit_971c = throttle_position_filtered;
    }
    else {
      fuel_temp_limit_delta = 1;
      fuel_temp_protection_timer_9722 = fuel_temp_timer_init;
      fuel_temp_protection_current = fuel_temp_protection_limit_3292;
      if (fuel_temp_protection_limit_3292 <
          fault_index_indicating_fuel_temperature_rpm_error_detected_0_ffff) {
        fuel_temp_protection_current =
             fault_index_indicating_fuel_temperature_rpm_error_detected_0_ffff;
      }
      else if (time_duration_to_warn_driver_before_shutdown_due_to_fuel_tem_0_65535 <
               fuel_temp_protection_limit_3292) {
        fuel_temp_protection_current =
             time_duration_to_warn_driver_before_shutdown_due_to_fuel_tem_0_65535;
      }
      throttle_position_filtered = fuel_temp_protection_current;
      _fuel_temp_protection_state_328e = (uint)fuel_temp_protection_current << 0x10;
    }
    if ((current_engine_rpm < 8000) &&
       (start_duration_for_ambient_air_pressure_rpm_derate_0_65535 < throttle_position_value)) {
      fuel_temp_rpm_timer = start_duration_for_ambient_air_pressure_fueling_derate_0_65535;
    }
    else if (fuel_temp_rpm_timer != 0) {
      fuel_temp_rpm_timer = fuel_temp_rpm_timer - 1;
    }
    if ((fuel_arbitrator_diag_t_0080cff8.fuel_limit == 0 && fuel_temp_protection_timer_9722 == 0) &&
       (fuel_temp_rpm_timer == 0)) {
      fuel_temp_protection_threshold_flag = 0;
    }
    else {
      fuel_temp_protection_threshold_flag = 1;
      fuel_temp_protection_calculator = 1;
    }
    if ((((fuel_temp_calculated_limit_971c == fuel_temp_limit_previous) &&
         (fuel_temp_protection_threshold_flag == 0)) && (fuel_temp_protection_calculator == 1)) &&
       (time_to_reach_full_derate_during_ambient_air_eng_protc_1_256_65535_256 <
        current_fuel_demand_value)) {
      fuel_temp_limit_output_9724 = fuel_temp_calculated_limit_971c;
      fuel_temp_protection_calculator = 0;
    }
    fuel_temp_limit_previous = fuel_temp_calculated_limit_971c;
    return;
  }
  fuel_temp_protection_current =
       threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255;
  throttle_position_filtered = threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255;
  fuel_temp_calculated_limit_971c =
       threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255;
  fuel_temp_limit_output_9724 = threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255
  ;
  fuel_temp_protection_threshold_flag = 1;
  _fuel_temp_protection_state_328e =
       (uint)threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255 << 0x10;
  return;
}



/*
 * Function: fuelArbitratorVariablesInit @ 0x0002ddea
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelArbitratorVariablesInit(void)

{
  fuel_arbitrator_diag_t_0080cff8.fuel_limit = 0;
  fuel_temp_protection_current =
       threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255;
  throttle_position_filtered = threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255;
  fuel_temp_calculated_limit_971c =
       threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255;
  _fuel_temp_protection_state_328e =
       (uint)threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255 << 0x10;
  fuel_temp_protection_table_ptr =
       (dword)&threshold_for_fuel_temperature_fuel_limiting_to_initiate_shutd_0_255;
  fuel_temp_limit_previous = threshold_for_fuel_temperature_rpm_limiting_to_initiate_shutdo_0_255;
  return;
}



/*
 * Function: shutdownLimitSelector @ 0x0002de2e
 */

ushort shutdownLimitSelector(void)

{
  ushort in_D0w;
  
  if (((fuel_temp_protection_threshold_flag != 0) &&
      (in_D0w = throttle_position_value, boost_pressure_max_target < throttle_position_value)) &&
     (in_D0w = diagnostic_system_flags_1 & 0x80, (diagnostic_system_flags_1 & 0x80) != 0)) {
    shutdown_limit_selector_value = shutdown_limit_selector_param;
    return in_D0w;
  }
  shutdown_limit_selector_value = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
  return in_D0w;
}



/*
 * Function: shutdownMinimumSelector21 @ 0x0002de68
 */

void shutdownMinimumSelector21(void)

{
  if (shutdown_limit_selector_value < shutdown_limit_accumulator) {
    shutdown_limit_accumulator = shutdown_limit_selector_value;
    shutdown_minimum_selector_value = SHUTDOWN_LIMIT_SELECTOR;
  }
  return;
}



/*
 * Function: crankDataBufferStore @ 0x0002de92
 */

void crankDataBufferStore(void)

{
  short sVar1;
  
  crank_data_buffer_index = (word)((crank_fuel_buffer_index + 2) % 3);
  *(dword *)((short)(crank_data_buffer_index * 2) * 8 + 0x805fb4) = clutch_operating_time_total;
  *(dword *)((short)(crank_data_buffer_index * 2) * 8 + 0x805fb8) = crank_protection_time_delta;
  if (crank_fuel_timing_buffer_value == 0) {
    sVar1 = crank_data_buffer_index << 4;
    *(uint *)(sVar1 + 0x805fbc) = (uint)crank_protection_divisor * 0x280;
    if (crank_adjusted_initial_fuel_0_100 < 0x6400) {
      *(dword *)((short)(crank_data_buffer_index * 2) * 8 + 0x805fc0) =
           crank_protection_time_delta + (*(int *)(sVar1 + 0x805fbc) - crank_protection_accumulator)
      ;
    }
    else {
      *(dword *)((short)(crank_data_buffer_index * 2) * 8 + 0x805fc0) =
           crank_protection_threshold_time;
    }
  }
  else if (crank_fuel_timing_buffer_value == 3) {
    *(ushort *)((short)crank_data_buffer_index * 2 + 0x805594) =
         (ushort)(crank_fuel_status_flags != 0);
    *(uint *)((short)(crank_data_buffer_index * 2) * 8 + 0x805fc0) =
         (uint)crank_fuel_mode_3_divisor * 0x280;
    *(uint *)((short)(crank_data_buffer_index * 2) * 8 + 0x805fbc) =
         (uint)crank_fuel_mode_3_divisor * 0x280;
  }
  else {
    *(undefined4 *)((short)(crank_data_buffer_index * 2) * 8 + 0x805fc0) = 0;
    *(undefined4 *)((short)(crank_data_buffer_index * 2) * 8 + 0x805fbc) = 0;
  }
  crank_protection_threshold_time = 0;
  crank_protection_accumulator = 0;
  return;
}



/*
 * Function: crankAndProtectionStateMonitor @ 0x0002dfd0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint crankAndProtectionStateMonitor(void)

{
  undefined4 in_D0;
  uint uVar1;
  ushort uVar2;
  
  uVar1 = CONCAT22((short)((uint)in_D0 >> 0x10),vp44_status_flags_2) & 0xffff2000;
  if ((vp44_status_flags_2 & 0x2000) != 0) {
    if ((((current_engine_rpm == 0) && (system_logging_state == 2)) &&
        (crank_protection_state_index <= min_threshold_for_ambient_air_pressure_fuel_limiting_0_15))
       && (crank_protection_sample_counter < 0xc)) {
      crank_protection_state_flags = 0;
      if (crank_protection_sequence_flag == 1) {
        if (crank_protection_state_index ==
            min_threshold_for_ambient_air_pressure_fuel_limiting_0_15) {
          crank_protection_state_index = 0;
          crank_protection_sample_counter = 0;
        }
        crank_protection_state_index = crank_protection_state_index + 1;
      }
      else {
        crank_protection_state_index = 0;
      }
      if ((derate_status_byte & 8) != 0) {
        crank_protection_state_flags = 2;
      }
      if (crank_derate_status_previous == 1) {
        crank_protection_state_flags = crank_protection_state_flags | 1;
      }
      if (derate_threshold_exceeded == 1) {
        crank_protection_state_flags = crank_protection_state_flags | 8;
      }
      if (crank_derate_threshold_previous == 1) {
        crank_protection_state_flags = crank_protection_state_flags | 4;
      }
      if ((&crank_protection_sequence_table)[(short)crank_protection_sample_counter] ==
          crank_protection_state_flags) {
        crank_derate_threshold_previous = derate_threshold_exceeded;
        crank_derate_status_previous = (word)((derate_status_byte & 8) != 0);
        crank_protection_sample_counter = crank_protection_sample_counter + 1;
        if (4 < crank_protection_sample_counter) {
          crank_protection_sequence_flag = 1;
        }
      }
      if ((crank_protection_sample_counter == 0xc) &&
         (crank_initial_fuel_break_speed_0_1000 = 1, crank_data_buffer_enable_flag == 1)) {
        _crank_state_active_flag = 1;
      }
    }
    if (((current_engine_rpm != 0) && ((engine_fault_register_a & 0x100) != 0)) &&
       ((engine_fault_register_b & 0x100) != 0)) {
      if (engine_fault_a_timer == crank_debounce_threshold) {
        crank_fuel_status_flags = crank_fuel_status_flags | 1;
      }
      else {
        engine_fault_a_timer = engine_fault_a_timer + 1;
      }
    }
    if (((current_engine_rpm != 0) && ((engine_fault_register_a & 0x200) != 0)) &&
       ((engine_fault_register_b & 0x200) != 0)) {
      if (engine_fault_b_timer == crank_debounce_threshold) {
        crank_fuel_status_flags = crank_fuel_status_flags | 0x20;
      }
      else {
        engine_fault_b_timer = engine_fault_b_timer + 1;
      }
    }
    uVar1 = clutch_operating_time_total -
            *(int *)((short)(crank_fuel_buffer_index * 2) * 8 + 0x805fb4);
    crank_protection_time_delta = uVar1;
    if (crank_fuel_timing_buffer_value == 0) {
      crank_lookup_table_selector = 9;
      param_scaling_factor =
           lookupTableInterpolation((table_interp_args_t *)&crank_scaling_lookup_arg);
      uVar2 = (short)clutch_operating_time_total - crank_operating_time_previous;
      _crank_operating_time_snapshot = clutch_operating_time_total;
      uVar2 = (ushort)((uint)uVar2 * (uint)param_scaling_factor >> 8);
      if (-(uint)uVar2 - 1 < crank_protection_accumulator) {
        crank_fuel_status_flags = crank_fuel_status_flags | 8;
      }
      crank_protection_accumulator = uVar2 + crank_protection_accumulator;
      uVar1 = proportionalCalculation
                        (crank_protection_accumulator,0x6400,(uint)crank_protection_divisor * 0x280)
      ;
      crank_adjusted_initial_rpm_0_1000 = (word)uVar1;
      if ((crank_protection_threshold_time == 0) && (0x63ff < crank_adjusted_initial_fuel_0_100)) {
        crank_protection_threshold_time = crank_protection_time_delta;
      }
    }
    else if (crank_fuel_timing_buffer_value == 3) {
      uVar1 = proportionalCalculation(uVar1,0x6400,(uint)crank_fuel_mode_3_divisor * 0x280);
      crank_adjusted_initial_rpm_0_1000 = (word)uVar1;
    }
    else {
      crank_adjusted_initial_rpm_0_1000 = 0;
    }
    if ((crank_initial_advace_break_speed_0_1000 == 1) ||
       ((crank_initial_fuel_break_speed_0_1000 == 1 && (crank_data_buffer_enable_flag == 1)))) {
      uVar1 = crankDataBufferStore();
    }
  }
  return uVar1;
}



/*
 * Function: calibrationDataValidatorInit @ 0x0002e282
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void calibrationDataValidatorInit(void)

{
  ushort uVar1;
  table_interp_args_t local_10;
  
  uVar1 = 0;
  _crank_operating_time_snapshot = clutch_operating_time_total;
  crank_data_buffer_enable_flag = 1;
  crank_scaling_lookup_arg = 2;
  crank_calibration_table_ptr_1 =
       (dword)&delay_after_rpm_is_reached_before_ambient_air_pressure_errors_0_8000;
  crank_calibration_table_ptr_2 = 0x807188;
  local_10.current_index = 2;
  local_10.x_axis_ptr = 0x80888c;
  local_10.y_axis_ptr = (dword)&max_threshold_for_ambient_air_pressure_fuel_limiting_0_15;
  while ((uVar1 < 6 && (crank_data_buffer_enable_flag == 1))) {
    if ((*(char *)((int)&calibration_validator_ptr + (int)(short)uVar1) == '0') &&
       ((&calibration_validation_buffer)[(short)uVar1] == (byte)((char)uVar1 + 0x41U))) {
      uVar1 = uVar1 + 1;
    }
    else {
      crank_data_buffer_enable_flag = 0;
    }
  }
  if (crank_fuel_timing_buffer_value == 0) {
    local_10.input_value = param_scaling_lookup_value;
    crank_protection_divisor = lookupTableInterpolation(&local_10);
  }
  return;
}



/*
 * Function: engineParameterControllerWithTimer @ 0x0002e336
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineParameterControllerWithTimer(void)

{
  if (timer_capture_countdown != 0) {
    timer_capture_countdown = timer_capture_countdown - 1;
  }
  if (timer_capture_countdown == 0) {
    clutch_rpm_accumulator = 0;
  }
  else if (_timer_capture_raw < _timer_capture_low_threshold) {
    clutch_rpm_accumulator = clutch_rpm_low_value;
  }
  else if (_timer_capture_high_threshold < _timer_capture_raw) {
    clutch_rpm_accumulator = fuel_temp_throttle_threshold;
  }
  else {
    clutch_rpm_accumulator = (word)(clutch_rpm_calc_numerator / _timer_capture_raw);
  }
  throttle_position_value = coreTableInterpolation();
  return;
}



/*
 * Function: derateTablePointerInit @ 0x0002e3a8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void derateTablePointerInit(void)

{
  derate_table_init_flag = 0;
  derate_table_pointer = (dword)&derate_table_EPFLTB_008071a8;
  clutch_rpm_calc_numerator =
       proportionalCalculation
                 ((uint)qsm_newqp_multiplier * 0xe1000,500000,_derate_table_pointer_init);
  return;
}



/*
 * Function: boostPressureTargetCalculator @ 0x0002e3ee
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint boostPressureTargetCalculator(void)

{
  int iVar1;
  uint uVar2;
  undefined4 in_D0;
  uint uVar3;
  dword *pdVar4;
  ushort uVar5;
  word wVar6;
  word wVar7;
  
  uVar3 = CONCAT22((short)((uint)in_D0 >> 0x10),diagnostic_system_flags_1) & 0xffff0100;
  if ((diagnostic_system_flags_1 & 0x100) == 0) {
    boost_pressure_max_target = boost_pressure_target_pointer;
  }
  else {
    if (fuel_temp_protection_current < throttle_position_filtered) {
      iVar1 = (uint)throttle_position_filtered - (uint)fuel_temp_protection_current;
    }
    else {
      iVar1 = (uint)fuel_temp_protection_current - (uint)throttle_position_filtered;
    }
    if (throttle_position_filtered == 0) {
      pdVar4 = &firmware_vector_table_base;
    }
    else {
      pdVar4 = (dword *)((uint)(iVar1 * 0x6400) / (uint)throttle_position_filtered);
      if ((dword *)0x63ff < pdVar4) {
        pdVar4 = &firmware_vector_table_base;
      }
    }
    wVar7 = boost_pressure_target_pointer;
    wVar6 = boost_pressure_target_pointer;
    if ((_boost_pressure_rpm_comparison < (int)(uint)throttle_position_filtered) &&
       (wVar7 = boost_pressure_high_limit, wVar6 = boost_pressure_low_limit,
       _boost_pressure_rpm_threshold < (int)(uint)throttle_position_filtered)) {
      wVar7 = boost_pressure_high_limit - boost_pressure_high_offset;
      wVar6 = boost_pressure_low_limit - boost_pressure_low_offset;
    }
    uVar2 = (int)(short)boost_pressure_state_machine - 1;
    uVar3 = uVar2;
    if (uVar2 < 6) {
      uVar3 = CONCAT22((short)(uVar2 >> 0x10),(&switchD_0002e4d8::switchdataD_0002e4dc)[uVar2]);
      uVar5 = (ushort)pdVar4;
      switch(uVar2) {
      case 0:
        uVar3 = (uint)throttle_position_filtered;
        if (_boost_pressure_rpm_comparison < (int)uVar3) {
          boost_pressure_state_machine = 2;
          boost_pressure_max_target = wVar6;
        }
        else {
          boost_pressure_state_machine = 6;
          boost_pressure_max_target = wVar6;
        }
        break;
      case 1:
        boost_pressure_interp_state = 0x64000000;
        boost_pressure_interpolation_result = 0x6400;
        boost_pressure_state_machine = 3;
        boost_pressure_max_target = wVar6;
        break;
      case 2:
        boost_pressure_interpolation_result = coreTableInterpolation();
        uVar3 = (uint)throttle_position_filtered;
        if ((_boost_pressure_rpm_comparison < (int)uVar3) &&
           (uVar5 <= boost_pressure_state_3_threshold)) {
          uVar3 = (uint)boost_pressure_interpolation_result;
          if (boost_pressure_interpolation_result <= boost_pressure_interp_threshold) {
            boost_pressure_state_machine = 4;
          }
        }
        else {
          boost_pressure_state_machine = 1;
        }
        break;
      case 3:
        boost_pressure_max_target = throttle_position_value;
        if ((wVar7 <= throttle_position_value) &&
           (wVar7 = boost_pressure_max_target, wVar6 < throttle_position_value)) {
          wVar7 = wVar6;
        }
        boost_pressure_max_target = wVar7;
        boost_pressure_state_machine = 5;
        break;
      case 4:
        if (wVar7 < boost_pressure_max_target) {
          boost_pressure_max_target = boost_pressure_max_target - boost_pressure_decrement_rate;
        }
        uVar3 = (uint)throttle_position_filtered;
        if ((_boost_pressure_rpm_comparison < (int)uVar3) &&
           (uVar5 <= boost_pressure_state_3_threshold)) {
          uVar3 = (uint)smoke_limiter_output_value;
          if (boost_pressure_smoke_threshold < smoke_limiter_output_value) {
            boost_pressure_state_machine = 2;
          }
        }
        else {
          boost_pressure_state_machine = 1;
        }
        break;
      case 5:
        boost_pressure_active_flag = 0;
        uVar3 = (uint)throttle_position_filtered;
        if ((_boost_pressure_rpm_comparison < (int)uVar3) ||
           (boost_pressure_max_target = wVar6, boost_pressure_state_6_threshold < uVar5)) {
          boost_pressure_state_machine = 1;
          boost_pressure_max_target = wVar6;
        }
      }
    }
    if ((derate_status_byte & 8) != 0) {
      boost_pressure_state_machine = 5;
    }
    if (boost_pressure_state_machine != 6) {
      boost_pressure_active_flag = 1;
      return uVar3;
    }
  }
  return uVar3;
}



/*
 * Function: boostPressureControlStateInit @ 0x0002e5fe
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void boostPressureControlStateInit(void)

{
  uint uVar1;
  
  boost_pressure_state_machine = 1;
  boost_pressure_active_flag = 1;
  boost_pressure_max_target = boost_pressure_target_pointer;
  boost_pressure_interpolation_result = smoke_limiter_output_value;
  boost_pressure_interp_state = 0x64000000;
  boost_pressure_table_pointer = (dword)&boost_pressure_stats_threshold_71b6;
  _boost_pressure_rpm_comparison =
       ((uint)vp44_boost_pressure_reference *
       ((int)&firmware_vector_table_base + (uint)boost_pressure_offset_factor)) / 0x6400;
  if (time_duration_to_warn_driver_before_shutdown_due_to_fuel_tem_0_65535 <
      _boost_pressure_rpm_comparison) {
    _boost_pressure_rpm_comparison =
         (uint)time_duration_to_warn_driver_before_shutdown_due_to_fuel_tem_0_65535;
  }
  else {
    _boost_pressure_rpm_comparison = _boost_pressure_rpm_comparison & 0xffff;
  }
  uVar1 = (((int)&firmware_vector_table_base + (uint)boost_pressure_offset_factor) *
          (uint)vp44_timing_base_value) / 0x6400;
  if (time_duration_to_warn_driver_before_shutdown_due_to_fuel_tem_0_65535 < uVar1) {
    _boost_pressure_rpm_threshold =
         (uint)time_duration_to_warn_driver_before_shutdown_due_to_fuel_tem_0_65535;
    return;
  }
  _boost_pressure_rpm_threshold = uVar1 & 0xffff;
  return;
}



/*
 * Function: accumulatorWithOverflowCarry @ 0x0002e6c2
 */

undefined4 accumulatorWithOverflowCarry(uint *param_1,uint *param_2)

{
  dword dVar1;
  uint uVar2;
  ushort uVar3;
  
  dVar1 = clutch_rpm_proportional_calc_974c;
  uVar3 = 0;
  *param_1 = clutch_rpm_proportional_calc_974c + *param_1;
  if (0xfffff < *param_1) {
    uVar2 = *param_1 >> 0x14;
    uVar3 = (ushort)(-uVar2 - 1 <= *param_2);
    *param_2 = uVar2 + *param_2;
    dVar1 = uVar2 * 0x100000;
    *param_1 = *param_1 + uVar2 * -0x100000;
  }
  return CONCAT22((short)(dVar1 >> 0x10),uVar3);
}



/*
 * Function: fuelDemandStatisticsAccumulator @ 0x0002e702
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelDemandStatisticsAccumulator(void)

{
  if ((protection_system_enable_flag == 1) &&
     (((vp44_engine_state == 9 && (cached_parameter_value < current_fuel_demand_value)) ||
      ((vp44_engine_state != 9 &&
       ((cached_parameter_value < protection_fuel_limit_alternate || (active_derate_value == 0))))))
     )) {
    _fuel_demand_statistics_flags = _fuel_demand_statistics_flags + 1;
    fuel_demand_exceeded_counter_62a6 = fuel_demand_exceeded_counter_62a6 + 1;
    accumulatorWithOverflowCarry
              (&fuel_demand_exceeded_accumulator_629e,&fuel_demand_exceeded_arg_62aa);
  }
  if (vp44_engine_state == 10) {
    fuel_source_10_statistics_counter_628a = fuel_source_10_statistics_counter_628a + 1;
    accumulatorWithOverflowCarry
              (&fuel_source_10_time_accumulator_62a2,&fuel_source_10_time_arg_62ae);
  }
  return;
}



/*
 * Function: boostPressureStatisticsAccumulator @ 0x0002e786
 */

void boostPressureStatisticsAccumulator(void)

{
  if ((fuel_timing_control_value != 0) &&
     (boost_pressure_stats_threshold_71d4 < clutch_rpm_accumulator)) {
    accumulatorWithOverflowCarry
              ((uint *)&boost_pressure_stats_accumulator_625c,&boost_pressure_stats_arg_6292);
  }
  return;
}



/*
 * Function: fuelLimitExceedanceStatisticsAccumulator @ 0x0002e7b0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelLimitExceedanceStatisticsAccumulator(void)

{
  if (_boost_pressure_rpm_comparison < (int)(uint)fuel_temp_calculated_limit_971c) {
    fuel_temp_exceedance_timer = 0;
  }
  else if (fuel_temp_exceedance_timer < fuel_temp_exceedance_threshold) {
    fuel_temp_exceedance_timer = fuel_temp_exceedance_timer + 1;
  }
  else {
    fuel_temp_exceedance_counter_628e = fuel_temp_exceedance_counter_628e + 1;
    accumulatorWithOverflowCarry
              (&fuel_temp_exceedance_accumulator_62b6,&fuel_temp_exceedance_arg_62be);
  }
  if ((_boost_pressure_rpm_comparison < (int)(uint)fuel_temp_calculated_limit_971c) &&
     ((int)(uint)fuel_temp_calculated_limit_971c <= _boost_pressure_rpm_threshold)) {
    if (fuel_limit_near_threshold <= fuel_limit_near_exceedance_timer) {
      fuel_limit_exceedance_counter_1_6282 = fuel_limit_exceedance_counter_1_6282 + 1;
      accumulatorWithOverflowCarry
                (&fuel_limit_near_exceedance_accum_62b2,&fuel_limit_near_exceedance_arg_62ba);
      return;
    }
    fuel_limit_near_exceedance_timer = fuel_limit_near_exceedance_timer + 1;
    return;
  }
  fuel_limit_near_exceedance_timer = 0;
  return;
}



/*
 * Function: rpmHistogramAndProtectionStatisticsAccumulator @ 0x0002e84a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void rpmHistogramAndProtectionStatisticsAccumulator(void)

{
  ushort uVar1;
  
  if ((_rpm_protection_stats_index_62ca < throttle_position_value) && (active_derate_value != 0)) {
    _rpm_protection_stats_index_62ca = throttle_position_value;
  }
  uVar1 = throttle_position_value >> 8;
  if (uVar1 == 0) {
    _rpm_protection_statistics_buffer = _rpm_protection_statistics_buffer + 1;
  }
  else if (1 < uVar1) {
    if (uVar1 < 0x98) {
      *(int *)(&rpm_protection_statistics_buffer + (short)uVar1 * 4) =
           *(int *)(&rpm_protection_statistics_buffer + (short)uVar1 * 4) + 1;
    }
    else {
      rpm_protection_overflow_counter = rpm_protection_overflow_counter + 1;
    }
  }
  if ((high_rpm_protection_state == SHUTDOWN_PENDING) && (high_rpm_state_4_latch_flag == 0)) {
    rpm_protection_stats_counter = rpm_protection_stats_counter + 1;
    high_rpm_state_4_latch_flag = 1;
    high_rpm_state_3_latch_flag = 0;
  }
  if ((high_rpm_protection_state == FAULT_TRIGGERED) && (high_rpm_state_3_latch_flag == 0)) {
    rpm_protection_stats_accumulator = rpm_protection_stats_accumulator + 1;
    high_rpm_state_3_latch_flag = 1;
    high_rpm_state_4_latch_flag = 0;
  }
  if ((high_rpm_protection_state != SHUTDOWN_PENDING) &&
     (high_rpm_protection_state != FAULT_TRIGGERED)) {
    high_rpm_state_3_latch_flag = 0;
    high_rpm_state_4_latch_flag = 0;
  }
  return;
}



/*
 * Function: clutchOperatingStatisticsTracker @ 0x0002e8f2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort clutchOperatingStatisticsTracker(void)

{
  undefined4 uVar1;
  ushort uVar2;
  undefined4 *puVar3;
  
  if (fuel_statistics_init_flag == 1) {
    fuel_statistics_init_flag = 0;
    uVar2 = 0;
    puVar3 = (undefined4 *)&rpm_protection_statistics_buffer;
    do {
      *puVar3 = 0;
      uVar2 = uVar2 + 1;
      puVar3 = puVar3 + 1;
    } while (uVar2 < 0x97);
    _clutch_time_accumulator_1_6258 = 0;
    _boost_pressure_stats_accumulator_625c = 0;
    clutch_time_accumulator_2_6260 = 0;
    clutch_time_accumulator_3_6264 = 0;
    _clutch_transitions_counter_0_100 = 0;
    clutch_transition_accumulator_6274 = 0;
    clutch_statistics_status_flags_6278 = 0;
    derate_event_counter_627a = 0;
    clutch_slip_event_counter_627c = 0;
    _fuel_demand_statistics_flags = 0;
    fuel_limit_exceedance_counter_1_6282 = 0;
    fuel_source_10_statistics_counter_628a = 0;
    fuel_temp_exceedance_counter_628e = 0;
    boost_pressure_stats_arg_6292 = 0;
    derate_time_accumulator_6296 = 0;
    derate_time_accumulator_arg_629a = 0;
    fuel_demand_exceeded_accumulator_629e = 0;
    fuel_source_10_time_accumulator_62a2 = 0;
    fuel_demand_exceeded_counter_62a6 = 0;
    fuel_demand_exceeded_arg_62aa = 0;
    fuel_source_10_time_arg_62ae = 0;
    fuel_limit_near_exceedance_accum_62b2 = 0;
    fuel_temp_exceedance_accumulator_62b6 = 0;
    fuel_limit_near_exceedance_arg_62ba = 0;
    fuel_temp_exceedance_arg_62be = 0;
    rpm_protection_stats_counter = 0;
    rpm_protection_stats_accumulator = 0;
    _rpm_protection_stats_index_62ca = 0;
    clutch_rpm_proportional_calc_974c = 0;
    fuel_temp_protection_counter_1_5fa2 = 0;
    fuel_temp_protection_counter_2_5fa6 = 0;
  }
  uVar2 = diagnostic_system_flags_1 & 0x200;
  if (uVar2 != 0) {
    clutch_rpm_proportional_calc_974c =
         proportionalCalculation
                   ((uint)clutch_rpm_previous_32c8 + (uint)clutch_rpm_accumulator,0x20000,36000);
    if (engine_runtime_statistics_accumulator == 0) {
      if (clutch_rpm_proportional_calc_974c == 0) {
        clutch_statistics_ratio_calc_9750 = 0;
        fuel_economy_statistics_output = 0;
      }
      else {
        clutch_statistics_ratio_calc_9750 = 0xffffffff;
        fuel_economy_statistics_output = 0xffff;
      }
    }
    else {
      if (clutch_rpm_proportional_calc_974c / engine_runtime_statistics_accumulator < 0x7ff) {
        clutch_statistics_ratio_calc_9750 =
             proportionalCalculation
                       (clutch_rpm_proportional_calc_974c,0x200000,
                        engine_runtime_statistics_accumulator);
      }
      else {
        clutch_statistics_ratio_calc_9750 = 0xffffffff;
      }
      if (clutch_statistics_ratio_calc_9750 >> 0x10 < 0x10000) {
        fuel_economy_statistics_output = (word)(clutch_statistics_ratio_calc_9750 >> 0x10);
      }
      else {
        fuel_economy_statistics_output = 0xffff;
      }
    }
    uVar1 = accumulatorWithOverflowCarry
                      ((uint *)&clutch_time_accumulator_1_6258,
                       (uint *)&counts_time_percent_load_is_low_for_const_freq_alg_0_100);
    if ((short)uVar1 == 1) {
      clutch_statistics_status_flags_6278 = clutch_statistics_status_flags_6278 | 8;
    }
    uVar1 = accumulatorWithOverflowCarry
                      (&clutch_time_accumulator_2_6260,&clutch_operating_time_total);
    if ((short)uVar1 == 1) {
      clutch_statistics_status_flags_6278 = clutch_statistics_status_flags_6278 | 4;
    }
    uVar1 = accumulatorWithOverflowCarry
                      (&clutch_time_accumulator_3_6264,&clutch_transition_accumulator_6274);
    if ((short)uVar1 == 1) {
      clutch_statistics_status_flags_6278 = clutch_statistics_status_flags_6278 | 0x20;
    }
    if ((((engine_fault_register_a & 0x100) == 0) || ((engine_fault_register_b & 0x100) == 0)) &&
       (((engine_fault_register_a & 0x200) == 0 || ((engine_fault_register_b & 0x200) == 0)))) {
      fault_presence_timer = 0;
    }
    else if (the_minimum_time_a_fault_must_be_present_before_logged_in_trip_in_0_30 <
             fault_presence_timer) {
      clutch_statistics_status_flags_6278 = clutch_statistics_status_flags_6278 | 0x13;
    }
    else {
      fault_presence_timer = fault_presence_timer + 1;
    }
    if (clutch_operating_stats_value == 0) {
      if (clutch_transition_accumulator_6274 == 0) {
        _clutch_transitions_counter_0_100 = 0;
      }
      else {
        _clutch_transitions_counter_0_100 = 0xffffffff;
      }
    }
    else if (clutch_transition_accumulator_6274 / clutch_operating_stats_value < 0x3ff) {
      _clutch_transitions_counter_0_100 =
           proportionalCalculation
                     (clutch_transition_accumulator_6274,0x400000,clutch_operating_stats_value);
    }
    else {
      _clutch_transitions_counter_0_100 = 0xffffffff;
    }
    vehicle_distance_statistics_value = vehicle_distance_base_value + clutch_operating_time_total;
    vehicle_distance_clutch_value = clutch_transition_accumulator_6274;
    if (_clutch_transitions_counter_0_100 >> 0x11 < 0x10000) {
      clutch_transitions_per_distance = (word)(_clutch_transitions_counter_0_100 >> 0x11);
    }
    else {
      clutch_transitions_per_distance = 0xffff;
    }
    if ((derate_status_byte & 8) == 0) {
      derate_event_state_machine_32da = NO_DERATE;
    }
    else {
      if (derate_event_state_machine_32da == NO_DERATE) {
        derate_event_state_machine_32da = TIMING_ACTIVE;
        derate_event_timer_32ca = 0;
      }
      else if ((derate_event_state_machine_32da == TIMING_ACTIVE) &&
              (derate_event_timer_32ca < _derate_event_threshold_time)) {
        derate_event_timer_32ca = derate_event_timer_32ca + 1;
      }
      else {
        derate_event_counter_627a = derate_event_counter_627a + 1;
        derate_event_state_machine_32da = EVENT_COUNTED;
      }
      accumulatorWithOverflowCarry(&derate_time_accumulator_6296,&derate_time_accumulator_arg_629a);
    }
    clutch_sample_divider_32d0 = clutch_sample_divider_32d0 + 1;
    if (clutch_sample_divider_32d0 == 10) {
      clutch_sample_divider_32d0 = 0;
      _clutch_rpm_delta_32cc = (uint)clutch_rpm_previous_32c8 - (uint)clutch_rpm_accumulator;
      if ((clutch_slip_detection_state_32d8 == 0) &&
         (_clutch_slip_threshold <= _clutch_rpm_delta_32cc)) {
        clutch_slip_detection_state_32d8 = 1;
        clutch_slip_event_counter_627c = clutch_slip_event_counter_627c + 1;
      }
      else if (_clutch_rpm_delta_32cc < _clutch_slip_threshold) {
        clutch_slip_detection_state_32d8 = 0;
      }
      clutch_rpm_previous_32c8 = clutch_rpm_accumulator;
    }
    if (current_engine_rpm_raw != 0) {
      fuelDemandStatisticsAccumulator();
      boostPressureStatisticsAccumulator();
      fuelLimitExceedanceStatisticsAccumulator();
    }
    uVar2 = rpmHistogramAndProtectionStatisticsAccumulator();
  }
  return uVar2;
}



/*
 * Function: statisticsTrackingFlagsReset @ 0x0002ecec
 */

void statisticsTrackingFlagsReset(void)

{
  derate_event_state_machine_32da = NO_DERATE;
  clutch_slip_detection_state_32d8 = 0;
  high_rpm_state_4_latch_flag = 0;
  high_rpm_state_3_latch_flag = 0;
  return;
}



/*
 * Function: timerCaptureAverageCalculator @ 0x0002ed06
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined8 timerCaptureAverageCalculator(void)

{
  undefined4 in_D0;
  undefined4 in_D1;
  
  can1_canidmr2 = can1_canidmr2 & 0xfffb;
  timer_capture_countdown = timer_capture_init_value;
  _timer_capture_raw = _QSM_SPCR2;
  _QSM_SPCR2 = _QSM_SPCR2 & 0xffff;
  if (engine_rpm_source_selector == 0) {
    if (timer_capture_delta_count == 0) {
      _timer_capture_average = 0;
    }
    else {
      _timer_capture_average = rpm_period_accumulator / timer_capture_delta_count;
    }
    rpm_period_accumulator = 0;
    timer_capture_delta_count = 0;
  }
  else if (engine_rpm_source_selector == 1) {
    if (timer_capture_sample_count == 0) {
      _timer_capture_average = 0;
    }
    else {
      _timer_capture_average = timer_capture_accumulator / timer_capture_sample_count;
    }
    timer_capture_accumulator = 0;
    timer_capture_sample_count = 0;
  }
  return CONCAT44(in_D0,in_D1);
}



/*
 * Function: timerCaptureHardwareInit @ 0x0002ed96
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void timerCaptureHardwareInit(void)

{
  can1_canidmr2 = can1_canidmr2 & 0xfffb;
  timer_capture_hardware_init_address = (dword)timerCaptureAverageCalculator;
  can1_cantxerr = can1_cantxerr & 0xf0ff | 0xd00;
  QSM_NEWQP = qsm_newqp_multiplier << 8;
  QSM_SPCR1 = 0;
  _QSM_SPCR2 = 0;
  QSM_SPCR3 = 0xb;
  can1_canidar1 = can1_canidar1 & 0xffcf | 0x30;
  can1_canidar3 = can1_canidar3 & 0xffcf | 0x30;
  can1_cantbsel = can1_cantbsel & 0xfffb | 4;
  can1_canidmr1 = can1_canidmr1 & 0xffcf | 0x20;
  return;
}



/*
 * Function: vp44FaultThresholdTablesInit @ 0x0002ee28
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FaultThresholdTablesInit(void)

{
  vp44_fault_accumulator_1 = 0;
  _vp44_fault_accumulator_2 = 0;
  vp44_fault_protection_counter_5fec = 0;
  vp44_protection_threshold_value = 0;
  vp44_fault_protection_timer = 0;
  vp44_fault_protection_counter_5ff2 = 0;
  vp44_fuel_table_lookup_1 = coreTableInterpolation();
  vp44_fuel_table_lookup_2 = coreTableInterpolation();
  vp44_timing_table_lookup_1 = coreTableInterpolation();
  vp44_timing_table_lookup_2 = coreTableInterpolation();
  return;
}



/*
 * Function: vp44FaultProtectionController @ 0x0002eeac
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FaultProtectionController(void)

{
  bool bVar1;
  uint uVar2;
  ushort uVar3;
  short sVar4;
  word wVar5;
  dword *pdVar6;
  
  if (vp44_fault_protection_init_flag == 0) {
    if (((((engine_fault_register_a & 0x100) != 0) && ((engine_fault_register_b & 0x100) != 0)) ||
        (((engine_fault_register_a & 0x200) != 0 && ((engine_fault_register_b & 0x200) != 0)))) &&
       (vp44_fault_protection_threshold < fuel_arbitrator_threshold_2)) {
      fuel_arbitrator_threshold_2 = vp44_fault_protection_threshold;
    }
    uVar2 = proportionalCalculation
                      ((uint)boost_pressure_target_pointer,
                       (uint)vp44_boost_pressure_reference *
                       ((uint)vp44_fault_calc_factor_1 * (uint)vp44_fault_calc_factor_2 >> 7 &
                       0xffff) >> 0xb & 0xffff,0x100);
    uVar2 = proportionalCalculation(uVar2,8,0x3c);
    if (uVar2 < 0x10000) {
      vp44_fault_threshold_calc = (word)uVar2;
    }
    else {
      vp44_fault_threshold_calc = 0xffff;
    }
    sVar4 = (short)((uint)vp44_boost_pressure_reference * (uint)vp44_fault_tolerance_factor >> 0xb);
    vp44_fuel_limit_upper = sVar4 + vp44_boost_pressure_reference;
    vp44_fuel_limit_lower = vp44_boost_pressure_reference - sVar4;
    uVar3 = vp44_timing_base_value;
    if (0x7ffc < vp44_timing_base_value) {
      uVar3 = vp44_timing_base_value - 1;
    }
    sVar4 = (short)((uint)uVar3 * (uint)vp44_fault_tolerance_factor >> 0xb);
    vp44_timing_limit_upper = sVar4 + uVar3;
    vp44_timing_limit_lower = uVar3 - sVar4;
    vp44_fault_protection_init_flag = 1;
  }
  if (((((vp44_status_flags_2 & 0x100) != 0) && (vp44_fault_detection_enable != 0)) &&
      (clutch_rpm_accumulator == 0)) &&
     ((vp44_throttle_threshold < throttle_position_value && ((derate_status_byte & 8) == 0)))) {
    vp44_fault_source_code = 2;
    fuel_arbitrator_threshold_2 = vp44_fault_protection_threshold;
    engine_fault_register_a = engine_fault_register_a | 0x100;
    engine_fault_register_c = engine_fault_register_c | 0x100;
  }
  if ((((vp44_status_flags_2 & 0x200) != 0) && (oil_pressure_protection_enabled == 0)) &&
     ((vp44_fault_detection_enable != 0 && (throttle_position_value == 0)))) {
    if ((vp44_derate_exceeded_previous == 0) && (derate_threshold_exceeded == 1)) {
      vp44_derate_exceeded_counter = vp44_derate_exceeded_counter + 1;
    }
    if (blank_spot_for_esdn_backwards_compatibility_0_0_1 < current_engine_rpm) {
      if ((~vp44_derate_bit8_previous & (derate_status_byte & 8) != 0) != 0) {
        vp44_derate_bit8_counter = vp44_derate_bit8_counter + 1;
      }
      if ((~vp44_derate_bit4_previous & (derate_status_byte & 4) != 0) != 0) {
        vp44_derate_bit4_counter = vp44_derate_bit4_counter + 1;
      }
    }
    if ((fueling_value_above_which_wet_stack_timing_is_set_to_zero_0_100 <=
         vp44_derate_exceeded_counter) &&
       ((vp44_derate_bit8_limit <= vp44_derate_bit8_counter ||
        (vp44_derate_bit4_limit <= vp44_derate_bit4_counter)))) {
      vp44_fault_source_code = 1;
      fuel_arbitrator_threshold_2 = vp44_fault_protection_threshold;
      engine_fault_register_a = engine_fault_register_a | 0x100;
      engine_fault_register_c = engine_fault_register_c | 0x100;
    }
  }
  if (((clutch_rpm_accumulator != 0) || (oil_pressure_protection_enabled == 1)) ||
     (((vp44_status_flags_2 & 0x100) == 0 && ((vp44_status_flags_2 & 0x200) == 0)))) {
    if (((engine_fault_register_a & 0x100) != 0) && ((engine_fault_register_c & 0x100) == 0)) {
      engine_fault_register_a = engine_fault_register_a & 0xfeff;
      fuel_arbitrator_threshold_2 = oil_pressure_precrank_status;
    }
    vp44_derate_exceeded_counter = 0;
    vp44_derate_bit4_counter = 0;
    vp44_derate_bit8_counter = 0;
  }
  if (((vp44_fault_detection_enable != 0) && (oil_pressure_protection_enabled == 0)) &&
     ((vp44_status_flags_1 & 0x80) != 0)) {
    if (((engine_fault_register_a & 0x100) == 0) || ((engine_fault_register_b & 0x100) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (((engine_fault_register_a & 0x200) == 0) || ((engine_fault_register_b & 0x200) == 0)) {
        if (fuel_temp_throttle_threshold < throttle_position_value) {
          if ((vp44_fault_mode_flags & 1) != 0) {
            if ((short)vp44_fuel_temp_previous < (short)fuel_temp_calculated_limit_971c) {
              uVar3 = fuel_temp_calculated_limit_971c - vp44_fuel_temp_previous;
            }
            else {
              uVar3 = vp44_fuel_temp_previous - fuel_temp_calculated_limit_971c;
            }
            if (vp44_fuel_temp_delta_threshold < uVar3) {
              if (vp44_fault_protection_counter_5fec == 0) {
                vp44_fault_protection_counter_5fec = 1;
                vp44_clutch_rpm_snapshot = clutch_rpm_accumulator;
              }
              else {
                vp44_fuel_temp_previous = fuel_temp_calculated_limit_971c;
              }
            }
            if (vp44_fault_protection_counter_5fec != 0) {
              if (vp44_fault_counter_threshold_1 < vp44_fault_protection_counter_5fec) {
                if (vp44_fault_protection_timer < vp44_fault_timer_threshold) {
                  vp44_fault_protection_counter_5ff2 = vp44_fault_protection_counter_5ff2 + 1;
                  if (vp44_fault_counter_threshold_2 < vp44_fault_protection_counter_5ff2) {
                    engine_fault_register_a = engine_fault_register_a | 0x200;
                    engine_fault_register_c = engine_fault_register_c | 0x200;
                    vp44_fault_source_code = 3;
                    fuel_arbitrator_threshold_2 = vp44_fault_protection_threshold;
                  }
                  else {
                    vp44_fault_protection_counter_5fec = 0;
                    vp44_fault_protection_timer = 0;
                  }
                }
                else {
                  vp44_fault_protection_counter_5fec = 0;
                  vp44_fault_protection_timer = 0;
                }
              }
              else {
                vp44_fault_protection_counter_5fec = vp44_fault_protection_counter_5fec + 1;
                if (smoke_limiter_output_value < vp44_smoke_limiter_threshold) {
                  vp44_fault_protection_timer = vp44_fault_protection_timer + 1;
                }
                if ((short)vp44_clutch_rpm_snapshot < (short)clutch_rpm_accumulator) {
                  uVar3 = clutch_rpm_accumulator - vp44_clutch_rpm_snapshot;
                }
                else {
                  uVar3 = vp44_clutch_rpm_snapshot - clutch_rpm_accumulator;
                }
                if (vp44_clutch_rpm_delta_threshold < uVar3) {
                  vp44_fault_protection_counter_5fec = 0;
                  vp44_fault_protection_counter_5ff2 = 0;
                  vp44_fault_protection_timer = 0;
                  vp44_clutch_rpm_snapshot = clutch_rpm_accumulator;
                  vp44_fuel_temp_previous = fuel_temp_calculated_limit_971c;
                }
              }
            }
          }
          if ((vp44_fault_mode_flags & 4) != 0) {
            pdVar6 = &oil_pressure_fault_table_ptr;
            wVar5 = current_engine_rpm_raw;
            vp44_fuel_table_lookup_1 = coreTableInterpolation();
            vp44_fuel_table_lookup_2 = coreTableInterpolation(0x80,wVar5,pdVar6);
            if (vp44_fault_counter_limit_1 < vp44_fault_accumulator_1) {
              engine_fault_register_a = engine_fault_register_a | 0x200;
              engine_fault_register_c = engine_fault_register_c | 0x200;
              vp44_fault_source_code = 4;
              fuel_arbitrator_threshold_2 = vp44_fault_protection_threshold;
            }
            else if (((fuel_temp_protection_threshold_flag == 0) ||
                     (vp44_fuel_table_lookup_1 <= vp44_fault_threshold_calc)) ||
                    (vp44_fuel_table_lookup_2 <= vp44_table_compare_threshold)) {
              vp44_fault_accumulator_1 = 0;
            }
            else {
              vp44_fault_accumulator_1 = vp44_fault_accumulator_1 + 1;
            }
          }
          if ((vp44_fault_mode_flags & 2) != 0) {
            pdVar6 = &oil_pressure_table_3_pointer;
            wVar5 = current_engine_rpm_raw;
            vp44_timing_table_lookup_1 = coreTableInterpolation();
            vp44_timing_table_lookup_2 = coreTableInterpolation(0x80,wVar5,pdVar6);
            if (_vp44_fault_counter_limit_2 < _vp44_fault_accumulator_2) {
              engine_fault_register_a = engine_fault_register_a | 0x200;
              engine_fault_register_c = engine_fault_register_c | 0x200;
              vp44_fault_source_code = 5;
              fuel_arbitrator_threshold_2 = vp44_fault_protection_threshold;
            }
            else if (((fuel_temp_calculated_limit_971c == vp44_fuel_limit_upper) ||
                     (fuel_temp_calculated_limit_971c == vp44_fuel_limit_lower)) ||
                    (((fuel_temp_calculated_limit_971c == vp44_timing_limit_upper ||
                      ((fuel_temp_calculated_limit_971c == vp44_timing_limit_lower ||
                       (vp44_timing_table_lookup_1 <= vp44_fault_threshold_calc)))) ||
                     (vp44_timing_table_lookup_2 <= vp44_table_compare_threshold)))) {
              _vp44_fault_accumulator_2 = 0;
            }
            else {
              _vp44_fault_accumulator_2 = _vp44_fault_accumulator_2 + 1;
            }
          }
        }
        else {
          vp44FaultThresholdTablesInit();
        }
      }
      else if ((vp44_protection_recovery_threshold < vp44_protection_threshold_value) ||
              ((((vp44_fault_mode_flags & 1) == 0 && ((vp44_fault_mode_flags & 2) == 0)) &&
               ((vp44_fault_mode_flags & 4) == 0)))) {
        if (((engine_fault_register_a & 0x200) != 0) && ((engine_fault_register_c & 0x200) == 0)) {
          engine_fault_register_a = engine_fault_register_a & 0xfdff;
          fuel_arbitrator_threshold_2 = oil_pressure_precrank_status;
          vp44FaultThresholdTablesInit();
        }
      }
      else if (throttle_position_value == 0 && current_engine_rpm == 0) {
        vp44_protection_threshold_value = vp44_protection_threshold_value + 1;
      }
      else {
        vp44_protection_threshold_value = 0;
      }
      goto LAB_0002f5b6;
    }
  }
  if ((((vp44_status_flags_1 & 0x80) == 0) && ((engine_fault_register_a & 0x200) != 0)) &&
     ((engine_fault_register_c & 0x200) == 0)) {
    engine_fault_register_a = engine_fault_register_a & 0xfdff;
    fuel_arbitrator_threshold_2 = oil_pressure_precrank_status;
  }
  vp44FaultThresholdTablesInit();
LAB_0002f5b6:
  vp44_derate_bit8_previous = -((derate_status_byte & 8) != 0) & 1;
  vp44_derate_bit4_previous = -((derate_status_byte & 4) != 0) & 1;
  vp44_derate_exceeded_previous = derate_threshold_exceeded;
  return;
}



/*
 * Function: oilPressureTablePointersInit @ 0x0002f5f2
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void oilPressureTablePointersInit(void)

{
  _oil_pressure_table_1_offset = 0;
  oil_pressure_fault_table_ptr = 0x8071ec;
  _oil_pressure_table_2_offset = 0;
  oil_pressure_table_1_pointer = 0x8071ec;
  _oil_pressure_table_3_offset = 0;
  oil_pressure_table_3_pointer = 0x8071f6;
  _oil_pressure_table_4_offset = 0;
  oil_pressure_table_4_pointer = 0x8071f6;
  vp44_fuel_temp_previous = 0x7ffd;
  vp44_fault_mode_flags =
       *(word *)((uint)(byte)((byte)oil_pressure_mode_flag_1 |
                             (char)oil_pressure_mode_flag_2 * '\x02') * 2 + 0x8071fc);
  return;
}



/*
 * Function: oilPressureFuelArbitrationMonitor @ 0x0002f662
 */

ushort oilPressureFuelArbitrationMonitor(void)

{
  word wVar1;
  
  wVar1 = oil_pressure_debounce_counter;
  if (oil_pressure_protection_enabled == 1) {
    if ((diagnostic_system_flags_2 & 0x8000) == 0) {
      oil_pressure_debounce_counter = 0;
      fuel_arbitrator_threshold_4 = oil_pressure_precrank_status;
      return diagnostic_system_flags_2 & 0x8000;
    }
    if (oil_pressure_throttle_threshold <= throttle_position_value) {
      oil_pressure_debounce_counter = 0;
      fuel_arbitrator_threshold_4 = oil_pressure_precrank_status;
      return throttle_position_value;
    }
    if (oil_pressure_debounce_counter <= oil_pressure_debounce_threshold) {
      oil_pressure_debounce_counter = oil_pressure_debounce_counter + 1;
      return wVar1;
    }
    fuel_arbitrator_threshold_4 = vp44_fault_protection_threshold;
    return oil_pressure_debounce_counter;
  }
  if ((diagnostic_system_flags_2 & 0x8000) != 0) {
    if (oil_pressure_throttle_threshold <= throttle_position_value) {
      oil_pressure_debounce_counter = 0;
      fuel_arbitrator_threshold_4 = oil_pressure_precrank_status;
      return throttle_position_value;
    }
    if (oil_pressure_debounce_counter <= oil_pressure_debounce_threshold) {
      oil_pressure_debounce_counter = oil_pressure_debounce_counter + 1;
      return wVar1;
    }
    fuel_arbitrator_threshold_4 = vp44_fault_protection_threshold;
    return oil_pressure_debounce_counter;
  }
  if (oil_pressure_throttle_threshold <= throttle_position_value) {
    oil_pressure_debounce_counter = 0;
    fuel_arbitrator_threshold_4 = oil_pressure_precrank_status;
    return throttle_position_value;
  }
  if (oil_pressure_debounce_counter <= oil_pressure_debounce_threshold) {
    oil_pressure_debounce_counter = oil_pressure_debounce_counter + 1;
    return wVar1;
  }
  fuel_arbitrator_threshold_4 = vp44_fault_protection_threshold;
  return oil_pressure_debounce_counter;
}



/*
 * Function: protectionLimitValueInit @ 0x0002f748
 */

void protectionLimitValueInit(void)

{
  fuel_arbitrator_threshold_4 = oil_pressure_precrank_status;
  return;
}



/*
 * Function: fuelDemandLimitSelector4 @ 0x0002f754
 */

void fuelDemandLimitSelector4(void)

{
  if (fuel_limit_floor_value < fuel_limit_minimum_value) {
    fuel_demand_limit_selector_state = fuel_limit_minimum_value;
    fuel_limit_minimum_value = fuel_limit_floor_value;
    fuel_demand_source_id = FUEL_LIMIT_FLOOR;
  }
  return;
}



/*
 * Function: fuelDemandUpdateOrchestrator @ 0x0002f778
 */

void fuelDemandUpdateOrchestrator(void)

{
  fuelDemandLimitSelector11();
  timingAccumulatorUpdate();
  fuelAdjustmentWithFlagUpdate();
  timingAccumulatorClampedUpdate();
  fuelDemandLimitMinimumUpdater();
  fuelLimitMinimumSelector();
  fuelDemandLimitSelector4();
  engineModeTransitionStateUpdater();
  fuelDemandState24Override();
  return;
}



/*
 * Function: diagnosticModeFuelArbitrationHandler @ 0x0002f7ac
 */

void diagnosticModeFuelArbitrationHandler(void)

{
  diagnostic_fuel_arbitration_state_d486 = fuel_limit_minimum_value;
  if (vp44_engine_state == FAULT_EMERGENCY_STATE) {
    diagnostic_fuel_arbitration_output = diagnostic_fuel_arbitration_state_10_value;
    diagnostic_fuel_arbitration_state_c9b4 = 10;
    fuel_adjustment_active_flag = 0;
  }
  else if (vp44_engine_state == HIGH_PERFORMANCE_MODE) {
    diagnostic_fuel_arbitration_output = diagnostic_fuel_arbitration_state_9_value;
    diagnostic_fuel_arbitration_state_c9b4 = 9;
    fuel_adjustment_active_flag = 0;
  }
  else if (vp44_engine_state == IDLE_STATE) {
    diagnostic_fuel_arbitration_output = 0;
    diagnostic_fuel_arbitration_state_c9b4 = 8;
    fuel_adjustment_active_flag = 0;
  }
  else if ((fuel_demand_control_flags & 8) == 0) {
    diagnostic_fuel_arbitration_output = fuel_limit_minimum_value;
    diagnostic_fuel_arbitration_state_c9b4 = fuel_demand_source_id;
  }
  else {
    diagnostic_fuel_arbitration_output = diagnostic_mode_fuel_limit_value;
    diagnostic_fuel_arbitration_state_c9b4 = 7;
    fuel_adjustment_active_flag = 0;
  }
  diagnostic_fuel_arbitration_write_flag = fuel_adjustment_active_flag;
  fuel_adjustment_active_flag = 0;
  return;
}



/*
 * Function: shutdownMinimumSelector28 @ 0x0002f83e
 */

void shutdownMinimumSelector28(void)

{
  if (shutdown_minimum_init_value < shutdown_limit_accumulator) {
    shutdown_limit_accumulator = shutdown_minimum_init_value;
    shutdown_minimum_selector_value = SHUTDOWN_MINIMUM_INIT;
  }
  return;
}



/*
 * Function: shutdownMinimumSelector20 @ 0x0002f85c
 */

void shutdownMinimumSelector20(void)

{
  if ((fuel_arbitrator_diag_t_0080cff8.rpm_target == 3) &&
     (fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_ < shutdown_limit_accumulator)) {
    shutdown_limit_accumulator = fuel_arbitrator_diag_t_0080cff8.prev_state_pointer._1_2_;
    shutdown_minimum_selector_value = FUEL_ARBITRATOR_DIAG;
  }
  return;
}



/*
 * Function: shutdownMinimumSelectorOrchestrator @ 0x0002f884
 */

void shutdownMinimumSelectorOrchestrator(void)

{
  shutdown_limit_accumulator = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
  shutdownMinimumSelector17();
  shutdownMinimumSelector16();
  shutdownMinimumSelector15();
  shutdownMinimumSelector19();
  shutdownMinimumSelector29();
  shutdownMinimumSelector20();
  shutdownMinimumSelector28();
  shutdownMinimumSelector21();
  return;
}



/*
 * Function: masterSubsystemInit @ 0x0002f8b8
 */

void masterSubsystemInit(void)

{
  fuelParameterPointerSetup();
  timingParameterPointerSetup();
  dmaDescriptorSetup1();
  fuelLimitParameterPointerSetup();
  shutdown_minimum_init_value = max_number_of_shutdowns_before_restart_is_not_allowed_0_255;
  return;
}



/*
 * Function: dualTableLookupSum @ 0x0002f8dc
 */

void dualTableLookupSum(void)

{
  short sVar1;
  short sVar2;
  
  diagnostic_rpm_setpoint_saved = diagnostic_target_rpm_setpoint;
  diagnostic_throttle_saved = throttle_position_raw;
  sVar1 = lookupTableInterpolation((table_interp_args_t *)&interpolation_table_2_size);
  sVar2 = lookupTableInterpolation((table_interp_args_t *)&interpolation_wscltatb_size);
  governor_reference_fuel = sVar1 + sVar2;
  return;
}



/*
 * Function: interpolationTableSetup @ 0x0002f920
 */

void interpolationTableSetup(void)

{
  diagnostic_rpm_setpoint_saved = diagnostic_target_rpm_setpoint;
  interpolation_table_1_ptr = 0x80720a;
  interpolation_wscltatb_ptr = (dword)&WSCLTATB;
  interpolation_wscltatb_size = 2;
  diagnostic_throttle_saved = throttle_position_raw;
  interpolation_table_2_ptr = 0x807232;
  interpolation_table_3_ptr = 0x807246;
  interpolation_table_2_size = 2;
  return;
}



/*
 * Function: vp44ExtendedProcessingRouter @ 0x0002f96e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44ExtendedProcessingRouter(void)

{
  if (_vp44_extended_processing_enable != 0) {
    vp44DiagnosticModeStateMachine();
    return;
  }
  vp44StateProcessor();
  return;
}



/*
 * Function: vp44StateVariablesInit @ 0x0002f986
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44StateVariablesInit(void)

{
  if (_vp44_extended_processing_enable != 0) {
    vp44ControlVariablesReset();
    return;
  }
  output_timing_base_value = 0;
  vp44_state_output_timing_base = 0;
  vp44_operating_condition_value = RESET_INACTIVE;
  vp44_state_operating_condition_cached = RESET_INACTIVE;
  vp44_state_input_current = STATE_4_DEFAULT;
  vp44_state_previous = STATE_4_DEFAULT;
  vp44_state_current_debounced = STATE_4_DEFAULT;
  vp44_state_debounce_value_333e = STATE_4_DEFAULT;
  vp44_state_debounce_countdown = 0;
  vp44_state_processing_timeout_counter = vp44_state_processing_timeout_reload;
  return;
}



/*
 * Function: vp44StateProcessor @ 0x0002f9e0
 */

void vp44StateProcessor(void)

{
  uint uVar1;
  undefined4 uVar2;
  
  vp44_state_current_debounced = vp44StateDebounceFilter();
  output_timing_base_value = vp44StateToControlModeMapper();
  uVar1 = vp44FaultStateCodeMapper();
  vp44_diagnostic_mode_state = (VP44_DIAG_MODE)uVar1;
  uVar2 = vp44OperatingConditionChecker();
  if ((short)uVar2 == 0) {
    if (vp44_state_current_debounced == STATE_2_MONITOR) {
      vp44_diagnostic_mode_state = vp44State2TransitionHandler();
    }
    else if (vp44_state_current_debounced == STATE_1_ACTIVE) {
      uVar2 = vp44State1TransitionHandler();
      vp44_diagnostic_mode_state = (VP44_DIAG_MODE)uVar2;
    }
    else {
      uVar1 = vp44State3Or4TransitionChecker();
      if ((short)uVar1 != 0) {
        vp44_diagnostic_mode_state = vp44StateOutputSelector();
      }
    }
  }
  else {
    uVar2 = vp44FuelControlConditionChecker();
    if ((short)uVar2 == 0) {
      vp44_diagnostic_mode_state = EXIT_DISABLED;
    }
    else {
      vp44_diagnostic_mode_state = INACTIVE;
    }
  }
  vp44_state_previous = vp44_state_input_current;
  vp44_state_operating_condition_cached = vp44_operating_condition_value;
  vp44_state_output_timing_base = output_timing_base_value;
  vp44_state_debounce_value_333e = vp44_state_current_debounced;
  return;
}



/*
 * Function: vp44StateDebounceFilter @ 0x0002fa84
 */

short vp44StateDebounceFilter(void)

{
  vp44_state_input_current = vp44_state_debounce_value_938c;
  if (vp44_state_debounce_threshold < 2) {
    return vp44_state_debounce_value_938c;
  }
  if (vp44_state_debounce_value_938c == vp44_state_debounce_value_333e) {
    vp44_state_debounce_countdown = 2;
    return vp44_state_debounce_value_333e;
  }
  if (vp44_state_debounce_value_938c != vp44_state_previous) {
    if (1 < vp44_state_debounce_countdown) {
      vp44_state_debounce_countdown = vp44_state_debounce_countdown - 1;
      return vp44_state_debounce_value_333e;
    }
    return 4;
  }
  if ((int)(uint)vp44_state_debounce_countdown < (int)(vp44_state_debounce_threshold - 1)) {
    vp44_state_debounce_countdown = vp44_state_debounce_countdown + 1;
    return 4;
  }
  return vp44_state_debounce_value_938c;
}



/*
 * Function: vp44StateToControlModeMapper @ 0x0002fb08
 */

undefined2 vp44StateToControlModeMapper(void)

{
  if (vp44_state_current_debounced == STATE_5_FAULT) {
    return 1;
  }
  if (vp44_state_current_debounced == STATE_0_IDLE) {
    return 0;
  }
  return vp44_state_output_timing_base;
}



/*
 * Function: vp44OperatingConditionChecker @ 0x0002fb28
 */

undefined4 vp44OperatingConditionChecker(void)

{
  if (((((((diagnostic_system_flags_1 & 0x40) != 0) && (output_timing_base_value != 0)) &&
        (insite_fuel_timing_display <= boost_pressure_feedback)) &&
       (((derate_status_byte & 4) == 0 &&
        (shutdown_threshold_for_intake_temp_fuel_50_293 < current_engine_rpm_raw)))) &&
      (((derate_status_byte & 8) == 0 &&
       ((fuel_temp_limit_delta == 0 ||
        (shutdown_delay_for_engine_sync_fuel_pressure_shutdown_0_255 == 0)))))) &&
     ((vp44_operating_condition_value != FUEL_CONTROL_B &&
      (vp44_operating_condition_value != FUEL_CONTROL_A)))) {
    return 0;
  }
  return 1;
}



/*
 * Function: vp44FuelControlConditionChecker @ 0x0002fba2
 */

undefined4 vp44FuelControlConditionChecker(void)

{
  if ((((diagnostic_system_flags_1 & 0x40) != 0) && (output_timing_base_value != 0)) &&
     (vp44_diagnostic_mode_state_2 != INACTIVE)) {
    return 0;
  }
  return 1;
}



/*
 * Function: vp44State2TransitionHandler @ 0x0002fbc8
 */

VP44_DIAG_MODE vp44State2TransitionHandler(void)

{
  VP44_DIAG_MODE VVar1;
  
  VVar1 = vp44_diagnostic_mode_state;
  if (protection_system_enable_flag == 0) {
    if (shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535 <= boost_pressure_feedback) {
      VVar1 = BOOST_PRESSURE_INIT;
    }
  }
  else if (vp44_state_debounce_value_333e == STATE_2_MONITOR) {
    if (vp44_state_processing_timeout_counter == 0) {
      VVar1 = SENSOR_BIT2_PROTECTION;
    }
    else {
      vp44_state_processing_timeout_counter = vp44_state_processing_timeout_counter - 1;
    }
  }
  else {
    vp44_state_processing_timeout_counter = vp44_state_processing_timeout_reload;
    if ((int)((uint)boost_pressure_feedback - (uint)target_boost_pressure_base) <
        (int)(uint)vp44_state2_transition_param) {
      VVar1 = SENSOR_TYPE_1_MODE;
    }
    else if (shutdown_duration_threshold_for_fuel_pressure_rpm_0_65535 <= boost_pressure_feedback) {
      VVar1 = BOOST_PRESSURE_INIT;
    }
  }
  return VVar1;
}



/*
 * Function: vp44State1TransitionHandler @ 0x0002fc40
 */

undefined4 vp44State1TransitionHandler(void)

{
  undefined2 uVar1;
  undefined4 in_D0;
  VP44_DIAG_MODE VVar2;
  
  uVar1 = (undefined2)((uint)in_D0 >> 0x10);
  VVar2 = vp44_diagnostic_mode_state;
  if (protection_system_enable_flag != 0) {
    if (vp44_state_debounce_value_333e == STATE_1_ACTIVE) {
      if (vp44_state_processing_timeout_counter == 0) {
        uVar1 = 0;
        VVar2 = SENSOR_BIT8_TRIGGERED;
      }
      else {
        vp44_state_processing_timeout_counter = vp44_state_processing_timeout_counter - 1;
      }
    }
    else {
      vp44_state_processing_timeout_counter = vp44_state_processing_timeout_reload;
      uVar1 = 0;
      VVar2 = SENSOR_TYPE_0_MODE;
    }
  }
  return CONCAT22(uVar1,VVar2);
}



/*
 * Function: vp44State3Or4TransitionChecker @ 0x0002fc76
 */

uint vp44State3Or4TransitionChecker(void)

{
  uint in_D0;
  
  if (((vp44_state_current_debounced != STATE_3_TRANSITION) &&
      ((vp44_state_operating_condition_cached == TRANSITION_STATE_4 ||
       (vp44_operating_condition_value != TRANSITION_STATE_4)))) &&
     ((vp44_state_operating_condition_cached == TRANSITION_STATE_3 ||
      (vp44_operating_condition_value != TRANSITION_STATE_3)))) {
    return in_D0 & 0xffff0000;
  }
  return 1;
}



/*
 * Function: vp44StateOutputSelector @ 0x0002fcac
 */

undefined2 vp44StateOutputSelector(void)

{
  if ((protection_system_enable_flag == 0) && (vp44_diagnostic_mode_state_2 != INACTIVE)) {
    return 2;
  }
  return vp44_diagnostic_mode_state;
}



/*
 * Function: vp44FaultStateCodeMapper @ 0x0002fcc8
 */

uint vp44FaultStateCodeMapper(void)

{
  uint in_D0;
  
  if (protection_system_enable_flag != 0) {
    return 7;
  }
  if (vp44_diagnostic_mode_state_2 != INACTIVE) {
    return 8;
  }
  return in_D0 & 0xffff0000;
}



/*
 * Function: diagnosticFuelOverrideHandler @ 0x0002fce4
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void diagnosticFuelOverrideHandler(void)

{
  if (((vp44_timing_override_state == 9) && (diagnostic_fuel_control_mode == 8)) &&
     (diagnostic_rpm_threshold_status < vp44_timing_override_counter)) {
    _output_control_can_state = vp44_timing_override_counter;
  }
  if (output_control_decrement_step < _output_control_can_state) {
    _output_control_can_state = _output_control_can_state - output_control_decrement_step;
  }
  else {
    _output_control_can_state = 0;
  }
  if (((diagnostic_rpm_threshold_status < _output_control_can_state) &&
      (diagnostic_fuel_control_mode == 8)) &&
     ((fuel_temp_protection_threshold_flag == 0 || (diagnostic_fuel_override_param != 0)))) {
    diagnostic_rpm_threshold_status = _output_control_can_state;
  }
  vp44_timing_override_state = diagnostic_fuel_control_mode;
  vp44_timing_override_counter = current_fuel_demand_value;
  return;
}



/*
 * Function: vp44TimingStateInit @ 0x0002fd5e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44TimingStateInit(void)

{
  _output_control_can_state = 0;
  vp44_timing_override_state = 8;
  vp44_timing_override_counter = 0;
  return;
}



/*
 * Function: vp44InjectionTimingSlowCycle40Coordinator @ 0x0002fd74
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44InjectionTimingSlowCycle40Coordinator(void)

{
  bool bVar1;
  
  if (vp44_injection_system_active == 1) {
    vp44_injection_timing_counter = 0;
  }
  if (vp44_injection_timing_counter < vp44_injection_timing_limit) {
    vp44_injection_timing_counter = vp44_injection_timing_counter + 1;
    if (((fault_flags_active_base & 0x8000) == 0) || ((fault_flags_enabled_base & 0x8000) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (((io_fault_status_reg_3 & 0x1000) == 0) || ((vp44_timing_param_1 & 0x1000) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        vp44_injection_timing_state = vp44_injection_timing_state_copy;
        goto LAB_0002fdf2;
      }
    }
    vp44_injection_timing_state = vp44_timing_coordinator_value;
  }
  else {
    vp44_injection_timing_state = intake_manifold_temp_raw;
  }
LAB_0002fdf2:
  _output_control_intake_temp_value = (uint)vp44_injection_timing_state;
  return;
}



/*
 * Function: vp44TimingValuesInit @ 0x0002fdfe
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44TimingValuesInit(void)

{
  vp44_injection_timing_state = intake_manifold_temp_raw;
  _output_control_intake_temp_value = (uint)intake_manifold_temp_raw;
  vp44_injection_timing_counter = vp44_injection_timing_limit;
  return;
}



/*
 * Function: engineModeOutputControlInit @ 0x0002fe20
 */

ushort engineModeOutputControlInit(void)

{
  if ((vp44_flag_register_1 & 0x40) != 0) {
    output_control_timer_value = 0;
    io_control_flags = io_control_flags & 0xf9;
    output_control_state_flags = 1;
    vp44_communication_status_9a0a = 0;
    engine_mode_output_control_state_9a0c = 0;
    output_timing_config_word_1 = 0;
    output_timing_state_previous = 0;
    output_control_idle_timeout_threshold = 10;
    output_control_active_flag = 0;
    output_control_table_2_ptr = 0x807292;
    output_control_table_2_size = 2;
    output_control_table_1_ptr = 0x807278;
    output_control_table_7_size = 2;
    output_control_table_7_ptr = 0x8072ac;
    output_control_table_8_size = 2;
    output_control_table_8_ptr = 0x8072bc;
    output_control_table_9_ptr = 0x8072c6;
    output_control_table_4_ptr = 0x807318;
    output_control_table_4_size = 2;
    output_control_table_3_ptr = 0x8072fe;
    output_control_table_6_ptr = 0x80733e;
    output_control_table_6_size = 2;
    output_control_table_5_ptr = 0x807332;
  }
  return vp44_flag_register_1 & 0x40;
}



/*
 * Function: engineModeOutputControlStateMachine @ 0x0002ff3a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint engineModeOutputControlStateMachine(void)

{
  bool bVar1;
  undefined4 in_D0;
  uint uVar2;
  uint uVar3;
  
  if ((vp44_flag_register_1 & 0x40) == 0) {
    return CONCAT22((short)((uint)in_D0 >> 0x10),vp44_flag_register_1) & 0xffff0040;
  }
  if ((throttle_position_threshold_for_output < throttle_position_value) &&
     (output_control_timer_value == 4)) {
    engine_mode_output_control_state_9a0c = 2;
    output_control_timer_value = 5;
    goto LAB_000300ac;
  }
  if (((io_fault_status_reg_2 & 0x1000) == 0) ||
     ((_engine_mode_output_control_state_68ce & 0x1000) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (bVar1) {
LAB_0002ffea:
    engine_mode_output_control_state_9a0c = 3;
    output_control_timer_value = 5;
  }
  else {
    if (((io_fault_status_reg_2 & 0x800) == 0) ||
       ((_engine_mode_output_control_state_68ce & 0x800) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (bVar1) goto LAB_0002ffea;
    if (((retarder_input_threshold_for_state < retarder_input_value) &&
        (output_control_timer_value != 0)) && (output_control_timer_value != 3)) {
      output_control_timer_value = 5;
    }
  }
  if ((output_timing_config_word_3 == 0) && (output_control_timer_value == 3)) {
    engine_mode_output_control_state_9a0c = 4;
    output_control_timer_value = 5;
  }
  else {
    if (((engine_operating_mode == FAULT_EMERGENCY) || (engine_operating_mode == ENGINE_IDLE)) &&
       ((output_control_timer_value == 4 || (output_control_timer_value == 3)))) {
      output_control_idle_counter = output_control_idle_counter + 1;
    }
    else {
      output_control_idle_counter = 0;
    }
    if ((output_control_idle_timeout_threshold <= output_control_idle_counter) &&
       ((output_control_timer_value == 3 || (output_control_timer_value == 4)))) {
      output_control_timer_value = 2;
    }
  }
  if (output_control_timer_value == 0) {
    output_control_timer_value = 1;
  }
  else if (output_control_timer_value == 1) {
    output_control_timer_value = 2;
  }
  else if (((engine_operating_mode == LOW_RPM_RUNNING) ||
           (engine_operating_mode == TRANSITIONAL_MODE_6)) && (output_control_timer_value == 2)) {
    output_control_timer_value = 3;
  }
  else if ((((engine_operating_mode == HIGH_RPM_RUNNING) ||
            (engine_operating_mode == VP44_INJECTION_ACTIVE)) ||
           ((engine_operating_mode == TRANSITIONAL_MODE_7 ||
            (engine_operating_mode == HIGH_PERFORMANCE)))) &&
          ((output_control_timer_value == 2 || (output_control_timer_value == 3)))) {
    output_control_timer_value = 4;
  }
LAB_000300ac:
  uVar2 = (uint)(short)output_control_timer_value;
  uVar3 = uVar2;
  if (uVar2 < 6) {
    uVar3 = CONCAT22((short)output_control_timer_value >> 0xf,
                     (&switchD_000300ba::switchdataD_000300be)[uVar2]);
    switch(uVar2) {
    case 1:
      uVar3 = outputControlState1Handler();
      break;
    case 2:
      uVar3 = outputControlState2Handler();
      break;
    case 3:
      uVar3 = outputControlState3Handler();
      break;
    case 4:
      uVar3 = outputControlState4Handler();
      break;
    case 5:
      uVar3 = outputControlState5FaultHandler();
    }
  }
  if (vp44_communication_status_9a0a == 1) {
    io_control_flags = io_control_flags & 0xfb | 2;
  }
  else if (vp44_communication_status_9a0a == 2) {
    io_control_flags = io_control_flags & 0xfd | 4;
  }
  else if (vp44_communication_status_9a0a == 3) {
    io_control_flags = io_control_flags | 6;
  }
  else if (vp44_communication_status_9a0a == 4) {
    io_control_flags = io_control_flags & 0xf9;
  }
  if (((vp44_communication_status_9a0a == 1) || (vp44_communication_status_9a0a == 2)) ||
     (vp44_communication_status_9a0a == 3)) {
    if (((output_timing_config_word_1 != 1) && (output_timing_config_word_1 != 2)) &&
       (output_timing_config_word_1 != 3)) {
      output_control_timing_reset_counter = output_control_timing_reset_countdown;
    }
    if (output_control_timing_reset_counter == 0) {
      io_control_flags = io_control_flags & 0xf9;
    }
    else {
      output_control_timing_reset_counter = output_control_timing_reset_counter - 1;
    }
  }
  output_timing_state_previous = output_control_timer_value;
  output_timing_config_word_1 = vp44_communication_status_9a0a;
  return uVar3;
}



/*
 * Function: outputControlState1Handler @ 0x000301a6
 */

void outputControlState1Handler(void)

{
  output_control_sensor_input_cached = sensor_fault_rpm_source_value;
  output_control_interpolation_result =
       lookupTableInterpolation((table_interp_args_t *)&output_control_table_4_size);
  if (output_control_interpolation_result != 0) {
    output_timing_config_word_2 = output_control_interpolation_result;
    io_control_flags = io_control_flags | 6;
    output_control_status_byte = output_control_status_byte | 4;
    output_control_state_flags = output_control_state_flags & 0xfe;
    output_control_state_flags = output_control_state_flags | 2;
    output_control_lookup_failure_flag = 0;
    return;
  }
  engine_mode_output_control_state_9a0c = 6;
  io_control_flags = io_control_flags & 0xf9;
  output_control_lookup_failure_flag = 1;
  return;
}



/*
 * Function: outputControlState2Handler @ 0x00030226
 */

void outputControlState2Handler(void)

{
  if ((output_control_state_flags & 0x10) != 0) {
    output_control_state_flags = output_control_state_flags & 0xef;
    output_control_state_flags = output_control_state_flags | 0x40;
  }
  if ((output_control_state_flags & 0x20) != 0) {
    output_control_state_flags = output_control_state_flags & 0xdf;
    output_control_state_flags = output_control_state_flags | 0x40;
  }
  if (output_timing_config_word_2 == 0) {
    io_control_flags = io_control_flags & 0xf9;
    if (output_control_lookup_failure_flag == 0) {
      output_control_status_byte = output_control_status_byte & 0xfb;
    }
    if (output_control_interpolation_result != 0) {
      output_control_state_flags = output_control_state_flags & 0xfd;
      output_control_state_flags = output_control_state_flags | 8;
    }
  }
  else {
    io_control_flags = io_control_flags | 6;
    output_control_status_byte = output_control_status_byte | 4;
    output_timing_config_word_2 = output_timing_config_word_2 - 1;
  }
  output_timing_config_word_3 = output_timing_interpolation_base_ptr;
  output_timing_state_selector = 100;
  return;
}



/*
 * Function: outputControlState3Handler @ 0x000302c6
 */

void outputControlState3Handler(void)

{
  io_control_flags = io_control_flags & 0xf9;
  output_control_status_byte = output_control_status_byte & 0xfb;
  if (output_timing_config_word_3 != 0) {
    output_timing_config_word_3 = output_timing_config_word_3 - 1;
  }
  if ((output_control_state_flags & 2) != 0) {
    output_control_state_flags = output_control_state_flags & 0xfd;
    output_control_state_flags = output_control_state_flags | 4;
  }
  output_control_state_flags = output_control_state_flags | 0x10;
  output_timing_config_word_2 = 0;
  return;
}



/*
 * Function: outputControlState4Handler @ 0x00030314
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void outputControlState4Handler(void)

{
  bool bVar1;
  byte bVar2;
  word *pwVar3;
  undefined8 uVar4;
  
  if ((output_timing_state_previous != 4) &&
     (output_control_status_byte = output_control_status_byte & 0xfb,
     output_control_countdown_timer != 0)) {
    engine_mode_output_control_state_9a0c = 8;
    output_control_countdown_timer = output_control_countdown_timer - 1;
    outputControlState5FaultHandler();
    return;
  }
  if (output_control_active_flag == 0) {
    bVar1 = (uint)sensor_fault_rpm_source_value <=
            (uint)output_control_rpm_offset + (uint)sensor_fault_rpm_threshold;
    if (bVar1) {
      output_control_rpm_workspace = sensor_fault_rpm_source_value;
    }
    else {
      output_control_rpm_workspace = sensor_fault_rpm_threshold;
    }
    output_control_state_4_write_flag._0_1_ = !bVar1;
    output_control_rpm_workspace_2 = output_control_rpm_workspace;
    output_control_timing_value =
         lookupTableInterpolation((table_interp_args_t *)&output_control_table_2_size);
    if (output_control_timing_value == 6) {
      if (output_timing_state_selector != 0) {
        output_timing_state_selector = output_timing_state_selector - 1;
      }
      if (output_timing_state_selector == 0) {
        engine_mode_output_control_state_9a0c = 6;
        outputControlState5FaultHandler();
        return;
      }
      io_control_flags = io_control_flags & 0xf9;
      return;
    }
    if ((output_control_throttle_limit < throttle_position_raw) &&
       (output_control_rpm_limit < output_control_rpm_workspace)) {
      engine_mode_output_control_state_9a0c = 7;
      outputControlState5FaultHandler();
      return;
    }
    bVar2 = 0;
    pwVar3 = &output_state_timing_delay_base;
    do {
      output_control_timing_workspace = output_control_timing_value;
      output_control_index_workspace = (word)bVar2;
      uVar4 = tableInterpolationLookup((short *)&output_control_table_7_size);
      *pwVar3 = (word)((ulonglong)uVar4 >> 0x20);
      bVar2 = bVar2 + 1;
      pwVar3 = pwVar3 + 1;
    } while (bVar2 < 5);
    _output_control_state_selector = 6;
    output_sequence_state = 0;
    output_control_state_4_value = 1;
    output_control_state_sequencer = 0;
    output_timing_cycle_counter = 0;
    output_control_timing_state_9a08 = 2;
    output_control_active_flag = 1;
  }
  else {
    output_control_state_sequencer = output_control_state_sequencer + 1;
  }
  output_control_state_flags = output_control_state_flags & 0xee;
  output_control_state_flags = output_control_state_flags | 0x20;
  if (output_control_fuel_threshold <= current_fuel_demand_value) {
    output_timing_cycle_counter = output_timing_cycle_counter + 1;
  }
  if (output_timing_cycle_counter < output_control_cycle_limit) {
    if (((output_control_timing_value == 0) || (output_control_timing_value == 1)) ||
       (output_control_timing_value == 2)) {
      outputControlStateToModeMapper();
    }
    else {
      outputControlStateMachineSelector();
    }
    if (output_sequence_state == 4) {
      output_control_state_flags = output_control_state_flags & 0xdf;
      output_control_state_flags = output_control_state_flags | 0x80;
      outputControlState5FaultHandler();
    }
    else {
      outputControlTimingGenerator();
    }
  }
  else {
    engine_mode_output_control_state_9a0c = 9;
    outputControlState5FaultHandler();
  }
  _output_control_state_selector = output_sequence_state;
  return;
}



/*
 * Function: outputControlStateToModeMapper @ 0x00030542
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void outputControlStateToModeMapper(void)

{
  if (output_control_state_4_value == 0) {
    if (_output_control_state_selector == 0) {
      output_sequence_state = 1;
      return;
    }
    if (_output_control_state_selector == 1) {
      output_sequence_state = 2;
      return;
    }
    if (_output_control_state_selector == 2) {
      output_sequence_state = 4;
    }
  }
  return;
}



/*
 * Function: outputControlStateMachineSelector @ 0x00030578
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint outputControlStateMachineSelector(void)

{
  undefined2 uVar1;
  undefined4 in_D0;
  uint uVar2;
  
  uVar1 = (undefined2)((uint)in_D0 >> 0x10);
  uVar2 = CONCAT22(uVar1,output_control_state_4_value | _output_control_state_selector);
  if ((output_control_state_4_value | _output_control_state_selector) == 0) {
    uVar2 = CONCAT22(uVar1,current_engine_rpm);
    if (output_sequence_rpm_threshold < current_engine_rpm) {
      output_sequence_state = 1;
      return uVar2;
    }
    output_sequence_state = 2;
    return uVar2;
  }
  if (_output_control_state_selector == 1) {
    if (output_control_state_4_value == 0) {
      output_sequence_state = 3;
      return uVar2;
    }
    uVar2 = (uint)output_sequence_rpm_threshold - (uint)output_sequence_rpm_hysteresis;
    if ((int)(uint)current_engine_rpm < (int)uVar2) {
      output_sequence_state = 2;
      return uVar2;
    }
  }
  else if (_output_control_state_selector == 2) {
    if (output_control_state_4_value == 0) {
      output_sequence_state = 4;
      return uVar2;
    }
    uVar2 = (uint)output_sequence_rpm_hysteresis + (uint)output_sequence_rpm_threshold;
    if (uVar2 < current_engine_rpm) {
      uVar2 = (uint)output_state_1_timing_offset + (uint)output_state_timing_delay_base;
      if ((uint)output_control_state_sequencer <
          (uint)output_state_1_timing_offset + (uint)output_state_timing_delay_base) {
        output_sequence_state = 1;
        return uVar2;
      }
      output_sequence_state = 3;
      return uVar2;
    }
  }
  else if (_output_control_state_selector == 3) {
    if (output_control_state_4_value == 0) {
      output_sequence_state = 4;
      return uVar2;
    }
    uVar2 = (uint)output_sequence_rpm_threshold - (uint)output_sequence_rpm_hysteresis;
    if ((int)(uint)current_engine_rpm < (int)uVar2) {
      output_sequence_state = 2;
    }
  }
  return uVar2;
}



/*
 * Function: outputControlTimingGenerator @ 0x0003068a
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void outputControlTimingGenerator(void)

{
  bool bVar1;
  
  if (output_sequence_state == _output_control_state_selector) {
    output_control_timing_state_33b0 = 0;
    bVar1 = false;
  }
  else {
    if ((((output_control_timing_value == 0) || (output_control_timing_value == 1)) ||
        (output_control_timing_value == 2)) || (output_sequence_state == 0)) {
      output_timing_interpolation_result =
           (&output_state_timing_delay_base)[(short)output_sequence_state];
    }
    else if (((output_control_timing_value == 3) || (output_control_timing_value == 4)) ||
            (output_control_timing_value == 5)) {
      if (output_sequence_state == 1) {
        output_timing_interpolation_result =
             (output_state_1_timing_offset + output_state_timing_delay_base) -
             output_control_state_sequencer;
      }
      else if (output_sequence_state == 2) {
        output_timing_interpolation_result =
             (output_state_2_timing_offset + output_state_timing_delay_base) -
             output_control_state_sequencer;
      }
      else if (output_sequence_state == 3) {
        output_timing_interpolation_result =
             (output_state_3_timing_offset +
             output_state_1_timing_offset + output_state_timing_delay_base) -
             output_control_state_sequencer;
      }
    }
    output_control_sequence_state = output_sequence_state;
    output_timing_duty_lookup_result =
         lookupTableInterpolation((table_interp_args_t *)&output_control_table_6_size);
    output_control_timing_state_33b0 = 1;
    bVar1 = true;
    output_control_state_4_value = 1;
  }
  if (bVar1) {
    output_timing_duration_countdown = output_timing_interpolation_result;
    output_timing_cycle_divider = 0x65;
    output_timing_duty_cycle_counter =
         (short)(((uint)output_timing_duty_lookup_result * 100) / 100) + 1;
    if (output_control_timing_state_9a08 == 1) {
      output_control_timing_state_9a08 = 2;
    }
    else {
      output_control_timing_state_9a08 = 1;
    }
  }
  if (output_timing_duration_countdown == 0) {
    output_control_state_4_value = 0;
    return;
  }
  output_timing_duration_countdown = output_timing_duration_countdown - 1;
  if (output_timing_duty_cycle_counter != 0) {
    output_timing_duty_cycle_counter = output_timing_duty_cycle_counter - 1;
  }
  output_timing_cycle_divider = output_timing_cycle_divider - 1;
  if (output_timing_cycle_divider == 0) {
    output_timing_cycle_divider = 100;
    output_timing_duty_cycle_counter = (word)(((uint)output_timing_duty_lookup_result * 100) / 100);
    if (output_control_timing_state_9a08 == 1) {
      output_control_timing_state_9a08 = 2;
    }
    else {
      output_control_timing_state_9a08 = 1;
    }
  }
  if (output_timing_duty_cycle_counter == 0) {
    io_control_flags = io_control_flags & 0xf9;
    return;
  }
  if (output_sequence_state == 0) {
    io_control_flags = io_control_flags | 6;
    return;
  }
  if (output_control_timing_state_9a08 == 1) {
    io_control_flags = io_control_flags & 0xfb | 2;
    return;
  }
  io_control_flags = io_control_flags & 0xfd | 4;
  return;
}



/*
 * Function: outputControlState5FaultHandler @ 0x00030896
 */

void outputControlState5FaultHandler(void)

{
  output_control_timer_value = 5;
  io_control_flags = io_control_flags & 0xf9;
  output_control_status_byte = output_control_status_byte & 0xfb;
  if ((output_control_state_flags & 2) != 0) {
    output_control_state_flags = output_control_state_flags & 0xfd;
    output_control_state_flags = output_control_state_flags | 4;
  }
  if ((output_control_state_flags & 0x10) != 0) {
    output_control_state_flags = output_control_state_flags & 0xef;
    output_control_state_flags = output_control_state_flags | 0x40;
  }
  if ((output_control_state_flags & 0x20) != 0) {
    output_control_state_flags = output_control_state_flags & 0xdf;
    output_control_state_flags = output_control_state_flags | 0x40;
  }
  if (engine_mode_output_control_state_9a0c == 0) {
    engine_mode_output_control_state_9a0c = 1;
  }
  return;
}



/*
 * Function: sensorFaultBasedRpmSourceSelector @ 0x00030914
 */

ushort sensorFaultBasedRpmSourceSelector(void)

{
  bool bVar2;
  ushort uVar1;
  
  uVar1 = vp44_flag_register_1 & 0x40;
  if (uVar1 != 0) {
    if (((fault_flags_active_base & 0x4000) == 0) || ((fault_flags_enabled_base & 0x4000) == 0)) {
      bVar2 = false;
    }
    else {
      bVar2 = true;
    }
    if (!bVar2) {
      if (((fault_flags_active_base & 0x2000) == 0) || ((fault_flags_enabled_base & 0x2000) == 0)) {
        bVar2 = false;
      }
      else {
        bVar2 = true;
      }
      if (!bVar2) {
        sensor_fault_rpm_source_value = intake_manifold_temp_raw;
        return 0;
      }
    }
    if (((engine_fault_status_register_1 & 2) == 0) ||
       ((engine_fault_confirmation_register & 2) == 0)) {
      uVar1 = 0;
    }
    else {
      uVar1 = 1;
    }
    if (uVar1 == 0) {
      if (((engine_fault_status_register_1 & 1) == 0) ||
         ((engine_fault_confirmation_register & 1) == 0)) {
        uVar1 = 0;
      }
      else {
        uVar1 = 1;
      }
      if (uVar1 == 0) {
        sensor_fault_rpm_source_value = throttle_position_raw;
        return 0;
      }
    }
    sensor_fault_rpm_source_value = sensor_fault_rpm_selector_param;
  }
  return uVar1;
}



/*
 * Function: faultBasedOutputStateCalculator @ 0x000309da
 */

ushort faultBasedOutputStateCalculator(void)

{
  ushort uVar1;
  word wVar2;
  
  uVar1 = vp44_flag_register_1 & 0x40;
  if (uVar1 != 0) {
    if ((short)fso_monitoring_command_value < 0xcd1) {
      wVar2 = fso_monitoring_command_value;
      if ((short)fso_monitoring_command_value < -800) {
        wVar2 = 0xfce0;
      }
    }
    else {
      wVar2 = 0xcd0;
    }
    if (((engine_fault_status_register_3 & 0x100) == 0) ||
       ((vp44_fso_fault_enable_mask & 0x100) == 0)) {
      uVar1 = 0;
    }
    else {
      uVar1 = 1;
    }
    if (uVar1 == 0) {
      if (((engine_fault_status_register_3 & 0x80) == 0) ||
         ((vp44_fso_fault_enable_mask & 0x80) == 0)) {
        uVar1 = 0;
      }
      else {
        uVar1 = 1;
      }
      if (uVar1 == 0) {
        if (((engine_fault_status_register_3 & 0x40) == 0) ||
           ((vp44_fso_fault_enable_mask & 0x40) == 0)) {
          uVar1 = 0;
        }
        else {
          uVar1 = 1;
        }
        if (uVar1 == 0) {
          sensor_fault_rpm_threshold = wVar2 * 8 + 0x1900;
          return 0;
        }
      }
    }
    sensor_fault_rpm_threshold = sensor_fault_rpm_source_value;
  }
  return uVar1;
}



/*
 * Function: outputControlFlagsInit @ 0x00030a8e
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void outputControlFlagsInit(void)

{
  output_control_mode_state_variable = 1;
  _output_control_flags_state = 1;
  io_control_flags = io_control_flags | 0x10;
  engine_mode_io_control_counter = engine_mode_io_control_timeout_initial;
  engine_mode_io_control_flags = 1;
  output_control_state_transition_flag = 0;
  return;
}



/*
 * Function: engineModeBasedIoController @ 0x00030ac0
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void engineModeBasedIoController(void)

{
  if (output_control_io_override_enable_flag != 0) {
    if (output_control_io_override_condition_flag == 0) {
      io_control_flags = io_control_flags & 0xef;
      return;
    }
    io_control_flags = io_control_flags | 0x10;
    return;
  }
  switch(engine_operating_mode) {
  case ENGINE_IDLE:
  case FAULT_EMERGENCY:
    _output_control_flags_state = 1;
    break;
  case LOW_RPM_RUNNING:
  case TRANSITIONAL_MODE_6:
  case TRANSITIONAL_MODE_7:
    _output_control_flags_state = 2;
    break;
  case HIGH_RPM_RUNNING:
  case VP44_INJECTION_ACTIVE:
    _output_control_flags_state = 3;
    break;
  case HIGH_PERFORMANCE:
    _output_control_flags_state = 4;
  }
  if (engine_control_system_ready != 0) {
    engine_mode_io_control_flags = 0;
    output_control_mode_state_variable = 1;
    io_control_flags = io_control_flags & 0xef;
    return;
  }
  if (_output_control_flags_state == 3) {
    if (output_control_mode_state_variable != 3) {
      output_control_state_transition_flag = 1;
      engine_mode_io_control_flags = 1;
      io_control_flags = io_control_flags | 0x10;
    }
  }
  else if ((output_control_mode_state_variable == _output_control_flags_state) &&
          (engine_mode_io_control_counter != 0)) {
    engine_mode_io_control_counter = engine_mode_io_control_counter - 1;
  }
  else if (_output_control_flags_state == 1) {
    if (output_control_mode_state_variable == 1) {
      if (engine_mode_io_control_flags != 0) {
        engine_mode_io_control_flags = 0;
        io_control_flags = io_control_flags & 0xef;
      }
    }
    else {
      if (output_control_state_transition_flag == 0) {
        engine_mode_io_control_counter = output_control_state_1_transition_delay_alt;
      }
      else {
        engine_mode_io_control_counter = output_control_state_1_transition_delay_primary;
      }
      io_control_flags = io_control_flags | 0x10;
      engine_mode_io_control_flags = 1;
    }
  }
  else if (_output_control_flags_state == 2) {
    if (output_control_mode_state_variable == 2) {
      if (engine_mode_io_control_flags == 0) {
        engine_mode_io_control_flags = 1;
        io_control_flags = io_control_flags | 0x10;
        engine_mode_io_control_counter = output_control_state_2_transition_threshold;
      }
      else {
        engine_mode_io_control_flags = 0;
        io_control_flags = io_control_flags & 0xef;
        engine_mode_io_control_counter = output_control_state_transition_countdown;
      }
    }
    else {
      engine_mode_io_control_flags = 0;
      io_control_flags = io_control_flags & 0xef;
      engine_mode_io_control_counter = output_control_state_transition_countdown;
    }
  }
  else if (_output_control_flags_state == 4) {
    engine_mode_io_control_flags = 0;
    io_control_flags = io_control_flags & 0xef;
  }
  output_control_mode_state_variable = _output_control_flags_state;
  return;
}



/*
 * Function: fuelDemandTablePointersInit @ 0x00030c3e
 */

void fuelDemandTablePointersInit(void)

{
  fuel_demand_table_2_size = 2;
  fuel_demand_table_2_ptr_33cc = 0x80735c;
  fuel_demand_table_3_size = 2;
  fuel_demand_table_1_ptr_33c4 = 0x807352;
  fuel_demand_table_3_ptr_33d2 = 0x807366;
  fuel_demand_limit_previous = 0;
  rpm_load_parameter_lookup_result = 0;
  return;
}



/*
 * Function: rpmLoadParameterLookup @ 0x00030c78
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint rpmLoadParameterLookup(void)

{
  undefined4 in_D0;
  uint uVar1;
  undefined8 uVar2;
  
  uVar1 = CONCAT22((short)((uint)in_D0 >> 0x10),vp44_flag_register_1) & 0xffff0001;
  if ((vp44_flag_register_1 & 1) != 0) {
    rpm_load_lookup_input = diagnostic_sensor_reading;
    _rpm_load_lookup_result_ptr = current_engine_rpm;
    uVar2 = tableInterpolationLookup((short *)&fuel_demand_table_3_size);
    uVar1 = (uint)((ulonglong)uVar2 >> 0x20);
    rpm_load_parameter_lookup_result = (word)((ulonglong)uVar2 >> 0x20);
  }
  return uVar1;
}



/*
 * Function: fuelDemandLimitSelector11 @ 0x00030cb0
 */

ushort fuelDemandLimitSelector11(void)

{
  ushort uVar1;
  
  uVar1 = vp44_flag_register_1 & 1;
  if (((vp44_flag_register_1 & 1) != 0) && (fuel_demand_source_id == TABLE_BLEND_CALC)) {
    fuel_demand_limit_previous = fuel_limit_minimum_value;
    uVar1 = rpm_load_parameter_lookup_result;
    if (fuel_limit_minimum_value < rpm_load_parameter_lookup_result) {
      fuel_limit_minimum_value = rpm_load_parameter_lookup_result;
      fuel_demand_source_id = VP44_FLAG_REGISTER;
    }
  }
  return uVar1;
}



/*
 * Function: simTimerControlInit @ 0x00030cec
 */

uint simTimerControlInit(void)

{
  undefined4 in_D0;
  
  rpm_derate_duty_cycle = 0;
  delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535 = 0;
  if ((dtc_active_fault_count & 1) != 0) {
    sim_timer_control_register = ((uint)pwm_output_scaling_factor * 8000) / 1000 << 0x10;
    return sim_timer_control_register;
  }
  sim_timer_control_register = sim_timer_control_register & 0xffff0000;
  return CONCAT22((short)((uint)in_D0 >> 0x10),dtc_active_fault_count) & 0xffff0001;
}



/*
 * Function: rpmDerateCalculationController @ 0x00030d40
 */

uint rpmDerateCalculationController(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  
  uVar1 = (uint)(short)rpm_derate_calculation_table_ptr;
  if (uVar1 < 0x10) {
    uVar3 = (uint)(ushort)((short)rpm_derate_calculation_table_ptr >> 0xf) << 0x10;
    switch(uVar1) {
    default:
      uVar3 = (uint)active_derate_value * 0x50 >> 2;
      rpm_derate_percent_scaled = (word)uVar3;
      break;
    case 3:
    case 4:
    case 5:
      if ((short)fuel_demand_percentage < 1) {
        rpm_derate_percent_scaled = 0;
      }
      else {
        uVar3 = (uint)((short)fuel_demand_percentage * 0x50) >> 8;
        rpm_derate_percent_scaled = (word)((uint)((short)fuel_demand_percentage * 0x50) >> 8);
      }
      break;
    case 6:
    case 7:
    case 8:
      uVar3 = 0;
      rpm_derate_percent_scaled = (word)((uint)asthrfes_calc_input * 0x50 >> 8);
      break;
    case 9:
    case 10:
      rpm_derate_percent_scaled = rpm_derate_scaling_factor;
      break;
    case 0xb:
    case 0xc:
    case 0xd:
      uVar3 = 0;
      rpm_derate_percent_scaled = (word)((uint)param_table_aux * 0x50 >> 8);
      break;
    case 0xe:
    case 0xf:
      iVar2 = rpmFuelCalculation((uint)current_fuel_demand_value,
                                 (int)(short)rpm_derate_calc_offset_1,0x3a);
      iVar2 = (uint)current_engine_rpm + (iVar2 >> 3);
      if (iVar2 < 64000) {
        if (iVar2 < 1) {
          derate_rpm_limit_low = 0;
        }
        else {
          derate_rpm_limit_low = (word)iVar2;
        }
      }
      else {
        derate_rpm_limit_low = 64000;
      }
      iVar2 = rpmFuelCalculation((uint)current_fuel_demand_value,
                                 (int)(short)rpm_derate_calc_offset_2,0x3a);
      iVar2 = (uint)current_engine_rpm + (iVar2 >> 3);
      if (iVar2 < 64000) {
        if (iVar2 < 1) {
          derate_rpm_limit_high = 0;
        }
        else {
          derate_rpm_limit_high = (word)iVar2;
        }
      }
      else {
        derate_rpm_limit_high = 64000;
      }
      uVar3 = 0;
      if (current_engine_rpm < rpm_derate_calc_multiplier) {
        if (rpm_derate_calculation_table_ptr == 0xe) {
          uVar3 = 0;
          rpm_derate_percent_scaled = (word)((uint)asthrfes_calc_input * 0x50 >> 8);
        }
        else {
          uVar3 = 0;
          rpm_derate_percent_scaled = (word)((uint)param_table_aux * 0x50 >> 8);
        }
      }
      else {
        rpm_derate_percent_scaled = 0;
      }
    }
  }
  else {
    rpm_derate_percent_scaled = 0;
    uVar3 = uVar1;
  }
  if (((rpm_derate_calculation_table_ptr == 0xe) || (rpm_derate_calculation_table_ptr == 0xf)) &&
     (((diagnostic_fuel_control_mode == 9 || (diagnostic_fuel_control_mode == 10)) ||
      (((protection_system_enable_flag == 1 && (diagnostic_fuel_control_mode == 0xc)) &&
       (active_derate_value < 0xc)))))) {
    if ((rpm_derate_lower_threshold < derate_rpm_limit_low) ||
       (rpm_derate_percent_upper < rpm_derate_percent_scaled)) {
      rpm_derate_duty_cycle = 0x6400;
    }
    else if ((derate_rpm_limit_high < rpm_derate_upper_threshold) &&
            (rpm_derate_percent_scaled < rpm_derate_percent_lower)) {
      rpm_derate_duty_cycle = 0;
    }
    delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535 = rpm_derate_duty_cycle;
    if ((dtc_active_fault_count & 1) == 0) {
      sim_timer_control_register = sim_timer_control_register & 0xffff0000;
      return CONCAT22((short)(uVar3 >> 0x10),dtc_active_fault_count) & 0xffff0001;
    }
    sim_timer_control_register =
         ((((uint)pwm_output_scaling_factor * (uint)rpm_derate_duty_cycle) / 0x6400 & 0xffff) * 8000
         ) / 1000 & 0xffff | ((uint)pwm_output_scaling_factor * 8000) / 1000 << 0x10;
    return sim_timer_control_register;
  }
  if (((((rpm_derate_calculation_table_ptr != 2) && (rpm_derate_calculation_table_ptr != 5)) &&
       (rpm_derate_calculation_table_ptr != 8)) &&
      ((rpm_derate_calculation_table_ptr != 10 && (rpm_derate_calculation_table_ptr != 0xd)))) &&
     ((rpm_derate_calculation_table_ptr != 0xe && (rpm_derate_calculation_table_ptr != 0xf)))) {
    derate_rpm_adjustment =
         rpm_derate_base_offset +
         (short)(((int)(short)rpm_derate_scale_factor * (int)(short)rpm_derate_percent_scaled) /
                4000);
    if ((int)(uint)derate_rpm_adjustment_max < (int)(short)derate_rpm_adjustment) {
      derate_rpm_adjustment = derate_rpm_adjustment_max;
    }
    else if ((int)(short)derate_rpm_adjustment < (int)(uint)derate_rpm_adjustment_min) {
      derate_rpm_adjustment = derate_rpm_adjustment_min;
    }
    uVar1 = ((uint)derate_rpm_adjustment << 8) >> 1;
    rpm_derate_duty_cycle = (word)uVar1;
    delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535 = rpm_derate_duty_cycle;
    if ((dtc_active_fault_count & 1) == 0) {
      sim_timer_control_register = sim_timer_control_register & 0xffff0000;
      return CONCAT22(derate_rpm_adjustment >> 9,dtc_active_fault_count) & 0xffff0001;
    }
    sim_timer_control_register =
         ((((uint)pwm_output_scaling_factor * (uVar1 & 0xffff)) / 0x6400 & 0xffff) * 8000) / 1000 &
         0xffff | ((uint)pwm_output_scaling_factor * 8000) / 1000 << 0x10;
    return sim_timer_control_register;
  }
  if ((rpm_derate_calculation_table_ptr == 0xe) || (rpm_derate_calculation_table_ptr == 0xf)) {
    uVar3 = (uint)active_derate_value * 0x50 >> 2;
    rpm_derate_percent_scaled = (word)uVar3;
  }
  if (rpm_derate_percent_upper < rpm_derate_percent_scaled) {
    rpm_derate_duty_cycle = 0x6400;
  }
  if (rpm_derate_percent_scaled < rpm_derate_percent_lower) {
    rpm_derate_duty_cycle = 0;
  }
  delay_before_warning_about_shutdown_from_oil_press_rpm_0_65535 = rpm_derate_duty_cycle;
  if ((dtc_active_fault_count & 1) == 0) {
    sim_timer_control_register = sim_timer_control_register & 0xffff0000;
    return CONCAT22((short)(uVar3 >> 0x10),dtc_active_fault_count) & 0xffff0001;
  }
  sim_timer_control_register =
       ((((uint)pwm_output_scaling_factor * (uint)rpm_derate_duty_cycle) / 0x6400 & 0xffff) * 8000)
       / 1000 & 0xffff | ((uint)pwm_output_scaling_factor * 8000) / 1000 << 0x10;
  return sim_timer_control_register;
}



/*
 * Function: vp44DiagnosticSensorThresholdMonitor @ 0x000311ea
 */

ushort vp44DiagnosticSensorThresholdMonitor(void)

{
  ushort uVar1;
  word wVar2;
  
  if ((vp44_flag_register_1 & 0x100) == 0) {
    return 0;
  }
  if (((fault_status_flags_2 & 0x200) == 0) || ((accelerator_pedal_position & 0x200) == 0)) {
    uVar1 = 0;
  }
  else {
    uVar1 = 1;
  }
  if (uVar1 == 0) {
    if (((fault_status_flags_2 & 0x400) == 0) || ((accelerator_pedal_position & 0x400) == 0)) {
      uVar1 = 0;
    }
    else {
      uVar1 = 1;
    }
    if (uVar1 == 0) {
      if (((fault_status_flags_2 & 0x2000) == 0) || ((accelerator_pedal_position & 0x2000) == 0)) {
        uVar1 = 0;
      }
      else {
        uVar1 = 1;
      }
      if (uVar1 == 0) {
        wVar2 = 0;
        if (((vp44_engine_state != 0x10) ||
            (wVar2 = diagnostic_sensor_reading,
            diagnostic_sensor_reading <= diagnostic_sensor_reading_threshold)) ||
           (wVar2 = current_engine_rpm, current_engine_rpm <= diagnostic_sensor_rpm_threshold)) {
          if (vp44_diagnostic_sensor_threshold == 0) {
            return wVar2;
          }
          vp44_diagnostic_sensor_threshold = vp44_diagnostic_sensor_threshold - 1;
          if (vp44_diagnostic_sensor_threshold != 0) {
            return wVar2;
          }
          fault_status_flags_2 = fault_status_flags_2 & 0xf7ff;
          return wVar2;
        }
        if (added_to_final_fuel_command_for_cylinder_1_300_to_300 <=
            vp44_diagnostic_sensor_threshold) {
          return vp44_diagnostic_sensor_threshold;
        }
        vp44_diagnostic_sensor_threshold = vp44_diagnostic_sensor_threshold + 1;
        if (vp44_diagnostic_sensor_threshold !=
            added_to_final_fuel_command_for_cylinder_1_300_to_300) {
          return vp44_diagnostic_sensor_threshold;
        }
        fault_status_flags_2 = fault_status_flags_2 | 0x800;
        fault_status_flags_8_previous = fault_status_flags_8_previous | 0x800;
        return vp44_diagnostic_sensor_threshold;
      }
    }
  }
  vp44_diagnostic_sensor_threshold = 0;
  fault_status_flags_2 = fault_status_flags_2 & 0xf7ff;
  return uVar1;
}



/*
 * Function: vp44FaultRegisterBit2Monitor @ 0x00031306
 */

ushort vp44FaultRegisterBit2Monitor(void)

{
  word wVar1;
  ushort uVar2;
  
  wVar1 = io_control_active_mask;
  if ((vp44_flag_register_1 & 2) == 0) {
    engine_fault_register_a = engine_fault_register_a & 0xdfff;
    uVar2 = 0;
  }
  else {
    if (vp44_fault_register_bit2_threshold == 1) {
      io_control_active_mask = io_control_active_mask | 0x10;
      engine_fault_register_a = engine_fault_register_a | 0x2000;
      engine_fault_register_c = engine_fault_register_c | 0x2000;
      return vp44_flag_register_1 & 2;
    }
    io_control_active_mask = io_control_active_mask & 0xffef;
    uVar2 = engine_fault_register_a & 0x2000;
    if (uVar2 != 0) {
      uVar2 = engine_fault_register_c & 0x2000;
      if (uVar2 == 0) {
        engine_fault_register_a = engine_fault_register_a & 0xdfff;
        return uVar2;
      }
    }
  }
  io_control_active_mask = wVar1 & 0xffef;
  return uVar2;
}



/*
 * Function: fuelDemandConditionFlagBuilder @ 0x00031394
 */

void fuelDemandConditionFlagBuilder(void)

{
  retarder_input_flags = (word)((derate_status_byte & 0x10) != 0);
  if ((fuel_temp_vp44_diagnostic_enable != 0) && ((sensor_status_register & 0x40) != 0)) {
    retarder_input_flags = retarder_input_flags | 2;
  }
  return;
}



/*
 * Function: fuelDemandFaultFlagUpdater @ 0x000313c4
 */

ushort fuelDemandFaultFlagUpdater(uint param_1)

{
  ushort uVar1;
  
  if (((param_1 & 0x10000) == 0) || ((io_fault_status_reg_2 & 0x20) != 0)) {
    io_control_flags = io_control_flags | 1;
  }
  else {
    io_control_flags = io_control_flags & 0xfe;
  }
  uVar1 = param_1._0_2_ & 2;
  if (((param_1 & 0x20000) != 0) &&
     (uVar1 = fault_flags_active_base & 1, (fault_flags_active_base & 1) == 0)) {
    output_control_status_byte = output_control_status_byte & 0xfe;
    return uVar1;
  }
  output_control_status_byte = output_control_status_byte | 1;
  return uVar1;
}



/*
 * Function: fuelDemandLimitSource2Selector @ 0x0003141c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort fuelDemandLimitSource2Selector(void)

{
  VP44_OPERATING_CONDITION VVar1;
  
  VVar1 = vp44_operating_condition_value | protection_system_enable_flag;
  if (VVar1 != RESET_INACTIVE) {
    if (_fuel_demand_limit_source_2_flag == RESET_INACTIVE) {
      vp44_diagnostic_fault_state = 0;
      fuel_demand_limit_source = NO_LIMIT_ACTIVE;
      return VVar1;
    }
    VVar1 = _fuel_demand_limit_source_2_flag;
    if (_fuel_demand_limit_source_2_flag < vp44_diagnostic_fault_state) {
      vp44_diagnostic_fault_state = _fuel_demand_limit_source_2_flag;
      fuel_demand_limit_source = VP44_DIAGNOSTIC_FAULT;
    }
  }
  return VVar1;
}



/*
 * Function: fuelDemandLimitSource3Selector @ 0x0003145a
 */

void fuelDemandLimitSource3Selector(void)

{
  fuelDemandConditionFlagBuilder();
  if (retarder_input_flags == 0) {
    vp44_diagnostic_fault_state = 0;
    fuel_demand_limit_source = NO_LIMIT_ACTIVE;
    return;
  }
  if (retarder_input_flags < vp44_diagnostic_fault_state) {
    vp44_diagnostic_fault_state = retarder_input_flags;
    fuel_demand_limit_source = RETARDER_INPUT_LIMIT;
  }
  return;
}



/*
 * Function: fuelDemandLimitSource4Selector @ 0x00031494
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelDemandLimitSource4Selector(void)

{
  if (((fuel_demand_limit_source != NO_LIMIT_ACTIVE) &&
      (fuel_demand_limit_source != PROTECTION_OVERRIDE)) &&
     ((int)(short)_retarder_mode_table_count < (int)(uint)vp44_diagnostic_fault_state)) {
    vp44_diagnostic_fault_state = _retarder_mode_table_count;
    fuel_demand_limit_source = RETARDER_MODE_TABLE;
  }
  return;
}



/*
 * Function: fuelDemandOverrideStateSelector @ 0x000314c6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void fuelDemandOverrideStateSelector(void)

{
  if (_retarder_mode_threshold_result == 0) {
    fuel_temp_limit_state_2 = 0;
    fuel_demand_override_state = 5;
    return;
  }
  fuel_temp_limit_state_2 = _retarder_mode_threshold_result;
  fuel_demand_override_state = 1;
  return;
}



/*
 * Function: fuelDemandLimitOrchestrator @ 0x000314ee
 */

ushort fuelDemandLimitOrchestrator(void)

{
  bool bVar1;
  ushort uVar2;
  ushort uVar3;
  
  uVar2 = 0;
  bVar1 = false;
  if (((rpm_to_reach_before_for_engine_sync_fuel_pressure_errors_0_8000 < current_engine_rpm) &&
      (diagnostic_sensor_reading < fault_when_epf_engine_sync_fuel_pressure_rpm_error_found_0_65535)
      ) && (current_fuel_demand_value <=
            time_from_fuel_temperature_overlimit_reached_to_start_of_fue_0_65535)) {
    uVar2 = 1;
  }
  else if ((current_engine_rpm <= fuel_demand_limit_special_value) ||
          (time_from_fuel_temperature_overlimit_reached_to_start_of_fue_0_65535 <
           current_fuel_demand_value)) {
    bVar1 = true;
  }
  if (((fuel_pressure_rpm_flag != 0) && (bVar1)) || ((uVar2 | fuel_pressure_rpm_flag) == 0)) {
    vp44_diagnostic_fault_state = 0;
    fuel_demand_limit_source = NO_LIMIT_ACTIVE;
    return 0;
  }
  if (fuel_temp_limit_state_2 != 0) {
    vp44_diagnostic_fault_state = fuel_temp_limit_state_2;
    fuel_demand_limit_source = fuel_demand_override_state;
    return uVar2 | fuel_pressure_rpm_flag;
  }
  uVar3 = 0;
  uVar2 = oil_pressure_protection_enabled | active_derate_value;
  if ((uVar2 == 0) &&
     ((uVar2 = derate_status_byte & 4, (derate_status_byte & 4) == 0 ||
      ((uVar2 = derate_status_byte & 4, (derate_status_byte & 4) != 0 &&
       (uVar2 = diagnostic_system_flags_2 & 0x40, (diagnostic_system_flags_2 & 0x40) == 0)))))) {
    uVar3 = 1;
  }
  if (((fuel_pressure_rpm_flag == 0) || (uVar3 != 0)) &&
     (uVar2 = uVar3 | fuel_pressure_rpm_flag, uVar2 != 0)) {
    vp44_diagnostic_fault_state = 4;
    fuel_demand_limit_source = PROTECTION_OVERRIDE;
    fuelDemandLimitSource2Selector();
    fuelDemandLimitSource3Selector();
    uVar2 = fuelDemandLimitSource4Selector();
    return uVar2;
  }
  vp44_diagnostic_fault_state = 0;
  fuel_demand_limit_source = NO_LIMIT_ACTIVE;
  return uVar2;
}



/*
 * Function: fuelPressureSyncStateMachine @ 0x000315f6
 */

void fuelPressureSyncStateMachine(void)

{
  bool bVar1;
  
  switch(fuel_pressure_sync_state_machine) {
  case FUEL_SYNC_IDLE:
    if (vp44_diagnostic_fault_state != 0) {
      if (((fault_status_flags_2 & 0x400) == 0) && ((fault_status_flags_2 & 0x200) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if ((bVar1) && (fault_when_epf_engine_sync_fuel_pressure_fuel_error_found_0_65535 != 0)) {
        fuel_pressure_sync_state_machine = FAULT_COUNTING;
        fuel_pressure_sync_counter = 0;
      }
      else if (((uint)(&vp44_status_flags_1)[(short)((int)(uint)EPFPRPSS >> 4)] &
               1 << (EPFPRPSS & 0xf)) == 0) {
        fuel_pressure_sync_state_machine = FAULT_CONFIRMED;
      }
      else {
        fuel_pressure_sync_state_machine = STATUS_MONITORING;
      }
    }
    break;
  case FAULT_COUNTING:
    if (vp44_diagnostic_fault_state == 0) {
      if (delay_after_rpm_is_reached_before_eng_sync_fuel_pressure_errors_0_8000 == 0) {
        fuel_pressure_sync_state_machine = FUEL_SYNC_IDLE;
      }
      else {
        fuel_pressure_sync_state_machine = DELAY_RECOVERY;
        fuel_pressure_sync_counter = 0;
      }
    }
    else if (fault_when_epf_engine_sync_fuel_pressure_fuel_error_found_0_65535 <=
             fuel_pressure_sync_counter) {
      fuel_pressure_sync_state_machine = FAULT_CONFIRMED;
    }
    break;
  case STATUS_MONITORING:
    if (vp44_diagnostic_fault_state == 0) {
      if (delay_after_rpm_is_reached_before_eng_sync_fuel_pressure_errors_0_8000 == 0) {
        fuel_pressure_sync_state_machine = FUEL_SYNC_IDLE;
      }
      else {
        fuel_pressure_sync_state_machine = DELAY_RECOVERY;
        fuel_pressure_sync_counter = 0;
      }
    }
    else {
      if (((fault_status_flags_2 & 0x400) == 0) && ((fault_status_flags_2 & 0x200) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if ((bVar1) && (fault_when_epf_engine_sync_fuel_pressure_fuel_error_found_0_65535 != 0)) {
        fuel_pressure_sync_state_machine = FAULT_COUNTING;
        fuel_pressure_sync_counter = 0;
      }
      else if ((fuel_pressure_rpm_flag != 0) &&
              ((fuel_pressure_sync_param <= current_engine_rpm ||
               (fuel_pressure_injection_flag != 0)))) {
        fuel_pressure_sync_state_machine = FAULT_CONFIRMED;
      }
    }
    break;
  case FAULT_CONFIRMED:
    if (vp44_diagnostic_fault_state == 0) {
      if (delay_after_rpm_is_reached_before_eng_sync_fuel_pressure_errors_0_8000 == 0) {
        fuel_pressure_sync_state_machine = FUEL_SYNC_IDLE;
      }
      else {
        fuel_pressure_sync_state_machine = DELAY_RECOVERY;
        fuel_pressure_sync_counter = 0;
      }
    }
    break;
  case DELAY_RECOVERY:
    if (delay_after_rpm_is_reached_before_eng_sync_fuel_pressure_errors_0_8000 <=
        fuel_pressure_sync_counter) {
      fuel_pressure_sync_state_machine = FUEL_SYNC_IDLE;
    }
  }
  fuel_pressure_sync_counter = fuel_pressure_sync_counter + 1;
  return;
}



/*
 * Function: vp44InjectionSystemStateController @ 0x00031768
 */

void vp44InjectionSystemStateController(void)

{
  undefined4 unaff_A2;
  ushort uVar1;
  
  uVar1 = (ushort)((uint)unaff_A2 >> 0x10);
  fuelDemandOverrideStateSelector();
  fuelDemandLimitOrchestrator();
  fuelPressureSyncStateMachine();
  vp44_injection_system_active = (word)(fuel_pressure_sync_state_machine != FUEL_SYNC_IDLE);
  if (fuel_pressure_sync_state_machine == FAULT_CONFIRMED) {
    fuelDemandFaultFlagUpdater(CONCAT22(vp44_diagnostic_fault_state,uVar1));
  }
  else {
    fuelDemandFaultFlagUpdater((uint)uVar1);
  }
  fuel_pressure_injection_flag = fuel_pressure_rpm_flag;
  fuel_pressure_rpm_flag = vp44_diagnostic_fault_state;
  return;
}



/*
 * Function: fuelDemandState24Override @ 0x000317c2
 */

void fuelDemandState24Override(void)

{
  if (vp44_engine_state == VP44_ACTIVE_MODE) {
    fuel_demand_state_24_write_flag = fuel_limit_minimum_value;
    fuel_limit_minimum_value = fuel_demand_state_24_override_value;
    fuel_demand_source_id = STATE_24_OVERRIDE;
    fuel_adjustment_active_flag = 0;
  }
  return;
}



/*
 * Function: fuelDemandControllerInit @ 0x000317ee
 */

void fuelDemandControllerInit(void)

{
  ushort in_stack_00000000;
  
  vp44_injection_system_active = 0;
  fuelDemandFaultFlagUpdater((uint)in_stack_00000000);
  fuel_pressure_sync_state_machine = FUEL_SYNC_IDLE;
  fuel_demand_override_state = 5;
  fuel_demand_limit_source = PROTECTION_OVERRIDE;
  return;
}



/*
 * Function: fuelTemperatureLimitingPrimary @ 0x00031814
 */

ushort fuelTemperatureLimitingPrimary(void)

{
  bool bVar1;
  ushort uVar2;
  
  fuel_temp_limit_primary = 0;
  fuel_temp_primary_counter_flag = 0;
  fuel_temp_secondary_counter_flag = 0;
  if (threshold_for_fuel_temperature_fuel_limiting_to_initiate_shu_0_65535 <= current_engine_rpm) {
    fuel_temp_primary_counter_flag = 0;
    fuel_temp_secondary_counter_flag = 0;
    fuel_temp_limit_primary = 0;
    return current_engine_rpm;
  }
  if ((vp44_communication_status & 1) == 0) {
    fuel_temp_primary_counter_flag = 0;
    fuel_temp_secondary_counter_flag = 0;
    fuel_temp_limit_primary = 0;
    return vp44_communication_status & 1;
  }
  if ((fuel_temp_limit_mode_selector == 1) || (fuel_temp_limit_mode_selector == 3)) {
    fuel_temp_limit_primary = 1;
  }
  if (throttle_position_raw < time_to_reach_full_derate_w_fuel_temperature_engine_prot_0_0039_256) {
    if (((engine_fault_status_register_1 & 1) == 0) ||
       ((engine_fault_confirmation_register & 1) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (bVar1) goto LAB_000318d6;
    if (((engine_fault_status_register_1 & 2) == 0) ||
       ((engine_fault_confirmation_register & 2) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if ((bVar1) ||
       ((fuel_temp_limit_primary_prev == 1 &&
        (time_from_fuel_temperature_overlimit_reached_to_start_of_rpm_0_65535 <=
         throttle_position_raw)))) goto LAB_000318d6;
  }
  else {
LAB_000318d6:
    fuel_temp_limit_primary = 1;
    fuel_temp_primary_counter_flag = 1;
  }
  if ((fuel_temp_control_flags & 0x1000) == 0) {
    if (intake_manifold_temp_raw <
        minimum_temperature_threshold_for_fuel_temperature_fuel_limi_0_65535) {
      if (((fault_flags_active_base & 0x2000) == 0) || ((fault_flags_enabled_base & 0x2000) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((fault_flags_active_base & 0x4000) == 0) || ((fault_flags_enabled_base & 0x4000) == 0))
        {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if ((!bVar1) &&
           ((fuel_temp_limit_primary_prev != 1 ||
            (intake_manifold_temp_raw <
             time_to_reach_full_derate_w_fuel_temperature_engine_prot_0_0039_256))))
        goto LAB_00031956;
      }
    }
    fuel_temp_limit_primary = 1;
    fuel_temp_primary_counter_flag = 1;
  }
LAB_00031956:
  if (((fuel_temp_control_flags & 0x4000) != 0) && ((vp44_communication_status & 0x10) != 0)) {
    fuel_temp_limit_primary = 1;
    fuel_temp_secondary_counter_flag = 1;
  }
  if (((fuel_temp_control_flags & 0x400) != 0) &&
     (((vp44_fuel_temperature_state & 1) != 0 ||
      ((fuel_temp_limit_primary_prev == 1 &&
       (fuel_temp_protection_timer_1 < fuel_temp_protection_threshold_383c)))))) {
    fuel_temp_limit_primary = 1;
  }
  if ((fuel_temp_control_flags & 0x2000) != 0) {
    if ((((fuel_temp_vp44_diagnostic_enable == 0) || (vp44_diagnostic_fault_state != 3)) ||
        (intake_manifold_temp_raw <= shutdown_delay_for_fuel_temperature_shutdown_0_65535)) ||
       ((throttle_position_raw <=
         threshold_for_fuel_temperature_rpm_limiting_to_initiate_shut_0_65535 ||
        (fuel_temp_protection_timer_2 <
         rpm_threshold_that_must_be_crossed_in_order_to_log_fuel_temp_0_4500)))) {
      if ((((fuel_temp_vp44_diagnostic_enable == 0) &&
           ((vp44_diagnostic_fault_state == 1 &&
            (shutdown_delay_for_fuel_temperature_shutdown_0_65535 < intake_manifold_temp_raw)))) &&
          (threshold_for_fuel_temperature_rpm_limiting_to_initiate_shut_0_65535 <
           throttle_position_raw)) &&
         (rpm_threshold_that_must_be_crossed_in_order_to_log_fuel_temp_0_4500 <=
          fuel_temp_protection_timer_2)) {
        fuel_temp_limit_primary = 1;
        fuel_temp_primary_counter_flag = 1;
      }
    }
    else {
      fuel_temp_limit_primary = 1;
      fuel_temp_primary_counter_flag = 1;
    }
  }
  if (fuel_temp_primary_countdown_timer != 0) {
    fuel_temp_limit_primary = 1;
  }
  uVar2 = fuel_temp_control_flags & 0x1000;
  if (((fuel_temp_control_flags & 0x1000) == 0) &&
     (uVar2 = fuel_temp_protection_timer_3,
     fuel_temp_protection_timer_3 < minimum_threshold_for_fuel_temperature_rpm_limiting_0_65535)) {
    fuel_temp_limit_primary = 1;
    fuel_temp_primary_counter_flag = 1;
  }
  return uVar2;
}



/*
 * Function: fuelTemperatureLimitingSecondary @ 0x00031a76
 */

word fuelTemperatureLimitingSecondary(void)

{
  bool bVar1;
  
  fuel_temp_limit_secondary = 0;
  if (threshold_for_fuel_temperature_fuel_limiting_to_initiate_shu_0_65535 <= current_engine_rpm) {
    fuel_temp_limit_secondary = 0;
    return current_engine_rpm;
  }
  if ((vp44_communication_status & 1) == 0) {
    fuel_temp_limit_secondary = 0;
    return vp44_communication_status & 1;
  }
  if ((fuel_temp_control_flags & 0x1000) == 0) {
    fuel_temp_limit_secondary = 0;
    return fuel_temp_control_flags & 0x1000;
  }
  if ((fuel_temp_limit_mode_selector == 2) || (fuel_temp_limit_mode_selector == 3)) {
    fuel_temp_limit_secondary = 1;
  }
  if (intake_manifold_temp_raw <
      minimum_temperature_threshold_for_fuel_temperature_fuel_limi_0_65535) {
    if (((fault_flags_active_base & 0x2000) == 0) || ((fault_flags_enabled_base & 0x2000) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (((fault_flags_active_base & 0x4000) == 0) || ((fault_flags_enabled_base & 0x4000) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if ((!bVar1) &&
         ((fuel_temp_limit_secondary_prev == 0 ||
          (intake_manifold_temp_raw <
           time_to_reach_full_derate_w_fuel_temperature_engine_prot_0_0039_256))))
      goto LAB_00031b34;
    }
  }
  fuel_temp_limit_secondary = 1;
LAB_00031b34:
  if (((fuel_temp_control_flags & 0x4000) != 0) && ((vp44_communication_status & 0x10) != 0)) {
    fuel_temp_limit_secondary = 1;
  }
  if (fuel_temp_secondary_countdown != 0) {
    fuel_temp_limit_secondary = 1;
  }
  if (fuel_temp_protection_timer_3 < minimum_threshold_for_fuel_temperature_rpm_limiting_0_65535) {
    fuel_temp_limit_secondary = 1;
  }
  return fuel_temp_protection_timer_3;
}



/*
 * Function: ioControlSourceRegisterManager @ 0x00031b78
 */

void ioControlSourceRegisterManager(uint param_1)

{
  byte bVar1;
  
  bVar1 = (byte)param_1;
  if (param_1._0_2_ == 0) {
    if (maximum_threshold_for_fuel_temperature_fuel_limiting_0_65535 == 0) {
      (&io_control_source_register)[(int)(param_1 & 0xffff) >> 3] =
           ~('\x01' << (bVar1 & 7)) & (&io_control_source_register)[(int)(param_1 & 0xffff) >> 3];
      return;
    }
    (&io_control_source_register)[(int)(param_1 & 0xffff) >> 3] =
         '\x01' << (bVar1 & 7) | (&io_control_source_register)[(int)(param_1 & 0xffff) >> 3];
    return;
  }
  if (maximum_threshold_for_fuel_temperature_fuel_limiting_0_65535 == 0) {
    (&io_control_source_register)[(int)(param_1 & 0xffff) >> 3] =
         '\x01' << (bVar1 & 7) | (&io_control_source_register)[(int)(param_1 & 0xffff) >> 3];
    return;
  }
  (&io_control_source_register)[(int)(param_1 & 0xffff) >> 3] =
       ~('\x01' << (bVar1 & 7)) & (&io_control_source_register)[(int)(param_1 & 0xffff) >> 3];
  return;
}



/*
 * Function: ioControlRegistersInit @ 0x00031c06
 */

void ioControlRegistersInit(void)

{
  fuel_temp_limit_primary = 0;
  fuel_temp_limit_secondary = 0;
  fuel_temp_protection_state_33e2 = 0;
  fuel_temp_protection_active_flag = 0;
  fuel_temp_vp44_state_flag = 0;
  fuel_temp_protection_timer_3 = minimum_threshold_for_fuel_temperature_rpm_limiting_0_65535;
  fuel_temp_protection_timer_2 = rpm_threshold_that_must_be_crossed_in_order_to_log_fuel_temp_0_4500
  ;
  fuel_temp_protection_timer_1 = fuel_temp_protection_threshold_383c;
  ioControlSourceRegisterManager(0xf);
  ioControlSourceRegisterManager(CONCAT22(fuel_temp_limit_secondary,0x18));
  return;
}



/*
 * Function: fuelTemperatureProtectionSlowCycle40Coordinator @ 0x00031c60
 */

uint fuelTemperatureProtectionSlowCycle40Coordinator(void)

{
  undefined2 uVar1;
  uint uVar2;
  bool bVar3;
  
  fuel_temp_limit_primary_prev = fuel_temp_limit_primary;
  fuel_temp_limit_secondary_prev = fuel_temp_limit_secondary;
  if (engine_operating_mode == ENGINE_IDLE) {
    fuel_temp_limit_primary = 0;
    fuel_temp_limit_secondary = 0;
    ioControlSourceRegisterManager(0xf);
    fuel_temp_limit_output_970a = (ushort)io_control_flags;
    return (uint)io_control_flags;
  }
  fuelTemperatureLimitingPrimary();
  ioControlSourceRegisterManager(CONCAT22(fuel_temp_limit_primary,0xf));
  fuel_temp_limit_output_970a = (word)io_control_flags;
  fuel_temp_vp44_state_previous = fuel_temp_vp44_state_flag;
  bVar3 = (vp44_fuel_temperature_state & 1) != 0;
  if ((fuel_temp_control_flags & 0x400) != 0) {
    if ((bVar3) && (fuel_temp_vp44_state_flag == 0)) {
      fuel_temp_protection_timer_1 = 0;
      fuel_temp_protection_state_33e2 = 1;
      fuel_temp_protection_active_flag = 1;
    }
    else if (fuel_temp_protection_timer_1 < fuel_temp_protection_threshold_383c) {
      fuel_temp_protection_timer_1 = fuel_temp_protection_timer_1 + 1;
    }
  }
  if (fuel_temp_limit_primary == 0) {
    fuel_temp_protection_active_flag = 0;
  }
  if ((fuel_temp_protection_active_flag != 0) && (fuel_temp_protection_time_accum != 0xffffffff)) {
    fuel_temp_protection_time_accum = fuel_temp_protection_time_accum + 1;
  }
  if ((fuel_temp_control_flags & 0x800) != 0) {
    if (fuel_temp_throttle_high_threshold < throttle_position_value) {
      fuel_temp_protection_timer_1 = fuel_temp_protection_threshold_383c;
    }
    if ((throttle_position_value < fuel_temp_throttle_low_threshold) &&
       (fuel_temp_protection_state_33e2 == 1)) {
      fuel_temp_protection_timer_1 = 0;
    }
    if ((fuel_temp_throttle_low_threshold <= throttle_position_value) &&
       (fuel_temp_protection_threshold_383c <= fuel_temp_protection_timer_1)) {
      fuel_temp_protection_state_33e2 = 0;
    }
  }
  if ((fuel_temp_control_flags & 0x2000) != 0) {
    if (((vp44_diagnostic_fault_state != 3) ||
        (intake_manifold_temp_raw <= shutdown_delay_for_fuel_temperature_shutdown_0_65535)) ||
       (throttle_position_raw <=
        threshold_for_fuel_temperature_rpm_limiting_to_initiate_shut_0_65535)) {
      fuel_temp_protection_timer_2 = 0;
    }
    if (((fuel_temp_vp44_diagnostic_enable == 0) && (vp44_diagnostic_fault_state != 1)) ||
       ((intake_manifold_temp_raw <= shutdown_delay_for_fuel_temperature_shutdown_0_65535 ||
        (throttle_position_raw <=
         threshold_for_fuel_temperature_rpm_limiting_to_initiate_shut_0_65535)))) {
      fuel_temp_protection_timer_2 = 0;
    }
    if (((vp44_diagnostic_fault_state == 3) &&
        (shutdown_delay_for_fuel_temperature_shutdown_0_65535 < intake_manifold_temp_raw)) &&
       ((threshold_for_fuel_temperature_rpm_limiting_to_initiate_shut_0_65535 <
         throttle_position_raw &&
        (fuel_temp_protection_timer_2 <
         rpm_threshold_that_must_be_crossed_in_order_to_log_fuel_temp_0_4500)))) {
      fuel_temp_protection_timer_2 = fuel_temp_protection_timer_2 + 1;
    }
    if ((((fuel_temp_vp44_diagnostic_enable == 0) && (vp44_diagnostic_fault_state == 1)) &&
        (shutdown_delay_for_fuel_temperature_shutdown_0_65535 < intake_manifold_temp_raw)) &&
       ((threshold_for_fuel_temperature_rpm_limiting_to_initiate_shut_0_65535 <
         throttle_position_raw &&
        (fuel_temp_protection_timer_2 <
         rpm_threshold_that_must_be_crossed_in_order_to_log_fuel_temp_0_4500)))) {
      fuel_temp_protection_timer_2 = fuel_temp_protection_timer_2 + 1;
    }
  }
  if (fuel_temp_primary_countdown_timer != 0) {
    fuel_temp_primary_countdown_timer = fuel_temp_primary_countdown_timer - 1;
  }
  if ((fuel_temp_control_flags & 0x1000) == 0) {
    if (((fuel_temp_limit_primary == 0) || (fuel_temp_limit_primary_prev != 0)) ||
       (intake_manifold_temp_raw <
        minimum_temperature_threshold_for_fuel_temperature_fuel_limi_0_65535)) {
      if (fuel_temp_protection_timer_3 < minimum_threshold_for_fuel_temperature_rpm_limiting_0_65535
         ) {
        fuel_temp_protection_timer_3 = fuel_temp_protection_timer_3 + 1;
      }
    }
    else {
      fuel_temp_protection_timer_3 = 0;
    }
  }
  if (fuel_temp_limit_primary != 0) {
    if (time_threshold_that_must_be_crossed_in_order_to_log_fuel_tempe_0_255 <
        throttle_position_value) {
      if (fuel_temp_high_throttle_accum != 0xffffffff) {
        fuel_temp_high_throttle_accum = fuel_temp_high_throttle_accum + 1;
      }
    }
    else if (fuel_temp_low_throttle_accum != 0xffffffff) {
      fuel_temp_low_throttle_accum = fuel_temp_low_throttle_accum + 1;
    }
    if (fuel_temp_secondary_counter_flag != 0) {
      fuel_temp_protection_counter_2_5fa6 = fuel_temp_protection_counter_2_5fa6 + 1;
    }
    if (fuel_temp_primary_counter_flag != 0) {
      fuel_temp_protection_counter_1_5fa2 = fuel_temp_protection_counter_1_5fa2 + 1;
    }
  }
  fuel_temp_vp44_state_flag = (ushort)bVar3;
  fuelTemperatureLimitingSecondary();
  ioControlSourceRegisterManager(CONCAT22(fuel_temp_limit_secondary,0x18));
  uVar1 = 0;
  fuel_temp_output_control_status = (ushort)output_control_status_byte;
  if ((fuel_temp_limit_secondary != 0) &&
     (uVar1 = 0xffff, fuel_temp_secondary_time_accum != 0xffffffff)) {
    fuel_temp_secondary_time_accum = fuel_temp_secondary_time_accum + 1;
  }
  if (fuel_temp_secondary_countdown != 0) {
    fuel_temp_secondary_countdown = fuel_temp_secondary_countdown - 1;
  }
  uVar2 = CONCAT22(uVar1,fuel_temp_control_flags) & 0xffff1000;
  if ((fuel_temp_control_flags & 0x1000) != 0) {
    if (((fuel_temp_limit_secondary != 0) && (fuel_temp_limit_secondary_prev == 0)) &&
       (uVar2 = CONCAT22(uVar1,intake_manifold_temp_raw),
       minimum_temperature_threshold_for_fuel_temperature_fuel_limi_0_65535 <=
       intake_manifold_temp_raw)) {
      fuel_temp_protection_timer_3 = 0;
      return uVar2;
    }
    uVar2 = CONCAT22((short)(uVar2 >> 0x10),fuel_temp_protection_timer_3);
    if (fuel_temp_protection_timer_3 < minimum_threshold_for_fuel_temperature_rpm_limiting_0_65535)
    {
      fuel_temp_protection_timer_3 = fuel_temp_protection_timer_3 + 1;
    }
  }
  return uVar2;
}



/*
 * Function: vp44SensorStatusMonitor @ 0x00031fb8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44SensorStatusMonitor(void)

{
  if (_vp44_extended_processing_enable == 0) {
    if (vp44_state_debounce_value_938c == vp44_sensor_status_monitor_state) {
      vp44_sensor_state_counter = 2;
    }
    else if (vp44_state_debounce_value_938c == vp44_sensor_prev_debounce) {
      if (vp44_sensor_state_counter + 1 < (uint)vp44_state_debounce_threshold) {
        vp44_sensor_state_counter = vp44_sensor_state_counter + 1;
        vp44_sensor_status_monitor_state = STATE_4_DEFAULT;
      }
      else {
        vp44_sensor_status_monitor_state = vp44_state_debounce_value_938c;
      }
    }
    else if (vp44_sensor_state_counter < 2) {
      vp44_sensor_status_monitor_state = STATE_4_DEFAULT;
    }
    else {
      vp44_sensor_state_counter = vp44_sensor_state_counter - 1;
    }
    if (vp44_state_debounce_threshold < 2) {
      vp44_sensor_status_monitor_state = vp44_state_debounce_value_938c;
    }
    if (vp44_sensor_status_monitor_state == STATE_5_FAULT) {
      sensor_status_register = sensor_status_register | 0x10;
    }
    else if (vp44_sensor_status_monitor_state == STATE_0_IDLE) {
      sensor_status_register = sensor_status_register & 0xef;
    }
    if (vp44_sensor_status_monitor_state == STATE_2_MONITOR) {
      if (vp44_sensor_debounce_counter < vp44_state_processing_timeout_reload) {
        sensor_status_register = sensor_status_register & 0xfd | 4;
        vp44_sensor_debounce_counter = vp44_sensor_debounce_counter + 1;
      }
      else {
        sensor_status_register = sensor_status_register | 6;
      }
    }
    else {
      sensor_status_register = sensor_status_register & 0xf9;
      vp44_sensor_debounce_counter = 0;
    }
    if (vp44_sensor_status_monitor_state == STATE_3_TRANSITION) {
      sensor_status_register = sensor_status_register | 1;
    }
    else {
      sensor_status_register = sensor_status_register & 0xfe;
    }
    if (vp44_sensor_status_monitor_state == STATE_1_ACTIVE) {
      sensor_status_register = sensor_status_register | 8;
    }
    else {
      sensor_status_register = sensor_status_register & 0xf7;
    }
    vp44_sensor_prev_debounce = vp44_state_debounce_value_938c;
  }
  return;
}



/*
 * Function: vp44DiagnosticStateInit @ 0x000320bc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44DiagnosticStateInit(void)

{
  if (_vp44_extended_processing_enable == 0) {
    vp44_sensor_prev_debounce = STATE_4_DEFAULT;
    vp44_sensor_status_monitor_state = STATE_4_DEFAULT;
    vp44_sensor_state_counter = 0;
  }
  return;
}



/*
 * Function: vp44ControlFlagsInit @ 0x000320dc
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44ControlFlagsInit(void)

{
  vp44_control_flags_state = 0;
  vp44_control_flags_init_state = 0;
  _vp44_control_flag_1 = 1;
  _vp44_control_flag_2 = 1;
  _vp44_control_flag_3 = 1;
  _vp44_control_flag_4 = 0;
  _vp44_control_flag_5 = 1;
  _vp44_control_flag_6 = 0;
  _vp44_control_flag_7 = 0;
  vp44_sensor_diagnostic_write_state = 0;
  return;
}



/*
 * Function: vp44SensorDiagnosticControl @ 0x0003211a
 */

ushort vp44SensorDiagnosticControl(void)

{
  ushort uVar1;
  
  uVar1 = vp44_flag_register_1 & 0x10;
  if (uVar1 != 0) {
    if (current_engine_rpm < added_to_final_fuel_command_for_cylinder_6_300_to_300) {
      vp44_control_flags_state = 0;
    }
    else if ((byte)((-((vp44_sensor_diagnostic_state_bdc9 & 8) != 0) & 1U) +
                   (-((vp44_sensor_diagnostic_state_bdc9 & 0x20) != 0) & 1U) * '\x02' +
                   (-((vp44_sensor_diagnostic_state_bdc9 & 0x40) != 0) & 1U) * '\x04') == '\x06') {
      vp44_control_flags_state = 1;
    }
    else {
      vp44_control_flags_state = 0;
    }
    vp44_sensor_diag_index =
         (-((vp44_sensor_diagnostic_state_bdc9 & 8) != 0) & 1U) +
         (-((vp44_fuel_temperature_state & 1) != 0) & 1U) * '\x02' +
         (-((vp44_sensor_diagnostic_state_bdc9 & 0x20) != 0) & 1U) * '\x04';
    if ((vp44_sensor_diag_timer_1 != 0) && (vp44_sensor_diagnostic_write_state == 0)) {
      vp44_sensor_diag_timer_1 = vp44_sensor_diag_timer_1 - 1;
    }
    if (vp44_sensor_diagnostic_write_state == 0) {
      if (((short)fuel_cylinder_average <
           (short)added_to_final_fuel_command_for_cylinder_3_300_to_300) ||
         ((vp44_engine_state != 0x10 && (vp44_engine_state != 0x13)))) {
        if (vp44_control_flags_state == 1) {
          dzg_pressure_control_state = 1;
        }
        else if ((vp44_sensor_diag_timer_1 == 0) || ((vp44_sensor_diagnostic_state_bdc9 & 8) != 0))
        {
          dzg_pressure_control_state = 0;
        }
      }
      else {
        dzg_pressure_state_saved = dzg_pressure_control_state;
        dzg_pressure_control_state = 0;
        vp44_sensor_diagnostic_write_state = 1;
        vp44_sensor_diagnostic_countdown = added_to_final_fuel_command_for_cylinder_4_300_to_300;
      }
    }
    else if (vp44_sensor_diagnostic_countdown == 0) {
      dzg_pressure_control_state = dzg_pressure_state_saved;
      vp44_sensor_diagnostic_write_state = 0;
    }
    else {
      dzg_pressure_control_state = 0;
      vp44_sensor_diagnostic_countdown = vp44_sensor_diagnostic_countdown - 1;
    }
    if ((vp44_sensor_diag_state_prev != 0) && ((vp44_sensor_diagnostic_state_bdc9 & 0x20) == 0)) {
      vp44_sensor_diag_timer_1 = added_to_final_fuel_command_for_cylinder_2_300_to_300;
    }
    vp44_sensor_diag_timer_2 =
         (&vp44_control_flags_init_state)[(short)(ushort)vp44_sensor_diag_index];
    if (vp44_sensor_diag_timer_2 == 1) {
      if (vp44_sensor_diagnostic_read_state < added_to_final_fuel_command_for_cylinder_5_300_to_300)
      {
        vp44_sensor_diagnostic_read_state = vp44_sensor_diagnostic_read_state + 1;
        vp44_sensor_diag_timer_2 = 0;
      }
      else {
        vp44_sensor_diag_timer_2 = 1;
      }
    }
    else {
      vp44_sensor_diagnostic_read_state = 0;
    }
    if (vp44_sensor_diag_timer_2 == 0) {
      engine_fault_register_a = engine_fault_register_a & 0xfbff;
    }
    else {
      engine_fault_register_a = engine_fault_register_a | 0x400;
      engine_fault_register_c = engine_fault_register_c | 0x400;
    }
    uVar1 = (byte)-((vp44_sensor_diagnostic_state_bdc9 & 0x20) != 0) & 1;
    vp44_sensor_diag_state_prev = (byte)uVar1;
    if (dzg_pressure_control_state == 1) {
      io_control_flags = io_control_flags | 8;
      return uVar1;
    }
    io_control_flags = io_control_flags & 0xf7;
  }
  return uVar1;
}



/*
 * Function: dzgTimingStateVariablesInit @ 0x00032342
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void dzgTimingStateVariablesInit(void)

{
  dzg_timing_accumulator_value = 0;
  dzg_state_transition_counter = 0;
  dzg_timing_state_variable = 7;
  dzg_pressure_ramp_rate = 7;
  dzg_timing_state_index = INITIAL;
  dzg_pressure_state_index = 0;
  dzg_timing_state_machine_value =
       _dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60;
  dzg_pressure_target_value = watchdog_fueling_enforced_above_this_speed_0_to_5000;
  return;
}



/*
 * Function: dzgTimingAndPressureControlStateMachine @ 0x00032380
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint dzgTimingAndPressureControlStateMachine(void)

{
  word wVar1;
  ushort uVar4;
  uint uVar2;
  ushort uVar5;
  int iVar3;
  ushort uVar6;
  bool bVar7;
  
  uVar6 = retarder_input_value;
  if (retarder_input_value < 0x11) {
    uVar6 = 0x10;
  }
  switch(dzg_timing_state_index) {
  case INITIAL:
    if (dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60._2_2_ <
        throttle_position_raw) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_timing_accumulator_value;
      dzg_timing_accumulator_value = dzg_timing_accumulator_value + 1;
      if (bVar7) {
        dzg_timing_accumulator_value = 0;
        dzg_timing_state_index = DZG_ACTIVE;
        if ((int)((uint)dzg_timing_control_params -
                 (uint)_dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60) < 0) {
          iVar3 = -((uint)dzg_timing_control_params -
                   (uint)_dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60);
        }
        else {
          iVar3 = (uint)dzg_timing_control_params -
                  (uint)_dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60;
        }
        dzg_timing_state_variable =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_timing_state_machine_value = dzg_timing_control_params;
      }
    }
    else {
      dzg_timing_accumulator_value = 0;
    }
    break;
  case DZG_ACTIVE:
    if (throttle_position_raw <
        dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60._2_2_) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_timing_accumulator_value;
      dzg_timing_accumulator_value = dzg_timing_accumulator_value + 1;
      if (bVar7) {
        dzg_timing_accumulator_value = 0;
        dzg_timing_state_index = INITIAL;
        if ((int)((uint)dzg_timing_control_params -
                 (uint)_dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60) < 0) {
          iVar3 = -((uint)dzg_timing_control_params -
                   (uint)_dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60);
        }
        else {
          iVar3 = (uint)dzg_timing_control_params -
                  (uint)_dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60;
        }
        dzg_timing_state_variable =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_timing_state_machine_value =
             _dzg_angular_duration_angular_high_duration_of_dzg_pulse_at_tpu_0_60;
      }
    }
    else if ((time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000._0_2_ <
              throttle_position_raw) || (dzg_threshold_level_2 < throttle_position_raw)) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_timing_accumulator_value;
      dzg_timing_accumulator_value = dzg_timing_accumulator_value + 1;
      if (bVar7) {
        dzg_timing_accumulator_value = 0;
        dzg_timing_state_index = ALTERNATE;
        if ((int)((uint)watchdog_fueling_debounce_counts_0_to_255 - (uint)dzg_timing_control_params)
            < 0) {
          iVar3 = -((uint)watchdog_fueling_debounce_counts_0_to_255 -
                   (uint)dzg_timing_control_params);
        }
        else {
          iVar3 = (uint)watchdog_fueling_debounce_counts_0_to_255 - (uint)dzg_timing_control_params;
        }
        dzg_timing_state_variable =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_timing_state_machine_value = watchdog_fueling_debounce_counts_0_to_255;
      }
    }
    else {
      dzg_timing_accumulator_value = 0;
    }
    break;
  case ALTERNATE:
    if ((throttle_position_raw <
         time_that_must_elasp_since_last_event_to_consider_an_abuse_0_100000._0_2_) &&
       (throttle_position_raw < dzg_threshold_level_2)) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_timing_accumulator_value;
      dzg_timing_accumulator_value = dzg_timing_accumulator_value + 1;
      if (bVar7) {
        dzg_timing_accumulator_value = 0;
        dzg_timing_state_index = DZG_ACTIVE;
        if ((int)((uint)watchdog_fueling_debounce_counts_0_to_255 - (uint)dzg_timing_control_params)
            < 0) {
          iVar3 = -((uint)watchdog_fueling_debounce_counts_0_to_255 -
                   (uint)dzg_timing_control_params);
        }
        else {
          iVar3 = (uint)watchdog_fueling_debounce_counts_0_to_255 - (uint)dzg_timing_control_params;
        }
        dzg_timing_state_variable =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_timing_state_machine_value = dzg_timing_control_params;
      }
    }
    else if (time_abuse_event_must_be_continuously_present_before_it_will_b_0_100 <
             throttle_position_raw) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_timing_accumulator_value;
      dzg_timing_accumulator_value = dzg_timing_accumulator_value + 1;
      if (bVar7) {
        dzg_timing_accumulator_value = 0;
        dzg_timing_state_index = ALTERNATE|DZG_ACTIVE;
        if ((int)((uint)max_allowed_fueling_at_high_rpm_and_min_throttle_0_to_200 -
                 (uint)watchdog_fueling_debounce_counts_0_to_255) < 0) {
          iVar3 = -((uint)max_allowed_fueling_at_high_rpm_and_min_throttle_0_to_200 -
                   (uint)watchdog_fueling_debounce_counts_0_to_255);
        }
        else {
          iVar3 = (uint)max_allowed_fueling_at_high_rpm_and_min_throttle_0_to_200 -
                  (uint)watchdog_fueling_debounce_counts_0_to_255;
        }
        dzg_timing_state_variable =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_timing_state_machine_value = max_allowed_fueling_at_high_rpm_and_min_throttle_0_to_200;
      }
    }
    else {
      dzg_timing_accumulator_value = 0;
    }
    break;
  case ALTERNATE|DZG_ACTIVE:
    if (throttle_position_raw < time_abuse_event_must_be_continuously_present_before_it_will_b_0_100
       ) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_timing_accumulator_value;
      dzg_timing_accumulator_value = dzg_timing_accumulator_value + 1;
      if (bVar7) {
        dzg_timing_accumulator_value = 0;
        dzg_timing_state_index = ALTERNATE;
        if ((int)((uint)max_allowed_fueling_at_high_rpm_and_min_throttle_0_to_200 -
                 (uint)watchdog_fueling_debounce_counts_0_to_255) < 0) {
          iVar3 = -((uint)max_allowed_fueling_at_high_rpm_and_min_throttle_0_to_200 -
                   (uint)watchdog_fueling_debounce_counts_0_to_255);
        }
        else {
          iVar3 = (uint)max_allowed_fueling_at_high_rpm_and_min_throttle_0_to_200 -
                  (uint)watchdog_fueling_debounce_counts_0_to_255;
        }
        dzg_timing_state_variable =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_timing_state_machine_value = watchdog_fueling_debounce_counts_0_to_255;
      }
    }
    else {
      dzg_timing_accumulator_value = 0;
    }
  }
  uVar4 = (ushort)(((uVar6 - 8) * (uint)dzg_timing_state_machine_value * 0x20) / 100);
  if (0x6400 < uVar4) {
    uVar4 = 0x6400;
  }
  if (dzg_timing_state_variable < 2) {
    dzg_timing_state_variable = 1;
  }
  uVar2 = ((uVar6 - 8) * (uint)dzg_timing_state_variable * 0x20) / 100;
  uVar5 = (ushort)uVar2;
  if (dzg_timing_pressure_state_2 < uVar4) {
    wVar1 = uVar4;
    if ((uVar2 & 0xffff) + (uint)dzg_timing_pressure_state_2 <= (uint)uVar4) {
      wVar1 = uVar5 + dzg_timing_pressure_state_2;
    }
  }
  else {
    wVar1 = dzg_timing_pressure_state_2;
    if (((uVar4 < dzg_timing_pressure_state_2) &&
        (wVar1 = uVar4, (uVar2 & 0xffff) + (uint)uVar4 <= (uint)dzg_timing_pressure_state_2)) &&
       (uVar5 <= dzg_timing_pressure_state_2)) {
      wVar1 = dzg_timing_pressure_state_2 - uVar5;
    }
  }
  dzg_timing_pressure_state_2 = wVar1;
  pointer_to_oil_pressure_fuel_fault_log_data_0_2_32 = dzg_timing_pressure_state_2;
  if (5 < amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535) {
    if ((dtc_active_fault_count & 8) == 0) {
      tpu_pwm_channel_4_output = tpu_pwm_channel_4_output & 0xffff0000;
    }
    else {
      tpu_pwm_channel_4_output =
           ((((uint)pwm_output_4_scaling_factor * (uint)dzg_timing_pressure_state_2) / 0x6400 &
            0xffff) * 8000) / 1000 & 0xffff |
           ((uint)pwm_output_4_scaling_factor * 8000) / 1000 << 0x10;
    }
  }
  if (dzg_pressure_state_index == 0) {
    if (eps_main_lost_duration_0_20 < insite_parameter_display_value) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_state_transition_counter;
      dzg_state_transition_counter = dzg_state_transition_counter + 1;
      if (bVar7) {
        dzg_state_transition_counter = 0;
        dzg_pressure_state_index = 1;
        if ((int)((uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300 -
                 (uint)watchdog_fueling_enforced_above_this_speed_0_to_5000) < 0) {
          iVar3 = -((uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300 -
                   (uint)watchdog_fueling_enforced_above_this_speed_0_to_5000);
        }
        else {
          iVar3 = (uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300 -
                  (uint)watchdog_fueling_enforced_above_this_speed_0_to_5000;
        }
        dzg_pressure_ramp_rate =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_pressure_target_value =
             default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300;
      }
    }
    else {
      dzg_state_transition_counter = 0;
    }
  }
  else if (dzg_pressure_state_index == 1) {
    if (insite_parameter_display_value < eps_main_lost_duration_0_20) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_state_transition_counter;
      dzg_state_transition_counter = dzg_state_transition_counter + 1;
      if (bVar7) {
        dzg_state_transition_counter = 0;
        dzg_pressure_state_index = 0;
        if ((int)((uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300 -
                 (uint)watchdog_fueling_enforced_above_this_speed_0_to_5000) < 0) {
          iVar3 = -((uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300 -
                   (uint)watchdog_fueling_enforced_above_this_speed_0_to_5000);
        }
        else {
          iVar3 = (uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300 -
                  (uint)watchdog_fueling_enforced_above_this_speed_0_to_5000;
        }
        dzg_pressure_ramp_rate =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_pressure_target_value = watchdog_fueling_enforced_above_this_speed_0_to_5000;
      }
    }
    else if (dzg_pressure_threshold_high < insite_parameter_display_value) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_state_transition_counter;
      dzg_state_transition_counter = dzg_state_transition_counter + 1;
      if (bVar7) {
        dzg_state_transition_counter = 0;
        dzg_pressure_state_index = 2;
        if ((int)((uint)dzg_pressure_max_limit -
                 (uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300) < 0) {
          iVar3 = -((uint)dzg_pressure_max_limit -
                   (uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300);
        }
        else {
          iVar3 = (uint)dzg_pressure_max_limit -
                  (uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300;
        }
        dzg_pressure_ramp_rate =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_pressure_target_value = dzg_pressure_max_limit;
      }
    }
    else {
      dzg_state_transition_counter = 0;
    }
  }
  else if (dzg_pressure_state_index == 2) {
    if (insite_parameter_display_value < dzg_pressure_threshold_high) {
      bVar7 = _index_of_first_tdc_after_missed_pulse_1_6 < dzg_state_transition_counter;
      dzg_state_transition_counter = dzg_state_transition_counter + 1;
      if (bVar7) {
        dzg_state_transition_counter = 0;
        dzg_pressure_state_index = 1;
        if ((int)((uint)dzg_pressure_max_limit -
                 (uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300) < 0) {
          iVar3 = -((uint)dzg_pressure_max_limit -
                   (uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300);
        }
        else {
          iVar3 = (uint)dzg_pressure_max_limit -
                  (uint)default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300;
        }
        dzg_pressure_ramp_rate =
             (word)(iVar3 / (int)(uint)dzg_angle_after_cyl_tdc_angle_after_cyl_tdc_to_put_dzg_first_60_60
                                       ._0_2_);
        dzg_pressure_target_value =
             default_value_for_vp44_fuel_temperature_when_sensor_is_fail_40_to_300;
      }
    }
    else {
      dzg_state_transition_counter = 0;
    }
  }
  uVar4 = (ushort)(((uVar6 - 8) * (uint)dzg_pressure_target_value * 0x20) / 100);
  if (0x6400 < uVar4) {
    uVar4 = 0x6400;
  }
  if (dzg_pressure_ramp_rate < 2) {
    dzg_pressure_ramp_rate = 1;
  }
  uVar2 = ((uVar6 - 8) * (uint)dzg_pressure_ramp_rate * 0x20) / 100;
  uVar6 = (ushort)uVar2;
  if (dzg_timing_pressure_state_1 < uVar4) {
    uVar2 = (uVar2 & 0xffff) + (uint)dzg_timing_pressure_state_1;
    wVar1 = uVar4;
    if (uVar2 <= uVar4) {
      wVar1 = uVar6 + dzg_timing_pressure_state_1;
    }
  }
  else {
    wVar1 = dzg_timing_pressure_state_1;
    if (((uVar4 < dzg_timing_pressure_state_1) &&
        (uVar2 = (uVar2 & 0xffff) + (uint)uVar4, wVar1 = uVar4, uVar2 <= dzg_timing_pressure_state_1
        )) && (uVar6 <= dzg_timing_pressure_state_1)) {
      wVar1 = dzg_timing_pressure_state_1 - uVar6;
    }
  }
  dzg_timing_pressure_state_1 = wVar1;
  errors_allowed_timer_running_flag_for_oil_pres_0_1 = dzg_timing_pressure_state_1;
  if (5 < amount_of_time_since_water_in_fuel_low_failure_was_detected_0_65535) {
    uVar2 = CONCAT22((short)(uVar2 >> 0x10),dtc_active_fault_count) & 0xffff0004;
    if ((dtc_active_fault_count & 4) != 0) {
      tpu_pwm_channel_3_output =
           ((((uint)pwm_output_3_scaling_factor * (uint)dzg_timing_pressure_state_1) / 0x6400 &
            0xffff) * 8000) / 1000 & 0xffff |
           ((uint)pwm_output_3_scaling_factor * 8000) / 1000 << 0x10;
      return tpu_pwm_channel_3_output;
    }
    tpu_pwm_channel_3_output = tpu_pwm_channel_3_output & 0xffff0000;
  }
  return uVar2;
}



/*
 * Function: sensorHistoryTablePointerInit @ 0x00032b00
 */

void sensorHistoryTablePointerInit(void)

{
  sensor_history_init_value = 0x80000000;
  sensor_history_table_ptr = 0x80784c;
  return;
}



/*
 * Function: timeDeltaCalculator @ 0x00032b16
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void timeDeltaCalculator(void)

{
  time_delta_calculator_state = clutch_rpm_accumulator - clutch_rpm_accumulator_previous;
  fuel_cylinder_average = exponentialMovingAverage();
  clutch_rpm_accumulator_previous = clutch_rpm_accumulator;
  return;
}



/*
 * Function: oilPressureRpmLimitTargetSelector @ 0x00032b72
 */

uint oilPressureRpmLimitTargetSelector(void)

{
  uint uVar1;
  
  if ((((vp44_status_flags_2 & 0x8000) != 0) && ((sensor_status_history_bits & 0x400) != 0)) &&
     ((sensor_status_history_bits & 0x800) == 0)) {
    oil_pressure_rpm_limit_target = oil_pressure_rpm_target_special;
    return sensor_status_history_bits & 0x800;
  }
  if ((((sensor_status_history_bits & 0x80) != 0) && ((sensor_status_history_bits & 0x40) == 0)) &&
     (((sensor_status_history_bits & 0x400) == 0 &&
      (((sensor_status_history_bits & 8) == 0 && ((sensor_status_history_bits & 2) == 0)))))) {
    oil_pressure_rpm_limit_target = oil_pressure_rpm_target_low;
    return sensor_status_history_bits & 2;
  }
  uVar1 = sensor_status_history_bits & 0x200;
  if ((uVar1 != 0) &&
     ((((uVar1 = sensor_status_history_bits & 0x100, uVar1 == 0 &&
        (uVar1 = sensor_status_history_bits & 0x400, uVar1 == 0)) &&
       (uVar1 = sensor_status_history_bits & 8, uVar1 == 0)) &&
      (uVar1 = sensor_status_history_bits & 2, uVar1 == 0)))) {
    oil_pressure_rpm_limit_target = oil_pressure_rpm_target_high;
  }
  return uVar1;
}



/*
 * Function: sensorStatusHistoryTracker @ 0x00032c1c
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void sensorStatusHistoryTracker(void)

{
  bool bVar1;
  
  sensor_status_history_bits = sensor_status_history_bits * 2 & 0x2aaaa;
  if ((sensor_status_register & 2) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 1;
  }
  if ((sensor_status_register & 8) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 4;
  }
  if ((sensor_status_register & 0x10) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 0x10;
  }
  if ((sensor_status_register & 1) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 0x40;
  }
  if ((sensor_status_register & 4) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 0x100;
  }
  if ((sensor_status_register & 0x20) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 0x400;
  }
  if ((vp44_sensor_history_state & 0x10) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 0x1000;
  }
  if ((derate_status_byte & 8) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 0x10000;
  }
  if ((derate_status_byte & 4) != 0) {
    sensor_status_history_bits = sensor_status_history_bits | 0x4000;
  }
  switch(sensor_history_state_machine) {
  case SENSOR_IDLE:
    if ((((diagnostic_system_flags_1 & 0x10) == 0) ||
        (oil_pressure_validation_timer <= oil_pressure_validation_threshold)) ||
       (oil_pressure_state_index == 0)) {
      if ((((oil_pressure_validation_threshold < sensor_status_validation_counter) &&
           (oil_pressure_rpm_limit_previous == 0)) ||
          ((sensor_status_history_pointer_37f8 < throttle_position_value ||
           (((engine_fault_register_a & 0x200) != 0 && ((engine_fault_register_b & 0x200) != 0))))))
         || (((engine_fault_register_a & 0x100) != 0 && ((engine_fault_register_b & 0x100) != 0))))
      {
        sensor_history_state_machine = SENSOR_FAULT_DETECTED;
      }
      else if ((oil_pressure_rpm_limit_previous == 0) ||
              (sensor_status_validation_counter <= oil_pressure_validation_threshold)) {
        if ((sensor_status_history_bits & 0x1000) == 0) {
          sensor_status_validation_counter = sensor_status_validation_counter + 1;
          oil_pressure_validation_timer = 0;
        }
        else {
          oil_pressure_validation_timer = oil_pressure_validation_timer + 1;
          sensor_status_validation_counter = 0;
          if (((sensor_status_history_bits & 0x2000) == 0) &&
             (oil_pressure_state_index < oil_pressure_state_index_limit)) {
            oil_pressure_state_index = oil_pressure_state_index + 1;
          }
        }
      }
      else {
        sensor_history_state_machine = RECOVERY;
        oil_pressure_rpm_limit_target = oil_pressure_rpm_limit_previous;
      }
    }
    else {
      sensor_history_state_machine = SENSOR_ACTIVE;
      oil_pressure_rpm_limit_target =
           *(word *)(&oil_pressure_protection_table_ptr)[(short)oil_pressure_state_index];
    }
    break;
  case SENSOR_ACTIVE:
    if ((sensor_status_history_bits & 0x1000) == 0) {
      sensor_history_state_machine = SENSOR_IDLE;
      oil_pressure_state_index = 0;
    }
    else if ((sensor_status_history_pointer_37f8 < throttle_position_value) ||
            (((engine_fault_register_a & 0x100) != 0 && ((engine_fault_register_b & 0x100) != 0))))
    {
      sensor_history_state_machine = SENSOR_FAULT_DETECTED;
    }
    else {
      sensor_status_validation_counter = 0;
      oil_pressure_validation_timer = 0;
      oil_pressure_state_index = 0;
    }
    break;
  case SENSOR_FAULT_DETECTED:
    if (((throttle_position_value < sensor_status_history_pointer_37f8) &&
        (rpm_range_lower_limit <= current_engine_rpm)) &&
       (current_engine_rpm <= rpm_range_upper_limit)) {
      if (((engine_fault_register_a & 0x200) == 0) || ((engine_fault_register_b & 0x200) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((engine_fault_register_a & 0x100) == 0) || ((engine_fault_register_b & 0x100) == 0)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if ((!bVar1) && ((sensor_status_history_bits & 0x1000) != 0)) {
          sensor_history_state_machine = SENSOR_IDLE;
          oil_pressure_state_index = oil_pressure_state_index + 1;
          break;
        }
      }
    }
    if (((((diagnostic_system_flags_1 & 0x10) != 0) && ((sensor_status_history_bits & 0x10) != 0))
        && (throttle_position_value <= sensor_status_history_pointer_37f8)) &&
       ((rpm_range_lower_limit <= current_engine_rpm &&
        (current_engine_rpm <= rpm_range_upper_limit)))) {
      if (((engine_fault_register_a & 0x200) == 0) || ((engine_fault_register_b & 0x200) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((engine_fault_register_a & 0x100) == 0) || ((engine_fault_register_b & 0x100) == 0)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if ((((!bVar1) &&
             (((sensor_status_history_bits & 0x4000) == 0 || ((vp44_status_flags_2 & 0x1000) == 0)))
             ) && (((sensor_status_history_bits & 0x10000) == 0 ||
                   ((vp44_status_flags_2 & 0x800) == 0)))) &&
           (((((sensor_status_history_bits & 0x80) != 0 &&
              ((sensor_status_history_bits & 0x40) == 0)) ||
             (((sensor_status_history_bits & 0x200) != 0 &&
              ((sensor_status_history_bits & 0x100) == 0)))) ||
            ((((sensor_status_history_bits & 0x800) == 0 &&
              ((sensor_status_history_bits & 0x400) != 0)) && ((vp44_status_flags_2 & 0x8000) != 0))
            )))) {
          sensor_history_state_machine = RECOVERY;
          if ((sensor_status_history_bits & 0x400) == 0) {
            if (((sensor_status_history_bits & 0x80) == 0) ||
               ((sensor_status_history_bits & 0x40) != 0)) {
              if (((sensor_status_history_bits & 0x200) != 0) &&
                 ((sensor_status_history_bits & 0x100) == 0)) {
                oil_pressure_rpm_limit_target = oil_pressure_rpm_target_high;
              }
            }
            else {
              oil_pressure_rpm_limit_target = oil_pressure_rpm_target_low;
            }
          }
          break;
        }
      }
    }
    oil_pressure_rpm_ramp_complete = 0;
    oil_pressure_state_index = 0;
    sensor_status_validation_counter = 0;
    oil_pressure_validation_timer = 0;
    oil_pressure_rpm_limit_previous = 0;
    break;
  case RECOVERY:
    if (throttle_position_value <= sensor_status_history_pointer_37f8) {
      if (((engine_fault_register_a & 0x200) == 0) || ((engine_fault_register_b & 0x200) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((engine_fault_register_a & 0x100) == 0) || ((engine_fault_register_b & 0x100) == 0)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if ((!bVar1) && ((sensor_status_history_bits & 0x1000) != 0)) {
          sensor_history_state_machine = SENSOR_IDLE;
          oil_pressure_state_index = oil_pressure_state_index + 1;
          oil_pressure_rpm_limit_previous = oil_pressure_rpm_limit_target;
          break;
        }
      }
    }
    if ((((((sensor_status_history_bits & 0x10) == 0) ||
          (sensor_status_history_pointer_37f8 < throttle_position_value)) ||
         (((engine_fault_register_a & 0x100) != 0 && ((engine_fault_register_b & 0x100) != 0)))) ||
        (((vp44_status_flags_2 & 0x1000) != 0 && ((sensor_status_history_bits & 0x4000) != 0)))) ||
       (((vp44_status_flags_2 & 0x800) != 0 && ((sensor_status_history_bits & 0x10000) != 0)))) {
      sensor_history_state_machine = SENSOR_FAULT_DETECTED;
    }
    else {
      sensor_status_validation_counter = 0;
      oil_pressure_validation_timer = 0;
      oil_pressure_state_index = 0;
      oilPressureRpmLimitTargetSelector();
      if ((sensor_status_history_bits & 1) == 0) {
        if ((sensor_status_history_bits & 4) == 0) {
          if (((sensor_status_history_bits & 2) != 0) || ((sensor_status_history_bits & 8) != 0)) {
            oil_pressure_rpm_limit_target = current_engine_rpm;
            if (fsmxthfl_calc_input <= current_fuel_demand_value) {
              oil_pressure_rpm_limit_target =
                   (short)(((uint)(ushort)(current_fuel_demand_value - fsmxthfl_calc_input) *
                           (uint)_oil_pressure_cal_factor_3) / 0x1d70) + current_engine_rpm;
            }
            if (oil_pressure_rpm_limit_max < oil_pressure_rpm_limit_target) {
              oil_pressure_rpm_limit_target = oil_pressure_rpm_limit_max;
            }
            else if (oil_pressure_rpm_limit_target < oil_pressure_rpm_limit_min) {
              oil_pressure_rpm_limit_target = oil_pressure_rpm_limit_min;
            }
          }
        }
        else if (oil_pressure_rpm_limit_target <
                 (ushort)(oil_pressure_rpm_limit_step + oil_pressure_rpm_limit_min)) {
          oil_pressure_rpm_limit_target = oil_pressure_rpm_limit_min;
        }
        else {
          oil_pressure_rpm_limit_target =
               oil_pressure_rpm_limit_target - oil_pressure_rpm_limit_step;
        }
      }
      else if ((ushort)(oil_pressure_rpm_limit_max - oil_pressure_rpm_limit_step) <
               oil_pressure_rpm_limit_target) {
        oil_pressure_rpm_limit_target = oil_pressure_rpm_limit_max;
      }
      else {
        oil_pressure_rpm_limit_target = oil_pressure_rpm_limit_step + oil_pressure_rpm_limit_target;
      }
    }
  }
  if (((ushort)(oil_pressure_rpm_increment + oil_pressure_rpm_limit_current) <
       oil_pressure_rpm_limit_target) && (oil_pressure_rpm_ramp_complete == 0)) {
    oil_pressure_rpm_limit_current = oil_pressure_rpm_increment + oil_pressure_rpm_limit_current;
  }
  else {
    oil_pressure_rpm_limit_current = oil_pressure_rpm_limit_target;
    oil_pressure_rpm_ramp_complete = 1;
  }
  pointer_to_oil_pressure_rpm_limit_threshold_0_2_32 = oil_pressure_rpm_limit_current;
  if ((sensor_history_state_machine != RECOVERY) && (sensor_history_state_machine != SENSOR_ACTIVE))
  {
    oil_pressure_protection_enabled = 0;
    return;
  }
  oil_pressure_protection_enabled = 1;
  return;
}



/*
 * Function: initOilPressureProtectionPointers @ 0x00033254
 */

void initOilPressureProtectionPointers(void)

{
  sensor_history_state_machine = SENSOR_FAULT_DETECTED;
  oil_pressure_protection_enabled = 0;
  pointer_to_oil_pressure_rpm_limit_threshold_0_2_32 = 0;
  oil_pressure_protection_table_ptr = 0x8036a0;
  oil_pressure_table_1_ptr = 0x8036a0;
  oil_pressure_table_2_ptr = 0x8037fe;
  oil_pressure_table_3_ptr = 0x803800;
  oil_pressure_table_4_ptr = 0x803802;
  oil_pressure_table_5_ptr = 0x803804;
  oil_pressure_rpm_limit_previous = 0;
  sensor_status_validation_counter = 0;
  oil_pressure_validation_timer = 0;
  oil_pressure_state_index = 0;
  oil_pressure_rpm_ramp_complete = 0;
  oil_pressure_rpm_limit_current = 0;
  sensor_status_history_bits._2_2_ = sensor_status_history_bits._2_2_ | 0x2000;
  return;
}



/*
 * Function: vp44FaultProtectionSystemInit @ 0x000332ce
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FaultProtectionSystemInit(void)

{
  byte bVar1;
  word *pwVar2;
  word *pwVar3;
  byte *pbVar4;
  
  vp44_fault_protection_addr_2 = 0x2240;
  vp44_fault_protection_mask_2 = 0;
  vp44_fault_protection_flags_2 = 0x80;
  vp44_fault_protection_can_id_2 = 0x9955;
  vp44_timing_system_monitor_ptr = 0x2000;
  vp44_fault_protection_mask_1 = 0;
  vp44_fault_protection_flags_1 = 0x88;
  vp44_fault_protection_can_id_1 = 0x5559;
  vp44_fault_protection_addr_4 = 0xa240;
  vp44_fault_protection_mask_4 = 0;
  vp44_fault_protection_flags_4 = 0x80;
  vp44_fault_protection_can_id_4 = 0x9955;
  vp44_fault_protection_addr_3 = 0xa000;
  vp44_fault_protection_mask_3 = 0;
  vp44_fault_protection_flags_3 = 0x88;
  vp44_fault_protection_can_id_3 = 0x5559;
  vp44_fault_protection_addr_6 = 0xe240;
  vp44_fault_protection_mask_6 = 0;
  vp44_fault_protection_flags_6 = 0x80;
  vp44_fault_protection_can_id_6 = 0x9955;
  vp44_fault_protection_addr_5 = 0xe000;
  vp44_fault_protection_mask_5 = 0;
  vp44_fault_protection_flags_5 = 0x88;
  vp44_fault_protection_can_id_5 = 0x5559;
  engine_control_system_ready = 0;
  vp44_fso_fault_active_flag = 0;
  vp44_fso_fault_detection_enable = 1;
  shutdown_minimum_init_value = 0x1700;
  bVar1 = 0;
  pwVar2 = &vp44_timing_range_table_ptr;
  pwVar3 = &vp44_fault_protection_table_base;
  pbVar4 = &vp44_fault_protection_state_array;
  do {
    *pwVar2 = *pwVar3;
    *pbVar4 = 1;
    bVar1 = bVar1 + 1;
    pwVar2 = pwVar2 + 1;
    pwVar3 = pwVar3 + 1;
    pbVar4 = pbVar4 + 1;
  } while (bVar1 < 6);
  vp44_timing_intermediate_value = 0;
  _base_timing_table_lookup_arg_346e = &base_timing_table_lookup_arg_345a;
  _lift_pump_table_lookup_arg_3486 = &lift_pump_table_lookup_arg_3472;
  base_timing_table_lookup_arg_345a = 2;
  vp44_timing_idle_cmd_ptr = (dword)&temporary_timing_command_at_idle_for_static_timing_check_0_100;
  vp44_timing_table_size = 2;
  vp44_timing_fault_limit_ptr = (dword)&fuel_limit_when_timing_fault_is_active_0_to_300;
  vp44_stuck_pump_threshold_ptr =
       (dword)&max_112_messages_received_after_pump_should_be_off_for_stuck_0_to_255;
  lift_pump_table_lookup_arg_3472 = 2;
  vp44_lift_pump_table_ptr = 0x807656;
  vp44_lift_pump_table_2_size = 2;
  vp44_lift_pump_table_2_ptr = 0x807670;
  vp44_lift_pump_table_3_ptr = 0x80768a;
  vp44_can_msg_200_min_value = vp44_can_msg_200_init_value;
  vp44_can_msg_200_max_value = vp44_can_msg_200_init_value;
  vp44_fso_circuit_fault_fuel_limit = 0x1700;
  fso_protection_fuel_limit = 0x1700;
  vp44_fso_fuel_limit_output = 0x1700;
  vp44_fso_bit0_fuel_limit = 0x1700;
  vp44_fso_bit15_fuel_limit = 0x1700;
  vp44_msg_300_fault_fuel_limit_1 = 0x1700;
  vp44_msg_300_fault_fuel_limit_2 = 0x1700;
  vp44_timing_actual_value = 0x28f;
  vp44_timing_expected_value = 0x28f;
  vp44_can_msg_200_word_2 = 0x28f;
  vp44_can_msg_200_last_word = 0x28f;
  vp44_status_register_5e12 = vp44_status_register_5e12 & 0x7fff;
  vp44_fault_status_reg = vp44_fault_status_reg & 0xfb6e;
  vp44_timing_expected_init = 0x28f0000;
  vp44_timing_expected_table_ptr = 0x807404;
  vp44_timing_actual_init = 0x28f0000;
  vp44_timing_actual_table_ptr = 0x807404;
  vp44FaultBit5Reset();
  return;
}



/*
 * Function: vp44TimingRangeValidation @ 0x00033524
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44TimingRangeValidation(void)

{
  bool bVar1;
  word wVar2;
  byte bVar3;
  dword **ppdVar4;
  dword *local_2a;
  undefined2 local_26;
  word *pwStack_24;
  byte local_6;
  byte bStack_5;
  
  ppdVar4 = (dword **)&stack0xffffffe0;
  if (vp44_timing_table_index == 0) {
    bVar3 = 0;
  }
  else {
    bVar3 = vp44_timing_table_index - 1;
  }
  if (maximum_increase_in_timing_command_allowed_per_loop_0_to_60 < current_engine_fuel_demand) {
    vp44_fuel_demand_range_fault_counter = vp44_fuel_demand_range_fault_counter + 1;
    wVar2 = maximum_increase_in_timing_command_allowed_per_loop_0_to_60;
    if ((byte)in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255 <
        vp44_fuel_demand_range_fault_counter) {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x400;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x400;
      vp44_fuel_demand_range_fault_counter = 0;
    }
  }
  else {
    vp44_fuel_demand_range_fault_counter = 0;
    wVar2 = current_engine_fuel_demand;
  }
  local_6 = (byte)((uint)((int)(uint)wVar2 >> 1) >> 8);
  vp44_fuel_demand_out_high_byte = local_6;
  bStack_5 = (byte)((int)(uint)wVar2 >> 1);
  vp44_fuel_demand_out_low_byte = bStack_5;
  if ((short)maximum_decrease_in_timing_command_allowed_per_loop_0_to_60 <
      (short)vp44_timing_intermediate_value) {
    vp44_timing_decrease_fault_counter = vp44_timing_decrease_fault_counter + 1;
    wVar2 = maximum_decrease_in_timing_command_allowed_per_loop_0_to_60;
    if ((byte)in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255 <
        vp44_timing_decrease_fault_counter) {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x400;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x400;
      vp44_timing_decrease_fault_counter = 0;
    }
  }
  else if ((short)vp44_timing_intermediate_value <
           (short)pump_ram_address_contents_requested_below_this_speed_0_to_5000) {
    vp44_timing_min_fault_counter = vp44_timing_min_fault_counter + 1;
    wVar2 = pump_ram_address_contents_requested_below_this_speed_0_to_5000;
    if ((byte)in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255 <
        vp44_timing_min_fault_counter) {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x400;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x400;
      vp44_timing_min_fault_counter = 0;
    }
  }
  else {
    vp44_timing_decrease_fault_counter = 0;
    vp44_timing_min_fault_counter = 0;
    wVar2 = vp44_timing_intermediate_value;
  }
  local_6 = (byte)(wVar2 >> 8);
  vp44_timing_range_out_high_byte = local_6;
  bStack_5 = (byte)wVar2;
  vp44_timing_range_out_low_byte = bStack_5;
  if ((short)_debounce_for_fuel_quantity_feedback_pulse_fault_detection_0_to_255 <
      (short)vp44_feedback_pulse_value) {
    vp44_feedback_pulse_high_fault_counter = vp44_feedback_pulse_high_fault_counter + 1;
    wVar2 = _debounce_for_fuel_quantity_feedback_pulse_fault_detection_0_to_255;
    if ((byte)in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255 <
        vp44_feedback_pulse_high_fault_counter) {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x400;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x400;
      vp44_feedback_pulse_high_fault_counter = 0;
    }
  }
  else if ((short)vp44_feedback_pulse_value <
           (short)feedback_pulse_fault_disabled_when_fueling_is_below_this_para_0_to_300) {
    vp44_feedback_pulse_low_fault_counter = vp44_feedback_pulse_low_fault_counter + 1;
    wVar2 = feedback_pulse_fault_disabled_when_fueling_is_below_this_para_0_to_300;
    if ((byte)in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255 <
        vp44_feedback_pulse_low_fault_counter) {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x400;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x400;
      vp44_feedback_pulse_low_fault_counter = 0;
    }
  }
  else {
    vp44_feedback_pulse_high_fault_counter = 0;
    vp44_feedback_pulse_low_fault_counter = 0;
    wVar2 = vp44_feedback_pulse_value;
  }
  local_6 = (byte)(wVar2 >> 8);
  vp44_feedback_pulse_out_high_byte = local_6;
  bStack_5 = (byte)wVar2;
  vp44_feedback_pulse_out_low_byte = bStack_5;
  if ((&vp44_fault_protection_state_array)[(short)(ushort)bVar3] == 0) {
    vp44_timing_final_value = 0;
  }
  else {
    vp44_timing_final_value =
         vp44_timing_base_offset + (&vp44_timing_range_table_ptr)[(short)(ushort)bVar3];
    if ((int)(uint)intercept_used_to_convert_final_timing_to_vp44_units_360_to_360 <
        (int)(short)vp44_timing_final_value) {
      vp44_timing_max_fault_counter = vp44_timing_max_fault_counter + 1;
      if ((byte)in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255 <
          vp44_timing_max_fault_counter) {
        vp44_fault_status_reg = vp44_fault_status_reg | 0x400;
        vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x400;
        vp44_timing_max_fault_counter = 0;
      }
      vp44_timing_final_value = intercept_used_to_convert_final_timing_to_vp44_units_360_to_360;
    }
    else if ((short)vp44_timing_final_value < 0) {
      derate_threshold_change_counter._1_1_ = (byte)derate_threshold_change_counter + 1;
      if ((byte)in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255 <
          (byte)derate_threshold_change_counter) {
        vp44_fault_status_reg = vp44_fault_status_reg | 0x400;
        vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x400;
        derate_threshold_change_counter._1_1_ = 0;
      }
      vp44_timing_final_value = 0;
    }
    else {
      vp44_timing_max_fault_counter = 0;
      derate_threshold_change_counter._1_1_ = 0;
    }
  }
  local_6 = (byte)(vp44_timing_final_value >> 8);
  vp44_timing_cmd_out_high_byte = local_6;
  bStack_5 = (byte)vp44_timing_final_value;
  vp44_timing_cmd_out_low_byte = bStack_5;
  vp44_fuel_demand_accumulator = vp44_fuel_demand_accumulator + current_fuel_demand_value;
  pwStack_24 = (word *)0x3381e;
  vp44RpmBasedFaultDetector();
  if (((vp44_fault_status_reg & 0x20) == 0) || ((fso_fault_enable_mask_1 & 0x20) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    pwStack_24 = &vp44_timing_system_monitor_ptr;
    local_26 = 2;
    ppdVar4 = &local_2a;
    local_2a = &serial_port_2_base_register;
    canFrameDataCopy();
  }
  if ((vp44_can_msg_lower_threshold <= current_engine_fuel_demand) &&
     (current_engine_fuel_demand <= vp44_can_msg_upper_threshold)) {
    *(undefined4 *)((int)ppdVar4 + -4) = 0x33876;
    vp44CanMessage100ResponseBuilder();
  }
  return;
}



/*
 * Function: vp44CanMessage100Parser @ 0x00033880
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

ushort vp44CanMessage100Parser(int param_1)

{
  int iVar1;
  ushort uVar2;
  undefined2 local_6;
  
  vp44_can_msg_100_received_flag = 1;
  vp44_can_msg_100_byte_0 = *(byte *)(param_1 + 7);
  vp44_can_msg_100_byte_1 = *(byte *)(param_1 + 8);
  vp44_can_msg_100_byte_2 = *(byte *)(param_1 + 9);
  vp44_can_msg_100_byte_3 = *(byte *)(param_1 + 10);
  vp44_can_msg_100_byte_4 = *(byte *)(param_1 + 0xb);
  vp44_can_msg_100_byte_5 = *(byte *)(param_1 + 0xc);
  vp44_can_msg_100_byte_6 = *(byte *)(param_1 + 0xd);
  vp44_can_msg_100_byte_7 = *(byte *)(param_1 + 0xe);
  vp44_can_msg_100_status_flags = vp44_can_msg_100_byte_1;
  vp44_status_register_9a5f = vp44_can_msg_100_byte_0;
  vp44_can_msg_100_mode_bits = (byte)((int)(vp44_can_msg_100_byte_3 & 0xe0) >> 5);
  local_6 = CONCAT11(vp44_can_msg_100_byte_3,vp44_can_msg_100_byte_2) & 0x1fff;
  vp44_can_msg_100_timing_value = local_6;
  local_6 = CONCAT11(vp44_can_msg_100_byte_5,vp44_can_msg_100_byte_4);
  vp44_timing_mode_selector = local_6 << 2;
  _engine_rpm_calculation_param_3 = vp44_timing_mode_selector;
  _engine_fault_timer_3 = engine_fault_timer_init;
  local_6 = CONCAT11(vp44_can_msg_100_byte_7,vp44_can_msg_100_byte_6);
  iVar1 = (short)local_6 * 0xe66;
  if (iVar1 < 0) {
    iVar1 = iVar1 + 0x7ff;
  }
  fso_monitoring_command_value = (short)(iVar1 >> 0xb) + 0xe34a;
  uVar2 = vp44_communication_status & 1;
  if (((vp44_communication_status & 1) == 0) &&
     (uVar2 = current_engine_fuel_demand,
     current_engine_fuel_demand < pump_ram_address_contents_requested_above_this_speed_0_to_5000)) {
    vp44_can_msg_100_received_flag = 1;
    vp44_can_msg_100_retry_counter = vp44_can_msg_100_retry_counter + 1;
    _engine_fault_timer_3 = engine_fault_timer_init;
    return current_engine_fuel_demand;
  }
  vp44_can_msg_100_retry_counter = 0;
  return uVar2;
}



/*
 * Function: vp44CanMessage100ResponseBuilder @ 0x000339c2
 */

void vp44CanMessage100ResponseBuilder(void)

{
  byte byte_swap_temp;
  byte bStack_5;
  
  byte_swap_temp = (byte)(vp44_can_msg_100_cmd_word_3 >> 8);
  vp44_can_msg_100_tx_byte_0 = byte_swap_temp;
  bStack_5 = (byte)vp44_can_msg_100_cmd_word_3;
  vp44_can_msg_100_tx_byte_1 = bStack_5;
  byte_swap_temp = (byte)(vp44_can_msg_100_cmd_word_2 >> 8);
  vp44_can_msg_100_tx_byte_2 = byte_swap_temp;
  bStack_5 = (byte)vp44_can_msg_100_cmd_word_2;
  vp44_can_msg_100_tx_byte_3 = bStack_5;
  byte_swap_temp = (byte)(vp44_can_msg_100_cmd_word_1 >> 8);
  vp44_can_msg_100_tx_byte_4 = byte_swap_temp;
  bStack_5 = (byte)vp44_can_msg_100_cmd_word_1;
  vp44_can_msg_100_tx_byte_5 = bStack_5;
  byte_swap_temp = (byte)(vp44_can_msg_100_cmd_word_0 >> 8);
  vp44_can_msg_100_tx_byte_6 = byte_swap_temp;
  bStack_5 = (byte)vp44_can_msg_100_cmd_word_0;
  vp44_can_msg_100_tx_byte_7 = bStack_5;
  canFrameDataCopy(&serial_port_2_base_register);
  return;
}



/*
 * Function: vp44CanMessage200Parser @ 0x00033a3a
 */

void vp44CanMessage200Parser(int param_1)

{
  ushort uVar1;
  ushort uVar2;
  undefined2 local_6;
  
  vp44_can_msg_200_byte_0 = *(byte *)(param_1 + 7);
  vp44_can_msg_200_byte_1 = *(byte *)(param_1 + 8);
  vp44_can_msg_200_byte_2 = *(byte *)(param_1 + 9);
  vp44_can_msg_200_byte_3 = *(byte *)(param_1 + 10);
  vp44_can_msg_200_byte_4 = *(byte *)(param_1 + 0xb);
  vp44_can_msg_200_byte_5 = *(byte *)(param_1 + 0xc);
  vp44_can_msg_200_byte_6 = *(byte *)(param_1 + 0xd);
  vp44_can_msg_200_byte_7 = *(byte *)(param_1 + 0xe);
  local_6 = CONCAT11(*(byte *)(param_1 + 8),*(byte *)(param_1 + 7));
  uVar1 = local_6;
  vp44_can_msg_200_word_0 = local_6;
  local_6 = CONCAT11(*(byte *)(param_1 + 10),*(byte *)(param_1 + 9));
  uVar2 = local_6;
  vp44_can_msg_200_word_1 = local_6;
  local_6 = CONCAT11(*(byte *)(param_1 + 0xc),*(byte *)(param_1 + 0xb));
  vp44_can_msg_200_word_2 = local_6;
  vp44_can_msg_200_word_2_copy = local_6;
  local_6 = CONCAT11(*(byte *)(param_1 + 0xe),*(byte *)(param_1 + 0xd));
  vp44_can_msg_200_word_3 = local_6;
  if (vp44_can_msg_200_parse_mode == 1) {
    vp44_can_msg_200_combined_value = uVar1 & 0xff;
  }
  else if (vp44_can_msg_200_parse_mode == 2) {
    vp44_can_msg_200_combined_value = (dword)uVar1;
  }
  else if (vp44_can_msg_200_parse_mode == 4) {
    vp44_can_msg_200_combined_value = (uint)uVar1 + (uint)uVar2 * 0x10000;
  }
  if (vp44_can_msg_200_combined_value < vp44_can_msg_200_min_value) {
    vp44_can_msg_200_min_value = vp44_can_msg_200_combined_value;
  }
  if (vp44_can_msg_200_max_value < vp44_can_msg_200_combined_value) {
    vp44_can_msg_200_max_value = vp44_can_msg_200_combined_value;
  }
  vp44_can_msg_200_last_word = local_6;
  return;
}



/*
 * Function: vp44CanMessage200ResponseBuilder @ 0x00033b8c
 */

void vp44CanMessage200ResponseBuilder(void)

{
  byte local_6;
  byte bStack_5;
  
  local_6 = (byte)(derate_output_value >> 8);
  vp44_can_msg_200_parsed_byte_9 = local_6;
  bStack_5 = (byte)derate_output_value;
  vp44_can_msg_200_parsed_byte_8 = bStack_5;
  vp44_can_msg_200_parsed_byte_10 = (byte)vp44_fso_stuck_debounce_threshold;
  vp44_can_msg_200_parsed_byte_11 = vp44_can_200_message_byte_4;
  vp44_can_msg_200_parsed_byte_12 = vp44_can_200_message_byte_5;
  vp44_can_msg_200_parsed_byte_13 = vp44_can_200_message_byte_6;
  vp44_can_msg_200_parsed_byte_14 = vp44_can_200_response_byte_0;
  vp44_can_msg_200_parsed_byte_15 = vp44_can_200_response_byte_1;
  canFrameDataCopy(&serial_port_2_base_register);
  return;
}



/*
 * Function: vp44CanMessage300Parser @ 0x00033bf2
 */

void vp44CanMessage300Parser(int param_1)

{
  vp44_can_msg_300_fault_flags = *(byte *)(param_1 + 7);
  vp44_can_msg_300_byte_1 = *(byte *)(param_1 + 8);
  vp44_can_msg_300_byte_2 = *(byte *)(param_1 + 9);
  vp44_can_msg_300_byte_3 = *(byte *)(param_1 + 10);
  vp44_can_msg_300_byte_4 = *(byte *)(param_1 + 0xb);
  vp44_can_msg_300_byte_5 = *(byte *)(param_1 + 0xc);
  vp44_can_msg_300_byte_6 = *(byte *)(param_1 + 0xd);
  vp44_can_msg_300_byte_7 = *(byte *)(param_1 + 0xe);
  vp44_can_msg_300_fault_flags_copy = vp44_can_msg_300_fault_flags;
  vp44Message300FaultFlagProcessor();
  return;
}



/*
 * Function: baseTimingTableLookup @ 0x00033c48
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void baseTimingTableLookup(void)

{
  undefined8 uVar1;
  
  base_timing_fuel_demand_input = current_fuel_demand_value;
  base_timing_rpm_input = current_engine_fuel_demand;
  base_timing_fuel_value_input = current_fuel_demand_value;
  uVar1 = tableInterpolationLookup(_base_timing_table_lookup_arg_346e);
  vp44_timing_base_offset = (word)((ulonglong)uVar1 >> 0x20);
  return;
}



/*
 * Function: liftPumpFuelDeliveryController @ 0x00033c84
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void liftPumpFuelDeliveryController(void)

{
  word wVar1;
  undefined8 uVar2;
  
  lift_pump_fuel_demand_input = current_engine_fuel_demand;
  lift_pump_fuel_value_input = current_fuel_demand_value;
  uVar2 = tableInterpolationLookup(_lift_pump_table_lookup_arg_3486);
  lift_pump_table_lookup_result = (word)((ulonglong)uVar2 >> 0x20);
  wVar1 = lift_pump_diagnostic_fuel_value;
  if ((vp44_fso_circuit_fault_flag == 0) &&
     (wVar1 = diagnostic_fuel_arbitration_output, lift_pump_diagnostic_mode_flag != 0)) {
    wVar1 = lift_pump_diagnostic_override_value;
  }
  lift_pump_fuel_offset_calc =
       lift_pump_fuel_base_offset +
       (short)((int)((int)(short)lift_pump_fuel_scale_factor * (uint)wVar1) / 0x161);
  lift_pump_combined_fuel_value = lift_pump_table_lookup_result + lift_pump_fuel_offset_calc;
  wVar1 = (short)lift_pump_combined_fuel_value / 3;
  lift_pump_timing_delta = wVar1 - lift_pump_timing_smoothed;
  if ((short)lift_pump_timing_delta < 0) {
    if ((-(uint)lift_pump_timing_decrease_limit == (int)(short)lift_pump_timing_delta ||
         -(int)(short)lift_pump_timing_delta < (int)(uint)lift_pump_timing_decrease_limit) &&
       (lift_pump_timing_decrease_limit != 0)) {
      lift_pump_timing_delta = -lift_pump_timing_decrease_limit;
      wVar1 = lift_pump_timing_delta + lift_pump_timing_smoothed;
    }
  }
  else if (((int)(uint)lift_pump_timing_increase_limit < (int)(short)lift_pump_timing_delta) &&
          (lift_pump_timing_increase_limit != 0)) {
    lift_pump_timing_delta = lift_pump_timing_increase_limit;
    wVar1 = lift_pump_timing_increase_limit + lift_pump_timing_smoothed;
  }
  lift_pump_timing_smoothed = wVar1;
  vp44_timing_intermediate_value = lift_pump_timing_smoothed * 3;
  lift_pump_run_time_calculated =
       lift_pump_run_time_when_stopping_after_cranking_0_to_120 +
       (short)((int)(((int)(short)lift_pump_on_time_duration_during_cranking_0_to_120 -
                     (int)(short)lift_pump_run_time_when_stopping_after_cranking_0_to_120) *
                    ((uint)current_engine_fuel_demand -
                    (uint)_flag_to_override_prime_pump_control_0_to_ff)) /
              (int)((uint)lift_pump_run_time_when_stopping_after_running_0_to_120 -
                   (uint)_flag_to_override_prime_pump_control_0_to_ff));
  return;
}



/*
 * Function: derateThresholdIoController @ 0x00033dca
 */

void derateThresholdIoController(void)

{
  if (derate_threshold_exceeded == 0) {
    sim_data_direction_control = sim_data_direction_control & 0xbf;
  }
  else {
    sim_data_direction_control = sim_data_direction_control | 0x40;
  }
  if ((derate_threshold_exceeded != derate_threshold_previous) &&
     (derate_threshold_change_counter._0_1_ < 2)) {
    derate_threshold_change_counter._0_1_ = derate_threshold_change_counter._0_1_ + 1;
  }
  derate_threshold_previous = derate_threshold_exceeded;
  return;
}



/*
 * Function: vp44FsoFaultDetectionMonitor @ 0x00033e0e
 */

void vp44FsoFaultDetectionMonitor(void)

{
  bool bVar1;
  int iVar2;
  
  if (vp44_fso_fault_detection_enable != 0) {
    if ((vp44_status_register_9a5f & 0x20) == 0) {
      fso_bit5_fault_clear_counter = fso_bit5_fault_clear_counter + 1;
      if (fso_fault_debounce_threshold <= fso_bit5_fault_clear_counter) {
        vp44_fault_status_reg = vp44_fault_status_reg & 0xfff7;
        fso_bit5_fault_clear_counter = 0;
      }
      fso_bit5_fault_set_counter = 0;
    }
    else {
      fso_bit5_fault_set_counter = fso_bit5_fault_set_counter + 1;
      if (fso_fault_debounce_threshold <= fso_bit5_fault_set_counter) {
        vp44_fault_status_reg = vp44_fault_status_reg | 8;
        vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 8;
        fso_bit5_fault_set_counter = 0;
      }
      fso_bit5_fault_clear_counter = 0;
    }
    if ((vp44_status_register_9a5f & 0x40) == 0) {
      fso_bit6_fault_clear_counter = fso_bit6_fault_clear_counter + 1;
      if (fso_fault_debounce_threshold <= fso_bit6_fault_clear_counter) {
        engine_fault_status_register_3 = engine_fault_status_register_3 & 0xff7f;
        fso_bit6_fault_clear_counter = 0;
      }
      fso_fault_debounce_counter = 0;
    }
    else {
      fso_fault_debounce_counter = fso_fault_debounce_counter + 1;
      if (fso_fault_debounce_threshold <= fso_fault_debounce_counter) {
        engine_fault_status_register_4 = engine_fault_status_register_4 | 0x80;
        engine_fault_status_register_3 = engine_fault_status_register_3 & 0xfeff | 0x80;
        fso_fault_debounce_counter = 0;
      }
      fso_bit6_fault_clear_counter = 0;
    }
    if (((vp44_status_register_9a5f & 0x20) == 0) || ((vp44_status_register_9a5f & 0x40) == 0)) {
      if ((short)fso_fault_delta_threshold < (short)fso_monitoring_command_value) {
        fso_high_cmd_fault_debounce_counter = fso_high_cmd_fault_debounce_counter + 1;
        if (fso_fault_debounce_threshold <= fso_high_cmd_fault_debounce_counter) {
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x40;
          engine_fault_status_register_3 = engine_fault_status_register_3 & 0xfeff | 0x40;
          fso_high_cmd_fault_debounce_counter = 0;
        }
      }
      else {
        fso_high_cmd_fault_debounce_counter = 0;
      }
    }
    if (((engine_fault_status_register_3 & 0x80) == 0) || ((vp44_fso_fault_enable_mask & 0x80) == 0)
       ) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (((vp44_fault_status_reg & 8) == 0) || ((fso_fault_enable_mask_1 & 8) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((engine_fault_status_register_3 & 0x800) == 0) ||
           ((vp44_fso_fault_enable_mask & 0x800) == 0)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if (!bVar1) {
          if (((engine_fault_status_register_3 & 0x400) == 0) ||
             ((vp44_fso_fault_enable_mask & 0x400) == 0)) {
            bVar1 = false;
          }
          else {
            bVar1 = true;
          }
          if (!bVar1) {
            if (((engine_fault_status_register_3 & 0x200) == 0) ||
               ((vp44_fso_fault_enable_mask & 0x200) == 0)) {
              bVar1 = false;
            }
            else {
              bVar1 = true;
            }
            if (((!bVar1) && ((short)fso_monitoring_command_value < (short)fso_fault_low_threshold))
               && (fso_fault_detection_threshold < throttle_position_raw)) {
              if (fso_monitoring_command_value == fso_fault_previous_value) {
                fso_stuck_fault_debounce_counter = fso_stuck_fault_debounce_counter + 1;
                if (fso_fault_delta_calc_threshold <= fso_stuck_fault_debounce_counter) {
                  engine_fault_status_register_3 = engine_fault_status_register_3 | 0x100;
                  engine_fault_status_register_4 = engine_fault_status_register_4 | 0x100;
                  fso_fault_latched_value = fso_monitoring_command_value;
                  fso_stuck_fault_debounce_counter = 0;
                }
              }
              else {
                fso_fault_previous_value = fso_monitoring_command_value;
                fso_stuck_fault_debounce_counter = 0;
              }
            }
          }
        }
      }
    }
    if ((short)fso_monitoring_command_value < (short)fso_fuel_command_limit) {
      fso_low_cmd_fault_clear_counter = fso_low_cmd_fault_clear_counter + 1;
      if (fso_fault_debounce_threshold <= fso_low_cmd_fault_clear_counter) {
        engine_fault_status_register_3 = engine_fault_status_register_3 & 0xffbf;
        fso_low_cmd_fault_clear_counter = 0;
      }
    }
    else {
      fso_low_cmd_fault_clear_counter = 0;
    }
    if (((engine_fault_status_register_3 & 0x100) != 0) &&
       ((vp44_fso_fault_enable_mask & 0x100) != 0)) {
      if ((int)(short)fso_monitoring_command_value - (int)(short)fso_fault_latched_value < 0) {
        iVar2 = -((int)(short)fso_monitoring_command_value - (int)(short)fso_fault_latched_value);
      }
      else {
        iVar2 = (int)(short)fso_monitoring_command_value - (int)(short)fso_fault_latched_value;
      }
      if ((int)(uint)fso_fault_counter_limit < iVar2) {
        engine_fault_status_register_3 = engine_fault_status_register_3 & 0xfeff;
      }
    }
    if (((engine_fault_status_register_3 & 0x80) == 0) || ((vp44_fso_fault_enable_mask & 0x80) == 0)
       ) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    fso_protection_fuel_limit = 0x1700;
    if ((bVar1) && (fso_protection_fuel_level_1 < 0x1700)) {
      fso_protection_fuel_limit = fso_protection_fuel_level_1;
    }
    if (((engine_fault_status_register_3 & 0x40) == 0) || ((vp44_fso_fault_enable_mask & 0x40) == 0)
       ) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if ((bVar1) && (fso_protection_fuel_level_2 < fso_protection_fuel_limit)) {
      fso_protection_fuel_limit = fso_protection_fuel_level_2;
    }
    if (((engine_fault_status_register_3 & 0x100) == 0) ||
       ((vp44_fso_fault_enable_mask & 0x100) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if ((bVar1) && (fso_protection_fuel_level_3 < fso_protection_fuel_limit)) {
      fso_protection_fuel_limit = fso_protection_fuel_level_3;
    }
  }
  return;
}



/*
 * Function: vp44FsoCircuitFaultDetection @ 0x000341ea
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FsoCircuitFaultDetection(void)

{
  if (vp44_fso_fault_detection_enable != 0) {
    if ((vp44_status_register_9a5f & 1) != 0) {
      if ((_debounce_counts_for_vp44_micro_error_0_to_255 < current_engine_fuel_demand) &&
         (current_engine_fuel_demand <= _debounce_for_vp44_fso_circuit_fault_detection_0_to_255)) {
        vp44_fso_range1_fault_counter = vp44_fso_range1_fault_counter + 1;
        if ((byte)FLSYPSII <= vp44_fso_range1_fault_counter) {
          engine_fault_status_register_3 = engine_fault_status_register_3 | 0x20;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x20;
          vp44_fso_fault_active_flag = 1;
          vp44_fso_circuit_fault_flag = 1;
          vp44_fso_range1_fault_counter = 0;
        }
      }
      else if (_debounce_for_vp44_fso_circuit_fault_detection_0_to_255 < current_engine_fuel_demand)
      {
        vp44_fso_range2_fault_counter = vp44_fso_range2_fault_counter + 1;
        if (vp44_fso_stuck_low_detection_disabled_above_this_fueling_0_to_300._0_1_ <=
            vp44_fso_range2_fault_counter) {
          engine_fault_status_register_3 = engine_fault_status_register_3 | 0x20;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x20;
          vp44_fso_fault_active_flag = 1;
          vp44_fso_circuit_fault_flag = 1;
          vp44_fso_range2_fault_counter = 0;
        }
      }
      else {
        vp44_fso_range1_fault_counter = 0;
        vp44_fso_range2_fault_counter = 0;
      }
      vp44_fso_recovery_counter = 0;
      return;
    }
    vp44_fso_recovery_counter = vp44_fso_recovery_counter + 1;
    if ((byte)FLSYPSII <= vp44_fso_recovery_counter) {
      engine_fault_status_register_3 = engine_fault_status_register_3 & 0xffdf;
      vp44_fso_circuit_fault_flag = 0;
      vp44_fso_recovery_counter = 0;
    }
    vp44_fso_range1_fault_counter = 0;
    vp44_fso_range2_fault_counter = 0;
  }
  return;
}



/*
 * Function: vp44FsoCircuitFaultDetectionBit1 @ 0x000342f6
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FsoCircuitFaultDetectionBit1(void)

{
  if (vp44_fso_fault_detection_enable != 0) {
    if ((vp44_status_register_9a5f & 2) != 0) {
      if ((_debounce_counts_for_vp44_micro_error_0_to_255 < current_engine_fuel_demand) &&
         (current_engine_fuel_demand <= _debounce_for_vp44_fso_circuit_fault_detection_0_to_255)) {
        vp44_fso_bit1_range1_fault_counter = vp44_fso_bit1_range1_fault_counter + 1;
        if ((byte)FLSYPSII <= vp44_fso_bit1_range1_fault_counter) {
          engine_fault_status_register_3 = engine_fault_status_register_3 | 0x10;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x10;
          vp44_fso_circuit_fault_fuel_limit =
               target_angle_during_which_sync_pulse_is_held_low_0_to_120;
          vp44_fso_bit1_range1_fault_counter = 0;
        }
      }
      else if (_debounce_for_vp44_fso_circuit_fault_detection_0_to_255 < current_engine_fuel_demand)
      {
        vp44_fso_bit1_range2_fault_counter = vp44_fso_bit1_range2_fault_counter + 1;
        if (vp44_fso_stuck_low_detection_disabled_above_this_fueling_0_to_300._0_1_ <=
            vp44_fso_bit1_range2_fault_counter) {
          engine_fault_status_register_3 = engine_fault_status_register_3 | 0x10;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x10;
          vp44_fso_circuit_fault_fuel_limit =
               target_angle_during_which_sync_pulse_is_held_low_0_to_120;
          vp44_fso_bit1_range2_fault_counter = 0;
        }
      }
      else {
        vp44_fso_bit1_range1_fault_counter = 0;
        vp44_fso_bit1_range2_fault_counter = 0;
      }
      vp44_fso_bit1_recovery_counter = 0;
      return;
    }
    vp44_fso_bit1_recovery_counter = vp44_fso_bit1_recovery_counter + 1;
    if ((byte)FLSYPSII <= vp44_fso_bit1_recovery_counter) {
      engine_fault_status_register_3 = engine_fault_status_register_3 & 0xffef;
      vp44_fso_circuit_fault_fuel_limit = 0x1700;
      vp44_fso_bit1_recovery_counter = 0;
    }
    vp44_fso_bit1_range1_fault_counter = 0;
    vp44_fso_bit1_range2_fault_counter = 0;
  }
  return;
}



/*
 * Function: vp44FsoFaultRangeMonitor @ 0x000343f8
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FsoFaultRangeMonitor(void)

{
  if (vp44_fso_fault_detection_enable != 0) {
    if ((vp44_status_register_9a5f & 0x10) != 0) {
      if ((_reserved_location_for_future_pump_setup_information_0_to_ff < current_engine_fuel_demand
          ) && (current_engine_fuel_demand <=
                vp44_fso_stuck_low_detection_enabled_above_this_speed_0_to_5000)) {
        fso_range_fault_low_counter = fso_range_fault_low_counter + 1;
        if (FLSYPSII._0_1_ <= fso_range_fault_low_counter) {
          engine_fault_status_register_3 = engine_fault_status_register_3 | 8;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 8;
          fso_range_fault_low_counter = 0;
        }
      }
      else if (vp44_fso_stuck_low_detection_enabled_above_this_speed_0_to_5000 <
               current_engine_fuel_demand) {
        fso_range_fault_high_counter = fso_range_fault_high_counter + 1;
        if ((byte)vp44_fso_stuck_low_detection_disabled_above_this_fueling_0_to_300 <=
            fso_range_fault_high_counter) {
          engine_fault_status_register_3 = engine_fault_status_register_3 | 8;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 8;
          fso_range_fault_high_counter = 0;
        }
      }
      else {
        fso_range_fault_low_counter = 0;
        fso_range_fault_high_counter = 0;
      }
      fso_range_fault_clear_counter = 0;
      return;
    }
    if ((vp44_status_register_9a5f & 8) == 0) {
      fso_range_fault_clear_counter = fso_range_fault_clear_counter + 1;
      if ((byte)FLSYPSII <= fso_range_fault_clear_counter) {
        engine_fault_status_register_3 = engine_fault_status_register_3 & 0xfff7;
        fso_range_fault_clear_counter = 0;
      }
    }
    fso_range_fault_low_counter = 0;
    fso_range_fault_high_counter = 0;
  }
  return;
}



/*
 * Function: vp44TimingFaultMonitor @ 0x000344e8
 */

void vp44TimingFaultMonitor(void)

{
  word wVar1;
  bool bVar2;
  
  if (vp44_fso_fault_detection_enable != 0) {
    vp44_timing_expected_value = coreTableInterpolation();
    wVar1 = vp44_timing_expected_value;
    if (vp44_timing_mode_selector != 0) {
      wVar1 = coreTableInterpolation();
    }
    vp44_timing_actual_value = wVar1;
    vp44_timing_error_delta = vp44_timing_expected_value - vp44_timing_actual_value;
    if (((engine_fault_status_register_3 & 0x800) == 0) ||
       ((vp44_fso_fault_enable_mask & 0x800) == 0)) {
      bVar2 = false;
    }
    else {
      bVar2 = true;
    }
    if (!bVar2) {
      if (((engine_fault_status_register_3 & 0x400) == 0) ||
         ((vp44_fso_fault_enable_mask & 0x400) == 0)) {
        bVar2 = false;
      }
      else {
        bVar2 = true;
      }
      if (!bVar2) {
        if (((engine_fault_status_register_3 & 0x200) == 0) ||
           ((vp44_fso_fault_enable_mask & 0x200) == 0)) {
          bVar2 = false;
        }
        else {
          bVar2 = true;
        }
        if (!bVar2) {
          if ((vp44_status_register_9a5f & 0x80) == 0) {
            vp44_fault_status_reg = vp44_fault_status_reg & 0xfffb;
            vp44_timing_status_fault_counter = 0;
          }
          else {
            vp44_timing_status_fault_counter = vp44_timing_status_fault_counter + 1;
            if (vp44_timing_status_fault_threshold <= vp44_timing_status_fault_counter) {
              vp44_fault_status_reg = vp44_fault_status_reg | 4;
              vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 4;
              vp44_timing_status_fault_counter = 0;
            }
          }
          if (((vp44_fault_status_reg & 4) == 0) || ((fso_fault_enable_mask_1 & 4) == 0)) {
            bVar2 = false;
          }
          else {
            bVar2 = true;
          }
          if (!bVar2) {
            switch(engine_operating_mode) {
            case LOW_RPM_RUNNING:
            case TRANSITIONAL_MODE_6:
            case TRANSITIONAL_MODE_7:
              if (max_retarded_timing_allowed_to_detect_static_timing_erro_0_to_ffffffff._2_2_ <
                  vp44_timing_error_delta) {
                vp44_timing_mode_267_high_counter = vp44_timing_mode_267_high_counter + 1;
                if (vp44_timing_fault_threshold <= vp44_timing_mode_267_high_counter) {
                  vp44_fault_status_reg = vp44_fault_status_reg | 2;
                  vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 2;
                  vp44_timing_mode_267_high_counter = 0;
                }
                vp44_timing_mode_267_low_counter = 0;
              }
              else {
                if ((vp44_timing_error_delta <
                     min_retarded_timing_allowed_to_detect_static_timing_erro_0_to_ffffffff._2_2_)
                   && (vp44_timing_mode_267_low_counter = vp44_timing_mode_267_low_counter + 1,
                      vp44_timing_fault_threshold <= vp44_timing_mode_267_low_counter)) {
                  vp44_fault_status_reg = vp44_fault_status_reg & 0xfffd;
                  vp44_timing_mode_267_low_counter = 0;
                }
                vp44_timing_mode_267_high_counter = 0;
              }
              vp44_timing_mode_3_high_counter = 0;
              vp44_timing_mode_3_low_counter = 0;
              return;
            case HIGH_RPM_RUNNING:
              if (max_retarded_timing_allowed_to_detect_static_timing_erro_0_to_ffffffff._0_2_ <
                  vp44_timing_error_delta) {
                vp44_timing_mode_3_high_counter = vp44_timing_mode_3_high_counter + 1;
                if (vp44_timing_fault_threshold <= vp44_timing_mode_3_high_counter) {
                  vp44_fault_status_reg = vp44_fault_status_reg | 2;
                  vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 2;
                  vp44_timing_mode_3_high_counter = 0;
                }
                vp44_timing_mode_3_low_counter = 0;
              }
              else {
                if ((vp44_timing_error_delta <
                     min_retarded_timing_allowed_to_detect_static_timing_erro_0_to_ffffffff._0_2_)
                   && (vp44_timing_mode_3_low_counter = vp44_timing_mode_3_low_counter + 1,
                      vp44_timing_fault_threshold <= vp44_timing_mode_3_low_counter)) {
                  vp44_fault_status_reg = vp44_fault_status_reg & 0xfffd;
                  vp44_timing_mode_3_low_counter = 0;
                }
                vp44_timing_mode_3_high_counter = 0;
              }
              vp44_timing_mode_267_high_counter = 0;
              vp44_timing_mode_267_low_counter = 0;
              return;
            default:
              vp44_timing_mode_3_high_counter = 0;
              vp44_timing_mode_3_low_counter = 0;
              vp44_timing_mode_267_high_counter = 0;
              vp44_timing_mode_267_low_counter = 0;
            }
          }
        }
      }
    }
  }
  return;
}



/*
 * Function: vp44FsoFaultDetectionAndProtectionController @ 0x00034782
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FsoFaultDetectionAndProtectionController(void)

{
  bool bVar1;
  ushort uVar2;
  
  if (vp44_fso_fault_detection_enable == 0) {
    return;
  }
  if ((((vp44_can_msg_100_status_flags & 1) == 0) ||
      ((short)lift_pump_fuel_offset_calc <=
       (short)lift_pump_off_time_duration_during_cranking_0_to_120)) ||
     ((int)(uint)lift_pump_run_time_calculated <= (int)(short)lift_pump_fuel_offset_calc)) {
    engine_fault_status_register_3 = engine_fault_status_register_3 & 0xfffd;
    vp44_fso_timing_fault_counter = 0;
  }
  else {
    vp44_fso_timing_fault_counter = vp44_fso_timing_fault_counter + 1;
    if ((byte)lift_pump_run_time_after_key_on_0_to_120 <= vp44_fso_timing_fault_counter) {
      engine_fault_status_register_3 = engine_fault_status_register_3 | 2;
      engine_fault_status_register_4 = engine_fault_status_register_4 | 2;
      vp44_fso_timing_fault_counter = 0;
    }
  }
  if ((vp44_fso_detection_enable_flag != 0) && (vp44_fso_fault_latch_flag == 0)) {
    if ((((slope_used_to_convert_final_timing_to_vp44_units_50_to_50 < throttle_position_raw) &&
         ((vp44_fso_fuel_demand_lower_threshold < current_engine_fuel_demand &&
          (current_engine_fuel_demand < vp44_fso_fuel_demand_upper_threshold)))) &&
        (current_fuel_demand_value < vp44_fso_fuel_value_threshold)) &&
       (derate_threshold_exceeded == 0)) {
      uVar2 = vp44_fso_condition_counter + 1;
      if (vp44_fso_condition_threshold <= (ushort)(vp44_fso_condition_counter + 1)) {
        lift_pump_diagnostic_mode_flag = 1;
        uVar2 = vp44_fso_condition_counter;
      }
      vp44_fso_condition_counter = uVar2;
      if ((lift_pump_diagnostic_mode_flag != 0) &&
         (vp44_fso_duration_counter = vp44_fso_duration_counter + 1,
         vp44_fso_duration_threshold <= vp44_fso_duration_counter)) {
        vp44_fso_fault_latch_flag = 1;
        lift_pump_diagnostic_mode_flag = 0;
        if ((vp44_can_msg_200_min_value < _vp44_fso_value_lower_threshold) ||
           (_vp44_fso_value_upper_threshold < vp44_can_msg_200_min_value)) {
          vp44_fault_status_reg = vp44_fault_status_reg | 0x40;
          vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x40;
        }
        else if ((_vp44_fso_value_lower_threshold < vp44_can_msg_200_min_value) &&
                (vp44_can_msg_200_min_value < _vp44_fso_value_upper_threshold)) {
          vp44_fault_status_reg = vp44_fault_status_reg & 0xffbf;
        }
      }
    }
    else {
      vp44_fso_condition_counter = 0;
      vp44_fso_duration_counter = 0;
    }
  }
  if (((vp44_fault_status_reg & 0x40) == 0) || ((fso_fault_enable_mask_1 & 0x40) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    if (((engine_fault_status_register_3 & 2) == 0) || ((vp44_fso_fault_enable_mask & 2) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      vp44_fso_fuel_limit_output = 0x1700;
      return;
    }
  }
  vp44_fso_fuel_limit_output = vp44_fso_fault_fuel_limit;
  return;
}



/*
 * Function: vp44FsoFaultBit0Monitor @ 0x00034976
 */

void vp44FsoFaultBit0Monitor(void)

{
  if (vp44_fso_fault_detection_enable != 0) {
    if ((vp44_can_msg_100_status_flags & 4) != 0) {
      if ((vp44_fso_bit0_fuel_threshold < current_fuel_demand_value) &&
         (time_period_to_disable_imt_epf_due_to_exh_brake_0_65535 < vp44_timing_actual_value)) {
        vp44_fso_bit0_fault_counter = vp44_fso_bit0_fault_counter + 1;
        if (vp44_fso_bit0_debounce_threshold < vp44_fso_bit0_fault_counter) {
          engine_fault_status_register_3 = engine_fault_status_register_3 | 1;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 1;
          vp44_fso_bit0_fuel_limit = vp44_fso_bit0_fault_fuel_limit;
          vp44_fso_bit0_fault_counter = 0;
        }
      }
      else {
        vp44_fso_bit0_fault_counter = 0;
      }
      vp44_fso_bit0_recovery_counter = 0;
      return;
    }
    vp44_fso_bit0_recovery_counter = vp44_fso_bit0_recovery_counter + 1;
    if (vp44_fso_bit0_debounce_threshold < vp44_fso_bit0_recovery_counter) {
      engine_fault_status_register_3 = engine_fault_status_register_3 & 0xfffe;
      vp44_fso_bit0_fuel_limit = 0x1700;
      vp44_fso_bit0_recovery_counter = 0;
    }
    vp44_fso_bit0_fault_counter = 0;
  }
  return;
}



/*
 * Function: vp44FsoFaultBit15Monitor @ 0x00034a32
 */

void vp44FsoFaultBit15Monitor(void)

{
  bool bVar1;
  
  if (vp44_fso_fault_detection_enable == 0) {
    return;
  }
  if ((vp44_can_msg_100_status_flags & 0x20) == 0) {
    vp44_fso_bit15_recovery_counter = vp44_fso_bit15_recovery_counter + 1;
    if ((byte)FLSYPSII < vp44_fso_bit15_recovery_counter) {
      vp44_fault_status_reg = vp44_fault_status_reg & 0x7fff;
      vp44_fso_bit15_fuel_limit = 0x1700;
      vp44_fso_bit15_recovery_counter = 0;
    }
    vp44_fso_bit15_fault_counter = 0;
    vp44_fso_bit15_limit_counter = 0;
    return;
  }
  if (engine_operating_mode == ENGINE_IDLE) {
    vp44_fso_bit15_recovery_counter = 0;
    return;
  }
  if (engine_operating_mode == FAULT_EMERGENCY) {
    vp44_fso_bit15_recovery_counter = 0;
    return;
  }
  if (((engine_fault_status_register_1 & 0x1000) == 0) ||
     ((engine_fault_confirmation_register & 0x1000) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    if (((engine_fault_status_register_1 & 0x4000) == 0) ||
       ((engine_fault_confirmation_register & 0x4000) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      vp44_fso_bit15_fault_counter = vp44_fso_bit15_fault_counter + 1;
      if (in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255._0_1_ <
          vp44_fso_bit15_fault_counter) {
        vp44_fault_status_reg = vp44_fault_status_reg | 0x8000;
        vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x8000;
        vp44_fso_bit15_fault_counter = 0;
      }
      goto LAB_00034af2;
    }
  }
  vp44_fso_bit15_fault_counter = 0;
LAB_00034af2:
  vp44_fso_bit15_limit_counter = vp44_fso_bit15_limit_counter + 1;
  if (in_range_fuel_temp_fault_enabled_when_coolant_temp_is_above_50_to_255._0_1_ <
      vp44_fso_bit15_limit_counter) {
    vp44_fso_bit15_fuel_limit = vp44_fso_bit15_fault_fuel_limit;
    vp44_fso_bit15_limit_counter = 0;
  }
  vp44_fso_bit15_recovery_counter = 0;
  return;
}



/*
 * Function: vp44FsoMultiBitFaultMonitor @ 0x00034b46
 */

void vp44FsoMultiBitFaultMonitor(void)

{
  bool bVar1;
  
  if ((vp44_fso_fault_detection_enable != 0) && (1 < derate_threshold_change_counter._0_1_)) {
    if (((engine_fault_status_register_3 & 0x800) == 0) ||
       ((vp44_fso_fault_enable_mask & 0x800) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (((engine_fault_status_register_3 & 0x400) == 0) ||
         ((vp44_fso_fault_enable_mask & 0x400) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((engine_fault_status_register_3 & 0x200) == 0) ||
           ((vp44_fso_fault_enable_mask & 0x200) == 0)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if (!bVar1) {
          if ((vp44_status_register_9a5f & 4) != 0) {
            if (derate_threshold_exceeded != 0) {
              if (required_change_to_clear_in_range_fuel_temp_fault_0_to_300 <
                  current_engine_fuel_demand) {
                vp44_fso_multibit_fault_debounce_counter =
                     vp44_fso_multibit_fault_debounce_counter + 1;
                if (fso_multibit_fault_threshold < vp44_fso_multibit_fault_debounce_counter) {
                  vp44_fault_status_reg = vp44_fault_status_reg | 0x4000;
                  vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x4000;
                  vp44_fso_multibit_fault_debounce_counter = 0;
                }
              }
              else {
                vp44_fso_multibit_fault_debounce_counter = 0;
              }
              vp44_fso_multibit_fault_state = 0;
              return;
            }
            vp44_fso_multibit_fault_state = vp44_fso_multibit_fault_state + 1;
            if (fso_multibit_fault_threshold < vp44_fso_multibit_fault_state) {
              vp44_fault_status_reg = vp44_fault_status_reg & 0xdfff;
              vp44_fso_multibit_fault_state = 0;
            }
            vp44_fso_multibit_fault_debounce_counter = 0;
            return;
          }
          if (derate_threshold_exceeded == 0) {
            if (required_change_to_clear_in_range_fuel_temp_fault_0_to_300 <
                current_engine_fuel_demand) {
              vp44_fso_multibit_fault_accumulator = vp44_fso_multibit_fault_accumulator + 1;
              if (fso_multibit_fault_threshold < vp44_fso_multibit_fault_accumulator) {
                vp44_fault_status_reg = vp44_fault_status_reg | 0x2000;
                vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x2000;
                vp44_fso_multibit_fault_accumulator = 0;
              }
              vp44_fso_multibit_clear_flag = 0;
            }
            else {
              vp44_fso_multibit_fault_debounce_counter = 0;
            }
            vp44_fso_multibit_fault_accumulator = vp44_fso_multibit_fault_accumulator + 1;
            if (fso_multibit_fault_threshold < vp44_fso_multibit_fault_accumulator) {
              vp44_fault_status_reg = vp44_fault_status_reg | 0x2000;
              vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x2000;
              vp44_fso_multibit_fault_accumulator = 0;
            }
            vp44_fso_multibit_fault_state = 0;
            return;
          }
          vp44_fso_multibit_fault_state = vp44_fso_multibit_fault_state + 1;
          if (fso_multibit_fault_threshold < vp44_fso_multibit_fault_state) {
            vp44_fault_status_reg = vp44_fault_status_reg & 0xbfff;
            vp44_fso_multibit_fault_state = 0;
          }
          vp44_fso_multibit_fault_accumulator = 0;
        }
      }
    }
  }
  return;
}



/*
 * Function: vp44FsoStuckHighFaultDetector @ 0x00034d16
 */

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vp44FsoStuckHighFaultDetector(void)

{
  if (vp44_fso_fault_detection_enable != 0) {
    if ((vp44_can_msg_100_status_flags & 8) != 0) {
      vp44_fso_stuck_high_state = vp44_fso_stuck_high_state + 1;
      if (vp44_fso_stuck_debounce_threshold._0_1_ < vp44_fso_stuck_high_state) {
        vp44_fault_status_reg = vp44_fault_status_reg | 0x1000;
        vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x1000;
        vp44_fso_stuck_high_state = 0;
      }
      _vp44_fso_stuck_high_recovery_counter = 0;
      return;
    }
    _vp44_fso_stuck_high_recovery_counter = _vp44_fso_stuck_high_recovery_counter + 1;
    if (vp44_fso_stuck_debounce_threshold._0_1_ < _vp44_fso_stuck_high_recovery_counter) {
      vp44_fault_status_reg = vp44_fault_status_reg & 0xefff;
      _vp44_fso_stuck_high_recovery_counter = 0;
    }
    vp44_fso_stuck_high_state = 0;
  }
  return;
}



/*
 * Function: vp44FsoStuckLowFaultDetector @ 0x00034d9e
 */

void vp44FsoStuckLowFaultDetector(void)

{
  bool bVar1;
  
  if (vp44_fso_fault_detection_enable != 0) {
    if ((vp44_can_msg_100_status_flags & 0x80) == 0) {
      vp44_status_register_5e12 = vp44_status_register_5e12 & 0xf7ff;
    }
    else {
      if (((vp44_fault_status_reg & 0x400) == 0) || ((fso_fault_enable_mask_1 & 0x400) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((engine_fault_status_register_3 & 0x800) == 0) ||
           ((vp44_fso_fault_enable_mask & 0x800) == 0)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if (!bVar1) {
          if (((engine_fault_status_register_3 & 0x400) == 0) ||
             ((vp44_fso_fault_enable_mask & 0x400) == 0)) {
            bVar1 = false;
          }
          else {
            bVar1 = true;
          }
          if (!bVar1) {
            if (((engine_fault_status_register_3 & 0x200) == 0) ||
               ((vp44_fso_fault_enable_mask & 0x200) == 0)) {
              bVar1 = false;
            }
            else {
              bVar1 = true;
            }
            if (!bVar1) {
              vp44_status_register_5e12 = vp44_status_register_5e12 | 0x800;
              vp44_fso_fault_flags = vp44_fso_fault_flags | 0x800;
              return;
            }
          }
        }
      }
    }
  }
  return;
}



/*
 * Function: vp44FsoFaultConditionDetector @ 0x00034e7a
 */

void vp44FsoFaultConditionDetector(void)

{
  bool bVar1;
  int iVar2;
  
  if (vp44_fso_fault_detection_enable == 0) {
    return;
  }
  if (vp44_fso_warmup_counter <
      fuel_temp_in_range_fault_detection_enabled_below_this_value_40_to_400) {
    vp44_fso_warmup_counter = vp44_fso_warmup_counter + 1;
  }
  if (((vp44_status_register_5e12 & 0x800) == 0) || ((vp44_fso_fault_enable_mask_2 & 0x800) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    if (((engine_fault_status_register_3 & 0x800) == 0) ||
       ((vp44_fso_fault_enable_mask & 0x800) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (((engine_fault_status_register_3 & 0x400) == 0) ||
         ((vp44_fso_fault_enable_mask & 0x400) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((engine_fault_status_register_3 & 0x200) == 0) ||
           ((vp44_fso_fault_enable_mask & 0x200) == 0)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if (!bVar1) {
          if ((((vp44_timing_final_value == 0) &&
               (fuel_is_limited_to_this_when_fuel_temp_sensor_faults_are_acti_0_to_300 <
                current_engine_fuel_demand)) &&
              (requested_location_on_pump_cam_for_soi_100_to_100 < vp44_can_msg_100_timing_value))
             && (vp44_fso_zero_timing_fault_counter = vp44_fso_zero_timing_fault_counter + 1,
                vp44_fso_fault_debounce_threshold <= vp44_fso_zero_timing_fault_counter)) {
            vp44_fault_status_reg = vp44_fault_status_reg | 1;
            vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 1;
            vp44_fso_fault_active_flag = 1;
            vp44_fso_zero_timing_fault_counter = 0;
          }
          goto LAB_00034fa0;
        }
      }
    }
  }
  vp44_fso_zero_timing_fault_counter = 0;
LAB_00034fa0:
  if (((vp44_status_register_5e12 & 0x800) == 0) || ((vp44_fso_fault_enable_mask_2 & 0x800) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    if (((engine_fault_status_register_3 & 0x800) == 0) ||
       ((vp44_fso_fault_enable_mask & 0x800) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (((engine_fault_status_register_3 & 0x400) == 0) ||
         ((vp44_fso_fault_enable_mask & 0x400) == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) {
        if (((engine_fault_status_register_3 & 0x200) == 0) ||
           ((vp44_fso_fault_enable_mask & 0x200) == 0)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
        if (!bVar1) {
          if (current_engine_fuel_demand <=
              upper_limit_for_abnormally_high_fuel_temp_fault_40_to_300) {
            return;
          }
          if ((int)((uint)current_engine_fuel_demand - (uint)vp44_timing_mode_selector) < 0) {
            iVar2 = -((uint)current_engine_fuel_demand - (uint)vp44_timing_mode_selector);
          }
          else {
            iVar2 = (uint)current_engine_fuel_demand - (uint)vp44_timing_mode_selector;
          }
          if (iVar2 <= (int)(uint)target_angular_position_of_sync_pulse_after_tdc_0_to_60) {
            return;
          }
          if ((byte)(vp44_fso_demand_delta_fault_counter + 1) < vp44_fso_fault_debounce_threshold) {
            vp44_fso_demand_delta_fault_counter = vp44_fso_demand_delta_fault_counter + 1;
            return;
          }
          vp44_status_register_5e12 = vp44_status_register_5e12 | 0x8000;
          vp44_fso_fault_flags = vp44_fso_fault_flags | 0x8000;
          vp44_fso_fault_active_flag = 1;
          vp44_fso_demand_delta_fault_counter = 0;
          return;
        }
      }
    }
  }
  vp44_fso_demand_delta_fault_counter = 0;
  return;
}



/*
 * Function: vp44Message300FaultFlagProcessor @ 0x000350ae
 */

void vp44Message300FaultFlagProcessor(void)

{
  if (vp44_fso_fault_detection_enable != 0) {
    if (((vp44_can_msg_300_fault_flags & 1) == 0) && ((vp44_can_msg_300_fault_flags & 2) == 0)) {
      vp44_fault_status_reg = vp44_fault_status_reg & 0xfdff;
      vp44_msg_300_fault_fuel_limit_1 = 0x1700;
    }
    else {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x200;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x200;
      vp44_msg_300_fault_fuel_limit_1 = vp44_msg_300_fault_1_fuel_limit;
    }
    if ((vp44_can_msg_300_fault_flags & 4) == 0) {
      vp44_fault_status_reg = vp44_fault_status_reg & 0xfeff;
      vp44_msg_300_fault_fuel_limit_2 = 0x1700;
    }
    else {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x100;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x100;
      vp44_msg_300_fault_fuel_limit_2 = vp44_msg_300_fault_2_fuel_limit;
    }
    if ((vp44_can_msg_300_fault_flags & 8) != 0) {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x80;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x80;
      vp44_fso_fault_active_flag = 1;
    }
    if ((vp44_can_msg_300_fault_flags & 0x10) != 0) {
      vp44_fault_status_reg = vp44_fault_status_reg | 0x10;
      vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x10;
      vp44_fso_fault_active_flag = 1;
    }
    if ((vp44_can_msg_300_fault_flags & 0x20) == 0) {
      vp44_status_register_5e12 = vp44_status_register_5e12 & 0xdfff;
    }
    else {
      vp44_status_register_5e12 = vp44_status_register_5e12 | 0x2000;
      vp44_fso_fault_flags = vp44_fso_fault_flags | 0x2000;
    }
    if ((vp44_can_msg_300_fault_flags & 0x40) != 0) {
      vp44_status_register_5e12 = vp44_status_register_5e12 | 0x4000;
      vp44_fso_fault_flags = vp44_fso_fault_flags | 0x4000;
      return;
    }
    vp44_status_register_5e12 = vp44_status_register_5e12 & 0xbfff;
  }
  return;
}



/*
 * Function: multiParameterMinimumSelector @ 0x00035228
 */

void multiParameterMinimumSelector(void)

{
  shutdown_minimum_init_value = 0x1700;
  if (vp44_fso_circuit_fault_fuel_limit < 0x1700) {
    shutdown_minimum_init_value = vp44_fso_circuit_fault_fuel_limit;
  }
  if (fso_protection_fuel_limit < shutdown_minimum_init_value) {
    shutdown_minimum_init_value = fso_protection_fuel_limit;
  }
  if (vp44_fso_fuel_limit_output < shutdown_minimum_init_value) {
    shutdown_minimum_init_value = vp44_fso_fuel_limit_output;
  }
  if (vp44_fso_bit0_fuel_limit < shutdown_minimum_init_value) {
    shutdown_minimum_init_value = vp44_fso_bit0_fuel_limit;
  }
  if (vp44_fso_bit15_fuel_limit < shutdown_minimum_init_value) {
    shutdown_minimum_init_value = vp44_fso_bit15_fuel_limit;
  }
  if (vp44_msg_300_fault_fuel_limit_1 < shutdown_minimum_init_value) {
    shutdown_minimum_init_value = vp44_msg_300_fault_fuel_limit_1;
  }
  if (vp44_msg_300_fault_fuel_limit_2 < shutdown_minimum_init_value) {
    shutdown_minimum_init_value = vp44_msg_300_fault_fuel_limit_2;
  }
  return;
}



/*
 * Function: systemStatusMonitor @ 0x00035298
 */

void systemStatusMonitor(void)

{
  bool bVar1;
  
  if (vp44_fso_fault_detection_enable != 0) {
    if (((vp44_fault_status_reg & 0x20) == 0) || ((fso_fault_enable_mask_1 & 0x20) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (!bVar1) {
      if (vp44_can_msg_100_received_flag != 0) {
        engine_fault_status_register_3 = engine_fault_status_register_3 & 0xf1ff;
        vp44_can_msg_timeout_counter = 0;
        vp44_can_msg_100_received_flag = 0;
        return;
      }
      if (vp44_can_msg_timeout_threshold < vp44_can_msg_timeout_counter) {
        switch((byte)serial_port_1_isr_counter & 7) {
        case 0:
        case 1:
        case 3:
        case 6:
        case 7:
          engine_fault_status_register_3 = engine_fault_status_register_3 | 0x800;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x800;
          break;
        case 2:
          engine_fault_status_register_3 = engine_fault_status_register_3 | 0x200;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x200;
          break;
        case 4:
        case 5:
          engine_fault_status_register_3 = engine_fault_status_register_3 | 0x400;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x400;
          break;
        default:
          engine_fault_status_register_3 = engine_fault_status_register_3 | 0x800;
          engine_fault_status_register_4 = engine_fault_status_register_4 | 0x800;
        }
        vp44_can_msg_timeout_counter = 0;
        return;
      }
      vp44_can_msg_timeout_counter = vp44_can_msg_timeout_counter + 1;
      if (vp44_can_msg_timeout_threshold < vp44_can_msg_timeout_counter) {
        canFrameDataCopy(&serial_port_2_base_register);
      }
    }
  }
  return;
}



/*
 * Function: liftPumpCommStatusMonitor @ 0x000353ec
 */

byte liftPumpCommStatusMonitor(void)

{
  byte bVar1;
  
  bVar1 = vp44_can_msg_100_retry_counter;
  if (lift_pump_run_time_after_key_on_0_to_120._0_1_ < vp44_can_msg_100_retry_counter) {
    vp44_status_register_5e12 = vp44_status_register_5e12 | 0x1000;
    vp44_fso_fault_flags = vp44_fso_fault_flags | 0x1000;
    vp44_can_msg_100_retry_counter = lift_pump_run_time_after_key_on_0_to_120._0_1_;
    return bVar1;
  }
  if ((vp44_communication_status & 1) == 0) {
    vp44_status_register_5e12 = vp44_status_register_5e12 & 0xefff;
  }
  return vp44_communication_status & 1;
}



/*
 * Function: vp44FsoFaultEnableController @ 0x0003544a
 */

void vp44FsoFaultEnableController(void)

{
  engine_control_system_ready = (ushort)vp44_fso_fault_active_flag;
  if (((engine_operating_mode != HIGH_PERFORMANCE) && (engine_operating_mode != FAULT_EMERGENCY)) &&
     (vp44_fso_fault_active_flag != 1)) {
    vp44_fso_fault_detection_enable = 1;
    return;
  }
  vp44_fso_fault_detection_enable = 0;
  return;
}



/*
 * Function: vp44RpmBasedFaultDetector @ 0x00035488
 */

ushort vp44RpmBasedFaultDetector(void)

{
  word wVar1;
  ushort uVar2;
  
  wVar1 = vp44_fso_rpm_fault_counter;
  vp44_rpm_based_fault_state = CONCAT11(vp44_timing_cmd_out_high_byte,vp44_timing_cmd_out_low_byte);
  uVar2 = vp44_flag_register_1 & 0x2000;
  if ((((((vp44_flag_register_1 & 0x2000) != 0) && (fuel_arbitrator_diag_t_0080cff8.rpm_target != 1)
        ) && (fuel_arbitrator_diag_t_0080cff8.rpm_target != 2)) &&
      ((oil_pressure_protection_enabled == 0 && (protection_system_enable_flag == 0)))) &&
     ((derate_threshold_exceeded == 0 &&
      ((uVar2 = vp44_rpm_based_fault_state,
       vp44_rpm_fault_state_threshold < vp44_rpm_based_fault_state &&
       (uVar2 = current_engine_fuel_demand,
       vp44_rpm_fault_fuel_demand_threshold < current_engine_fuel_demand)))))) {
    if (vp44_fso_rpm_fault_counter < vp44_rpm_fault_counter_limit) {
      vp44_fso_rpm_fault_counter = vp44_fso_rpm_fault_counter + 1;
      return wVar1;
    }
    vp44_fault_status_reg = vp44_fault_status_reg | 0x20;
    vp44_fso_fault_accumulator = vp44_fso_fault_accumulator | 0x20;
    return vp44_fso_rpm_fault_counter;
  }
  vp44_fso_rpm_fault_counter = 0;
  return uVar2;
}



/*
 * Function: vp44FaultBit5Reset @ 0x00035548
 */

void vp44FaultBit5Reset(void)

{
  vp44_fso_rpm_fault_counter = 0;
  vp44_fault_status_reg = vp44_fault_status_reg & 0xffdf;
  return;
}



/*
 * Function: lookupTableInterpolation @ 0x00035560
 */

/* Setting prototype: short lookupTableInterpolation(table_interp_args_t *args) */

short lookupTableInterpolation(table_interp_args_t *args)

{
  short *psVar1;
  ushort uVar2;
  ushort uVar3;
  short sVar4;
  int iVar5;
  ushort *puVar6;
  ushort *puVar7;
  
  psVar1 = (short *)args->x_axis_ptr;
  puVar6 = (ushort *)((int)psVar1 + (int)(short)args->current_index);
  uVar3 = args->input_value;
  if (*puVar6 < uVar3) {
    for (; puVar6[1] <= uVar3; puVar6 = puVar6 + 1) {
      if (*(ushort *)((int)psVar1 + (int)*psVar1) <= uVar3) {
        iVar5 = ((int)psVar1 + (int)*psVar1) - (int)psVar1;
        args->current_index = (short)iVar5 - 2;
        return *(short *)(args->y_axis_ptr + iVar5);
      }
    }
  }
  else {
    do {
      if (uVar3 <= (ushort)psVar1[1]) {
        sVar4 = *(short *)(args->y_axis_ptr + 2);
        args->current_index = 2;
        return sVar4;
      }
      puVar6 = puVar6 + -1;
    } while (uVar3 < *puVar6);
  }
  uVar2 = *puVar6;
  args->current_index = (word)((int)puVar6 - (int)psVar1);
  puVar7 = (ushort *)(args->y_axis_ptr + ((int)puVar6 - (int)psVar1));
  if (*puVar7 < puVar7[1]) {
    sVar4 = *puVar7 + (short)(((uint)(ushort)(puVar7[1] - *puVar7) * (uint)(ushort)(uVar3 - uVar2))
                             / (uint)(ushort)(puVar6[1] - *puVar6));
  }
  else {
    sVar4 = *puVar7 - (short)(((uint)(ushort)(*puVar7 - puVar7[1]) * (uint)(ushort)(uVar3 - uVar2))
                             / (uint)(ushort)(puVar6[1] - *puVar6));
  }
  return sVar4;
}



/*
 * Function: exponentialMovingAverage @ 0x00035608
 */
/* ERROR: Failed to decompile */
void exponentialMovingAverage(void) {
    /* Decompilation failed */
}


/*
 * Function: signedLinearInterpolation @ 0x0003566e
 */
/* ERROR: Failed to decompile */
void signedLinearInterpolation(void) {
    /* Decompilation failed */
}


/*
 * Function: coreTableInterpolation @ 0x000356f8
 */
/* ERROR: Failed to decompile */
void coreTableInterpolation(void) {
    /* Decompilation failed */
}


/*
 * Function: unsignedLinearInterpolation @ 0x0003574e
 */
/* ERROR: Failed to decompile */
void unsignedLinearInterpolation(void) {
    /* Decompilation failed */
}


/*
 * Function: proportionalCalculation @ 0x000357d2
 */

undefined4 proportionalCalculation(uint param_1,uint param_2,uint param_3)

{
  return (int)(((ulonglong)param_2 * (ulonglong)param_1) / (ulonglong)param_3);
}



/*
 * Function: rpmFuelCalculation @ 0x000357e4
 */

undefined4 rpmFuelCalculation(int param_1,int param_2,int param_3)

{
  return (int)(((longlong)(int)((ulonglong)((longlong)param_2 * (longlong)param_1) >> 0x20) << 0x20
               | (longlong)(int)((longlong)param_2 * (longlong)param_1)) / (longlong)param_3);
}



/*
 * Function: tableInterpolationLookup @ 0x000357f6
 */

undefined8 tableInterpolationLookup(short *param_1)

{
  short *psVar1;
  short *psVar2;
  ushort uVar3;
  ushort uVar4;
  ushort uVar5;
  ushort uVar6;
  ushort uVar7;
  uint uVar8;
  undefined4 uVar9;
  undefined4 in_D1;
  ushort uVar10;
  undefined2 uVar11;
  undefined4 unaff_D3;
  ushort uVar12;
  ushort *puVar13;
  ushort *puVar14;
  short sVar15;
  ushort *puVar16;
  
  psVar1 = *(short **)(param_1 + 1);
  puVar13 = (ushort *)((int)psVar1 + (int)*psVar1);
  puVar14 = (ushort *)((int)psVar1 + (int)*param_1);
  uVar10 = param_1[3];
  if (*puVar14 < uVar10) {
    for (; puVar14[1] <= uVar10; puVar14 = puVar14 + 1) {
      if (*puVar13 <= uVar10) {
        puVar14 = puVar13 + -1;
        uVar10 = *puVar13;
        break;
      }
    }
  }
  else {
    do {
      if (uVar10 <= (ushort)psVar1[1]) {
        puVar14 = (ushort *)(psVar1 + 1);
        uVar10 = psVar1[1];
        break;
      }
      puVar14 = puVar14 + -1;
    } while (uVar10 < *puVar14);
  }
  psVar2 = *(short **)(param_1 + 5);
  puVar16 = (ushort *)((int)psVar2 + (int)*psVar2);
  puVar13 = (ushort *)((int)psVar2 + (int)param_1[4]);
  uVar12 = param_1[7];
  if (*puVar13 < uVar12) {
    for (; puVar13[1] <= uVar12; puVar13 = puVar13 + 1) {
      if (*puVar16 <= uVar12) {
        puVar13 = puVar16 + -1;
        uVar12 = *puVar16;
        break;
      }
    }
  }
  else {
    do {
      if (uVar12 <= (ushort)psVar2[1]) {
        puVar13 = (ushort *)(psVar2 + 1);
        uVar12 = psVar2[1];
        break;
      }
      puVar13 = puVar13 + -1;
    } while (uVar12 < *puVar13);
  }
  uVar6 = puVar14[1] - *puVar14;
  uVar10 = uVar10 - *puVar14;
  sVar15 = (short)puVar14 - (short)psVar1;
  *param_1 = sVar15;
  uVar7 = puVar13[1] - *puVar13;
  uVar3 = *puVar13;
  param_1[4] = (short)((int)puVar13 - (int)psVar2);
  puVar13 = (ushort *)
            ((int)sVar15 +
            *(int *)(param_1 + 8) +
            (int)(short)((ushort)(((int)puVar13 - (int)psVar2) - 2U >> 1) & 0x7fff) * (int)*psVar1);
  uVar4 = puVar13[-1];
  if (uVar4 < *puVar13) {
    sVar15 = (short)(((uint)(ushort)(*puVar13 - uVar4) * (uint)uVar10) / (uint)uVar6);
  }
  else {
    sVar15 = -(short)(((uint)(ushort)(uVar4 - *puVar13) * (uint)uVar10) / (uint)uVar6);
  }
  uVar4 = sVar15 + uVar4;
  puVar13 = (ushort *)((int)*psVar1 + (int)(puVar13 + -1));
  uVar5 = *puVar13;
  uVar11 = (undefined2)((uint)unaff_D3 >> 0x10);
  if (uVar5 < puVar13[1]) {
    sVar15 = (short)(((uint)(ushort)(puVar13[1] - uVar5) * (uint)uVar10) / (uint)uVar6);
  }
  else {
    uVar8 = (uint)(ushort)(uVar5 - puVar13[1]) * (uint)uVar10;
    uVar11 = (undefined2)(uVar8 % (uint)uVar6);
    sVar15 = -(short)(uVar8 / uVar6);
  }
  uVar5 = uVar5 + sVar15;
  if (uVar4 < uVar5) {
    uVar8 = (uint)(ushort)(uVar5 - uVar4) * (uint)(ushort)(uVar12 - uVar3);
    uVar9 = CONCAT22((short)(uVar8 % (uint)uVar7),uVar4 + (short)(uVar8 / uVar7));
  }
  else {
    uVar9 = CONCAT22(uVar11,uVar4 - (short)(((uint)(ushort)(uVar4 - uVar5) *
                                            (uint)(ushort)(uVar12 - uVar3)) / (uint)uVar7));
  }
  return CONCAT44(uVar9,in_D1);
}



