using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using System.Threading;
using <CppImplementationDetails>;
using <CrtImplementationDetails>;
using std;

[assembly: SecurityRules(SecurityRuleSet.Level1)]
[assembly: TargetFramework(".NETFramework,Version=v4.5", FrameworkDisplayName = ".NET Framework 4.5")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
internal class <Module>
{
	internal static $ArrayType$$$BY00$$CBD ??_C@_00CNPNBAHC@?$AA@/* Not supported: data(00) */;

	internal static $ArrayType$$$BY07$$CBD ??_C@_07DCLBNMLN@generic?$AA@/* Not supported: data(67 65 6E 65 72 69 63 00) */;

	internal static $ArrayType$$$BY0O@$$CBD ??_C@_0O@BFJCFAAK@unknown?5error?$AA@/* Not supported: data(75 6E 6B 6E 6F 77 6E 20 65 72 72 6F 72 00) */;

	internal static $ArrayType$$$BY08$$CBD ??_C@_08LLGCOLLL@iostream?$AA@/* Not supported: data(69 6F 73 74 72 65 61 6D 00) */;

	internal static $ArrayType$$$BY0BG@$$CBD ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@/* Not supported: data(69 6F 73 74 72 65 61 6D 20 73 74 72 65 61 6D 20 65 72 72 6F 72 00) */;

	internal static $ArrayType$$$BY06$$CBD ??_C@_06FHFOAHML@system?$AA@/* Not supported: data(73 79 73 74 65 6D 00) */;

	internal static $ArrayType$$$BY0BI@$$CBD ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@/* Not supported: data(69 6E 76 61 6C 69 64 20 73 74 72 69 6E 67 20 70 6F 73 69 74 69 6F 6E 00) */;

	internal static $ArrayType$$$BY0BA@$$CBD ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@/* Not supported: data(73 74 72 69 6E 67 20 74 6F 6F 20 6C 6F 6E 67 00) */;

	internal static _s__RTTIClassHierarchyDescriptor ??_R3error_category@std@@8/* Not supported: data(00 00 00 00 00 00 00 00 01 00 00 00 A8 58 11 10) */;

	internal static _s__RTTIBaseClassDescriptor2 ??_R1A@?0A@EA@error_category@std@@8/* Not supported: data(00 70 11 10 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 B0 58 11 10) */;

	internal static _s__RTTIClassHierarchyDescriptor ??_R3_System_error_category@std@@8/* Not supported: data(00 00 00 00 00 00 00 00 03 00 00 00 8C 59 11 10) */;

	internal static $_s__RTTIBaseClassArray$_extraBytes_12 ??_R2_System_error_category@std@@8/* Not supported: data(70 59 11 10 D4 58 11 10 8C 58 11 10 00) */;

	internal static $ArrayType$$$BY06Q6AXXZ ??_7_Generic_error_category@std@@6B@/* Not supported: data(B8 1D 00 10 D2 1D 00 10 40 1E 00 10 EA 1C 00 10 14 1D 00 10 68 1D 00 10 D4 35 10 10) */;

	internal static _Iostream_error_category ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A/* Not supported: data(28 70 11 10) */;

	internal unsafe static delegate*<void> ?A0x3b475fdd.?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6MXXZA/* Not supported: data(1E 00 00 06) */;

	internal static piecewise_construct_t std.?A0x3b475fdd.piecewise_construct/*Field data (rva=0x12d499) could not be foundin any section!*/;

	internal static _s__RTTICompleteObjectLocator ??_R4_Generic_error_category@std@@6B@/* Not supported: data(00 00 00 00 00 00 00 00 00 00 00 00 40 70 11 10 FC 58 11 10) */;

	internal static $_TypeDescriptor$_extraBytes_35 ??_R0?AV_Iostream_error_category@std@@@8/* Not supported: data(D4 35 10 10 00 00 00 00 2E 3F 41 56 5F 49 6F 73 74 72 65 61 6D 5F 65 72 72 6F 72 5F 63 61 74 65 67 6F 72 79 40 73 74 64 40 40 00) */;

	internal static _s__RTTIBaseClassDescriptor2 ??_R1A@?0A@EA@_Generic_error_category@std@@8/* Not supported: data(40 70 11 10 01 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 FC 58 11 10) */;

	internal static _s__RTTIBaseClassDescriptor2 ??_R1A@?0A@EA@_Iostream_error_category@std@@8/* Not supported: data(88 70 11 10 02 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 4C 59 11 10) */;

	internal static _s__RTTICompleteObjectLocator ??_R4error_category@std@@6B@/* Not supported: data(00 00 00 00 00 00 00 00 00 00 00 00 00 70 11 10 B0 58 11 10) */;

	internal static _s__RTTICompleteObjectLocator ??_R4_Iostream_error_category@std@@6B@/* Not supported: data(00 00 00 00 00 00 00 00 00 00 00 00 88 70 11 10 4C 59 11 10) */;

	internal static allocator_arg_t std.?A0x3b475fdd.allocator_arg/*Field data (rva=0x12d498) could not be foundin any section!*/;

	internal static $_TypeDescriptor$_extraBytes_33 ??_R0?AV_System_error_category@std@@@8/* Not supported: data(D4 35 10 10 00 00 00 00 2E 3F 41 56 5F 53 79 73 74 65 6D 5F 65 72 72 6F 72 5F 63 61 74 65 67 6F 72 79 40 73 74 64 40 40 00) */;

	internal static _System_error_category ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A/* Not supported: data(28 70 11 10) */;

	internal unsafe static delegate*<void> ?A0x3b475fdd.?_System_object$initializer$@?$_Error_objects@H@std@@2P6MXXZA/* Not supported: data(1F 00 00 06) */;

	internal static $_s__RTTIBaseClassArray$_extraBytes_4 ??_R2error_category@std@@8/* Not supported: data(8C 58 11 10 00) */;

	internal static _s__RTTIBaseClassDescriptor2 ??_R1A@?0A@EA@_System_error_category@std@@8/* Not supported: data(D0 70 11 10 02 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 9C 59 11 10) */;

	internal static _s__RTTIClassHierarchyDescriptor ??_R3_Iostream_error_category@std@@8/* Not supported: data(00 00 00 00 00 00 00 00 03 00 00 00 3C 59 11 10) */;

	internal static _Generic_error_category ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A/* Not supported: data(28 70 11 10) */;

	internal unsafe static delegate*<void> ?A0x3b475fdd.?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6MXXZA/* Not supported: data(1D 00 00 06) */;

	internal static $ArrayType$$$BY06Q6AXXZ ??_7_System_error_category@std@@6B@/* Not supported: data(98 1F 00 10 B2 1F 00 10 20 20 00 10 58 20 00 10 14 1D 00 10 68 1D 00 10 03 00 00 06) */;

	internal static $_TypeDescriptor$_extraBytes_25 ??_R0?AVerror_category@std@@@8/* Not supported: data(D4 35 10 10 00 00 00 00 2E 3F 41 56 65 72 72 6F 72 5F 63 61 74 65 67 6F 72 79 40 73 74 64 40 40 00) */;

	internal static $ArrayType$$$BY06Q6AXXZ ??_7_Iostream_error_category@std@@6B@/* Not supported: data(90 1E 00 10 AA 1E 00 10 48 1F 00 10 EA 1C 00 10 14 1D 00 10 68 1D 00 10 D4 35 10 10) */;

	internal static $ArrayType$$$BY06Q6AXXZ ??_7error_category@std@@6B@/* Not supported: data(CD 1C 00 10 B6 37 00 10 B6 37 00 10 EA 1C 00 10 14 1D 00 10 68 1D 00 10 D4 35 10 10) */;

	internal static _s__RTTICompleteObjectLocator ??_R4_System_error_category@std@@6B@/* Not supported: data(00 00 00 00 00 00 00 00 00 00 00 00 D0 70 11 10 9C 59 11 10) */;

	internal static $_TypeDescriptor$_extraBytes_34 ??_R0?AV_Generic_error_category@std@@@8/* Not supported: data(D4 35 10 10 00 00 00 00 2E 3F 41 56 5F 47 65 6E 65 72 69 63 5F 65 72 72 6F 72 5F 63 61 74 65 67 6F 72 79 40 73 74 64 40 40 00) */;

	internal static locale.id ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A/* Not supported: data(00 00 00 00) */;

	internal unsafe static delegate*<void> ?A0x3b475fdd.?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6MXXZA/* Not supported: data(23 00 00 06) */;

	internal static $_s__RTTIBaseClassArray$_extraBytes_8 ??_R2_Generic_error_category@std@@8/* Not supported: data(D4 58 11 10 8C 58 11 10 00) */;

	internal static locale.id ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A/* Not supported: data(00 00 00 00) */;

	internal unsafe static delegate*<void> ?A0x3b475fdd.?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6MXXZA/* Not supported: data(24 00 00 06) */;

	internal static _s__RTTIClassHierarchyDescriptor ??_R3_Generic_error_category@std@@8/* Not supported: data(00 00 00 00 00 00 00 00 02 00 00 00 F0 58 11 10) */;

	internal static $_s__RTTIBaseClassArray$_extraBytes_12 ??_R2_Iostream_error_category@std@@8/* Not supported: data(20 59 11 10 D4 58 11 10 8C 58 11 10 00) */;

	internal static piecewise_construct_t std.?A0xfdc4e589.piecewise_construct/*Field data (rva=0x12d5a9) could not be foundin any section!*/;

	internal static allocator_arg_t std.?A0xfdc4e589.allocator_arg/*Field data (rva=0x12d5a8) could not be foundin any section!*/;

	internal static piecewise_construct_t std.?A0x49148180.piecewise_construct/*Field data (rva=0x12d6bd) could not be foundin any section!*/;

	internal static allocator_arg_t std.?A0x49148180.allocator_arg/*Field data (rva=0x12d6bc) could not be foundin any section!*/;

	internal static piecewise_construct_t std.?A0xd32db643.piecewise_construct/*Field data (rva=0x12d7e5) could not be foundin any section!*/;

	internal static allocator_arg_t std.?A0xd32db643.allocator_arg/*Field data (rva=0x12d7e4) could not be foundin any section!*/;

	internal static piecewise_construct_t std.?A0x67e5a30c.piecewise_construct/*Field data (rva=0x12d8f1) could not be foundin any section!*/;

	internal static allocator_arg_t std.?A0x67e5a30c.allocator_arg/*Field data (rva=0x12d8f0) could not be foundin any section!*/;

	internal static piecewise_construct_t std.?A0xab9c9a25.piecewise_construct/*Field data (rva=0x12d9e5) could not be foundin any section!*/;

	internal static allocator_arg_t std.?A0xab9c9a25.allocator_arg/*Field data (rva=0x12d9e4) could not be foundin any section!*/;

	internal static __s_GUID _GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02/* Not supported: data(6E A0 F1 90 12 77 62 47 86 B5 7A 5E BA 6B DB 02) */;

	internal static __s_GUID _GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e/* Not supported: data(22 67 2F CB 3A AB D2 11 9C 40 00 C0 4F A3 0A 3E) */;

	internal static $ArrayType$$$BY00Q6MPBXXZ ?A0x357a6285.__xc_mp_z/* Not supported: data(00 00 00 00) */;

	[FixedAddressValueType]
	internal static int ?Uninitialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA;

	internal unsafe static delegate*<void> ?A0x357a6285.?Uninitialized$initializer$@CurrentDomain@<CrtImplementationDetails>@@$$Q2P6MXXZA/* Not supported: data(36 00 00 06) */;

	internal static $ArrayType$$$BY00Q6MPBXXZ ?A0x357a6285.__xi_vt_a/* Not supported: data(00 00 00 00) */;

	[FixedAddressValueType]
	internal static Progress.State ?InitializedPerAppDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A;

	internal unsafe static delegate*<void> ?A0x357a6285.?InitializedPerAppDomain$initializer$@CurrentDomain@<CrtImplementationDetails>@@$$Q2P6MXXZA/* Not supported: data(3B 00 00 06) */;

	[FixedAddressValueType]
	internal static bool ?IsDefaultDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2_NA;

	internal unsafe static delegate*<void> ?A0x357a6285.?IsDefaultDomain$initializer$@CurrentDomain@<CrtImplementationDetails>@@$$Q2P6MXXZA/* Not supported: data(37 00 00 06) */;

	internal static $ArrayType$$$BY00Q6MPBXXZ ?A0x357a6285.__xc_ma_a/* Not supported: data(00 00 00 00) */;

	[FixedAddressValueType]
	internal static Progress.State ?InitializedNative@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A;

	internal unsafe static delegate*<void> ?A0x357a6285.?InitializedNative$initializer$@CurrentDomain@<CrtImplementationDetails>@@$$Q2P6MXXZA/* Not supported: data(39 00 00 06) */;

	[FixedAddressValueType]
	internal static int ?Initialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA;

	internal unsafe static delegate*<void> ?A0x357a6285.?Initialized$initializer$@CurrentDomain@<CrtImplementationDetails>@@$$Q2P6MXXZA/* Not supported: data(35 00 00 06) */;

	internal static $ArrayType$$$BY00Q6MPBXXZ ?A0x357a6285.__xc_ma_z/* Not supported: data(00 00 00 00) */;

	[FixedAddressValueType]
	internal static Progress.State ?InitializedVtables@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A;

	internal unsafe static delegate*<void> ?A0x357a6285.?InitializedVtables$initializer$@CurrentDomain@<CrtImplementationDetails>@@$$Q2P6MXXZA/* Not supported: data(38 00 00 06) */;

	internal static $ArrayType$$$BY00Q6MPBXXZ ?A0x357a6285.__xi_vt_z/* Not supported: data(00 00 00 00) */;

	internal static __s_GUID _GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e/* Not supported: data(23 67 2F CB 3A AB D2 11 9C 40 00 C0 4F A3 0A 3E) */;

	[FixedAddressValueType]
	internal static Progress.State ?InitializedPerProcess@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A;

	internal unsafe static delegate*<void> ?A0x357a6285.?InitializedPerProcess$initializer$@CurrentDomain@<CrtImplementationDetails>@@$$Q2P6MXXZA/* Not supported: data(3A 00 00 06) */;

	internal static bool ?InitializedPerProcess@DefaultDomain@<CrtImplementationDetails>@@2_NA/*Field data (rva=0x12dd1f) could not be foundin any section!*/;

	internal static bool ?Entered@DefaultDomain@<CrtImplementationDetails>@@2_NA/*Field data (rva=0x12dd1c) could not be foundin any section!*/;

	internal static bool ?InitializedNative@DefaultDomain@<CrtImplementationDetails>@@2_NA/*Field data (rva=0x12dd1d) could not be foundin any section!*/;

	internal static int ?Count@AllDomains@<CrtImplementationDetails>@@2HA/*Field data (rva=0x12dd18) could not be foundin any section!*/;

	internal static TriBool.State ?hasNative@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A/* Not supported: data() */;

	internal static TriBool.State ?hasPerProcess@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A/* Not supported: data() */;

	internal static bool ?InitializedNativeFromCCTOR@DefaultDomain@<CrtImplementationDetails>@@2_NA/*Field data (rva=0x12dd1e) could not be foundin any section!*/;

	internal static $ArrayType$$$BY00Q6MPBXXZ ?A0x357a6285.__xc_mp_a/* Not supported: data(00 00 00 00) */;

	internal static __s_GUID _GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02/* Not supported: data(6C A0 F1 90 12 77 62 47 86 B5 7A 5E BA 6B DB 02) */;

	public unsafe static int** __unep@?DoNothing@DefaultDomain@<CrtImplementationDetails>@@$$FCGJPAX@Z/* Not supported: data(FD 4E 00 10) */;

	public unsafe static int** __unep@?_UninitializeDefaultDomain@LanguageSupport@<CrtImplementationDetails>@@$$FCGJPAX@Z/* Not supported: data(03 4F 00 10) */;

	[FixedAddressValueType]
	internal static uint __exit_list_size_app_domain;

	[FixedAddressValueType]
	internal unsafe static delegate*<void>* __onexitbegin_app_domain;

	internal static uint ?A0x0107eea2.__exit_list_size/*Field data (rva=0x12de2c) could not be foundin any section!*/;

	[FixedAddressValueType]
	internal unsafe static delegate*<void>* __onexitend_app_domain;

	internal unsafe static delegate*<void>* ?A0x0107eea2.__onexitbegin_m/*Field data (rva=0x12de24) could not be foundin any section!*/;

	internal unsafe static delegate*<void>* ?A0x0107eea2.__onexitend_m/*Field data (rva=0x12de28) could not be foundin any section!*/;

	[FixedAddressValueType]
	internal unsafe static void* ?_lock@AtExitLock@<CrtImplementationDetails>@@$$Q0PAXA;

	[FixedAddressValueType]
	internal static int ?_ref_count@AtExitLock@<CrtImplementationDetails>@@$$Q0HA;

	internal static $ArrayType$$$BY01Q6AXXZ ??_7type_info@@6B@/* Not supported: data(6B 37 00 10 00 00 00 00) */;

	internal static $ArrayType$$$BY0A@P6AXXZ __xc_z/* Not supported: data(00) */;

	internal static $ArrayType$$$BY0A@P6AXXZ __xc_a/* Not supported: data(00) */;

	internal static $ArrayType$$$BY0A@P6AHXZ __xi_a/* Not supported: data(00) */;

	internal static volatile __enative_startup_state __native_startup_state/* Not supported: data() */;

	internal static $ArrayType$$$BY0A@P6AHXZ __xi_z/* Not supported: data(00) */;

	internal unsafe static volatile void* __native_startup_lock/*Field data (rva=0x133810) could not be foundin any section!*/;

	internal static volatile uint __native_dllmain_reason/* Not supported: data(FF FF FF FF) */;

	internal unsafe static void delete(void* A_0, void* A_1)
	{
	}

	internal unsafe static void std.error_category.{dtor}(error_category* P_0)
	{
		*(int*)P_0 = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
	}

	internal unsafe static void* std.error_category.__vecDelDtor(error_category* P_0, uint A_0)
	{
		if ((A_0 & 2) != 0)
		{
			error_category* ptr = (error_category*)((byte*)P_0 - 4);
			__ehvec_dtor(P_0, 4u, *(int*)ptr, (delegate*<void*, void>)(delegate*<error_category*, void>)(&std.error_category.{dtor}));
			if ((A_0 & 1) != 0)
			{
				delete[](ptr);
			}
			return ptr;
		}
		*(int*)P_0 = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
		if ((A_0 & 1) != 0)
		{
			delete(P_0);
		}
		return P_0;
	}

	[return: MarshalAs(UnmanagedType.U1)]
	internal unsafe static bool std.error_condition.==(error_condition* P_0, error_condition* _Right)
	{
		int num = ((((int*)P_0)[1] == ((int*)_Right)[1] && *(int*)P_0 == *(int*)_Right) ? 1 : 0);
		return (byte)num != 0;
	}

	internal unsafe static error_condition* std.error_category.default_error_condition(error_category* P_0, error_condition* P_1, int _Errval)
	{
		*(int*)P_1 = _Errval;
		((int*)P_1)[1] = (int)P_0;
		return P_1;
	}

	[return: MarshalAs(UnmanagedType.U1)]
	internal unsafe static bool std.error_category.equivalent(error_category* P_0, int _Errval, error_condition* _Cond)
	{
		Unsafe.SkipInit(out error_condition error_condition);
		return std.error_condition.==(((delegate* unmanaged[Thiscall, Thiscall]<IntPtr, error_condition*, int, error_condition*>)(int)(*(uint*)(*(int*)P_0 + 12)))((nint)P_0, &error_condition, _Errval), _Cond);
	}

	[return: MarshalAs(UnmanagedType.U1)]
	internal unsafe static bool std.error_category.equivalent(error_category* P_0, error_code* _Code, int _Errval)
	{
		int num = ((P_0 == (error_category*)((int*)_Code)[1] && *(int*)_Code == _Errval) ? 1 : 0);
		return (byte)num != 0;
	}

	internal unsafe static sbyte* std._Generic_error_category.name(_Generic_error_category* P_0)
	{
		return (sbyte*)Unsafe.AsPointer(ref ??_C@_07DCLBNMLN@generic?$AA@);
	}

	internal unsafe static basic_string<char,std::char_traits<char>,std::allocator<char> >* std._Generic_error_category.message(_Generic_error_category* P_0, basic_string<char,std::char_traits<char>,std::allocator<char> >* P_1, int _Errcode)
	{
		//IL_0015->IL0015: Incompatible stack types: I vs Ref
		uint num = 0u;
		sbyte* ptr = std._Syserror_map(_Errcode);
		sbyte* ptr2 = (sbyte*)Unsafe.AsPointer(ref ptr == null ? ref Unsafe.As<$ArrayType$$$BY0O@$$CBD, ?>(ref ??_C@_0O@BFJCFAAK@unknown?5error?$AA@) : ref *(?*)ptr);
		std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(P_1, ptr2);
		try
		{
			num = 1u;
			return P_1;
		}
		catch
		{
			//try-fault
			if ((num & 1) != 0)
			{
				num &= 0xFFFFFFFEu;
				___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), P_1);
			}
			throw;
		}
	}

	internal unsafe static void* std._Generic_error_category.__vecDelDtor(_Generic_error_category* P_0, uint A_0)
	{
		if ((A_0 & 2) != 0)
		{
			_Generic_error_category* ptr = (_Generic_error_category*)((byte*)P_0 - 4);
			__ehvec_dtor(P_0, 4u, *(int*)ptr, (delegate*<void*, void>)(delegate*<_Generic_error_category*, void>)(&std._Generic_error_category.{dtor}));
			if ((A_0 & 1) != 0)
			{
				delete[](ptr);
			}
			return ptr;
		}
		*(int*)P_0 = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
		if ((A_0 & 1) != 0)
		{
			delete(P_0);
		}
		return P_0;
	}

	internal unsafe static void std._Generic_error_category.{dtor}(_Generic_error_category* P_0)
	{
		*(int*)P_0 = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
	}

	internal unsafe static sbyte* std._Iostream_error_category.name(_Iostream_error_category* P_0)
	{
		return (sbyte*)Unsafe.AsPointer(ref ??_C@_08LLGCOLLL@iostream?$AA@);
	}

	internal unsafe static basic_string<char,std::char_traits<char>,std::allocator<char> >* std._Iostream_error_category.message(_Iostream_error_category* P_0, basic_string<char,std::char_traits<char>,std::allocator<char> >* P_1, int _Errcode)
	{
		uint num = 0u;
		if (_Errcode == 1)
		{
			std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(P_1, (sbyte*)Unsafe.AsPointer(ref ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@));
			try
			{
				num = 1u;
				return P_1;
			}
			catch
			{
				//try-fault
				if ((num & 1) != 0)
				{
					num &= 0xFFFFFFFEu;
					___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), P_1);
				}
				throw;
			}
		}
		std._Generic_error_category.message((_Generic_error_category*)P_0, P_1, _Errcode);
		try
		{
			num = 1u;
			return P_1;
		}
		catch
		{
			//try-fault
			if ((num & 1) != 0)
			{
				num &= 0xFFFFFFFEu;
				___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), P_1);
			}
			throw;
		}
	}

	internal unsafe static void* std._Iostream_error_category.__vecDelDtor(_Iostream_error_category* P_0, uint A_0)
	{
		if ((A_0 & 2) != 0)
		{
			_Iostream_error_category* ptr = (_Iostream_error_category*)((byte*)P_0 - 4);
			__ehvec_dtor(P_0, 4u, *(int*)ptr, (delegate*<void*, void>)(delegate*<_Iostream_error_category*, void>)(&std._Iostream_error_category.{dtor}));
			if ((A_0 & 1) != 0)
			{
				delete[](ptr);
			}
			return ptr;
		}
		*(int*)P_0 = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
		if ((A_0 & 1) != 0)
		{
			delete(P_0);
		}
		return P_0;
	}

	internal unsafe static void std._Iostream_error_category.{dtor}(_Iostream_error_category* P_0)
	{
		*(int*)P_0 = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
	}

	internal unsafe static sbyte* std._System_error_category.name(_System_error_category* P_0)
	{
		return (sbyte*)Unsafe.AsPointer(ref ??_C@_06FHFOAHML@system?$AA@);
	}

	internal unsafe static basic_string<char,std::char_traits<char>,std::allocator<char> >* std._System_error_category.message(_System_error_category* P_0, basic_string<char,std::char_traits<char>,std::allocator<char> >* P_1, int _Errcode)
	{
		//IL_0015->IL0015: Incompatible stack types: I vs Ref
		uint num = 0u;
		sbyte* ptr = std._Winerror_map(_Errcode);
		sbyte* ptr2 = (sbyte*)Unsafe.AsPointer(ref ptr == null ? ref Unsafe.As<$ArrayType$$$BY0O@$$CBD, ?>(ref ??_C@_0O@BFJCFAAK@unknown?5error?$AA@) : ref *(?*)ptr);
		std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(P_1, ptr2);
		try
		{
			num = 1u;
			return P_1;
		}
		catch
		{
			//try-fault
			if ((num & 1) != 0)
			{
				num &= 0xFFFFFFFEu;
				___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), P_1);
			}
			throw;
		}
	}

	internal unsafe static error_condition* std._System_error_category.default_error_condition(_System_error_category* P_0, error_condition* P_1, int _Errval)
	{
		if (std._Syserror_map(_Errval) != null)
		{
			*(int*)P_1 = _Errval;
			((int*)P_1)[1] = (int)Unsafe.AsPointer(ref ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A);
			return P_1;
		}
		*(int*)P_1 = _Errval;
		((int*)P_1)[1] = (int)Unsafe.AsPointer(ref ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A);
		return P_1;
	}

	internal unsafe static void* std._System_error_category.__vecDelDtor(_System_error_category* P_0, uint A_0)
	{
		if ((A_0 & 2) != 0)
		{
			_System_error_category* ptr = (_System_error_category*)((byte*)P_0 - 4);
			__ehvec_dtor(P_0, 4u, *(int*)ptr, (delegate*<void*, void>)(delegate*<_System_error_category*, void>)(&std._System_error_category.{dtor}));
			if ((A_0 & 1) != 0)
			{
				delete[](ptr);
			}
			return ptr;
		}
		*(int*)P_0 = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
		if ((A_0 & 1) != 0)
		{
			delete(P_0);
		}
		return P_0;
	}

	internal unsafe static void std._System_error_category.{dtor}(_System_error_category* P_0)
	{
		*(int*)P_0 = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
	}

	internal unsafe static basic_string<char,std::char_traits<char>,std::allocator<char> >* std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(basic_string<char,std::char_traits<char>,std::allocator<char> >* P_0, sbyte* _Ptr)
	{
		((int*)P_0)[4] = 0;
		((int*)P_0)[5] = 0;
		std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(P_0, false, 0u);
		uint count;
		if (*_Ptr == 0)
		{
			count = 0u;
		}
		else
		{
			sbyte* ptr = _Ptr;
			do
			{
				ptr++;
			}
			while (*ptr != 0);
			count = (uint)(ptr - (nuint)_Ptr);
		}
		std.basic_string<char,std::char_traits<char>,std::allocator<char> >.assign(P_0, _Ptr, count);
		return P_0;
	}

	internal unsafe static void std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}(basic_string<char,std::char_traits<char>,std::allocator<char> >* P_0)
	{
		std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(P_0, true, 0u);
	}

	internal unsafe static void std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(basic_string<char,std::char_traits<char>,std::allocator<char> >* P_0, [MarshalAs(UnmanagedType.U1)] bool _Built, uint _Newsize)
	{
		if (_Built && 16u <= (uint)((int*)P_0)[5])
		{
			sbyte* ptr = (sbyte*)(int)(*(uint*)P_0);
			if (0 < _Newsize && _Newsize != 0)
			{
				// IL cpblk instruction
				Unsafe.CopyBlock(P_0, ptr, _Newsize);
			}
			delete(ptr);
		}
		((int*)P_0)[5] = 15;
		((int*)P_0)[4] = (int)_Newsize;
		*((int)_Newsize + (sbyte*)P_0) = 0;
	}

	internal unsafe static basic_string<char,std::char_traits<char>,std::allocator<char> >* std.basic_string<char,std::char_traits<char>,std::allocator<char> >.assign(basic_string<char,std::char_traits<char>,std::allocator<char> >* P_0, sbyte* _Ptr, uint _Count)
	{
		if (_Ptr != null)
		{
			uint num = ((uint*)P_0)[5];
			sbyte* ptr = ((16 > num) ? ((sbyte*)P_0) : ((sbyte*)(int)(*(uint*)P_0)));
			if (_Ptr >= ptr)
			{
				sbyte* ptr2 = ((16 > num) ? ((sbyte*)P_0) : ((sbyte*)(int)(*(uint*)P_0)));
				if (((int*)P_0)[4] + ptr2 > _Ptr)
				{
					sbyte* ptr3 = ((16 > num) ? ((sbyte*)P_0) : ((sbyte*)(int)(*(uint*)P_0)));
					return std.basic_string<char,std::char_traits<char>,std::allocator<char> >.assign(P_0, P_0, (uint)(_Ptr - (nuint)ptr3), _Count);
				}
			}
		}
		if (std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Grow(P_0, _Count, false))
		{
			sbyte* ptr4 = ((16u > (uint)((int*)P_0)[5]) ? ((sbyte*)P_0) : ((sbyte*)(int)(*(uint*)P_0)));
			if (_Count != 0)
			{
				// IL cpblk instruction
				Unsafe.CopyBlock(ptr4, _Ptr, _Count);
			}
			((int*)P_0)[4] = (int)_Count;
			*(sbyte*)(((16u > (uint)((int*)P_0)[5]) ? ((nint)P_0) : ((nint)(*(int*)P_0))) + (int)_Count) = 0;
		}
		return P_0;
	}

	internal unsafe static basic_string<char,std::char_traits<char>,std::allocator<char> >* std.basic_string<char,std::char_traits<char>,std::allocator<char> >.assign(basic_string<char,std::char_traits<char>,std::allocator<char> >* P_0, basic_string<char,std::char_traits<char>,std::allocator<char> >* _Right, uint _Roff, uint _Count)
	{
		uint num = ((uint*)_Right)[4];
		if (num < _Roff)
		{
			std._Xout_of_range((sbyte*)Unsafe.AsPointer(ref ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@));
		}
		uint num2 = num - _Roff;
		num2 = ((_Count < num2) ? _Count : num2);
		if (P_0 == _Right)
		{
			if ((uint)((int*)P_0)[4] < _Roff + num2)
			{
				std._Xout_of_range((sbyte*)Unsafe.AsPointer(ref ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@));
			}
			((int*)P_0)[4] = (int)(_Roff + num2);
			sbyte* ptr = ((16u > (uint)((int*)P_0)[5]) ? ((sbyte*)P_0) : ((sbyte*)(int)(*(uint*)P_0)));
			*((int)(_Roff + num2) + ptr) = 0;
			std.basic_string<char,std::char_traits<char>,std::allocator<char> >.erase(P_0, 0u, _Roff);
		}
		else if (std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Grow(P_0, num2, false))
		{
			sbyte* ptr2 = ((16u > (uint)((int*)_Right)[5]) ? ((sbyte*)_Right) : ((sbyte*)(int)(*(uint*)_Right)));
			sbyte* ptr3 = ((16u > (uint)((int*)P_0)[5]) ? ((sbyte*)P_0) : ((sbyte*)(int)(*(uint*)P_0)));
			if (num2 != 0)
			{
				// IL cpblk instruction
				Unsafe.CopyBlock(ptr3, ptr2 + (int)_Roff, num2);
			}
			((int*)P_0)[4] = (int)num2;
			*(sbyte*)(((16u > (uint)((int*)P_0)[5]) ? ((nint)P_0) : ((nint)(*(int*)P_0))) + (int)num2) = 0;
		}
		return P_0;
	}

	[return: MarshalAs(UnmanagedType.U1)]
	internal unsafe static bool std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Grow(basic_string<char,std::char_traits<char>,std::allocator<char> >* P_0, uint _Newsize, [MarshalAs(UnmanagedType.U1)] bool _Trim)
	{
		if (4294967294u < _Newsize)
		{
			std._Xlength_error((sbyte*)Unsafe.AsPointer(ref ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@));
		}
		uint num = ((uint*)P_0)[5];
		if (num < _Newsize)
		{
			std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Copy(P_0, _Newsize, ((uint*)P_0)[4]);
		}
		else if (_Trim && _Newsize < 16)
		{
			uint num2 = ((uint*)P_0)[4];
			uint newsize = ((_Newsize < num2) ? _Newsize : num2);
			std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(P_0, true, newsize);
		}
		else if (_Newsize == 0)
		{
			((int*)P_0)[4] = 0;
			*((16 > num) ? ((sbyte*)P_0) : ((sbyte*)(int)(*(uint*)P_0))) = 0;
			goto IL_0067;
		}
		if (0 >= _Newsize)
		{
			goto IL_0067;
		}
		int num3 = 1;
		goto IL_0069;
		IL_0067:
		num3 = 0;
		goto IL_0069;
		IL_0069:
		return (byte)num3 != 0;
	}

	internal unsafe static basic_string<char,std::char_traits<char>,std::allocator<char> >* std.basic_string<char,std::char_traits<char>,std::allocator<char> >.erase(basic_string<char,std::char_traits<char>,std::allocator<char> >* P_0, uint _Off, uint _Count)
	{
		uint num = ((uint*)P_0)[4];
		if (num < _Off)
		{
			std._Xout_of_range((sbyte*)Unsafe.AsPointer(ref ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@));
		}
		if (num - _Off <= _Count)
		{
			((int*)P_0)[4] = (int)_Off;
			*(sbyte*)(((16u > (uint)((int*)P_0)[5]) ? ((nint)P_0) : ((nint)(*(int*)P_0))) + (int)_Off) = 0;
		}
		else if (0 < _Count)
		{
			sbyte* ptr = (sbyte*)(((16u > (uint)((int*)P_0)[5]) ? ((nint)P_0) : ((nint)(*(int*)P_0))) + (int)_Off);
			uint num2 = num - _Count;
			uint num3 = num2 - _Off;
			if (num3 != 0)
			{
				memmove(ptr, ptr + (int)_Count, num3);
			}
			((int*)P_0)[4] = (int)num2;
			*(sbyte*)(((16u > (uint)((int*)P_0)[5]) ? ((nint)P_0) : ((nint)(*(int*)P_0))) + (int)num2) = 0;
		}
		return P_0;
	}

	internal unsafe static void std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Copy(basic_string<char,std::char_traits<char>,std::allocator<char> >* P_0, uint _Newsize, uint _Oldlen)
	{
		uint num = (uint)__CxxQueryExceptionSize();
		int num2 = (int)stackalloc byte[(int)(num << 1)];
		uint num3 = _Newsize | 0xF;
		if (4294967294u < num3)
		{
			num3 = _Newsize;
		}
		else
		{
			uint num4 = ((uint*)P_0)[5];
			uint num5 = num4 >> 1;
			if (num5 > num3 / 3)
			{
				num3 = ((num4 > (uint)(-2 - (int)num5)) ? 4294967294u : (num5 + num4));
			}
		}
		Unsafe.SkipInit(out int num6);
		Unsafe.SkipInit(out sbyte* ptr5);
		try
		{
			num6 = (int)num + num2;
			uint num7 = num3 + 1;
			void* ptr = null;
			if (num7 == 0)
			{
				goto IL_0068;
			}
			if (uint.MaxValue >= num7)
			{
				ptr = @new(num7);
				if (ptr != null)
				{
					goto IL_0068;
				}
			}
			std._Xbad_alloc();
			goto end_IL_0046;
			IL_0068:
			sbyte* ptr2 = (sbyte*)ptr;
			sbyte* ptr3 = (sbyte*)ptr;
			sbyte* ptr4 = (sbyte*)ptr;
			ptr5 = (sbyte*)ptr;
			end_IL_0046:;
		}
		catch when (((Func<bool>)delegate
		{
			// Could not convert BlockContainer to single expression
			uint exceptionCode = (uint)Marshal.GetExceptionCode();
			return (byte)__CxxExceptionFilter((void*)Marshal.GetExceptionPointers(), null, 0, null) != 0;
		}).Invoke())
		{
			uint num8 = 0u;
			__CxxRegisterExceptionObject((void*)Marshal.GetExceptionPointers(), (void*)num6);
			try
			{
				try
				{
					num3 = _Newsize;
					try
					{
						uint num9 = _Newsize + 1;
						uint num10 = num9;
						void* ptr6 = null;
						if (num9 == 0)
						{
							goto IL_00ce;
						}
						if (uint.MaxValue >= num9)
						{
							ptr6 = @new(num9);
							if (ptr6 != null)
							{
								goto IL_00ce;
							}
						}
						std._Xbad_alloc();
						goto end_IL_00ad;
						IL_00ce:
						sbyte* ptr7 = (sbyte*)ptr6;
						sbyte* ptr8 = (sbyte*)ptr6;
						sbyte* ptr9 = (sbyte*)ptr6;
						ptr5 = (sbyte*)ptr6;
						end_IL_00ad:;
					}
					catch when (((Func<bool>)delegate
					{
						// Could not convert BlockContainer to single expression
						uint exceptionCode2 = (uint)Marshal.GetExceptionCode();
						return (byte)__CxxExceptionFilter((void*)Marshal.GetExceptionPointers(), null, 0, null) != 0;
					}).Invoke())
					{
						uint num11 = 0u;
						__CxxRegisterExceptionObject((void*)Marshal.GetExceptionPointers(), (void*)num2);
						try
						{
							try
							{
								std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(P_0, true, 0u);
								_CxxThrowException(null, null);
							}
							catch when (((Func<bool>)delegate
							{
								// Could not convert BlockContainer to single expression
								num11 = (uint)__CxxDetectRethrow((void*)Marshal.GetExceptionPointers());
								return (byte)num11 != 0;
							}).Invoke())
							{
							}
							if (num11 != 0)
							{
								throw;
							}
							goto end_IL_00fa;
						}
						finally
						{
							__CxxUnregisterExceptionObject((void*)num2, (int)num11);
						}
						end_IL_00fa:;
					}
					goto end_IL_00ab;
				}
				catch when (((Func<bool>)delegate
				{
					// Could not convert BlockContainer to single expression
					num8 = (uint)__CxxDetectRethrow((void*)Marshal.GetExceptionPointers());
					return (byte)num8 != 0;
				}).Invoke())
				{
				}
				if (num8 != 0)
				{
					throw;
				}
				end_IL_00ab:;
			}
			finally
			{
				__CxxUnregisterExceptionObject((void*)num6, (int)num8);
			}
		}
		if (0 < _Oldlen)
		{
			sbyte* ptr10 = ((16u > (uint)((int*)P_0)[5]) ? ((sbyte*)P_0) : ((sbyte*)(int)(*(uint*)P_0)));
			if (_Oldlen != 0)
			{
				// IL cpblk instruction
				Unsafe.CopyBlock(ptr5, ptr10, _Oldlen);
			}
		}
		std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(P_0, true, 0u);
		try
		{
			if (P_0 != null)
			{
				*(int*)P_0 = (int)ptr5;
			}
		}
		catch
		{
			//try-fault
			delete(P_0, P_0);
			throw;
		}
		((int*)P_0)[5] = (int)num3;
		((int*)P_0)[4] = (int)_Oldlen;
		*(sbyte*)(((16 > num3) ? ((nint)P_0) : ((nint)(*(int*)P_0))) + (int)_Oldlen) = 0;
	}

	internal unsafe static void ?A0x3b475fdd.??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YMXXZ()
	{
		try
		{
			Unsafe.As<_Generic_error_category, int>(ref ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A) = (int)Unsafe.AsPointer(ref ??_7_Generic_error_category@std@@6B@);
		}
		catch
		{
			//try-fault
			___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<error_category*, void>)(&std.error_category.{dtor}), Unsafe.AsPointer(ref ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A));
			throw;
		}
		_atexit_m((delegate*<void>)(&?A0x3b475fdd.??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YMXXZ));
	}

	internal unsafe static void ?A0x3b475fdd.??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YMXXZ()
	{
		try
		{
			Unsafe.As<_Iostream_error_category, int>(ref ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A) = (int)Unsafe.AsPointer(ref ??_7_Generic_error_category@std@@6B@);
		}
		catch
		{
			//try-fault
			___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<error_category*, void>)(&std.error_category.{dtor}), Unsafe.AsPointer(ref ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A));
			throw;
		}
		try
		{
			Unsafe.As<_Iostream_error_category, int>(ref ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A) = (int)Unsafe.AsPointer(ref ??_7_Iostream_error_category@std@@6B@);
		}
		catch
		{
			//try-fault
			___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<_Generic_error_category*, void>)(&std._Generic_error_category.{dtor}), Unsafe.AsPointer(ref ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A));
			throw;
		}
		_atexit_m((delegate*<void>)(&?A0x3b475fdd.??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YMXXZ));
	}

	internal unsafe static void ?A0x3b475fdd.??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YMXXZ()
	{
		try
		{
			Unsafe.As<_System_error_category, int>(ref ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A) = (int)Unsafe.AsPointer(ref ??_7_Generic_error_category@std@@6B@);
		}
		catch
		{
			//try-fault
			___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<error_category*, void>)(&std.error_category.{dtor}), Unsafe.AsPointer(ref ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A));
			throw;
		}
		try
		{
			Unsafe.As<_System_error_category, int>(ref ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A) = (int)Unsafe.AsPointer(ref ??_7_System_error_category@std@@6B@);
		}
		catch
		{
			//try-fault
			___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<_Generic_error_category*, void>)(&std._Generic_error_category.{dtor}), Unsafe.AsPointer(ref ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A));
			throw;
		}
		_atexit_m((delegate*<void>)(&?A0x3b475fdd.??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YMXXZ));
	}

	internal unsafe static void ?A0x3b475fdd.??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YMXXZ()
	{
		Unsafe.As<_System_error_category, int>(ref ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A) = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
	}

	internal unsafe static void ?A0x3b475fdd.??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YMXXZ()
	{
		Unsafe.As<_Iostream_error_category, int>(ref ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A) = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
	}

	internal unsafe static void ?A0x3b475fdd.??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YMXXZ()
	{
		Unsafe.As<_Generic_error_category, int>(ref ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A) = (int)Unsafe.AsPointer(ref ??_7error_category@std@@6B@);
	}

	internal unsafe static void ?A0x3b475fdd.??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YMXXZ()
	{
		std.locale.id.{ctor}((locale.id*)Unsafe.AsPointer(ref ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A), 0u);
	}

	internal unsafe static void ?A0x3b475fdd.??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YMXXZ()
	{
		std.locale.id.{ctor}((locale.id*)Unsafe.AsPointer(ref ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A), 0u);
	}

	[return: MarshalAs(UnmanagedType.U1)]
	internal static bool <CrtImplementationDetails>.NativeDll.IsSafeForManagedCode()
	{
		if (!(__native_dllmain_reason != uint.MaxValue))
		{
			return true;
		}
		int num = ((__native_dllmain_reason != 1 && __native_dllmain_reason != 0) ? 1 : 0);
		return (byte)num != 0;
	}

	internal static void <CrtImplementationDetails>.ThrowNestedModuleLoadException(Exception innerException, Exception nestedException)
	{
		throw new ModuleLoadExceptionHandlerException("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", innerException, nestedException);
	}

	internal static void <CrtImplementationDetails>.ThrowModuleLoadException(string errorMessage)
	{
		throw new ModuleLoadException(errorMessage);
	}

	internal static void <CrtImplementationDetails>.ThrowModuleLoadException(string errorMessage, Exception innerException)
	{
		throw new ModuleLoadException(errorMessage, innerException);
	}

	internal static void <CrtImplementationDetails>.RegisterModuleUninitializer(EventHandler handler)
	{
		ModuleUninitializer._ModuleUninitializer.AddHandler(handler);
	}

	[SecuritySafeCritical]
	internal unsafe static Guid <CrtImplementationDetails>.FromGUID(_GUID* guid)
	{
		return new Guid(*(uint*)guid, ((ushort*)guid)[2], ((ushort*)guid)[3], ((byte*)guid)[8], ((byte*)guid)[9], ((byte*)guid)[10], ((byte*)guid)[11], ((byte*)guid)[12], ((byte*)guid)[13], ((byte*)guid)[14], ((byte*)guid)[15]);
	}

	[SecurityCritical]
	internal unsafe static int __get_default_appdomain(IUnknown** ppUnk)
	{
		ICorRuntimeHost* ptr = null;
		int num;
		try
		{
			Guid guid = <CrtImplementationDetails>.FromGUID((_GUID*)Unsafe.AsPointer(ref _GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e));
			Guid guid2 = guid;
			Guid guid3 = <CrtImplementationDetails>.FromGUID((_GUID*)Unsafe.AsPointer(ref _GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e));
			Guid guid4 = guid3;
			ptr = (ICorRuntimeHost*)RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(guid3, guid).ToPointer();
		}
		catch (Exception e)
		{
			num = Marshal.GetHRForException(e);
			goto IL_0039;
		}
		goto IL_003d;
		IL_0039:
		if (num >= 0)
		{
			goto IL_003d;
		}
		goto IL_0057;
		IL_003d:
		num = ((delegate* unmanaged[Stdcall, Stdcall]<IntPtr, IUnknown**, int>)(int)(*(uint*)(*(int*)ptr + 52)))((nint)ptr, ppUnk);
		ICorRuntimeHost* intPtr = ptr;
		((delegate* unmanaged[Stdcall, Stdcall]<IntPtr, uint>)(int)(*(uint*)(*(int*)intPtr + 8)))((nint)intPtr);
		goto IL_0057;
		IL_0057:
		return num;
	}

	internal unsafe static void __release_appdomain(IUnknown* ppUnk)
	{
		((delegate* unmanaged[Stdcall, Stdcall]<IntPtr, uint>)(int)(*(uint*)(*(int*)ppUnk + 8)))((nint)ppUnk);
	}

	[SecurityCritical]
	internal unsafe static AppDomain <CrtImplementationDetails>.GetDefaultDomain()
	{
		IUnknown* ptr = null;
		int num = __get_default_appdomain(&ptr);
		if (num >= 0)
		{
			try
			{
				IntPtr pUnk = new IntPtr(ptr);
				return (AppDomain)Marshal.GetObjectForIUnknown(pUnk);
			}
			finally
			{
				__release_appdomain(ptr);
			}
		}
		Marshal.ThrowExceptionForHR(num);
		return null;
	}

	[SecurityCritical]
	internal unsafe static void <CrtImplementationDetails>.DoCallBackInDefaultDomain(delegate* unmanaged[Stdcall, Stdcall]<void*, int> function, void* cookie)
	{
		Guid riid = <CrtImplementationDetails>.FromGUID((_GUID*)Unsafe.AsPointer(ref _GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02));
		ICLRRuntimeHost* ptr = (ICLRRuntimeHost*)RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(<CrtImplementationDetails>.FromGUID((_GUID*)Unsafe.AsPointer(ref _GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02)), riid).ToPointer();
		try
		{
			AppDomain appDomain = <CrtImplementationDetails>.GetDefaultDomain();
			int num = ((delegate* unmanaged[Stdcall, Stdcall]<IntPtr, uint, delegate* unmanaged[Stdcall, Stdcall]<void*, int>, void*, int>)(int)(*(uint*)(*(int*)ptr + 32)))((nint)ptr, (uint)appDomain.Id, function, cookie);
			if (num < 0)
			{
				Marshal.ThrowExceptionForHR(num);
			}
		}
		finally
		{
			((delegate* unmanaged[Stdcall, Stdcall]<IntPtr, uint>)(int)(*(uint*)(*(int*)ptr + 8)))((nint)ptr);
		}
	}

	[SecuritySafeCritical]
	internal unsafe static int <CrtImplementationDetails>.DefaultDomain.DoNothing(void* cookie)
	{
		GC.KeepAlive(int.MaxValue);
		return 0;
	}

	[SecuritySafeCritical]
	[return: MarshalAs(UnmanagedType.U1)]
	internal unsafe static bool <CrtImplementationDetails>.DefaultDomain.HasPerProcess()
	{
		if (?hasPerProcess@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A == (TriBool.State)2)
		{
			void** ptr = (void**)Unsafe.AsPointer(ref ?A0x357a6285.__xc_mp_a);
			if (Unsafe.IsAddressLessThan(ref ?A0x357a6285.__xc_mp_a, ref ?A0x357a6285.__xc_mp_z))
			{
				do
				{
					if (*(int*)ptr == 0)
					{
						ptr = (void**)((byte*)ptr + 4);
						continue;
					}
					?hasPerProcess@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A = (TriBool.State)(-1);
					return true;
				}
				while (ptr < Unsafe.AsPointer(ref ?A0x357a6285.__xc_mp_z));
			}
			?hasPerProcess@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A = (TriBool.State)0;
			return false;
		}
		return ?hasPerProcess@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A == (TriBool.State)(-1);
	}

	[SecuritySafeCritical]
	[return: MarshalAs(UnmanagedType.U1)]
	internal unsafe static bool <CrtImplementationDetails>.DefaultDomain.HasNative()
	{
		if (?hasNative@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A == (TriBool.State)2)
		{
			void** ptr = (void**)Unsafe.AsPointer(ref __xi_a);
			if (Unsafe.IsAddressLessThan(ref __xi_a, ref __xi_z))
			{
				do
				{
					if (*(int*)ptr == 0)
					{
						ptr = (void**)((byte*)ptr + 4);
						continue;
					}
					?hasNative@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A = (TriBool.State)(-1);
					return true;
				}
				while (ptr < Unsafe.AsPointer(ref __xi_z));
			}
			void** ptr2 = (void**)Unsafe.AsPointer(ref __xc_a);
			if (Unsafe.IsAddressLessThan(ref __xc_a, ref __xc_z))
			{
				do
				{
					if (*(int*)ptr2 == 0)
					{
						ptr2 = (void**)((byte*)ptr2 + 4);
						continue;
					}
					?hasNative@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A = (TriBool.State)(-1);
					return true;
				}
				while (ptr2 < Unsafe.AsPointer(ref __xc_z));
			}
			?hasNative@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A = (TriBool.State)0;
			return false;
		}
		return ?hasNative@DefaultDomain@<CrtImplementationDetails>@@0W4State@TriBool@2@A == (TriBool.State)(-1);
	}

	[SecuritySafeCritical]
	[return: MarshalAs(UnmanagedType.U1)]
	internal static bool <CrtImplementationDetails>.DefaultDomain.NeedsInitialization()
	{
		int num = (((<CrtImplementationDetails>.DefaultDomain.HasPerProcess() && !?InitializedPerProcess@DefaultDomain@<CrtImplementationDetails>@@2_NA) || (<CrtImplementationDetails>.DefaultDomain.HasNative() && !?InitializedNative@DefaultDomain@<CrtImplementationDetails>@@2_NA && __native_startup_state == (__enative_startup_state)0)) ? 1 : 0);
		return (byte)num != 0;
	}

	[return: MarshalAs(UnmanagedType.U1)]
	internal static bool <CrtImplementationDetails>.DefaultDomain.NeedsUninitialization()
	{
		return ?Entered@DefaultDomain@<CrtImplementationDetails>@@2_NA;
	}

	[SecurityCritical]
	internal unsafe static void <CrtImplementationDetails>.DefaultDomain.Initialize()
	{
		<CrtImplementationDetails>.DoCallBackInDefaultDomain((delegate* unmanaged[Stdcall, Stdcall]<void*, int>)__unep@?DoNothing@DefaultDomain@<CrtImplementationDetails>@@$$FCGJPAX@Z, null);
	}

	internal static void ?A0x357a6285.??__E?Initialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA@@YMXXZ()
	{
		?Initialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA = 0;
	}

	internal static void ?A0x357a6285.??__E?Uninitialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA@@YMXXZ()
	{
		?Uninitialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA = 0;
	}

	internal static void ?A0x357a6285.??__E?IsDefaultDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2_NA@@YMXXZ()
	{
		?IsDefaultDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2_NA = false;
	}

	internal static void ?A0x357a6285.??__E?InitializedVtables@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A@@YMXXZ()
	{
		?InitializedVtables@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)0;
	}

	internal static void ?A0x357a6285.??__E?InitializedNative@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A@@YMXXZ()
	{
		?InitializedNative@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)0;
	}

	internal static void ?A0x357a6285.??__E?InitializedPerProcess@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A@@YMXXZ()
	{
		?InitializedPerProcess@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)0;
	}

	internal static void ?A0x357a6285.??__E?InitializedPerAppDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A@@YMXXZ()
	{
		?InitializedPerAppDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)0;
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.InitializeVtables(LanguageSupport* P_0)
	{
		gcroot<System::String ^>.=((gcroot<System::String ^>*)P_0, "The C++ module failed to load during vtable initialization.\n");
		?InitializedVtables@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)1;
		_initterm_m((delegate*<void*>*)Unsafe.AsPointer(ref ?A0x357a6285.__xi_vt_a), (delegate*<void*>*)Unsafe.AsPointer(ref ?A0x357a6285.__xi_vt_z));
		?InitializedVtables@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)2;
	}

	[SecurityCritical]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.InitializeDefaultAppDomain(LanguageSupport* P_0)
	{
		gcroot<System::String ^>.=((gcroot<System::String ^>*)P_0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
		<CrtImplementationDetails>.DefaultDomain.Initialize();
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.InitializeNative(LanguageSupport* P_0)
	{
		gcroot<System::String ^>.=((gcroot<System::String ^>*)P_0, "The C++ module failed to load during native initialization.\n");
		__security_init_cookie();
		?InitializedNative@DefaultDomain@<CrtImplementationDetails>@@2_NA = true;
		if (!<CrtImplementationDetails>.NativeDll.IsSafeForManagedCode())
		{
			_amsg_exit(33);
		}
		if (__native_startup_state == (__enative_startup_state)1)
		{
			_amsg_exit(33);
		}
		else if (__native_startup_state == (__enative_startup_state)0)
		{
			?InitializedNative@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)1;
			__native_startup_state = (__enative_startup_state)1;
			if (_initterm_e((delegate* unmanaged[Cdecl, Cdecl]<int>*)Unsafe.AsPointer(ref __xi_a), (delegate* unmanaged[Cdecl, Cdecl]<int>*)Unsafe.AsPointer(ref __xi_z)) != 0)
			{
				<CrtImplementationDetails>.ThrowModuleLoadException(gcroot<System::String ^>..P$AAVString@System@@((gcroot<System::String ^>*)P_0));
			}
			_initterm((delegate* unmanaged[Cdecl, Cdecl]<void>*)Unsafe.AsPointer(ref __xc_a), (delegate* unmanaged[Cdecl, Cdecl]<void>*)Unsafe.AsPointer(ref __xc_z));
			__native_startup_state = (__enative_startup_state)2;
			?InitializedNativeFromCCTOR@DefaultDomain@<CrtImplementationDetails>@@2_NA = true;
			?InitializedNative@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)2;
		}
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.InitializePerProcess(LanguageSupport* P_0)
	{
		gcroot<System::String ^>.=((gcroot<System::String ^>*)P_0, "The C++ module failed to load during process initialization.\n");
		?InitializedPerProcess@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)1;
		_initatexit_m();
		_initterm_m((delegate*<void*>*)Unsafe.AsPointer(ref ?A0x357a6285.__xc_mp_a), (delegate*<void*>*)Unsafe.AsPointer(ref ?A0x357a6285.__xc_mp_z));
		?InitializedPerProcess@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)2;
		?InitializedPerProcess@DefaultDomain@<CrtImplementationDetails>@@2_NA = true;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.InitializePerAppDomain(LanguageSupport* P_0)
	{
		gcroot<System::String ^>.=((gcroot<System::String ^>*)P_0, "The C++ module failed to load during appdomain initialization.\n");
		?InitializedPerAppDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)1;
		_initatexit_app_domain();
		_initterm_m((delegate*<void*>*)Unsafe.AsPointer(ref ?A0x357a6285.__xc_ma_a), (delegate*<void*>*)Unsafe.AsPointer(ref ?A0x357a6285.__xc_ma_z));
		?InitializedPerAppDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2W4State@Progress@2@A = (Progress.State)2;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.InitializeUninitializer(LanguageSupport* P_0)
	{
		gcroot<System::String ^>.=((gcroot<System::String ^>*)P_0, "The C++ module failed to load during registration for the unload events.\n");
		<CrtImplementationDetails>.RegisterModuleUninitializer([ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] [SecurityCritical] [PrePrepareMethod] (object source, EventArgs arguments) =>
		{
			if (?Initialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA != 0 && Interlocked.Exchange(ref ?Uninitialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA, 1) == 0)
			{
				bool num = Interlocked.Decrement(ref ?Count@AllDomains@<CrtImplementationDetails>@@2HA) == 0;
				<CrtImplementationDetails>.LanguageSupport.UninitializeAppDomain();
				if (num)
				{
					<CrtImplementationDetails>.LanguageSupport.UninitializeDefaultDomain();
				}
			}
		});
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport._Initialize(LanguageSupport* P_0)
	{
		?IsDefaultDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
		if (?IsDefaultDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2_NA)
		{
			?Entered@DefaultDomain@<CrtImplementationDetails>@@2_NA = true;
		}
		void* ptr = _getFiberPtrId();
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		RuntimeHelpers.PrepareConstrainedRegions();
		try
		{
			while (num2 == 0)
			{
				try
				{
				}
				finally
				{
					IntPtr intPtr = (IntPtr)0;
					IntPtr intPtr2 = intPtr;
					IntPtr intPtr3 = (IntPtr)ptr;
					IntPtr intPtr4 = intPtr3;
					IntPtr intPtr5 = Interlocked.CompareExchange(ref Unsafe.As<void*, IntPtr>(ref __native_startup_lock), intPtr3, intPtr);
					IntPtr intPtr6 = intPtr5;
					void* ptr2 = (void*)intPtr5;
					if (ptr2 == null)
					{
						num2 = 1;
					}
					else if (ptr2 == ptr)
					{
						num = 1;
						num2 = 1;
					}
				}
				if (num2 == 0)
				{
					Sleep(1000u);
				}
			}
			<CrtImplementationDetails>.LanguageSupport.InitializeVtables(P_0);
			if (?IsDefaultDomain@CurrentDomain@<CrtImplementationDetails>@@$$Q2_NA)
			{
				<CrtImplementationDetails>.LanguageSupport.InitializeNative(P_0);
				<CrtImplementationDetails>.LanguageSupport.InitializePerProcess(P_0);
			}
			else if (<CrtImplementationDetails>.DefaultDomain.NeedsInitialization())
			{
				num3 = 1;
			}
		}
		finally
		{
			if (num == 0)
			{
				IntPtr value = (IntPtr)0;
				Interlocked.Exchange(ref Unsafe.As<void*, IntPtr>(ref __native_startup_lock), value);
			}
		}
		if (num3 != 0)
		{
			<CrtImplementationDetails>.LanguageSupport.InitializeDefaultAppDomain(P_0);
		}
		<CrtImplementationDetails>.LanguageSupport.InitializePerAppDomain(P_0);
		?Initialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA = 1;
		<CrtImplementationDetails>.LanguageSupport.InitializeUninitializer(P_0);
	}

	[SecurityCritical]
	internal static void <CrtImplementationDetails>.LanguageSupport.UninitializeAppDomain()
	{
		_app_exit_callback();
	}

	[SecurityCritical]
	internal unsafe static int <CrtImplementationDetails>.LanguageSupport._UninitializeDefaultDomain(void* cookie)
	{
		_exit_callback();
		?InitializedPerProcess@DefaultDomain@<CrtImplementationDetails>@@2_NA = false;
		if (?InitializedNativeFromCCTOR@DefaultDomain@<CrtImplementationDetails>@@2_NA)
		{
			_cexit();
			__native_startup_state = (__enative_startup_state)0;
			?InitializedNativeFromCCTOR@DefaultDomain@<CrtImplementationDetails>@@2_NA = false;
		}
		?InitializedNative@DefaultDomain@<CrtImplementationDetails>@@2_NA = false;
		return 0;
	}

	[SecurityCritical]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.UninitializeDefaultDomain()
	{
		if (<CrtImplementationDetails>.DefaultDomain.NeedsUninitialization())
		{
			if (AppDomain.CurrentDomain.IsDefaultAppDomain())
			{
				<CrtImplementationDetails>.LanguageSupport._UninitializeDefaultDomain(null);
			}
			else
			{
				<CrtImplementationDetails>.DoCallBackInDefaultDomain((delegate* unmanaged[Stdcall, Stdcall]<void*, int>)__unep@?_UninitializeDefaultDomain@LanguageSupport@<CrtImplementationDetails>@@$$FCGJPAX@Z, null);
			}
		}
	}

	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	[SecurityCritical]
	[PrePrepareMethod]
	internal static void <CrtImplementationDetails>.LanguageSupport.DomainUnload(object source, EventArgs arguments)
	{
		if (?Initialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA != 0 && Interlocked.Exchange(ref ?Uninitialized@CurrentDomain@<CrtImplementationDetails>@@$$Q2HA, 1) == 0)
		{
			bool num = Interlocked.Decrement(ref ?Count@AllDomains@<CrtImplementationDetails>@@2HA) == 0;
			<CrtImplementationDetails>.LanguageSupport.UninitializeAppDomain();
			if (num)
			{
				<CrtImplementationDetails>.LanguageSupport.UninitializeDefaultDomain();
			}
		}
	}

	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.Cleanup(LanguageSupport* P_0, Exception innerException)
	{
		try
		{
			bool flag = Interlocked.Decrement(ref ?Count@AllDomains@<CrtImplementationDetails>@@2HA) == 0;
			<CrtImplementationDetails>.LanguageSupport.UninitializeAppDomain();
			if (flag)
			{
				<CrtImplementationDetails>.LanguageSupport.UninitializeDefaultDomain();
			}
		}
		catch (Exception nestedException)
		{
			<CrtImplementationDetails>.ThrowNestedModuleLoadException(innerException, nestedException);
		}
		catch
		{
			<CrtImplementationDetails>.ThrowNestedModuleLoadException(innerException, null);
		}
	}

	[SecurityCritical]
	internal unsafe static LanguageSupport* <CrtImplementationDetails>.LanguageSupport.{ctor}(LanguageSupport* P_0)
	{
		gcroot<System::String ^>.{ctor}((gcroot<System::String ^>*)P_0);
		return P_0;
	}

	[SecurityCritical]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.{dtor}(LanguageSupport* P_0)
	{
		gcroot<System::String ^>.{dtor}((gcroot<System::String ^>*)P_0);
	}

	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	[DebuggerStepThrough]
	[SecurityCritical]
	internal unsafe static void <CrtImplementationDetails>.LanguageSupport.Initialize(LanguageSupport* P_0)
	{
		bool flag = false;
		RuntimeHelpers.PrepareConstrainedRegions();
		try
		{
			gcroot<System::String ^>.=((gcroot<System::String ^>*)P_0, "The C++ module failed to load.\n");
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
			}
			finally
			{
				Interlocked.Increment(ref ?Count@AllDomains@<CrtImplementationDetails>@@2HA);
				flag = true;
			}
			<CrtImplementationDetails>.LanguageSupport._Initialize(P_0);
		}
		catch (Exception innerException)
		{
			if (flag)
			{
				<CrtImplementationDetails>.LanguageSupport.Cleanup(P_0, innerException);
			}
			<CrtImplementationDetails>.ThrowModuleLoadException(gcroot<System::String ^>..P$AAVString@System@@((gcroot<System::String ^>*)P_0), innerException);
		}
		catch
		{
			if (flag)
			{
				<CrtImplementationDetails>.LanguageSupport.Cleanup(P_0, null);
			}
			<CrtImplementationDetails>.ThrowModuleLoadException(gcroot<System::String ^>..P$AAVString@System@@((gcroot<System::String ^>*)P_0), null);
		}
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	static unsafe <Module>()
	{
		Unsafe.SkipInit(out LanguageSupport languageSupport);
		<CrtImplementationDetails>.LanguageSupport.{ctor}(&languageSupport);
		try
		{
			<CrtImplementationDetails>.LanguageSupport.Initialize(&languageSupport);
		}
		catch
		{
			//try-fault
			___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<LanguageSupport*, void>)(&<CrtImplementationDetails>.LanguageSupport.{dtor}), &languageSupport);
			throw;
		}
		<CrtImplementationDetails>.LanguageSupport.{dtor}(&languageSupport);
	}

	[SecuritySafeCritical]
	[DebuggerStepThrough]
	internal unsafe static gcroot<System::String ^>* gcroot<System::String ^>.{ctor}(gcroot<System::String ^>* P_0)
	{
		*(int*)P_0 = (int)((IntPtr)GCHandle.Alloc(null)).ToPointer();
		return P_0;
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	internal unsafe static void gcroot<System::String ^>.{dtor}(gcroot<System::String ^>* P_0)
	{
		IntPtr intPtr = new IntPtr((void*)(int)(*(uint*)P_0));
		((GCHandle)intPtr).Free();
		*(int*)P_0 = 0;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static gcroot<System::String ^>* gcroot<System::String ^>.=(gcroot<System::String ^>* P_0, string t)
	{
		IntPtr intPtr = new IntPtr((void*)(int)(*(uint*)P_0));
		GCHandle gCHandle = (GCHandle)intPtr;
		gCHandle.Target = t;
		return P_0;
	}

	[SecuritySafeCritical]
	internal unsafe static string gcroot<System::String ^>..P$AAVString@System@@(gcroot<System::String ^>* P_0)
	{
		IntPtr intPtr = new IntPtr((void*)(int)(*(uint*)P_0));
		return (string)((GCHandle)intPtr).Target;
	}

	[HandleProcessCorruptedStateExceptions]
	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	[SecurityCritical]
	[SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
	internal unsafe static void ___CxxCallUnwindDtor(delegate*<void*, void> pDtor, void* pThis)
	{
		try
		{
			pDtor(pThis);
		}
		catch when (__FrameUnwindFilter((_EXCEPTION_POINTERS*)Marshal.GetExceptionPointers()) != 0)
		{
		}
	}

	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	[SecurityCritical]
	[HandleProcessCorruptedStateExceptions]
	internal unsafe static void __ehvec_dtor(void* ptr, uint size, int count, delegate*<void*, void> pDtor)
	{
		int num = 0;
		ptr = (int)size * count + (byte*)ptr;
		try
		{
			while (true)
			{
				count--;
				if (count < 0)
				{
					break;
				}
				ptr = (byte*)ptr - (int)size;
				pDtor(ptr);
			}
			num = 1;
		}
		finally
		{
			if (num == 0)
			{
				__ArrayUnwind(ptr, size, count, pDtor);
			}
		}
	}

	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	[SecurityCritical]
	[SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
	internal unsafe static int ?A0x2a616a52.ArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
	{
		if (*(int*)(int)(*(uint*)pExPtrs) != -529697949)
		{
			return 0;
		}
		terminate();
		return 0;
	}

	[HandleProcessCorruptedStateExceptions]
	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	[SecurityCritical]
	internal unsafe static void __ArrayUnwind(void* ptr, uint size, int count, delegate*<void*, void> pDtor)
	{
		try
		{
			while (true)
			{
				count--;
				if (count >= 0)
				{
					ptr = (byte*)ptr - (int)size;
					pDtor(ptr);
					continue;
				}
				break;
			}
		}
		catch when (?A0x2a616a52.ArrayUnwindFilter((_EXCEPTION_POINTERS*)Marshal.GetExceptionPointers()) != 0)
		{
		}
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	internal unsafe static ValueType <CrtImplementationDetails>.AtExitLock._handle()
	{
		if (?_lock@AtExitLock@<CrtImplementationDetails>@@$$Q0PAXA != null)
		{
			IntPtr value = new IntPtr(?_lock@AtExitLock@<CrtImplementationDetails>@@$$Q0PAXA);
			return GCHandle.FromIntPtr(value);
		}
		return null;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static void <CrtImplementationDetails>.AtExitLock._lock_Construct(object value)
	{
		?_lock@AtExitLock@<CrtImplementationDetails>@@$$Q0PAXA = null;
		<CrtImplementationDetails>.AtExitLock._lock_Set(value);
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static void <CrtImplementationDetails>.AtExitLock._lock_Set(object value)
	{
		ValueType valueType = <CrtImplementationDetails>.AtExitLock._handle();
		if (valueType == null)
		{
			valueType = GCHandle.Alloc(value);
			?_lock@AtExitLock@<CrtImplementationDetails>@@$$Q0PAXA = GCHandle.ToIntPtr((GCHandle)valueType).ToPointer();
		}
		else
		{
			((GCHandle)valueType).Target = value;
		}
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	internal static object <CrtImplementationDetails>.AtExitLock._lock_Get()
	{
		ValueType valueType = <CrtImplementationDetails>.AtExitLock._handle();
		if (valueType != null)
		{
			return ((GCHandle)valueType).Target;
		}
		return null;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static void <CrtImplementationDetails>.AtExitLock._lock_Destruct()
	{
		ValueType valueType = <CrtImplementationDetails>.AtExitLock._handle();
		if (valueType != null)
		{
			((GCHandle)valueType).Free();
			?_lock@AtExitLock@<CrtImplementationDetails>@@$$Q0PAXA = null;
		}
	}

	[DebuggerStepThrough]
	[SecuritySafeCritical]
	[return: MarshalAs(UnmanagedType.U1)]
	internal static bool <CrtImplementationDetails>.AtExitLock.IsInitialized()
	{
		return <CrtImplementationDetails>.AtExitLock._lock_Get() != null;
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	internal static void <CrtImplementationDetails>.AtExitLock.AddRef()
	{
		if (!<CrtImplementationDetails>.AtExitLock.IsInitialized())
		{
			<CrtImplementationDetails>.AtExitLock._lock_Construct(new object());
			?_ref_count@AtExitLock@<CrtImplementationDetails>@@$$Q0HA = 0;
		}
		?_ref_count@AtExitLock@<CrtImplementationDetails>@@$$Q0HA++;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal static void <CrtImplementationDetails>.AtExitLock.RemoveRef()
	{
		?_ref_count@AtExitLock@<CrtImplementationDetails>@@$$Q0HA--;
		if (?_ref_count@AtExitLock@<CrtImplementationDetails>@@$$Q0HA == 0)
		{
			<CrtImplementationDetails>.AtExitLock._lock_Destruct();
		}
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal static void <CrtImplementationDetails>.AtExitLock.Enter()
	{
		Monitor.Enter(<CrtImplementationDetails>.AtExitLock._lock_Get());
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	internal static void <CrtImplementationDetails>.AtExitLock.Exit()
	{
		Monitor.Exit(<CrtImplementationDetails>.AtExitLock._lock_Get());
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	[return: MarshalAs(UnmanagedType.U1)]
	internal static bool ?A0x0107eea2.__global_lock()
	{
		bool result = false;
		if (<CrtImplementationDetails>.AtExitLock.IsInitialized())
		{
			<CrtImplementationDetails>.AtExitLock.Enter();
			result = true;
		}
		return result;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	[return: MarshalAs(UnmanagedType.U1)]
	internal static bool ?A0x0107eea2.__global_unlock()
	{
		bool result = false;
		if (<CrtImplementationDetails>.AtExitLock.IsInitialized())
		{
			<CrtImplementationDetails>.AtExitLock.Exit();
			result = true;
		}
		return result;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	[return: MarshalAs(UnmanagedType.U1)]
	internal static bool ?A0x0107eea2.__alloc_global_lock()
	{
		<CrtImplementationDetails>.AtExitLock.AddRef();
		return <CrtImplementationDetails>.AtExitLock.IsInitialized();
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal static void ?A0x0107eea2.__dealloc_global_lock()
	{
		<CrtImplementationDetails>.AtExitLock.RemoveRef();
	}

	[SecurityCritical]
	internal unsafe static int _atexit_helper(delegate*<void> func, uint* __pexit_list_size, delegate*<void>** __ponexitend_e, delegate*<void>** __ponexitbegin_e)
	{
		delegate*<void> delegate* = null;
		if (func == (delegate*<void>)null)
		{
			return -1;
		}
		if (?A0x0107eea2.__global_lock())
		{
			try
			{
				delegate*<void>* ptr = (delegate*<void>*)DecodePointer((void*)(int)(*(uint*)__ponexitbegin_e));
				delegate*<void>* ptr2 = (delegate*<void>*)DecodePointer((void*)(int)(*(uint*)__ponexitend_e));
				int num = (int)((byte*)ptr2 - (nuint)ptr);
				if (*__pexit_list_size - 1 < (uint)(num >>> 2))
				{
					try
					{
						uint num2 = *__pexit_list_size * 4;
						uint num3 = ((num2 >= 2048) ? 2048u : num2);
						IntPtr cb = new IntPtr((int)(num2 + num3));
						IntPtr pv = new IntPtr(ptr);
						IntPtr intPtr = Marshal.ReAllocHGlobal(pv, cb);
						IntPtr intPtr2 = intPtr;
						IntPtr intPtr3 = intPtr;
						ptr2 = (delegate*<void>*)((byte*)intPtr3.ToPointer() + num);
						ptr = (delegate*<void>*)intPtr3.ToPointer();
						uint num4 = *__pexit_list_size;
						uint num5 = ((512 >= num4) ? num4 : 512u);
						*__pexit_list_size = num4 + num5;
					}
					catch (OutOfMemoryException)
					{
						IntPtr cb2 = new IntPtr((int)(*__pexit_list_size * 4 + 8));
						IntPtr pv2 = new IntPtr(ptr);
						IntPtr intPtr4 = Marshal.ReAllocHGlobal(pv2, cb2);
						IntPtr intPtr5 = intPtr4;
						IntPtr intPtr6 = intPtr4;
						ptr2 = (delegate*<void>*)((byte*)intPtr6.ToPointer() - (nuint)ptr + (nuint)ptr2);
						ptr = (delegate*<void>*)intPtr6.ToPointer();
						*__pexit_list_size += 4u;
					}
				}
				*(int*)ptr2 = (int)func;
				ptr2 = (delegate*<void>*)((byte*)ptr2 + 4);
				delegate* = func;
				*(int*)__ponexitbegin_e = (int)EncodePointer(ptr);
				*(int*)__ponexitend_e = (int)EncodePointer(ptr2);
			}
			catch (OutOfMemoryException)
			{
			}
			finally
			{
				?A0x0107eea2.__global_unlock();
			}
			if (delegate* != (delegate*<void>)null)
			{
				return 0;
			}
		}
		return -1;
	}

	[SecurityCritical]
	internal unsafe static void _exit_callback()
	{
		if (?A0x0107eea2.__exit_list_size == 0)
		{
			return;
		}
		delegate*<void>* ptr = (delegate*<void>*)DecodePointer(?A0x0107eea2.__onexitbegin_m);
		delegate*<void>* ptr2 = (delegate*<void>*)DecodePointer(?A0x0107eea2.__onexitend_m);
		if (ptr != (delegate*<void>*)(-1) && ptr != null && ptr2 != null)
		{
			delegate*<void>* ptr3 = ptr;
			delegate*<void>* ptr4 = ptr2;
			while (true)
			{
				ptr2 = (delegate*<void>*)((byte*)ptr2 - 4);
				if (ptr2 < ptr)
				{
					break;
				}
				if ((void*)(*(int*)ptr2) != EncodePointer(null))
				{
					void* intPtr = DecodePointer((void*)(int)(*(uint*)ptr2));
					*(int*)ptr2 = (int)EncodePointer(null);
					((delegate*<void>)intPtr)();
					delegate*<void>* ptr5 = (delegate*<void>*)DecodePointer(?A0x0107eea2.__onexitbegin_m);
					delegate*<void>* ptr6 = (delegate*<void>*)DecodePointer(?A0x0107eea2.__onexitend_m);
					if (ptr3 != ptr5 || ptr4 != ptr6)
					{
						ptr3 = ptr5;
						ptr = ptr5;
						ptr4 = ptr6;
						ptr2 = ptr6;
					}
				}
			}
			IntPtr hglobal = new IntPtr(ptr);
			Marshal.FreeHGlobal(hglobal);
		}
		?A0x0107eea2.__dealloc_global_lock();
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static int _initatexit_m()
	{
		int result = 0;
		if (?A0x0107eea2.__alloc_global_lock())
		{
			?A0x0107eea2.__onexitbegin_m = (delegate*<void>*)EncodePointer(Marshal.AllocHGlobal(128).ToPointer());
			?A0x0107eea2.__onexitend_m = ?A0x0107eea2.__onexitbegin_m;
			?A0x0107eea2.__exit_list_size = 32u;
			result = 1;
		}
		return result;
	}

	[SecurityCritical]
	internal unsafe static int _atexit_m(delegate*<void> func)
	{
		return _atexit_helper((delegate*<void>)EncodePointer(func), (uint*)Unsafe.AsPointer(ref ?A0x0107eea2.__exit_list_size), (delegate*<void>**)Unsafe.AsPointer(ref ?A0x0107eea2.__onexitend_m), (delegate*<void>**)Unsafe.AsPointer(ref ?A0x0107eea2.__onexitbegin_m));
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static int _initatexit_app_domain()
	{
		if (?A0x0107eea2.__alloc_global_lock())
		{
			__onexitbegin_app_domain = (delegate*<void>*)EncodePointer(Marshal.AllocHGlobal(128).ToPointer());
			__onexitend_app_domain = __onexitbegin_app_domain;
			__exit_list_size_app_domain = 32u;
		}
		return 1;
	}

	[SecurityCritical]
	[HandleProcessCorruptedStateExceptions]
	internal unsafe static void _app_exit_callback()
	{
		if (__exit_list_size_app_domain == 0)
		{
			return;
		}
		delegate*<void>* ptr = (delegate*<void>*)DecodePointer(__onexitbegin_app_domain);
		delegate*<void>* ptr2 = (delegate*<void>*)DecodePointer(__onexitend_app_domain);
		try
		{
			if (ptr == (delegate*<void>*)(-1) || ptr == null || ptr2 == null)
			{
				return;
			}
			delegate*<void> delegate* = null;
			delegate*<void>* ptr3 = ptr;
			delegate*<void>* ptr4 = ptr2;
			while (true)
			{
				delegate*<void>* ptr5 = null;
				delegate*<void>* ptr6 = null;
				do
				{
					ptr2 = (delegate*<void>*)((byte*)ptr2 - 4);
				}
				while (ptr2 >= ptr && (void*)(*(int*)ptr2) == EncodePointer(null));
				if (ptr2 >= ptr)
				{
					delegate* = (delegate*<void>)DecodePointer((void*)(int)(*(uint*)ptr2));
					*(int*)ptr2 = (int)EncodePointer(null);
					delegate*();
					delegate*<void>* ptr7 = (delegate*<void>*)DecodePointer(__onexitbegin_app_domain);
					delegate*<void>* ptr8 = (delegate*<void>*)DecodePointer(__onexitend_app_domain);
					if (ptr3 != ptr7 || ptr4 != ptr8)
					{
						ptr3 = ptr7;
						ptr = ptr7;
						ptr4 = ptr8;
						ptr2 = ptr8;
					}
					continue;
				}
				break;
			}
		}
		finally
		{
			IntPtr hglobal = new IntPtr(ptr);
			Marshal.FreeHGlobal(hglobal);
			?A0x0107eea2.__dealloc_global_lock();
		}
	}

	[DllImport("KERNEL32.dll")]
	[SuppressUnmanagedCodeSecurity]
	[SecurityCritical]
	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	public unsafe static extern void* DecodePointer(void* Ptr);

	[DllImport("KERNEL32.dll")]
	[SecurityCritical]
	[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
	[SuppressUnmanagedCodeSecurity]
	public unsafe static extern void* EncodePointer(void* Ptr);

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static int _initterm_e(delegate* unmanaged[Cdecl, Cdecl]<int>* pfbegin, delegate* unmanaged[Cdecl, Cdecl]<int>* pfend)
	{
		int num = 0;
		if (pfbegin < pfend)
		{
			while (num == 0)
			{
				uint num2 = *(uint*)pfbegin;
				if (num2 != 0)
				{
					num = ((delegate* unmanaged[Cdecl, Cdecl]<int>)(int)num2)();
				}
				pfbegin = (delegate* unmanaged[Cdecl, Cdecl]<int>*)((byte*)pfbegin + 4);
				if (pfbegin >= pfend)
				{
					break;
				}
			}
		}
		return num;
	}

	[DebuggerStepThrough]
	[SecurityCritical]
	internal unsafe static void _initterm(delegate* unmanaged[Cdecl, Cdecl]<void>* pfbegin, delegate* unmanaged[Cdecl, Cdecl]<void>* pfend)
	{
		if (pfbegin >= pfend)
		{
			return;
		}
		do
		{
			uint num = *(uint*)pfbegin;
			if (num != 0)
			{
				((delegate* unmanaged[Cdecl, Cdecl]<void>)(int)num)();
			}
			pfbegin = (delegate* unmanaged[Cdecl, Cdecl]<void>*)((byte*)pfbegin + 4);
		}
		while (pfbegin < pfend);
	}

	[DebuggerStepThrough]
	internal static ModuleHandle <CrtImplementationDetails>.ThisModule.Handle()
	{
		return typeof(ThisModule).Module.ModuleHandle;
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	[SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
	internal unsafe static void _initterm_m(delegate*<void*>* pfbegin, delegate*<void*>* pfend)
	{
		if (pfbegin >= pfend)
		{
			return;
		}
		do
		{
			uint num = *(uint*)pfbegin;
			if (num != 0)
			{
				<CrtImplementationDetails>.ThisModule.ResolveMethod<void const * __clrcall(void)>((delegate*<void*>)(int)num)();
			}
			pfbegin = (delegate*<void*>*)((byte*)pfbegin + 4);
		}
		while (pfbegin < pfend);
	}

	[SecurityCritical]
	[DebuggerStepThrough]
	internal unsafe static delegate*<void*> <CrtImplementationDetails>.ThisModule.ResolveMethod<void const * __clrcall(void)>(delegate*<void*> methodToken)
	{
		return (delegate*<void*>)<CrtImplementationDetails>.ThisModule.Handle().ResolveMethodHandle((int)methodToken).GetFunctionPointer().ToPointer();
	}

	[DllImport("", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern locale.id* std.locale.id.{ctor}(locale.id* P_0, uint P_1);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void* @new(uint P_0);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern int __CxxQueryExceptionSize();

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern int __CxxDetectRethrow(void* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllActivateByResponseShortCode(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateActivationRequestShortCode(sbyte* P_0, sbyte** P_1);

	[DllImport("", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void _CxxThrowException(void* P_0, _s__ThrowInfo* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateActivationRequestString(sbyte* P_0, TLLReasonCode P_1, sbyte* P_2, sbyte** P_3);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void __CxxUnregisterExceptionObject(void* P_0, int P_1);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void delete(void* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllActivateByASR(sbyte* P_0);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern int __CxxExceptionFilter(void* P_0, void* P_1, int P_2, void* P_3);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void delete[](void* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllActivateByResponseFile(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllActivateByResponseString(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateActivationRequestFile(sbyte** P_0, sbyte* P_1, sbyte* P_2);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllActivateByServer(sbyte* P_0, sbyte* P_1);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern int __CxxRegisterExceptionObject(void* P_0, void* P_1);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void free(void* P_0);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void* memmove(void* P_0, void* P_1, uint P_2);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void std._Xlength_error(sbyte* P_0);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void std._Xout_of_range(sbyte* P_0);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern void std._Xbad_alloc();

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern sbyte* std._Syserror_map(int P_0);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern sbyte* std._Winerror_map(int P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern FlxActError* tllGetLastError();

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern sbyte* tllGetLastErrorString();

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllEnableFulfillmentId(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateRepairRequestString(sbyte* P_0, sbyte** P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllRepairByServer(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllRepairByResponseShortCode(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateRepairRequestFile(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllRepairByResponseString(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllRepairByResponseFile(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateRepairRequestShortCode(sbyte* P_0, sbyte* P_1, sbyte** P_2);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllReturnByServer(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllReturnByResponseString(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllReturnByResponseFile(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateReturnRequestString(sbyte* P_0, TLLReasonCode P_1, sbyte** P_2);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllDeleteFulfillmentId(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateReturnRequestShortCode(sbyte* P_0, sbyte* P_1, sbyte** P_2);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllReturnByResponseShortCode(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllCreateReturnRequestFile(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern TLLActivationInfo* tllGetActivationInfo(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern TLLAuthData* tllGetAuthDataByFeatureNotice(sbyte* P_0, sbyte* P_1, sbyte* P_2);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void tllCleanUpTLLAuthData(TLLAuthData* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern TLLActivationInfo* tllGetDataByActivationId2(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern TLLAuthData* tllCheckForValidFeature(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern sbyte** tllGetFulfillmentIds2(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern TLLActivationInfo* tllGetDataByFulfillmentId2(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllIsProductValid(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void tllCleanUpActivationInfo(TLLActivationInfo* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern sbyte* tllGetSerialNumber(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern sbyte* tllGetVendorString(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern int tllDaysUntilFeatureExpired(sbyte* P_0, sbyte* P_1);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern sbyte* tllGetUniqueMachineNumber(flxUMNType P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern int tllInitialize();

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern uint tllInitializeSegment(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern uint tllUnload();

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void tllSetExpirationDate(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern int tllInitializePath(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void tllSetOpsServer(sbyte* P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern void* _getFiberPtrId();

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern void _amsg_exit(int P_0);

	[MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern void __security_init_cookie();

	[DllImport("", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern void Sleep(uint P_0);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern void _cexit();

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal unsafe static extern int __FrameUnwindFilter(_EXCEPTION_POINTERS* P_0);

	[DllImport("", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
	[MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
	[SuppressUnmanagedCodeSecurity]
	internal static extern void terminate();
}
public class ActivationInfo
{
	public string EntitlementId;

	public string FulfillmentId;

	public uint TrustFlag;

	public ValueType ExpirationDate;

	public string SuiteId;

	public string FeatureLine;

	public bool IsDisabled;

	internal unsafe ActivationInfo(TLLActivationInfo* pdata)
	{
		if (null != pdata)
		{
			EntitlementId = new string((sbyte*)(int)(*(uint*)pdata));
			FulfillmentId = new string((sbyte*)(int)((uint*)pdata)[1]);
			TrustFlag = ((uint*)pdata)[2];
			ValueType valueType = default(DateTime);
			(DateTime)valueType = new DateTime(((int*)pdata)[8] + 1900, ((int*)pdata)[7] + 1, ((int*)pdata)[6]);
			ExpirationDate = valueType;
			SuiteId = new string((sbyte*)(int)((uint*)pdata)[12]);
			FeatureLine = new string((sbyte*)(int)((uint*)pdata)[13]);
			IsDisabled = ((((int*)pdata)[14] != 0) ? true : false);
		}
	}
}
public class AuthData
{
	public ValueType StartDate;

	public ValueType IssueDate;

	public ValueType ExpirationDate;

	public string VendorString;

	public string SerialNumber;

	public string Issuer;

	public string Notice;

	internal unsafe AuthData(TLLAuthData* fdata)
	{
		if (null != fdata)
		{
			ValueType valueType = default(DateTime);
			(DateTime)valueType = new DateTime(((int*)fdata)[5] + 1900, ((int*)fdata)[4] + 1, ((int*)fdata)[3]);
			StartDate = valueType;
			ValueType valueType2 = default(DateTime);
			(DateTime)valueType2 = new DateTime(((int*)fdata)[14] + 1900, ((int*)fdata)[13] + 1, ((int*)fdata)[12]);
			IssueDate = valueType2;
			ValueType valueType3 = default(DateTime);
			(DateTime)valueType3 = new DateTime(((int*)fdata)[23] + 1900, ((int*)fdata)[22] + 1, ((int*)fdata)[21]);
			ExpirationDate = valueType3;
			VendorString = new string((sbyte*)(int)((uint*)fdata)[27]);
			SerialNumber = new string((sbyte*)(int)((uint*)fdata)[28]);
			Issuer = new string((sbyte*)(int)((uint*)fdata)[29]);
			VendorString = new string((sbyte*)(int)((uint*)fdata)[27]);
			Notice = new string((sbyte*)(int)((uint*)fdata)[30]);
		}
	}
}
public class Error
{
	public uint MajorErrorNo;

	public uint MinorErrorNo;

	public uint SysErrorNo;

	internal Error(uint major, uint minor, uint system)
	{
		MajorErrorNo = major;
		MinorErrorNo = minor;
		SysErrorNo = system;
	}
}
namespace Cummins.ToolLicensing.Tll
{
	public class ToolLicensingLibrary
	{
		public enum ReasonCode
		{
			New,
			Rehost,
			Upgrade,
			Upsell,
			Renew,
			Reinstall
		}

		public enum TrustFlag
		{
			BrokenTime = 3,
			FullTrusted = 7,
			BrokenUnknown = 255
		}

		public enum ErrorCode
		{
			UnknownFailure,
			FulfillmentNotFound,
			FileOpenError,
			FileReadError,
			FileWriteError,
			ResourceAllocationError,
			SegmentNotInitialized,
			InvalidFile
		}

		private static int _instances = 0;

		public ToolLicensingLibrary()
		{
			int instances = _instances;
			_instances++;
			if (0 == instances)
			{
				global::<Module>.tllInitialize();
			}
		}

		private void !ToolLicensingLibrary()
		{
			_instances--;
			if (_instances <= 0)
			{
				global::<Module>.tllUnload();
				_instances = 0;
			}
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ActivateByServer(string activationId, string expirationDate)
		{
			//IL_007c->IL007c: Incompatible stack types: I4 vs Ref
			//IL_0047->IL0047: Incompatible stack types: I4 vs Ref
			//IL_0059->IL0059: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(activationId, &obj))
					{
						if (!string.IsNullOrEmpty(expirationDate))
						{
							if (util.convertToUnmanagedString(expirationDate, &obj2))
							{
								sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
								result = util.flxToBoolean(global::<Module>.tllActivateByServer((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr));
							}
							else
							{
								result = false;
							}
						}
						else
						{
							result = util.flxToBoolean(global::<Module>.tllActivateByServer((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), null));
						}
					}
					else
					{
						result = false;
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateActivationRequestFile(string expirationDate, string requestFileName, out string activationId)
		{
			//IL_008f->IL008f: Incompatible stack types: I4 vs Ref
			//IL_004c->IL004c: Incompatible stack types: I4 vs Ref
			//IL_005f->IL005f: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					sbyte* ptr = null;
					if (util.convertToUnmanagedString(requestFileName, &obj2))
					{
						if (!string.IsNullOrEmpty(expirationDate))
						{
							if (util.convertToUnmanagedString(expirationDate, &obj))
							{
								sbyte* ptr2 = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)));
								sbyte* ptr3 = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
								result = util.flxToBoolean(global::<Module>.tllCreateActivationRequestFile(&ptr, ptr3, ptr2));
								activationId = new string(ptr);
							}
							else
							{
								result = false;
							}
						}
						else
						{
							sbyte* ptr4 = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
							result = util.flxToBoolean(global::<Module>.tllCreateActivationRequestFile(&ptr, null, ptr4));
							activationId = new string(ptr);
						}
					}
					else
					{
						result = false;
					}
					global::<Module>.free(ptr);
					ptr = null;
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateActivationRequestString(string expirationDate, ReasonCode reasonCode, string activationId, out string activationRequestString)
		{
			//IL_009a->IL009a: Incompatible stack types: I4 vs Ref
			//IL_0059->IL0059: Incompatible stack types: I4 vs Ref
			//IL_00ac->IL00ac: Incompatible stack types: I4 vs Ref
			//IL_006b->IL006b: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj3);
					global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj3, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
					try
					{
						sbyte* ptr = null;
						if (util.convertToUnmanagedString(activationId, &obj3))
						{
							if (!string.IsNullOrEmpty(expirationDate))
							{
								if (util.convertToUnmanagedString(expirationDate, &obj))
								{
									sbyte* ptr2 = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj3, 20)) ? ref *(?*)(&obj3) : ref *(?*)(*(int*)(&obj3)));
									result = util.flxToBoolean(global::<Module>.tllCreateActivationRequestString((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), (TLLReasonCode)reasonCode, ptr2, &ptr));
									activationRequestString = new string(ptr);
								}
								else
								{
									result = false;
								}
							}
							else
							{
								sbyte* ptr3 = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj3, 20)) ? ref *(?*)(&obj3) : ref *(?*)(*(int*)(&obj3)));
								result = util.flxToBoolean(global::<Module>.tllCreateActivationRequestString((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), (TLLReasonCode)reasonCode, ptr3, &ptr));
								activationRequestString = new string(ptr);
							}
						}
						else
						{
							result = false;
						}
						global::<Module>.free(ptr);
						ptr = null;
					}
					catch
					{
						//try-fault
						global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj3);
						throw;
					}
					global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj3, true, 0u);
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ActivateByResponseFile(string responseFileName)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseFileName, &obj) && util.flxToBoolean(global::<Module>.tllActivateByResponseFile((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ActivateByResponseString(string responseString)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseString, &obj) && util.flxToBoolean(global::<Module>.tllActivateByResponseString((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateActivationRequestShortCode(string asrFileName, out string requestShortCode)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out sbyte* ptr);
				if (util.convertToUnmanagedString(asrFileName, &obj))
				{
					result = util.flxToBoolean(global::<Module>.tllCreateActivationRequestShortCode((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), &ptr));
					requestShortCode = new string(ptr);
				}
				else
				{
					result = false;
				}
				global::<Module>.free(ptr);
				ptr = null;
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ActivateByResponseShortCode(string responseShortCode)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseShortCode, &obj) && util.flxToBoolean(global::<Module>.tllActivateByResponseShortCode((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ActivateByASR(string asrFileName)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(asrFileName, &obj) && util.flxToBoolean(global::<Module>.tllActivateByASR((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool RepairByServer(string fulfillmentId)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(fulfillmentId, &obj) && util.flxToBoolean(global::<Module>.tllRepairByServer((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateRepairRequestFile(string fulfillmentId, string requestFileName)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(fulfillmentId, &obj) && util.convertToUnmanagedString(requestFileName, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						result = util.flxToBoolean(global::<Module>.tllCreateRepairRequestFile((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr));
					}
					else
					{
						result = false;
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateRepairRequestString(string fulfillmentId, out string repairRequestString)
		{
			//IL_002a->IL002a: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				sbyte* ptr = null;
				if (util.convertToUnmanagedString(fulfillmentId, &obj))
				{
					result = util.flxToBoolean(global::<Module>.tllCreateRepairRequestString((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), &ptr));
					repairRequestString = new string(ptr);
				}
				else
				{
					result = false;
				}
				global::<Module>.free(ptr);
				ptr = null;
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool RepairByResponseFile(string responseFileName)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseFileName, &obj) && util.flxToBoolean(global::<Module>.tllRepairByResponseFile((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool RepairByResponseString(string responseString)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseString, &obj) && util.flxToBoolean(global::<Module>.tllRepairByResponseString((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateRepairRequestShortCode(string asrFileName, string fulfillmentId, out string requestShortCode)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					Unsafe.SkipInit(out sbyte* ptr2);
					if (util.convertToUnmanagedString(asrFileName, &obj) && util.convertToUnmanagedString(fulfillmentId, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						result = util.flxToBoolean(global::<Module>.tllCreateRepairRequestShortCode((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr, &ptr2));
						requestShortCode = new string(ptr2);
					}
					else
					{
						result = false;
					}
					global::<Module>.free(ptr2);
					ptr2 = null;
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool RepairByResponseShortCode(string responseShortCode)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseShortCode, &obj) && util.flxToBoolean(global::<Module>.tllRepairByResponseShortCode((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool EnableFulfillmentId(string fulfillmentId)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(fulfillmentId, &obj) && util.flxToBoolean(global::<Module>.tllEnableFulfillmentId((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ReturnByServer(string fulfillmentId)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(fulfillmentId, &obj) && util.flxToBoolean(global::<Module>.tllReturnByServer((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateReturnRequestFile(string fulfillmentId, string requestFileName)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(fulfillmentId, &obj) && util.convertToUnmanagedString(requestFileName, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						result = util.flxToBoolean(global::<Module>.tllCreateReturnRequestFile((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr));
					}
					else
					{
						result = false;
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateReturnRequestString(string fulfillmentId, ReasonCode reasonCode, out string returnRequestString)
		{
			//IL_002a->IL002a: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				sbyte* ptr = null;
				if (util.convertToUnmanagedString(fulfillmentId, &obj))
				{
					result = util.flxToBoolean(global::<Module>.tllCreateReturnRequestString((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), (TLLReasonCode)reasonCode, &ptr));
					returnRequestString = new string(ptr);
				}
				else
				{
					result = false;
				}
				global::<Module>.free(ptr);
				ptr = null;
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ReturnByResponseFile(string responseFileName)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseFileName, &obj) && util.flxToBoolean(global::<Module>.tllReturnByResponseFile((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ReturnByResponseString(string responseString)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseString, &obj) && util.flxToBoolean(global::<Module>.tllReturnByResponseString((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool CreateReturnRequestShortCode(string asrFileName, string fulfillmentId, out string requestShortCode)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					Unsafe.SkipInit(out sbyte* ptr2);
					if (util.convertToUnmanagedString(asrFileName, &obj) && util.convertToUnmanagedString(fulfillmentId, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						result = util.flxToBoolean(global::<Module>.tllCreateReturnRequestShortCode((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr, &ptr2));
						requestShortCode = new string(ptr2);
					}
					else
					{
						result = false;
					}
					global::<Module>.free(ptr2);
					ptr2 = null;
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool ReturnByResponseShortCode(string responseShortCode)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(responseShortCode, &obj) && util.flxToBoolean(global::<Module>.tllReturnByResponseShortCode((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool DeleteFulfillmentId(string fulfillmentId)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				result = util.convertToUnmanagedString(fulfillmentId, &obj) && util.flxToBoolean(global::<Module>.tllDeleteFulfillmentId((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe int InitializePath(string runtimePath)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			int result;
			try
			{
				result = ((!util.convertToUnmanagedString(runtimePath, &obj)) ? (-1) : global::<Module>.tllInitializePath((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe void SetOpsServer(string opsServer)
		{
			//IL_002a->IL002a: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			try
			{
				if (util.convertToUnmanagedString(opsServer, &obj))
				{
					global::<Module>.tllSetOpsServer((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))));
				}
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
		}

		public unsafe void SetExpirationDate(string expirationDate)
		{
			//IL_002a->IL002a: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			try
			{
				if (util.convertToUnmanagedString(expirationDate, &obj))
				{
					global::<Module>.tllSetExpirationDate((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))));
				}
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool InitializeSegment(string asrFileName)
		{
			//IL_002a->IL002a: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			Unsafe.SkipInit(out bool result);
			try
			{
				if (util.convertToUnmanagedString(asrFileName, &obj))
				{
					result = util.flxToBoolean(global::<Module>.tllInitializeSegment((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj)))));
				}
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe string GetUniqueMachineNumber(int type)
		{
			return type switch
			{
				2 => new string(global::<Module>.tllGetUniqueMachineNumber((flxUMNType)1)), 
				1 => new string(global::<Module>.tllGetUniqueMachineNumber((flxUMNType)0)), 
				_ => null, 
			};
		}

		public unsafe AuthData CheckForValidFeature(string featureName, string version)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			AuthData result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(featureName, &obj) && util.convertToUnmanagedString(version, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						TLLAuthData* ptr2 = global::<Module>.tllCheckForValidFeature((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr);
						if (null != ptr2)
						{
							result = new AuthData(ptr2);
							global::<Module>.tllCleanUpTLLAuthData(ptr2);
						}
						else
						{
							result = null;
						}
					}
					else
					{
						result = null;
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe AuthData GetAuthDataByFeatureNotice(string featureName, string featureVersion, string featureNotice)
		{
			//IL_0056->IL0056: Incompatible stack types: I4 vs Ref
			//IL_0068->IL0068: Incompatible stack types: I4 vs Ref
			//IL_007a->IL007a: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			AuthData result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj3);
					global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj3, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
					try
					{
						if (util.convertToUnmanagedString(featureName, &obj) && util.convertToUnmanagedString(featureVersion, &obj2) && util.convertToUnmanagedString(featureNotice, &obj3))
						{
							sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj3, 20)) ? ref *(?*)(&obj3) : ref *(?*)(*(int*)(&obj3)));
							sbyte* ptr2 = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
							TLLAuthData* ptr3 = global::<Module>.tllGetAuthDataByFeatureNotice((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr2, ptr);
							if (null != ptr3)
							{
								result = new AuthData(ptr3);
								global::<Module>.tllCleanUpTLLAuthData(ptr3);
							}
							else
							{
								result = null;
							}
						}
						else
						{
							result = null;
						}
					}
					catch
					{
						//try-fault
						global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj3);
						throw;
					}
					global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj3, true, 0u);
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe List<string> GetFulfillmentIds2(string productName, string productVersion)
		{
			//IL_004f->IL004f: Incompatible stack types: I4 vs Ref
			//IL_0061->IL0061: Incompatible stack types: I4 vs Ref
			List<string> list = new List<string>();
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(productName, &obj) && util.convertToUnmanagedString(productVersion, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						sbyte** ptr2 = global::<Module>.tllGetFulfillmentIds2((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr);
						if (ptr2 != null)
						{
							int num = 0;
							if (0 != *(int*)ptr2)
							{
								while (num < 100)
								{
									list.Add(new string((sbyte*)(int)(*(uint*)(num * 4 + (byte*)ptr2))));
									global::<Module>.free((void*)(int)(*(uint*)(num * 4 + (byte*)ptr2)));
									*(int*)(num * 4 + (byte*)ptr2) = 0;
									num++;
									if (0 == *(int*)(num * 4 + (byte*)ptr2))
									{
										break;
									}
								}
							}
							global::<Module>.free(ptr2);
						}
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return list;
		}

		[return: MarshalAs(UnmanagedType.U1)]
		public unsafe bool IsProductValid(string productName, string productVersion)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			bool result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(productName, &obj) && util.convertToUnmanagedString(productVersion, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						result = util.flxToBoolean(global::<Module>.tllIsProductValid((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr));
					}
					else
					{
						result = false;
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe ActivationInfo GetActivationInfo(string productName, string version)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			ActivationInfo result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(productName, &obj) && util.convertToUnmanagedString(version, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						TLLActivationInfo* ptr2 = global::<Module>.tllGetActivationInfo((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr);
						if (null != ptr2)
						{
							result = new ActivationInfo(ptr2);
							global::<Module>.tllCleanUpActivationInfo(ptr2);
						}
						else
						{
							result = null;
						}
					}
					else
					{
						result = null;
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe ActivationInfo GetDataByActivationId2(string activationId)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			ActivationInfo result;
			try
			{
				if (util.convertToUnmanagedString(activationId, &obj))
				{
					TLLActivationInfo* ptr = global::<Module>.tllGetDataByActivationId2((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))));
					if (null != ptr)
					{
						result = new ActivationInfo(ptr);
						global::<Module>.tllCleanUpActivationInfo(ptr);
					}
					else
					{
						result = null;
					}
				}
				else
				{
					result = null;
				}
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe ActivationInfo GetDataByFulfillmentId2(string fulfillmentId)
		{
			//IL_0028->IL0028: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			ActivationInfo result;
			try
			{
				if (util.convertToUnmanagedString(fulfillmentId, &obj))
				{
					TLLActivationInfo* ptr = global::<Module>.tllGetDataByFulfillmentId2((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))));
					if (null != ptr)
					{
						result = new ActivationInfo(ptr);
						global::<Module>.tllCleanUpActivationInfo(ptr);
					}
					else
					{
						result = null;
					}
				}
				else
				{
					result = null;
				}
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe string GetVendorString(string featureName, string featureVersion)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			string result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(featureName, &obj) && util.convertToUnmanagedString(featureVersion, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						result = new string(global::<Module>.tllGetVendorString((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr));
					}
					else
					{
						result = "";
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe string GetSerialNumber(string featureName, string featureVersion)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			string result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(featureName, &obj) && util.convertToUnmanagedString(featureVersion, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						result = new string(global::<Module>.tllGetSerialNumber((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr));
					}
					else
					{
						result = "";
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe int DaysUntilFeatureExpired(string featureName, string featureVersion)
		{
			//IL_003f->IL003f: Incompatible stack types: I4 vs Ref
			//IL_0051->IL0051: Incompatible stack types: I4 vs Ref
			Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj);
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
			int result;
			try
			{
				Unsafe.SkipInit(out basic_string<char,std::char_traits<char>,std::allocator<char> > obj2);
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{ctor}(&obj2, (sbyte*)Unsafe.AsPointer(ref global::<Module>.??_C@_00CNPNBAHC@?$AA@));
				try
				{
					if (util.convertToUnmanagedString(featureName, &obj) && util.convertToUnmanagedString(featureVersion, &obj2))
					{
						sbyte* ptr = (sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj2, 20)) ? ref *(?*)(&obj2) : ref *(?*)(*(int*)(&obj2)));
						result = global::<Module>.tllDaysUntilFeatureExpired((sbyte*)Unsafe.AsPointer(ref 16u > (uint)Unsafe.As<basic_string<char,std::char_traits<char>,std::allocator<char> >, int>(ref Unsafe.AddByteOffset(ref obj, 20)) ? ref *(?*)(&obj) : ref *(?*)(*(int*)(&obj))), ptr);
					}
					else
					{
						result = 0;
					}
				}
				catch
				{
					//try-fault
					global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj2);
					throw;
				}
				global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj2, true, 0u);
			}
			catch
			{
				//try-fault
				global::<Module>.___CxxCallUnwindDtor((delegate*<void*, void>)(delegate*<basic_string<char,std::char_traits<char>,std::allocator<char> >*, void>)(&global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.{dtor}), &obj);
				throw;
			}
			global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >._Tidy(&obj, true, 0u);
			return result;
		}

		public unsafe Error GetLastError()
		{
			FlxActError* ptr = global::<Module>.tllGetLastError();
			return (null == ptr) ? null : new Error(*(uint*)ptr, ((uint*)ptr)[1], ((uint*)ptr)[2]);
		}

		public unsafe string GetLastErrorString()
		{
			return new string(global::<Module>.tllGetLastErrorString());
		}

		[HandleProcessCorruptedStateExceptions]
		protected virtual void Dispose([MarshalAs(UnmanagedType.U1)] bool A_0)
		{
			if (!A_0)
			{
				try
				{
					!ToolLicensingLibrary();
				}
				finally
				{
					base.Finalize();
				}
			}
		}

		~ToolLicensingLibrary()
		{
			Dispose(A_0: false);
		}
	}
}
internal class util
{
	[return: MarshalAs(UnmanagedType.U1)]
	internal static bool flxToBoolean(uint flxBool)
	{
		bool flag = true;
		return 0 != flxBool && flag;
	}

	[return: MarshalAs(UnmanagedType.U1)]
	internal unsafe static bool convertToUnmanagedString(string managedString, basic_string<char,std::char_traits<char>,std::allocator<char> >* unmanagedString)
	{
		if (null == managedString)
		{
			return false;
		}
		sbyte* ptr = (sbyte*)Marshal.StringToHGlobalAnsi(managedString).ToPointer();
		uint count;
		if (*ptr == 0)
		{
			count = 0u;
		}
		else
		{
			sbyte* ptr2 = ptr;
			do
			{
				ptr2++;
			}
			while (*ptr2 != 0);
			count = (uint)(ptr2 - (nuint)ptr);
		}
		global::<Module>.std.basic_string<char,std::char_traits<char>,std::allocator<char> >.assign(unmanagedString, ptr, count);
		IntPtr hglobal = new IntPtr(ptr);
		Marshal.FreeHGlobal(hglobal);
		return true;
	}
}
namespace <CppImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 16)]
	[UnsafeValueType]
	[NativeCppClass]
	internal struct $ArrayType$$$BY0BA@$$CBD
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[UnsafeValueType]
	[NativeCppClass]
	internal struct $ArrayType$$$BY00$$CBD
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 8)]
	[NativeCppClass]
	[UnsafeValueType]
	internal struct $ArrayType$$$BY07$$CBD
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 14)]
	[NativeCppClass]
	[UnsafeValueType]
	internal struct $ArrayType$$$BY0O@$$CBD
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 9)]
	[UnsafeValueType]
	[NativeCppClass]
	internal struct $ArrayType$$$BY08$$CBD
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 22)]
	[NativeCppClass]
	[UnsafeValueType]
	internal struct $ArrayType$$$BY0BG@$$CBD
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 7)]
	[NativeCppClass]
	[UnsafeValueType]
	internal struct $ArrayType$$$BY06$$CBD
	{
	}
}
namespace std
{
	[StructLayout(LayoutKind.Sequential, Size = 8)]
	[NativeCppClass]
	internal struct error_code
	{
	}
}
namespace <CppImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 24)]
	[UnsafeValueType]
	[NativeCppClass]
	internal struct $ArrayType$$$BY0BI@$$CBD
	{
	}
}
[NativeCppClass]
internal enum flxUMNType
{

}
[NativeCppClass]
internal enum TLLReasonCode
{

}
[StructLayout(LayoutKind.Sequential, Size = 60)]
[NativeCppClass]
[UnsafeValueType]
internal struct TLLActivationInfo
{
}
[StructLayout(LayoutKind.Sequential, Size = 124)]
[NativeCppClass]
[UnsafeValueType]
internal struct TLLAuthData
{
}
namespace std
{
	[StructLayout(LayoutKind.Sequential, Size = 24)]
	[UnsafeValueType]
	[NativeCppClass]
	internal struct basic_string<char,std::char_traits<char>,std::allocator<char> >
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 4)]
	[NativeCppClass]
	internal struct locale
	{
		[StructLayout(LayoutKind.Sequential, Size = 4)]
		[NativeCppClass]
		[CLSCompliant(false)]
		public struct id
		{
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 4)]
	[NativeCppClass]
	internal static struct error_category
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 8)]
	[NativeCppClass]
	internal struct error_condition
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 4)]
	[NativeCppClass]
	internal struct _Generic_error_category
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 4)]
	[NativeCppClass]
	internal struct _Iostream_error_category
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 4)]
	[NativeCppClass]
	internal struct _System_error_category
	{
	}
}
[StructLayout(LayoutKind.Sequential, Size = 28)]
[NativeCppClass]
[UnsafeValueType]
internal struct _s__RTTIBaseClassDescriptor2
{
}
[StructLayout(LayoutKind.Sequential, Size = 20)]
[NativeCppClass]
internal struct _s__RTTICompleteObjectLocator
{
}
[StructLayout(LayoutKind.Sequential, Size = 16)]
[NativeCppClass]
internal struct _s__ThrowInfo
{
}
[StructLayout(LayoutKind.Sequential, Size = 16)]
[NativeCppClass]
internal struct _s__RTTIClassHierarchyDescriptor
{
}
[StructLayout(LayoutKind.Sequential, Size = 13)]
[NativeCppClass]
internal struct $_s__RTTIBaseClassArray$_extraBytes_12
{
}
namespace <CppImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 8)]
	[NativeCppClass]
	internal struct $ArrayType$$$BY01Q6AXXZ
	{
	}
}
[StructLayout(LayoutKind.Sequential, Size = 9)]
[NativeCppClass]
internal struct $_s__RTTIBaseClassArray$_extraBytes_8
{
}
namespace <CppImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 28)]
	[NativeCppClass]
	internal struct $ArrayType$$$BY06Q6AXXZ
	{
	}
}
namespace std
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[NativeCppClass]
	internal struct allocator_arg_t
	{
	}
}
[StructLayout(LayoutKind.Sequential, Size = 5)]
[NativeCppClass]
internal struct $_s__RTTIBaseClassArray$_extraBytes_4
{
}
namespace std
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[NativeCppClass]
	internal struct piecewise_construct_t
	{
	}
}
[StructLayout(LayoutKind.Sequential, Size = 33)]
[NativeCppClass]
[UnsafeValueType]
internal struct $_TypeDescriptor$_extraBytes_25
{
}
[StructLayout(LayoutKind.Sequential, Size = 43)]
[UnsafeValueType]
[NativeCppClass]
internal struct $_TypeDescriptor$_extraBytes_35
{
}
[StructLayout(LayoutKind.Sequential, Size = 41)]
[UnsafeValueType]
[NativeCppClass]
internal struct $_TypeDescriptor$_extraBytes_33
{
}
[StructLayout(LayoutKind.Sequential, Size = 42)]
[UnsafeValueType]
[NativeCppClass]
internal struct $_TypeDescriptor$_extraBytes_34
{
}
[StructLayout(LayoutKind.Sequential, Size = 12)]
[UnsafeValueType]
[NativeCppClass]
internal struct FlxActError
{
}
namespace <CrtImplementationDetails>
{
	[Serializable]
	internal class ModuleLoadException : Exception
	{
		public const string Nested = "A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n";

		protected ModuleLoadException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public ModuleLoadException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public ModuleLoadException(string message)
			: base(message)
		{
		}
	}
	[Serializable]
	internal class ModuleLoadExceptionHandlerException : ModuleLoadException
	{
		private const string formatString = "\n{0}: {1}\n--- Start of primary exception ---\n{2}\n--- End of primary exception ---\n\n--- Start of nested exception ---\n{3}\n--- End of nested exception ---\n";

		private Exception <backing_store>NestedException;

		public Exception NestedException
		{
			get
			{
				return <backing_store>NestedException;
			}
			set
			{
				<backing_store>NestedException = value;
			}
		}

		protected ModuleLoadExceptionHandlerException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			NestedException = (Exception)info.GetValue("NestedException", typeof(Exception));
		}

		public ModuleLoadExceptionHandlerException(string message, Exception innerException, Exception nestedException)
			: base(message, innerException)
		{
			NestedException = nestedException;
		}

		public override string ToString()
		{
			string text = ((InnerException == null) ? string.Empty : InnerException.ToString());
			string text2 = ((NestedException == null) ? string.Empty : NestedException.ToString());
			object[] array = new object[4]
			{
				GetType(),
				null,
				null,
				null
			};
			string text3 = ((Message == null) ? string.Empty : Message);
			array[1] = text3;
			string text4 = ((text == null) ? string.Empty : text);
			array[2] = text4;
			string text5 = ((text2 == null) ? string.Empty : text2);
			array[3] = text5;
			return string.Format("\n{0}: {1}\n--- Start of primary exception ---\n{2}\n--- End of primary exception ---\n\n--- Start of nested exception ---\n{3}\n--- End of nested exception ---\n", array);
		}

		[SecurityCritical]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("NestedException", NestedException, typeof(Exception));
		}
	}
	internal class ModuleUninitializer : Stack
	{
		private static object @lock;

		internal static ModuleUninitializer _ModuleUninitializer;

		[SecuritySafeCritical]
		internal void AddHandler(EventHandler handler)
		{
			bool lockTaken = false;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				RuntimeHelpers.PrepareConstrainedRegions();
				Monitor.Enter(@lock, ref lockTaken);
				RuntimeHelpers.PrepareDelegate(handler);
				Push(handler);
			}
			finally
			{
				if (lockTaken)
				{
					Monitor.Exit(@lock);
				}
			}
		}

		[SecurityCritical]
		static ModuleUninitializer()
		{
			@lock = new object();
			_ModuleUninitializer = new ModuleUninitializer();
		}

		[SecuritySafeCritical]
		private ModuleUninitializer()
		{
			EventHandler value = SingletonDomainUnload;
			AppDomain.CurrentDomain.DomainUnload += value;
			AppDomain.CurrentDomain.ProcessExit += value;
		}

		[PrePrepareMethod]
		[SecurityCritical]
		private void SingletonDomainUnload(object source, EventArgs arguments)
		{
			bool lockTaken = false;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				RuntimeHelpers.PrepareConstrainedRegions();
				Monitor.Enter(@lock, ref lockTaken);
				IEnumerator enumerator = GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						((EventHandler)enumerator.Current)(source, arguments);
					}
				}
				finally
				{
					IEnumerator enumerator2 = enumerator;
					if (enumerator is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
			}
			finally
			{
				if (lockTaken)
				{
					Monitor.Exit(@lock);
				}
			}
		}
	}
}
[StructLayout(LayoutKind.Sequential, Size = 16)]
[NativeCppClass]
[UnsafeValueType]
internal struct _GUID
{
}
[StructLayout(LayoutKind.Sequential, Size = 4)]
[NativeCppClass]
internal static struct IUnknown
{
}
namespace <CrtImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 4)]
	[NativeCppClass]
	internal struct LanguageSupport
	{
	}
}
[StructLayout(LayoutKind.Sequential, Size = 4)]
[NativeCppClass]
internal struct gcroot<System::String ^>
{
}
[StructLayout(LayoutKind.Sequential, Size = 16)]
[NativeCppClass]
[UnsafeValueType]
internal struct __s_GUID
{
}
namespace <CppImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 4)]
	[NativeCppClass]
	internal struct $ArrayType$$$BY00Q6MPBXXZ
	{
	}
}
namespace <CrtImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[NativeCppClass]
	internal struct Progress
	{
		[NativeCppClass]
		[CLSCompliant(false)]
		public enum State
		{

		}
	}
}
namespace <CppImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[NativeCppClass]
	internal struct $ArrayType$$$BY0A@P6AXXZ
	{
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[NativeCppClass]
	internal struct $ArrayType$$$BY0A@P6AHXZ
	{
	}
}
[NativeCppClass]
internal enum __enative_startup_state
{

}
[StructLayout(LayoutKind.Sequential, Size = 4)]
[NativeCppClass]
internal static struct ICorRuntimeHost
{
}
namespace <CrtImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[NativeCppClass]
	internal struct TriBool
	{
		[NativeCppClass]
		[CLSCompliant(false)]
		public enum State
		{

		}
	}
}
[StructLayout(LayoutKind.Sequential, Size = 4)]
[NativeCppClass]
internal static struct ICLRRuntimeHost
{
}
[StructLayout(LayoutKind.Sequential, Size = 8)]
[NativeCppClass]
internal struct _EXCEPTION_POINTERS
{
}
namespace <CrtImplementationDetails>
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[NativeCppClass]
	internal struct ThisModule
	{
	}
}
