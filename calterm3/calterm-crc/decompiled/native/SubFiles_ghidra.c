/*
 * Decompiled from: SubFiles.dll
 * Using Ghidra 11.4.1
 */

// Function: FUN_10001000 at 10001000

int __fastcall FUN_10001000(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029ba6;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10001d20((undefined4 *)(param_1 + 8));
  local_8 = 0;
  FUN_10001f00(param_1);
  FUN_10001d80(param_1 + 4);
  *(undefined4 *)(param_1 + 0x28) = 0;
  *(undefined4 *)(param_1 + 0x2c) = 0;
  *(undefined4 *)(param_1 + 0x30) = 0;
  FUN_10001e90((void *)(param_1 + 0x38));
  ExceptionList = local_10;
  return param_1;
}



// Function: CBinaryData_FinalConstruct at 100010a0

void CBinaryData_FinalConstruct(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029bc9;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  FUN_10001192();
  return;
}



// Function: Catch@100010df at 100010df

undefined * Catch_100010df(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"BinaryData.cpp",0x46,
                       "CBinaryData::FinalConstruct",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_100011a9;
}



// Function: Catch@10001128 at 10001128

undefined * Catch_10001128(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x30),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x30),"BinaryData.cpp",0x46,
                       "CBinaryData::FinalConstruct",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x10001186;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x30));
  return &DAT_1000119b;
}



// Function: FUN_10001192 at 10001192

undefined4 FUN_10001192(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: FUN_100011d0 at 100011d0

undefined4 FUN_100011d0(undefined4 param_1,int *param_2)

{
  bool bVar1;
  int iVar2;
  
  bVar1 = false;
  while( true ) {
    if (bVar1) {
      return 1;
    }
    iVar2 = FUN_100022c0((int *)PTR_DAT_1003f004,param_2);
    if (iVar2 != 0) break;
    bVar1 = true;
  }
  return 0;
}



// Function: CBinaryData_get_Location at 10001220

void CBinaryData_get_Location(int param_1,undefined4 *param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029bec;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_2 == (undefined4 *)0x0) {
    FUN_10025510((uchar *)"BinaryData.cpp");
  }
  *param_2 = *(undefined4 *)(param_1 + 0x24);
  FUN_1000133a();
  return;
}



// Function: Catch@10001287 at 10001287

undefined * Catch_10001287(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x1c),"BinaryData.cpp",0x58,
                       "CBinaryData::get_Location",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10001351;
}



// Function: Catch@100012d0 at 100012d0

undefined * Catch_100012d0(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x2c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x2c),"BinaryData.cpp",0x58,"CBinaryData::get_Location"
                       ,*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x1000132e;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return &DAT_10001343;
}



// Function: FUN_1000133a at 1000133a

undefined4 FUN_1000133a(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return 0;
}



// Function: CBinaryData_put_Location at 10001380

void CBinaryData_put_Location(int param_1,undefined4 param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029c0f;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  *(undefined4 *)(param_1 + 0x24) = param_2;
  FUN_10001474();
  return;
}



// Function: Catch@100013c1 at 100013c1

undefined * Catch_100013c1(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x1c),"BinaryData.cpp",100,
                       "CBinaryData::put_Location",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_1000148b;
}



// Function: Catch@1000140a at 1000140a

undefined * Catch_1000140a(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x2c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x2c),"BinaryData.cpp",100,"CBinaryData::put_Location",
                       *puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x10001468;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return &DAT_1000147d;
}



// Function: FUN_10001474 at 10001474

undefined4 FUN_10001474(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return 0;
}



// Function: CBinaryData_get_Offset at 100014b0

void CBinaryData_get_Offset(int param_1,undefined4 *param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029c32;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_2 == (undefined4 *)0x0) {
    FUN_10025510((uchar *)"BinaryData.cpp");
  }
  *param_2 = *(undefined4 *)(param_1 + 0x28);
  FUN_100015ca();
  return;
}



// Function: Catch@10001517 at 10001517

undefined * Catch_10001517(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x1c),"BinaryData.cpp",0x78,"CBinaryData::get_Offset"
                       ,*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_100015e1;
}



// Function: Catch@10001560 at 10001560

undefined * Catch_10001560(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x2c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x2c),"BinaryData.cpp",0x78,"CBinaryData::get_Offset",
                       *puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x100015be;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return &DAT_100015d3;
}



// Function: FUN_100015ca at 100015ca

undefined4 FUN_100015ca(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return 0;
}



// Function: CBinaryData_put_Offset at 10001610

void CBinaryData_put_Offset(int param_1,undefined4 param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029c55;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  *(undefined4 *)(param_1 + 0x28) = param_2;
  FUN_1000170a();
  return;
}



// Function: Catch@10001651 at 10001651

undefined * Catch_10001651(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x1c),"BinaryData.cpp",0x85,"CBinaryData::put_Offset"
                       ,*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10001721;
}



// Function: Catch@1000169d at 1000169d

undefined * Catch_1000169d(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x2c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x2c),"BinaryData.cpp",0x85,"CBinaryData::put_Offset",
                       *puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x100016fe;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return &DAT_10001713;
}



// Function: FUN_1000170a at 1000170a

undefined4 FUN_1000170a(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return 0;
}



// Function: CBinaryData_get_Length at 10001750

void CBinaryData_get_Length(int param_1,undefined4 *param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029c78;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_2 == (undefined4 *)0x0) {
    FUN_10025510((uchar *)"BinaryData.cpp");
  }
  *param_2 = *(undefined4 *)(param_1 + 0x2c);
  FUN_10001873();
  return;
}



// Function: Catch@100017ba at 100017ba

undefined * Catch_100017ba(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x1c),"BinaryData.cpp",0x99,"CBinaryData::get_Length"
                       ,*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_1000188a;
}



// Function: Catch@10001806 at 10001806

undefined * Catch_10001806(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x2c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x2c),"BinaryData.cpp",0x99,"CBinaryData::get_Length",
                       *puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x10001867;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return &DAT_1000187c;
}



// Function: FUN_10001873 at 10001873

undefined4 FUN_10001873(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return 0;
}



// Function: CBinaryData_put_Length at 100018b0

void CBinaryData_put_Length(int param_1,undefined4 param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029c9b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  *(undefined4 *)(param_1 + 0x2c) = param_2;
  FUN_100019aa();
  return;
}



// Function: Catch@100018f1 at 100018f1

undefined * Catch_100018f1(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x1c),"BinaryData.cpp",0xa6,"CBinaryData::put_Length"
                       ,*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_100019c1;
}



// Function: Catch@1000193d at 1000193d

undefined * Catch_1000193d(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x2c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x2c),"BinaryData.cpp",0xa6,"CBinaryData::put_Length",
                       *puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x1000199e;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return &DAT_100019b3;
}



// Function: FUN_100019aa at 100019aa

undefined4 FUN_100019aa(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return 0;
}



// Function: CBinaryData_get_BinaryData at 100019f0

void CBinaryData_get_BinaryData(int param_1,undefined2 *param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029cbe;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_2 == (undefined2 *)0x0) {
    FUN_10025510((uchar *)"BinaryData.cpp");
  }
  *param_2 = *(undefined2 *)(param_1 + 0x34);
  Ordinal_27(*(undefined4 *)(param_1 + 0x3c),param_2 + 4);
  FUN_10001b29();
  return;
}



// Function: Catch@10001a70 at 10001a70

undefined * Catch_10001a70(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x1c),"BinaryData.cpp",0xbd,
                       "CBinaryData::get_BinaryData",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10001b40;
}



// Function: Catch@10001abc at 10001abc

undefined * Catch_10001abc(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x2c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x2c),"BinaryData.cpp",0xbd,
                       "CBinaryData::get_BinaryData",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x10001b1d;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return &DAT_10001b32;
}



// Function: FUN_10001b29 at 10001b29

undefined4 FUN_10001b29(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return 0;
}



// Function: CBinaryData_put_BinaryData at 10001b70

void CBinaryData_put_BinaryData(int param_1,ushort param_2,undefined4 param_3,int param_4)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029ce1;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (((param_2 & 0x2000) == 0) || ((param_2 & 0x11) == 0)) {
    FUN_10025510((uchar *)"BinaryData.cpp");
  }
  else {
    if (*(short *)(param_1 + 0x34) != 0) {
      Ordinal_16(*(undefined4 *)(param_1 + 0x3c));
    }
    Ordinal_27(param_4,param_1 + 0x3c);
    *(undefined2 *)(param_1 + 0x34) = 0x2011;
    *(undefined4 *)(param_1 + 0x2c) = *(undefined4 *)(param_4 + 0x10);
  }
  FUN_10001ce2();
  return;
}



// Function: Catch@10001c29 at 10001c29

undefined * Catch_10001c29(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x1c),"BinaryData.cpp",0xd9,
                       "CBinaryData::put_BinaryData",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10001cf9;
}



// Function: Catch@10001c75 at 10001c75

undefined * Catch_10001c75(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x2c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  puVar1 = (undefined8 *)FUN_10002270();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x2c),"BinaryData.cpp",0xd9,
                       "CBinaryData::put_BinaryData",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 1;
  uStack0000001c = 0x10001cd6;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return &DAT_10001ceb;
}



// Function: FUN_10001ce2 at 10001ce2

undefined4 FUN_10001ce2(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return 0;
}



// Function: FUN_10001d20 at 10001d20

undefined4 * __fastcall FUN_10001d20(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029d13;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10001e10(param_1);
  local_8 = 0;
  FUN_10001da0((CComCriticalSection *)(param_1 + 1));
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10001d80 at 10001d80

undefined4 __fastcall FUN_10001d80(undefined4 param_1)

{
  FUN_10001ec0(param_1);
  return param_1;
}



// Function: FUN_10001da0 at 10001da0

CComCriticalSection * __fastcall FUN_10001da0(CComCriticalSection *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029d38;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10001e30(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: CComCriticalSection at 10001df0

/* Library Function - Single Match
    public: __thiscall ATL::CComCriticalSection::CComCriticalSection(void)
   
   Library: Visual Studio */

CComCriticalSection * __thiscall
ATL::CComCriticalSection::CComCriticalSection(CComCriticalSection *this)

{
  memset(this,0,0x18);
  return this;
}



// Function: FUN_10001e10 at 10001e10

undefined4 * __fastcall FUN_10001e10(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10001e30 at 10001e30

CComCriticalSection * __fastcall FUN_10001e30(CComCriticalSection *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029d68;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  ATL::CComCriticalSection::CComCriticalSection(param_1);
  param_1[0x18] = (CComCriticalSection)0x0;
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10001e90 at 10001e90

void * __fastcall FUN_10001e90(void *param_1)

{
  memset(param_1,0,0x10);
  Ordinal_8(param_1);
  return param_1;
}



// Function: FUN_10001ec0 at 10001ec0

undefined4 __fastcall FUN_10001ec0(undefined4 param_1)

{
  FUN_10001ee0(param_1);
  return param_1;
}



// Function: FUN_10001ee0 at 10001ee0

undefined4 __fastcall FUN_10001ee0(undefined4 param_1)

{
  FUN_10001f20(param_1);
  return param_1;
}



// Function: FUN_10001f00 at 10001f00

undefined4 __fastcall FUN_10001f00(undefined4 param_1)

{
  FUN_10001f20(param_1);
  return param_1;
}



// Function: FUN_10001f20 at 10001f20

undefined4 __fastcall FUN_10001f20(undefined4 param_1)

{
  return param_1;
}



// Function: _com_error at 10001f30

/* Library Function - Single Match
    public: __thiscall _com_error::_com_error(long,struct IErrorInfo *,bool)
   
   Library: Visual Studio 2005 Debug */

_com_error * __thiscall
_com_error::_com_error(_com_error *this,long param_1,IErrorInfo *param_2,bool param_3)

{
  *(undefined ***)this = vftable;
  *(long *)(this + 4) = param_1;
  *(IErrorInfo **)(this + 8) = param_2;
  *(undefined4 *)(this + 0xc) = 0;
  if ((*(int *)(this + 8) != 0) && (param_3)) {
    (**(code **)(**(int **)(this + 8) + 4))(*(undefined4 *)(this + 8));
  }
  return this;
}



// Function: ~_ExceptionPtr_static<> at 10001f90

/* Library Function - Multiple Matches With Same Base Name
    public: virtual __thiscall `anonymous namespace'::_ExceptionPtr_static<class
   std::bad_alloc>::~_ExceptionPtr_static<class std::bad_alloc>(void)
    public: virtual __thiscall `anonymous namespace'::_ExceptionPtr_static<class
   std::bad_exception>::~_ExceptionPtr_static<class std::bad_exception>(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall ~_ExceptionPtr_static<>(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029da3;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  FID_conflict__bad_alloc((LPCRITICAL_SECTION)(param_1 + 4));
  local_8 = 0xffffffff;
  FUN_10002070();
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 10001ff0

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(LPCRITICAL_SECTION param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029dc8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_10002080(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10002040 at 10002040

void __fastcall FUN_10002040(undefined4 *param_1)

{
  Ordinal_6(*param_1);
  return;
}



// Function: FUN_10002060 at 10002060

void FUN_10002060(void)

{
  return;
}



// Function: FUN_10002070 at 10002070

void FUN_10002070(void)

{
  return;
}



// Function: FUN_10002080 at 10002080

void __fastcall FUN_10002080(LPCRITICAL_SECTION param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029df8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (*(char *)&param_1[1].DebugInfo != '\0') {
    *(undefined1 *)&param_1[1].DebugInfo = 0;
    FUN_10002280(param_1);
  }
  local_8 = 0xffffffff;
  FUN_10002060();
  ExceptionList = local_10;
  return;
}



// Function: FUN_100020f0 at 100020f0

void __fastcall FUN_100020f0(undefined4 param_1)

{
  FUN_10002250(param_1);
  return;
}



// Function: ~_com_error at 10002110

/* Library Function - Single Match
    public: virtual __thiscall _com_error::~_com_error(void)
   
   Library: Visual Studio 2005 Debug */

void __thiscall _com_error::~_com_error(_com_error *this)

{
  *(undefined ***)this = vftable;
  if (*(int *)(this + 8) != 0) {
    (**(code **)(**(int **)(this + 8) + 8))(*(undefined4 *)(this + 8));
  }
  if (*(int *)(this + 0xc) != 0) {
    LocalFree(*(HLOCAL *)(this + 0xc));
  }
  return;
}



// Function: FID_conflict:~bad_alloc at 10002160

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_10029e28;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_10002040(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:`vector_deleting_destructor' at 100021b0

/* Library Function - Multiple Matches With Different Base Names
    public: void * __thiscall Concurrency::details::GlobalCore::`vector deleting
   destructor'(unsigned int)
    public: void * __thiscall Concurrency::location::`vector deleting destructor'(unsigned int)
   
   Library: Visual Studio 2012 Release */

undefined4 * __thiscall FID_conflict__vector_deleting_destructor_(void *this,uint param_1)

{
  if ((param_1 & 2) == 0) {
    FID_conflict__bad_alloc((undefined4 *)this);
    if ((param_1 & 1) != 0) {
      operator_delete(this);
    }
  }
  else {
    _eh_vector_destructor_iterator_(this,0xc,*(int *)((int)this + -4),FID_conflict__bad_alloc);
    if ((param_1 & 1) != 0) {
      operator_delete__((void *)((int)this + -4));
    }
    this = (void *)((int)this + -4);
  }
  return (undefined4 *)this;
}



// Function: FUN_10002220 at 10002220

_com_error * __thiscall FUN_10002220(void *this,uint param_1)

{
  _com_error::~_com_error((_com_error *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (_com_error *)this;
}



// Function: FUN_10002250 at 10002250

void __fastcall FUN_10002250(undefined4 param_1)

{
  Ordinal_9(param_1);
  return;
}



// Function: FUN_10002270 at 10002270

undefined * FUN_10002270(void)

{
  return &DAT_100339b0;
}



// Function: FUN_10002280 at 10002280

undefined4 __fastcall FUN_10002280(LPCRITICAL_SECTION param_1)

{
  DeleteCriticalSection(param_1);
  return 0;
}



// Function: FUN_100022a0 at 100022a0

void __cdecl FUN_100022a0(LPCRITICAL_SECTION param_1,DWORD param_2)

{
  InitializeCriticalSectionAndSpinCount(param_1,param_2);
  return;
}



// Function: FUN_100022c0 at 100022c0

undefined4 __cdecl FUN_100022c0(int *param_1,int *param_2)

{
  undefined4 local_8;
  
  if ((((*param_1 == *param_2) && (param_1[1] == param_2[1])) && (param_1[2] == param_2[2])) &&
     (param_1[3] == param_2[3])) {
    local_8 = 1;
  }
  else {
    local_8 = 0;
  }
  return local_8;
}



// Function: FUN_10002360 at 10002360

undefined4 __cdecl FUN_10002360(int param_1,uint param_2,int *param_3)

{
  undefined4 uVar1;
  
  if (param_1 + param_2 < param_2) {
    uVar1 = 0x80070216;
  }
  else {
    *param_3 = param_1 + param_2;
    uVar1 = 0;
  }
  return uVar1;
}



// Function: FUN_10002390 at 10002390

undefined4 __cdecl FUN_10002390(uint param_1,uint param_2,undefined4 *param_3)

{
  undefined4 uVar1;
  undefined4 local_c;
  undefined4 local_8;
  
  local_8 = (int)((ulonglong)param_1 * (ulonglong)param_2 >> 0x20);
  if (local_8 == 0) {
    local_c = (undefined4)((ulonglong)param_1 * (ulonglong)param_2);
    *param_3 = local_c;
    uVar1 = 0;
  }
  else {
    uVar1 = 0x80070216;
  }
  return uVar1;
}



// Function: FUN_100023d0 at 100023d0

int __fastcall FUN_100023d0(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029ecf;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10001d20((undefined4 *)(param_1 + 0x14));
  local_8 = 0;
  FUN_10001f00(param_1);
  FUN_1000dc00(param_1 + 4);
  FUN_1000dbc0(param_1 + 8);
  FUN_1000dbe0(param_1 + 0xc);
  FUN_1000dc20(param_1 + 0x10);
  FUN_1000e770((void *)(param_1 + 0x34),"");
  local_8._0_1_ = 1;
  *(undefined2 *)(param_1 + 0x38) = 0;
  *(undefined4 *)(param_1 + 0x3c) = 0xffffffff;
  *(undefined4 *)(param_1 + 0x40) = 0;
  *(undefined4 *)(param_1 + 0x44) = 0;
  *(undefined4 *)(param_1 + 0x48) = 0xffffffff;
  vector<>((undefined4 *)(param_1 + 0x4c));
  local_8._0_1_ = 2;
  vector<>((undefined4 *)(param_1 + 0x58));
  local_8._0_1_ = 3;
  FUN_1000e770((void *)(param_1 + 100),"");
  local_8._0_1_ = 4;
  FUN_1000e770((void *)(param_1 + 0x68),"Cummins Subfile");
  local_8._0_1_ = 5;
  FUN_1000df70((undefined4 *)(param_1 + 0x6c));
  local_8._0_1_ = 6;
  FUN_1000dfe0((undefined4 *)(param_1 + 0x70));
  local_8._0_1_ = 7;
  FUN_1000e360((CComCriticalSection *)(param_1 + 0x74));
  local_8._0_1_ = 8;
  *(undefined4 *)(param_1 + 0x90) = 0;
  *(undefined4 *)(param_1 + 0x94) = 0xffffffff;
  *(undefined4 *)(param_1 + 0x98) = 0xffffffff;
  *(undefined4 *)(param_1 + 0x9c) = 0xffffffff;
  *(undefined4 *)(param_1 + 0xa0) = 0x400000;
  FUN_1000e8b0((undefined4 *)(param_1 + 0xa4));
  local_8._0_1_ = 9;
  *(undefined1 *)(param_1 + 0xa8) = 0;
  *(undefined4 *)(param_1 + 0xac) = 4;
  *(undefined4 *)(param_1 + 0xb0) = 6;
  FUN_1000e770((void *)(param_1 + 0xb4),"");
  local_8 = CONCAT31(local_8._1_3_,10);
  FUN_10015430((void *)(param_1 + 0x58),5000);
  FUN_100153f0((void *)(param_1 + 0x4c),25000);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_100025c0 at 100025c0

void * FUN_100025c0(void *param_1,int *param_2)

{
  int iVar1;
  IUnknown *pIVar2;
  int *piVar3;
  undefined4 uVar4;
  _GUID *p_Var5;
  undefined4 uVar6;
  refcount_ptr<struct_boost::exception_detail::error_info_container> local_14 [4];
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029f0b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000e100((undefined4 *)local_14);
  local_8 = 1;
  iVar1 = FUN_10011490(local_14,(IID *)&DAT_100304ac,(LPUNKNOWN)0x0,0x17);
  if (iVar1 < 0) {
    p_Var5 = (_GUID *)&DAT_1003302c;
    pIVar2 = (IUnknown *)FUN_1000fc90((undefined4 *)local_14);
    _com_issue_errorex(iVar1,pIVar2,p_Var5);
  }
  piVar3 = (int *)FUN_1000fee0((int *)local_14);
  uVar6 = 0;
  uVar4 = FUN_1000fd40(param_2);
  iVar1 = (**(code **)(*piVar3 + 0x14))(piVar3,uVar4,uVar6);
  if (iVar1 < 0) {
    p_Var5 = (_GUID *)&DAT_1003302c;
    pIVar2 = (IUnknown *)FUN_1000fc90((undefined4 *)local_14);
    _com_issue_errorex(iVar1,pIVar2,p_Var5);
  }
  FUN_1000be90(param_1,local_14);
  local_8 = local_8 & 0xffffff00;
  FUN_1000ef40((int *)local_14);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_100026c0 at 100026c0

void FUN_100026c0(_String_val<struct_std::_Simple_types<char>_> *param_1)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  void *this;
  undefined4 *puVar4;
  uint uVar5;
  undefined4 *puVar6;
  undefined4 local_5c [4];
  int *local_4c;
  undefined1 *local_48;
  int *local_44;
  undefined1 *local_40;
  LPCSTR local_3c;
  int *local_38;
  int local_34;
  int *local_30;
  int *local_2c;
  int *local_28;
  char *local_24;
  uint local_20;
  char *local_1c;
  int local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029f4e;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  uVar2 = FUN_10014d60((int)param_1);
  if (0x53 < uVar2) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  uVar5 = 0;
  uVar2 = FUN_10014d60((int)param_1);
  FUN_10013320(param_1,&DAT_10040460,0x54,uVar2,uVar5);
  local_20 = FUN_10014d60((int)param_1);
  if (0x53 < local_20) {
    ___report_rangecheckfailure();
  }
  (&DAT_10040460)[local_20] = 0;
  bVar1 = FUN_100237d0(&DAT_10040460,1);
  if (!bVar1) {
    iVar3 = FUN_10014d60((int)param_1);
    local_24 = (char *)operator_new__(iVar3 + 100);
    local_1c = local_24;
    sprintf(local_24,"A line checksum error is found. Line text: ");
    FUN_1000e000(&local_14);
    local_8 = 0;
    FUN_10011310(&local_14,(IID *)&DAT_1002fea8,(LPUNKNOWN)0x0,0x17);
    local_2c = FUN_1000e770(&local_34,&DAT_10040460);
    local_8._0_1_ = 1;
    local_28 = local_2c;
    FUN_1000e8d0(local_5c,local_2c);
    local_8._0_1_ = 2;
    puVar4 = local_5c;
    local_40 = &stack0xffffff98;
    puVar6 = puVar4;
    local_44 = FUN_1000e770(&stack0xffffff98,"lineText");
    local_8._0_1_ = 3;
    local_30 = local_44;
    this = (void *)FUN_1000fe50(&local_14);
    local_8._0_1_ = 2;
    FUN_100105d0(this,puVar4,puVar6);
    local_8._0_1_ = 1;
    FUN_1000f240(local_5c);
    local_8._0_1_ = 0;
    FUN_1000f220(&local_34);
    FUN_1000fc70(&local_14);
    local_48 = &stack0xffffff88;
    local_4c = FUN_1000e770(&stack0xffffff88,local_1c);
    local_8 = (uint)local_8._1_3_ << 8;
    local_38 = local_4c;
    FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                 (local_18 + 0x70));
    local_3c = local_1c;
    operator_delete__(local_1c);
    FUN_100146c0(param_1);
    FUN_10025510((uchar *)"SubFileComponent.cpp");
    local_8 = 0xffffffff;
    FUN_1000eee0(&local_14);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_100028f0 at 100028f0

void FUN_100028f0(void)

{
  uint uVar1;
  IUnknown *pIVar2;
  _GUID *p_Var3;
  undefined1 local_90 [16];
  undefined1 local_80 [16];
  undefined4 local_70;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  long local_4c;
  int *local_48;
  int local_44;
  int local_40;
  long local_3c;
  int *local_38;
  long local_34;
  int *local_30;
  long local_2c;
  int *local_28;
  long local_24;
  int *local_20;
  long local_1c;
  int *local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_10029f94;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 1;
  local_14 = 0;
  local_40 = 0;
  local_44 = 0;
  local_18 = (int *)FUN_1000fd70((undefined4 *)&stack0x00000004);
  local_1c = (**(code **)(*local_18 + 0x2c))(local_18,&local_40,uVar1);
  local_14 = local_1c;
  if (local_1c < 0) {
    p_Var3 = (_GUID *)&DAT_1002f4e0;
    pIVar2 = (IUnknown *)FUN_1000fbf0((undefined4 *)&stack0x00000004);
    _com_issue_errorex(local_1c,pIVar2,p_Var3);
  }
  local_20 = (int *)FUN_1000fd70((undefined4 *)&stack0x00000008);
  local_24 = (**(code **)(*local_20 + 0x2c))(local_20,&local_44);
  local_14 = local_24;
  if (local_24 < 0) {
    p_Var3 = (_GUID *)&DAT_1002f4e0;
    pIVar2 = (IUnknown *)FUN_1000fbf0((undefined4 *)&stack0x00000008);
    _com_issue_errorex(local_24,pIVar2,p_Var3);
  }
  FUN_10001e90(local_90);
  local_8._0_1_ = 2;
  FUN_10001e90(local_80);
  local_8 = CONCAT31(local_8._1_3_,3);
  local_28 = (int *)FUN_1000fd70((undefined4 *)&stack0x00000008);
  local_2c = (**(code **)(*local_28 + 0x34))(local_28,local_90);
  local_14 = local_2c;
  if (local_2c < 0) {
    p_Var3 = (_GUID *)&DAT_1002f4e0;
    pIVar2 = (IUnknown *)FUN_1000fbf0((undefined4 *)&stack0x00000008);
    _com_issue_errorex(local_2c,pIVar2,p_Var3);
  }
  local_30 = (int *)FUN_1000fd70((undefined4 *)&stack0x00000004);
  local_34 = (**(code **)(*local_30 + 0x34))(local_30,local_80);
  local_14 = local_34;
  if (local_34 < 0) {
    p_Var3 = (_GUID *)&DAT_1002f4e0;
    pIVar2 = (IUnknown *)FUN_1000fbf0((undefined4 *)&stack0x00000004);
    _com_issue_errorex(local_34,pIVar2,p_Var3);
  }
  FUN_10001e90(&local_70);
  local_8 = CONCAT31(local_8._1_3_,4);
  local_70 = CONCAT22(local_70._2_2_,0x2011);
  FUN_10002ba0((int)local_80,(int)local_90,(int)&local_70);
  local_60 = local_70;
  local_5c = local_6c;
  local_58 = local_68;
  local_54 = local_64;
  local_38 = (int *)FUN_1000fd70((undefined4 *)&stack0x00000004);
  local_3c = (**(code **)(*local_38 + 0x38))(local_38,local_60,local_5c,local_58,local_54);
  local_14 = local_3c;
  if (local_3c < 0) {
    p_Var3 = (_GUID *)&DAT_1002f4e0;
    pIVar2 = (IUnknown *)FUN_1000fbf0((undefined4 *)&stack0x00000004);
    _com_issue_errorex(local_3c,pIVar2,p_Var3);
  }
  local_48 = (int *)FUN_1000fd70((undefined4 *)&stack0x00000004);
  local_4c = (**(code **)(*local_48 + 0x30))(local_48,local_40 + local_44);
  local_14 = local_4c;
  if (local_4c < 0) {
    p_Var3 = (_GUID *)&DAT_1002f4e0;
    pIVar2 = (IUnknown *)FUN_1000fbf0((undefined4 *)&stack0x00000004);
    _com_issue_errorex(local_4c,pIVar2,p_Var3);
  }
  local_8._0_1_ = 3;
  FUN_100020f0(&local_70);
  local_8._0_1_ = 2;
  FUN_100020f0(local_80);
  local_8._0_1_ = 1;
  FUN_100020f0(local_90);
  local_8 = (uint)local_8._1_3_ << 8;
  FID_conflict__bad_alloc((int *)&stack0x00000004);
  local_8 = 0xffffffff;
  FID_conflict__bad_alloc((int *)&stack0x00000008);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10002ba0 at 10002ba0

void FUN_10002ba0(int param_1,int param_2,int param_3)

{
  undefined2 local_40 [4];
  undefined4 local_38;
  int local_30 [3];
  void *local_24;
  size_t local_20;
  void *local_1c;
  size_t local_18;
  void *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029fba;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_18 = *(size_t *)(*(int *)(param_1 + 8) + 0x10);
  local_20 = *(size_t *)(*(int *)(param_2 + 8) + 0x10);
  local_1c = (void *)0x0;
  Ordinal_23(*(undefined4 *)(param_1 + 8),&local_1c,DAT_10040398 ^ (uint)&stack0xfffffffc);
  local_24 = (void *)0x0;
  Ordinal_23(*(undefined4 *)(param_2 + 8),&local_24);
  local_30[0] = local_18 + local_20;
  local_30[1] = 0;
  FUN_10001e90(local_40);
  local_8 = 0;
  local_40[0] = 0x2011;
  local_38 = Ordinal_15(0x11,1,local_30);
  local_14 = (void *)0x0;
  Ordinal_23(local_38,&local_14);
  memcpy(local_14,local_1c,local_18);
  memcpy((void *)((int)local_14 + local_18),local_24,local_20);
  Ordinal_24(*(undefined4 *)(param_1 + 8));
  Ordinal_24(*(undefined4 *)(param_2 + 8));
  Ordinal_24(local_38);
  Ordinal_27(local_38,param_3 + 8);
  local_8 = 0xffffffff;
  FUN_100020f0(local_40);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10002cf0 at 10002cf0

void __thiscall
FUN_10002cf0(void *this,_String_val<struct_std::_Simple_types<char>_> *param_1,undefined4 param_2,
            undefined4 param_3)

{
  bool bVar1;
  char *_Src;
  int iVar2;
  char *_Format;
  
  _Format = "*C%2X%2X";
  _Src = (char *)FUN_100146c0(param_1);
  iVar2 = sscanf(_Src,_Format,param_2,param_3);
  if (iVar2 != 2) {
    FUN_100146c0(param_1);
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  bVar1 = FUN_1000f840((void *)((int)this + 0xa4),(int *)&DAT_100403e0);
  if (((bVar1) || (bVar1 = FUN_1000f840((void *)((int)this + 0xa4),(int *)&DAT_100403dc), bVar1)) ||
     (bVar1 = FUN_1000f840((void *)((int)this + 0xa4),(int *)&DAT_100403ec), bVar1)) {
    if (*(int *)((int)this + 0x44) == 2) {
      *(undefined4 *)((int)this + 0xac) = 5;
    }
    else if (*(int *)((int)this + 0x44) == 3) {
      *(undefined4 *)((int)this + 0xac) = 5;
    }
  }
  else {
    bVar1 = FUN_1000f840((void *)((int)this + 0xa4),(int *)&DAT_100403e4);
    if (bVar1) {
      *(uint *)((int)this + 0xac) = 4 - (uint)*(byte *)((int)this + 0xa8);
    }
  }
  return;
}



// Function: FUN_10002e00 at 10002e00

/* WARNING: Removing unreachable block (ram,0x10003030) */
/* WARNING: Removing unreachable block (ram,0x10002ffa) */

void FUN_10002e00(int *param_1)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar4;
  char *pcVar5;
  char local_58 [4];
  int local_54;
  char local_50;
  undefined1 local_4f;
  undefined1 uStack_4e;
  uint local_4c;
  char local_45;
  short local_44;
  uint local_40;
  void *local_3c;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_38 [24];
  char local_20 [12];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_10029fdd;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  iVar2 = FUN_10015520(param_1);
  if (iVar2 < *(int *)((int)local_3c + 0xac)) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  builtin_strncpy(local_20,"BCHVLTDGB",9);
  basic_string<>(local_38);
  local_8 = 0;
  local_4c = 0;
  local_45 = '\x01';
  local_44 = 9;
  local_40 = 0;
  local_54 = 0;
  while (((int)local_40 < (int)local_44 &&
         (uVar3 = FUN_10015520((int *)((int)local_3c + 0x58)), local_40 < uVar3))) {
    local_54 = *(byte *)((int)local_3c + 0xa8) + local_40;
    if (local_40 == (int)local_44 - 1U) {
      iVar2 = FUN_10015520(param_1);
      pbVar4 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
               FUN_1000fbb0(param_1,iVar2 + -1);
      FID_conflict_operator_(local_38,pbVar4);
    }
    else {
      pbVar4 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
               FUN_1000fbb0(param_1,local_40);
      FID_conflict_operator_(local_38,pbVar4);
    }
    if ((local_40 == *(uint *)((int)local_3c + 0xac)) && (*(int *)((int)local_3c + 0x44) != 3))
    break;
    if (*(char *)((int)local_3c + 0xa8) != '\0') {
      local_4c = 1;
    }
    iVar2 = FUN_10014d60((int)local_38);
    if ((iVar2 == 0) || (uVar3 = FUN_10014d60((int)local_38), uVar3 <= local_4c)) {
      iVar2 = FUN_10014d60((int)local_38);
      if (iVar2 == 0) {
        local_50 = 0x22;
        local_4f = 0x22;
        local_4f = 0x22;
        local_50 = '\"';
        uStack_4e = 0;
      }
      else {
        pcVar5 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                 operator[](local_38,0);
        local_50 = *pcVar5;
        local_4f = 0;
      }
      if (local_40 == (int)local_44 - 1U) {
        FUN_10025510((uchar *)"SubFileComponent.cpp");
      }
      else {
        FUN_10025510((uchar *)"SubFileComponent.cpp");
      }
    }
    pcVar5 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_38,local_4c);
    if (*pcVar5 == local_20[local_54]) {
LAB_100032d2:
      if (local_54 == 1) {
        FUN_10002cf0(local_3c,(_String_val<struct_std::_Simple_types<char>_> *)local_38,
                     (int)local_3c + 0x40,(int)local_3c + 0x44);
      }
      local_4c = 1;
    }
    else if ((local_54 == 3) &&
            (pcVar5 = std::
                      basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                      operator[](local_38,local_4c), *pcVar5 == 'R')) {
      FUN_1000f480((void *)((int)local_3c + 100),(int *)&DAT_100403f0);
    }
    else if ((((local_54 != local_44 + -2) ||
              (bVar1 = FUN_1000f840((void *)((int)local_3c + 100),(int *)&DAT_100403f0), !bVar1)) &&
             ((((local_54 != 4 ||
                (pcVar5 = std::
                          basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                          ::operator[](local_38,local_4c), *pcVar5 != 'B')) ||
               (*(int *)((int)local_3c + 0x44) != 2)) ||
              (((bVar1 = FUN_1000f840((void *)((int)local_3c + 0xa4),(int *)&DAT_100403e0), !bVar1
                && (bVar1 = FUN_1000f840((void *)((int)local_3c + 0xa4),(int *)&DAT_100403dc),
                   !bVar1)) &&
               (bVar1 = FUN_1000f840((void *)((int)local_3c + 0xa4),(int *)&DAT_100403ec), !bVar1)))
              ))) && (((local_54 != local_44 + -1 || (*(int *)((int)local_3c + 0x44) != 3)) ||
                      ((bVar1 = FUN_1000f840((void *)((int)local_3c + 0xa4),(int *)&DAT_100403e4),
                       !bVar1 && (((bVar1 = FUN_1000f840((void *)((int)local_3c + 0xa4),
                                                         (int *)&DAT_100403e0), !bVar1 &&
                                   (bVar1 = FUN_1000f840((void *)((int)local_3c + 0xa4),
                                                         (int *)&DAT_100403dc), !bVar1)) &&
                                  (bVar1 = FUN_1000f840((void *)((int)local_3c + 0xa4),
                                                        (int *)&DAT_100403ec), !bVar1)))))))) {
      if (local_4c == 1) {
        local_58[0] = '*';
      }
      pcVar5 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](local_38,local_4c);
      local_58[local_4c] = *pcVar5;
      uVar3 = local_4c;
      if (2 < local_4c + 1) {
        ___report_rangecheckfailure();
      }
      local_58[uVar3 + 1] = '\0';
      if (local_40 == (int)local_44 - 1U) {
        FUN_10025510((uchar *)"SubFileComponent.cpp");
      }
      else {
        FUN_10025510((uchar *)"SubFileComponent.cpp");
      }
      goto LAB_100032d2;
    }
    local_40 = local_40 + 1;
  }
  if ((*(int *)((int)local_3c + 0x44) == 3) && ((int)local_40 < *(int *)((int)local_3c + 0xb0))) {
    local_45 = '\0';
  }
  if (local_45 == '\0') {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  if (*(int *)((int)local_3c + 0x44) != 3) {
    FUN_10006aa0(local_3c,param_1);
  }
  if (*(int *)((int)local_3c + 0x44) == 3) {
    bVar1 = FUN_1000f840((void *)((int)local_3c + 100),(int *)&DAT_100403f0);
    if (bVar1) {
      FUN_10006be0(local_3c,param_1);
    }
    else {
      FUN_10006d00(local_3c,param_1);
    }
  }
  local_8 = 0xffffffff;
  ~basic_string<>(local_38);
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100033d0 at 100033d0

void FUN_100033d0(int *param_1,char *param_2)

{
  int iVar1;
  size_t sVar2;
  void *this;
  undefined4 uStack_90;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 local_64 [4];
  int *local_54;
  undefined1 *local_50;
  int *local_4c;
  undefined1 *local_48;
  LPCSTR local_44;
  int *local_40;
  int local_3c;
  int *local_38;
  int *local_34;
  int *local_30;
  char *local_2c;
  size_t local_28;
  char *local_24;
  int local_20;
  int local_1c;
  size_t local_18;
  char local_11;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a02a;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_18 = 0;
  local_11 = '\0';
  local_28 = strlen(param_2);
  iVar1 = (**(code **)(*param_1 + 0x10))();
  if ((-1 < iVar1) && (local_18 == local_28)) {
    iVar1 = (**(code **)(*param_1 + 0x10))();
    if ((-1 < iVar1) && (1 < local_18)) {
      local_11 = '\x01';
    }
  }
  if (local_11 == '\0') {
    sVar2 = strlen(param_2);
    local_2c = (char *)operator_new__(sVar2 + 100);
    local_24 = local_2c;
    sprintf(local_2c,"The request to write data to file failed. Line text: ");
    FUN_1000e000(&local_1c);
    local_8 = 0;
    FUN_10011310(&local_1c,(IID *)&DAT_1002fea8,(LPUNKNOWN)0x0,0x17);
    local_34 = FUN_1000e770(&local_3c,param_2);
    local_8._0_1_ = 1;
    local_30 = local_34;
    FUN_1000e8d0(local_64,local_34);
    local_8._0_1_ = 2;
    puVar3 = local_64;
    local_48 = &stack0xffffff80;
    puVar4 = puVar3;
    local_4c = FUN_1000e770(&stack0xffffff80,"lineText");
    local_8._0_1_ = 3;
    local_38 = local_4c;
    this = (void *)FUN_1000fe50(&local_1c);
    local_8._0_1_ = 2;
    FUN_100105d0(this,puVar3,puVar4);
    local_8._0_1_ = 1;
    FUN_1000f240(local_64);
    local_8._0_1_ = 0;
    FUN_1000f220(&local_3c);
    FUN_1000fc70(&local_1c);
    local_50 = (undefined1 *)&uStack_90;
    local_54 = FUN_1000e770(&uStack_90,local_24);
    local_8 = (uint)local_8._1_3_ << 8;
    local_40 = local_54;
    FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                 (local_20 + 0x70));
    local_44 = local_24;
    operator_delete__(local_24);
    uStack_90 = 0x100035bf;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
    local_8 = 0xffffffff;
    FUN_1000eee0(&local_1c);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_100035f0 at 100035f0

void FUN_100035f0(int *param_1)

{
  longlong lVar1;
  int iVar2;
  wchar_t *_Filename;
  int *piVar3;
  char *pcVar4;
  undefined4 *puVar5;
  void *pvVar6;
  undefined4 *puVar7;
  size_t sVar8;
  int iVar9;
  ushort *puVar10;
  uint uVar11;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  short sVar12;
  undefined4 uVar13;
  short sVar14;
  undefined1 local_d8 [16];
  undefined1 local_c8 [16];
  undefined1 local_b8 [16];
  int *local_a8;
  int *local_a4;
  int *local_a0;
  int *local_9c;
  undefined1 *local_98;
  undefined1 *local_94;
  undefined1 *local_90;
  int *local_8c;
  undefined1 *local_88;
  undefined1 *local_84;
  int *local_80;
  undefined1 *local_7c;
  undefined4 *local_78;
  int *local_74;
  int *local_70;
  undefined4 *local_6c;
  wchar_t *local_68;
  undefined4 *local_64;
  int *local_60;
  wchar_t *local_5c;
  undefined4 *local_58;
  undefined4 *local_54;
  wchar_t *local_50;
  int *local_4c;
  wchar_t *local_48;
  int *local_44;
  wchar_t *local_40;
  wchar_t *local_3c;
  int *local_38;
  undefined4 *local_34;
  wchar_t *local_30;
  wchar_t *local_2c;
  wchar_t *local_28;
  int local_24;
  int local_20;
  int local_1c;
  char local_15;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a0ba;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  iVar2 = FUN_10014db0(param_1);
  lVar1 = (ulonglong)(iVar2 + 0x32) * 2;
  local_50 = (wchar_t *)operator_new__(-(uint)((int)((ulonglong)lVar1 >> 0x20) != 0) | (uint)lVar1);
  local_28 = local_50;
  FUN_1000fd40(param_1);
  FUN_10015540(local_28,0x10031600);
  local_7c = &stack0xffffff18;
  local_a4 = FUN_1000e810(&stack0xffffff18,(int)local_28);
  local_8 = 0xffffffff;
  local_70 = local_a4;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (local_14 + 0x70));
  local_40 = local_28;
  operator_delete__(local_28);
  iVar2 = 4;
  _Filename = (wchar_t *)FUN_1000fd40(param_1);
  iVar2 = _waccess(_Filename,iVar2);
  if (iVar2 == -1) {
    piVar3 = _errno();
    pcVar4 = strerror(*piVar3);
    FUN_1000e770(&local_20,pcVar4);
    local_8 = 1;
    FUN_1000e000(&local_1c);
    local_8._0_1_ = 2;
    FUN_10011310(&local_1c,(IID *)&DAT_1002fea8,(LPUNKNOWN)0x0,0x17);
    puVar5 = (undefined4 *)FUN_1000e8d0(local_b8,param_1);
    local_8._0_1_ = 3;
    local_88 = &stack0xffffff18;
    uVar13 = extraout_ECX;
    local_78 = puVar5;
    local_6c = puVar5;
    local_a0 = FUN_1000e770(&stack0xffffff18,"fileName");
    local_8._0_1_ = 4;
    local_4c = local_a0;
    pvVar6 = (void *)FUN_1000fe50(&local_1c);
    local_8._0_1_ = 3;
    FUN_100105d0(pvVar6,uVar13,puVar5);
    local_8._0_1_ = 2;
    FUN_1000f240(local_b8);
    puVar7 = (undefined4 *)FUN_1000e8d0(local_c8,&local_20);
    local_8._0_1_ = 5;
    local_90 = &stack0xffffff18;
    puVar5 = puVar7;
    local_64 = puVar7;
    local_54 = puVar7;
    local_a8 = FUN_1000e770(&stack0xffffff18,"reason");
    local_8._0_1_ = 6;
    local_74 = local_a8;
    pvVar6 = (void *)FUN_1000fe50(&local_1c);
    local_8._0_1_ = 5;
    FUN_100105d0(pvVar6,puVar7,puVar5);
    local_8._0_1_ = 2;
    FUN_1000f240(local_c8);
    sVar8 = strlen(PTR_s_The_request_to_open_the_file__s_f_1003f050);
    iVar2 = FUN_10014db0(param_1);
    iVar9 = FUN_10014db0(&local_20);
    lVar1 = (ulonglong)(sVar8 + iVar2 + 1 + iVar9) * 2;
    local_5c = (wchar_t *)
               operator_new__(-(uint)((int)((ulonglong)lVar1 >> 0x20) != 0) | (uint)lVar1);
    local_2c = local_5c;
    FUN_1000fd40(&local_20);
    FUN_1000fd40(param_1);
    FUN_10015540(local_2c,0x10031658);
    FUN_1000fc70(&local_1c);
    local_98 = &stack0xffffff08;
    local_80 = FUN_1000e810(&stack0xffffff08,(int)local_2c);
    local_8._0_1_ = 2;
    local_44 = local_80;
    FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                 (local_14 + 0x70));
    local_48 = local_2c;
    operator_delete__(local_2c);
    FUN_10025510((uchar *)"SubFileComponent.cpp");
    local_8 = CONCAT31(local_8._1_3_,1);
    FUN_1000eee0(&local_1c);
    local_8 = 0xffffffff;
    FUN_1000f220(&local_20);
  }
  sVar14 = 1;
  sVar12 = 3;
  puVar10 = (ushort *)FUN_1000fd40(param_1);
  uVar11 = FUN_10021c70(puVar10,sVar12,sVar14);
  local_15 = (char)uVar11;
  if (local_15 == '\0') {
    FUN_1000e000(&local_24);
    local_8 = 8;
    FUN_10011310(&local_24,(IID *)&DAT_1002fea8,(LPUNKNOWN)0x0,0x17);
    puVar5 = (undefined4 *)FUN_1000e8d0(local_d8,param_1);
    local_8._0_1_ = 9;
    local_84 = &stack0xffffff18;
    uVar13 = extraout_ECX_00;
    local_58 = puVar5;
    local_34 = puVar5;
    local_8c = FUN_1000e770(&stack0xffffff18,"fileName");
    local_8._0_1_ = 10;
    local_60 = local_8c;
    pvVar6 = (void *)FUN_1000fe50(&local_24);
    local_8._0_1_ = 9;
    FUN_100105d0(pvVar6,uVar13,puVar5);
    local_8._0_1_ = 8;
    FUN_1000f240(local_d8);
    sVar8 = strlen(PTR_s_The_CRC_of_the_file__s_is_incorr_1003f04c);
    iVar2 = FUN_10014db0(param_1);
    lVar1 = (ulonglong)(sVar8 + 1 + iVar2) * 2;
    local_68 = (wchar_t *)
               operator_new__(-(uint)((int)((ulonglong)lVar1 >> 0x20) != 0) | (uint)lVar1);
    local_30 = local_68;
    FUN_1000fd40(param_1);
    FUN_10015540(local_30,0x10031798);
    FUN_1000fc70(&local_24);
    local_94 = &stack0xffffff08;
    local_9c = FUN_1000e810(&stack0xffffff08,(int)local_30);
    local_8 = CONCAT31(local_8._1_3_,8);
    local_38 = local_9c;
    FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                 (local_14 + 0x70));
    local_3c = local_30;
    operator_delete__(local_30);
    FUN_10025510((uchar *)"SubFileComponent.cpp");
    local_8 = 0xffffffff;
    FUN_1000eee0(&local_24);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10003ab0 at 10003ab0

void __thiscall
FUN_10003ab0(void *this,
            basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1)

{
  char cVar1;
  bool bVar2;
  char *pcVar3;
  int iVar4;
  CHAR local_18 [4];
  undefined2 local_14;
  undefined2 local_12;
  int local_10;
  void *local_c;
  char local_5;
  
  local_c = this;
  cVar1 = FUN_10004ba0(this,param_1);
  if (cVar1 == '\0') {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_5 = '\0';
  pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
           operator[](param_1,0);
  if (*pcVar3 == 'B') {
    local_14 = 0;
    local_12 = 0;
    FUN_10013320(param_1,&local_14,4,3,0x20);
    FUN_1000f4c0((void *)((int)local_c + 0xa4),(LPCSTR)&local_14);
  }
  else {
    pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](param_1,0);
    if (*pcVar3 == '*') {
      pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](param_1,1);
      local_10 = *pcVar3 + -0x42;
      switch(*pcVar3) {
      case 'B':
        bVar2 = FUN_1000f840((void *)((int)local_c + 0xa4),(int *)&DAT_100403e4);
        if (bVar2) {
          local_5 = '\x01';
        }
        else {
          bVar2 = FUN_1000f840((void *)((int)local_c + 0xa4),(int *)&DAT_100403e0);
          if (((bVar2) ||
              (bVar2 = FUN_1000f840((void *)((int)local_c + 0xa4),(int *)&DAT_100403dc), bVar2)) ||
             (bVar2 = FUN_1000f840((void *)((int)local_c + 0xa4),(int *)&DAT_100403ec), bVar2)) {
            if (*(int *)((int)local_c + 0x44) != 2) {
              local_5 = '\x01';
            }
          }
          else if (*(int *)((int)local_c + 0x44) != 3) {
            local_5 = '\x01';
          }
        }
        break;
      case 'C':
        FUN_10002cf0(local_c,(_String_val<struct_std::_Simple_types<char>_> *)param_1,
                     (int)local_c + 0x40,(int)local_c + 0x44);
        break;
      case 'D':
        if (*(int *)((int)local_c + 0x44) == 3) {
          iVar4 = FUN_10014db0((int *)((int)local_c + 0xa4));
          if (iVar4 == 0) {
            local_18[0] = '\0';
            local_18[1] = '\0';
            local_18[2] = '\0';
            local_18[3] = '\0';
            FUN_10013320(param_1,local_18,4,3,10);
            FUN_1000f4c0((void *)((int)local_c + 0xa4),local_18);
          }
          bVar2 = FUN_1000f840((void *)((int)local_c + 0xa4),(int *)&DAT_100403e4);
          if (bVar2) {
            *(uint *)((int)local_c + 0xb0) = 5 - (uint)*(byte *)((int)local_c + 0xa8);
          }
        }
        else {
          local_5 = '\x01';
        }
        break;
      default:
        pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                 operator[](param_1,0);
        if (*pcVar3 != 'B') {
          local_5 = '\x01';
        }
        break;
      case 'F':
        if (*(int *)((int)local_c + 0x44) == 3) {
          local_5 = '\x01';
        }
        break;
      case 'G':
        if (*(int *)((int)local_c + 0x44) != 3) {
          local_5 = '\x01';
        }
        break;
      case 'H':
      case 'L':
      case 'R':
      case 'T':
      case 'V':
      }
    }
  }
  if (local_5 != '\0') {
    FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  return;
}



// Function: FUN_10003d70 at 10003d70

void FUN_10003d70(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                  *param_1)

{
  char *pcVar1;
  int iVar2;
  size_t sVar3;
  uint uVar4;
  char *pcVar5;
  int *piVar6;
  int *piVar7;
  int local_80;
  int local_7c;
  int local_78;
  uint local_74;
  int local_70;
  int local_6c;
  uint local_68;
  int local_64;
  void *local_60;
  char local_5c [84];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  FUN_100026c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
  local_6c = 0;
  local_64 = 0;
  local_5c[0] = '\0';
  memset(local_5c + 1,0,0x52);
  pcVar1 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
           operator[](param_1,0);
  if (*pcVar1 == ':') {
    piVar7 = &local_64;
    piVar6 = &local_6c;
    pcVar5 = ":%4X%4X";
    pcVar1 = (char *)FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
    iVar2 = sscanf(pcVar1,pcVar5,piVar6,piVar7);
    if (iVar2 != 2) {
      FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
    iVar2 = FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
    strcpy(local_5c,(char *)(iVar2 + 9));
  }
  else {
    pcVar1 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](param_1,0);
    if (*pcVar1 == '+') {
      piVar7 = &local_64;
      piVar6 = &local_6c;
      pcVar5 = "+%8X%8X";
      pcVar1 = (char *)FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
      iVar2 = sscanf(pcVar1,pcVar5,piVar6,piVar7);
      if (iVar2 != 2) {
        FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
        FUN_10025510((uchar *)"SubFileComponent.cpp");
      }
      iVar2 = FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
      strcpy(local_5c,(char *)(iVar2 + 0x11));
    }
  }
  sVar3 = strlen(local_5c);
  local_74 = sVar3 - 2;
  local_68 = local_74;
  if (0x52 < local_74) {
    ___report_rangecheckfailure();
  }
  local_5c[local_74] = '\0';
  uVar4 = local_68 & 0x80000001;
  if ((int)uVar4 < 0) {
    uVar4 = (uVar4 - 1 | 0xfffffffe) + 1;
  }
  if (uVar4 != 0) {
    FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_70 = (int)local_68 / 2;
  if ((*(int *)((int)local_60 + 0x94) == -1) || (*(int *)((int)local_60 + 0x9c) == -1)) {
    *(int *)((int)local_60 + 0x98) = local_64;
    *(int *)((int)local_60 + 0x94) = local_6c;
    *(int *)((int)local_60 + 0x9c) = local_64 + local_70;
  }
  else if ((*(int *)((int)local_60 + 0x94) == local_6c) &&
          (*(int *)((int)local_60 + 0x9c) == local_64)) {
    *(int *)((int)local_60 + 0x9c) = (int)local_68 / 2 + *(int *)((int)local_60 + 0x9c);
  }
  else {
    FUN_10007150((int)local_60);
    *(int *)((int)local_60 + 0x98) = local_64;
    *(int *)((int)local_60 + 0x94) = local_6c;
    *(int *)((int)local_60 + 0x9c) = local_64 + local_70;
  }
  local_80 = local_70;
  local_78 = local_64;
  local_7c = local_6c;
  uVar4 = FUN_10004660(local_60,&local_7c,&local_78,&local_80,-1);
  if ((uVar4 & 0xff) == 1) {
    FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)param_1);
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  FUN_10006e20(local_60,local_5c,local_68);
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10004050 at 10004050

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __thiscall FUN_10004050(void *this,int *param_1)

{
  bool bVar1;
  int *piVar2;
  _String_val<struct_std::_Simple_types<char>_> *p_Var3;
  char *_Source;
  int iVar4;
  undefined4 uVar5;
  byte *pbVar6;
  uint uVar7;
  ushort uVar8;
  short sVar9;
  undefined1 local_101c [4];
  undefined1 local_1018 [4];
  int local_1014;
  void *local_1010;
  char local_100c [4100];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_1010 = this;
  bVar1 = FUN_10014a80((int *)((int)this + 0x58));
  if (bVar1) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  CSubFileComponent_FinalConstruct(local_1010);
  FUN_10002e00((int *)((int)local_1010 + 0x58));
  FUN_1000de10(&local_1014);
  piVar2 = (int *)FID_conflict_begin((void *)((int)local_1010 + 0x58),local_1018);
  local_1014 = *piVar2;
  while( true ) {
    piVar2 = (int *)FID_conflict_begin((void *)((int)local_1010 + 0x58),local_101c);
    bVar1 = FID_conflict_operator__(&local_1014,piVar2);
    if (!bVar1) break;
    p_Var3 = (_String_val<struct_std::_Simple_types<char>_> *)FUN_1000ffb0(&local_1014);
    _Source = (char *)FUN_100146c0(p_Var3);
    strcpy(local_100c,_Source);
    FUN_100033d0(param_1,local_100c);
    sVar9 = 1;
    iVar4 = FUN_1000ffb0(&local_1014);
    uVar5 = FUN_10014d60(iVar4);
    uVar8 = (ushort)uVar5;
    p_Var3 = (_String_val<struct_std::_Simple_types<char>_> *)FUN_1000ffb0(&local_1014);
    pbVar6 = (byte *)FUN_100146c0(p_Var3);
    uVar7 = FUN_10023760((uint)*(ushort *)((int)local_1010 + 0x38),pbVar6,uVar8,sVar9);
    *(short *)((int)local_1010 + 0x38) = (short)uVar7;
    FUN_10010050(&local_1014);
  }
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100041c0 at 100041c0

void FUN_100041c0(int *param_1)

{
  bool bVar1;
  int *piVar2;
  int *piVar3;
  undefined4 *puVar4;
  IUnknown *pIVar5;
  undefined4 uVar6;
  uint uVar7;
  undefined4 extraout_ECX;
  int *piVar8;
  _GUID *p_Var9;
  int *piVar10;
  undefined1 local_d0 [4];
  undefined1 *local_cc;
  undefined1 local_c8 [4];
  undefined1 local_c4 [8];
  int local_bc;
  void *local_b4;
  int local_b0;
  int local_ac;
  int *local_a8;
  int local_a4;
  int local_a0;
  int local_9c;
  int local_98;
  int local_94;
  int local_90;
  int local_8c;
  int local_88;
  int local_84;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_80 [24];
  byte local_68 [84];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a0f6;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_ac = 0;
  FUN_10001e90(local_c4);
  local_8 = 0;
  local_a4 = 0;
  local_88 = 0;
  local_94 = 0;
  local_90 = 0;
  local_9c = 0;
  local_98 = 0;
  *(undefined4 *)(local_84 + 0xac) = 4;
  *(undefined1 *)(local_84 + 0xa8) = 0;
  *(undefined4 *)(local_84 + 0xb0) = 6;
  FUN_1000ddd0(&local_8c);
  piVar2 = (int *)FID_conflict_begin((void *)(local_84 + 0x4c),local_d0);
  local_8c = *piVar2;
  while( true ) {
    piVar2 = (int *)FID_conflict_begin((void *)(local_84 + 0x4c),local_c8);
    bVar1 = FID_conflict_operator__(&local_8c,piVar2);
    if (!bVar1) break;
    local_94 = 0;
    local_88 = 0;
    piVar2 = &local_88;
    piVar10 = &local_90;
    piVar8 = &local_94;
    piVar3 = (int *)FUN_1000ff90(&local_8c);
    local_cc = &stack0xffffff18;
    uVar6 = extraout_ECX;
    local_b4 = FUN_1000d830(&stack0xffffff18,piVar3);
    local_8 = local_8 & 0xffffff00;
    FUN_10005fb0(uVar6,piVar8,piVar10,piVar2);
    FUN_10002250(local_c4);
    puVar4 = (undefined4 *)FUN_1000ff90(&local_8c);
    local_a8 = (int *)FUN_1000fd70(puVar4);
    local_ac = (**(code **)(*local_a8 + 0x34))();
    local_a0 = local_ac;
    if (local_ac < 0) {
      p_Var9 = (_GUID *)&DAT_1002f4e0;
      puVar4 = (undefined4 *)FUN_1000ff90(&local_8c);
      pIVar5 = (IUnknown *)FUN_1000fbf0(puVar4);
      _com_issue_errorex(local_a0,pIVar5,p_Var9);
    }
    local_88 = *(int *)(local_bc + 0x10);
    Ordinal_23();
    local_9c = 0;
    basic_string<>(local_80);
    local_8._0_1_ = 2;
    while (0 < local_88) {
      if (local_88 < 0x21) {
        local_b0 = local_88;
      }
      else {
        local_b0 = 0x20;
      }
      local_98 = local_b0;
      FUN_10005980(local_a4 + local_9c,local_b0,local_80);
      if ((local_94 < 0x10000) && (local_90 < 0x10000)) {
        uVar6 = FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)local_80);
        sprintf((char *)local_68,":%04X%04X%s",local_94,local_90,uVar6);
      }
      else {
        uVar6 = FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)local_80);
        sprintf((char *)local_68,"+%08X%08X%s",local_94,local_90,uVar6);
      }
      local_88 = local_88 - local_98;
      local_9c = local_9c + local_98;
      local_90 = local_90 + local_98;
      FUN_100237d0((char *)local_68,0);
      FUN_100033d0(param_1,(char *)local_68);
      uVar7 = FUN_10023760((uint)*(ushort *)(local_84 + 0x38),local_68,0,1);
      *(short *)(local_84 + 0x38) = (short)uVar7;
    }
    Ordinal_24(local_bc);
    local_8 = (uint)local_8._1_3_ << 8;
    ~basic_string<>(local_80);
    FUN_10010030(&local_8c);
  }
  local_8 = 0xffffffff;
  FUN_100020f0(local_c4);
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10004580 at 10004580

/* WARNING: Type propagation algorithm not settling */

undefined1 __thiscall FUN_10004580(void *this,undefined4 param_1,int param_2)

{
  bool bVar1;
  undefined4 uVar2;
  int *piVar3;
  int *piVar4;
  int *piVar5;
  int *piVar6;
  int local_24 [3];
  void *local_18;
  undefined1 local_12;
  undefined1 local_11;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002a12e;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  local_18 = this;
  bVar1 = FUN_10014a50((int *)((int)this + 0x4c));
  if (bVar1) {
    local_11 = 0;
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&param_1);
  }
  else {
    local_24[2] = 0;
    local_24[0] = 0;
    local_24[1] = 0;
    piVar3 = local_24 + 2;
    piVar5 = local_24 + 1;
    piVar4 = local_24;
    piVar6 = piVar3;
    FUN_1000d830(&stack0xffffffbc,&param_1);
    local_8 = local_8 & 0xffffff00;
    FUN_10005fb0(piVar3,piVar4,piVar5,piVar6);
    uVar2 = FUN_10004660(local_18,local_24,local_24 + 1,local_24 + 2,param_2);
    local_12 = (undefined1)uVar2;
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&param_1);
    local_11 = local_12;
  }
  ExceptionList = local_10;
  return local_11;
}



// Function: FUN_10004660 at 10004660

undefined4 __thiscall FUN_10004660(void *this,int *param_1,int *param_2,int *param_3,int param_4)

{
  bool bVar1;
  undefined4 uVar2;
  int iVar3;
  void *pvVar4;
  int *piVar5;
  uint uVar6;
  undefined4 *puVar7;
  undefined3 extraout_var;
  int *piVar8;
  undefined4 extraout_ECX;
  int *piVar9;
  int *piVar10;
  undefined1 local_44 [4];
  undefined4 local_40;
  undefined1 local_3c [4];
  undefined4 local_38;
  void *local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  void *local_18;
  undefined1 local_12;
  byte local_11;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a151;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_12 = 0;
  local_18 = this;
  bVar1 = FUN_10014a50((int *)((int)this + 0x4c));
  if (bVar1) {
    uVar2 = 0;
  }
  else {
    FUN_1000e2c0(&local_20);
    local_2c = 0;
    local_1c = 0;
    local_28 = 0;
    local_11 = 1;
    local_24 = size((int *)((int)local_18 + 0x4c));
    local_24 = local_24 + -1;
    local_30 = 0;
    if ((param_4 != -1) && (iVar3 = size((int *)((int)local_18 + 0x4c)), param_4 < iVar3)) {
      local_30 = size((int *)((int)local_18 + 0x4c));
      local_30 = local_30 - param_4;
      local_24 = local_30;
    }
    puVar7 = &local_38;
    iVar3 = local_30;
    pvVar4 = FUN_10015390((void *)((int)local_18 + 0x4c),local_3c);
    piVar5 = FID_conflict_operator_(pvVar4,puVar7,iVar3);
    local_20 = *piVar5;
    while (uVar6 = (uint)local_11, uVar6 == 1) {
      puVar7 = &local_40;
      iVar3 = local_24;
      pvVar4 = FUN_10015390((void *)((int)local_18 + 0x4c),local_44);
      puVar7 = FID_conflict_operator_(pvVar4,puVar7,iVar3);
      bVar1 = operator!=<>(&local_20,puVar7);
      uVar6 = CONCAT31(extraout_var,bVar1);
      if (!bVar1) break;
      piVar5 = &local_28;
      piVar10 = &local_1c;
      piVar9 = &local_2c;
      piVar8 = (int *)FUN_1000ff40(&local_20);
      uVar2 = extraout_ECX;
      local_34 = FUN_1000d830(&stack0xffffffa0,piVar8);
      local_8 = 0xffffffff;
      FUN_10005fb0(uVar2,piVar9,piVar10,piVar5);
      if (*param_1 == local_2c) {
        if (((local_1c < *param_2) && (*param_2 < local_1c + local_28)) ||
           ((*param_2 < local_1c && (local_1c < *param_2 + *param_3)))) {
          local_12 = 1;
          local_11 = 0;
        }
        else if ((local_1c < *param_2) && (local_1c + local_28 < *param_2)) {
          local_11 = 0;
        }
      }
      else if (local_2c < *param_1) {
        local_11 = 0;
      }
      FUN_10010070(&local_20);
    }
    uVar2 = CONCAT31((int3)(uVar6 >> 8),local_12);
  }
  ExceptionList = local_10;
  return uVar2;
}



// Function: FUN_10004850 at 10004850

undefined1 __thiscall FUN_10004850(void *this,undefined4 param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  void *pvVar3;
  int *piVar4;
  undefined4 *puVar5;
  int *piVar6;
  undefined4 extraout_ECX;
  undefined4 uVar7;
  int *piVar8;
  int *piVar9;
  undefined1 local_5c [4];
  undefined4 local_58;
  undefined1 local_54 [4];
  undefined4 local_50;
  void *local_4c;
  undefined1 *local_48;
  void *local_44;
  void *local_40;
  int local_3c;
  int local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  void *local_18;
  undefined1 local_14;
  undefined1 local_13;
  undefined1 local_12;
  char local_11;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002a184;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  local_18 = this;
  bVar1 = FUN_10014a50((int *)((int)this + 0x4c));
  if (bVar1) {
    local_13 = 0;
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&param_1);
  }
  else {
    local_12 = 0;
    FUN_1000e2c0(&local_1c);
    local_30 = 0;
    local_24 = 0;
    local_38 = 0;
    local_3c = 0;
    local_2c = 0;
    local_20 = 0;
    local_11 = '\x01';
    piVar4 = &local_3c;
    piVar9 = &local_20;
    piVar8 = &local_2c;
    local_48 = &stack0xffffff88;
    piVar6 = piVar4;
    local_4c = FUN_1000d830(&stack0xffffff88,&param_1);
    local_8 = local_8 & 0xffffff00;
    local_40 = local_4c;
    FUN_10005fb0(piVar4,piVar8,piVar9,piVar6);
    local_28 = size((int *)((int)local_18 + 0x4c));
    local_28 = local_28 + -1;
    local_34 = 0;
    if ((param_2 != -1) && (iVar2 = size((int *)((int)local_18 + 0x4c)), param_2 < iVar2)) {
      local_34 = size((int *)((int)local_18 + 0x4c));
      local_34 = local_34 - param_2;
      local_28 = local_34;
    }
    puVar5 = &local_50;
    iVar2 = local_34;
    pvVar3 = FUN_10015390((void *)((int)local_18 + 0x4c),local_54);
    piVar4 = FID_conflict_operator_(pvVar3,puVar5,iVar2);
    local_1c = *piVar4;
    while (local_11 == '\x01') {
      puVar5 = &local_58;
      iVar2 = local_28;
      pvVar3 = FUN_10015390((void *)((int)local_18 + 0x4c),local_5c);
      puVar5 = FID_conflict_operator_(pvVar3,puVar5,iVar2);
      bVar1 = operator!=<>(&local_1c,puVar5);
      if (!bVar1) break;
      piVar4 = &local_38;
      piVar9 = &local_24;
      piVar8 = &local_30;
      piVar6 = (int *)FUN_1000ff40(&local_1c);
      uVar7 = extraout_ECX;
      local_44 = FUN_1000d830(&stack0xffffff88,piVar6);
      local_8 = local_8 & 0xffffff00;
      FUN_10005fb0(uVar7,piVar8,piVar9,piVar4);
      if (local_2c == local_30) {
        if ((local_20 == local_24 + local_38) || (local_20 + local_3c == local_24)) {
          local_12 = 1;
          local_11 = '\0';
        }
        else if (local_24 < local_20) {
          local_11 = '\0';
        }
      }
      else if (local_30 < local_2c) {
        local_11 = '\0';
      }
      FUN_10010070(&local_1c);
    }
    local_14 = local_12;
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&param_1);
    local_13 = local_14;
  }
  ExceptionList = local_10;
  return local_13;
}



// Function: FUN_10004a80 at 10004a80

undefined1 __thiscall FUN_10004a80(void *this,int param_1,int param_2,int param_3,int param_4)

{
  int *piVar1;
  int *piVar2;
  int *piVar3;
  int *piVar4;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  void *local_18;
  undefined1 local_12;
  undefined1 local_11;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a1af;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_11 = 0;
  local_18 = this;
  if (param_4 == -1) {
    param_4 = FUN_10004f80(param_1,param_2);
    if (param_4 == -1) {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
  }
  piVar1 = (int *)FUN_1000fb90((void *)((int)local_18 + 0x4c),param_4);
  FUN_1000d830(&local_28,piVar1);
  local_8 = 0;
  local_20 = 0;
  local_24 = 0;
  local_1c = 0;
  piVar1 = &local_24;
  piVar3 = &local_20;
  piVar2 = &local_1c;
  piVar4 = piVar1;
  FUN_1000d830(&stack0xffffffb8,&local_28);
  local_8 = local_8 & 0xffffff00;
  FUN_10005fb0(piVar1,piVar2,piVar3,piVar4);
  if ((param_1 == local_1c) && (local_20 + local_24 < param_2 + param_3)) {
    local_11 = 1;
  }
  local_12 = local_11;
  local_8 = 0xffffffff;
  FID_conflict__bad_alloc(&local_28);
  ExceptionList = local_10;
  return local_12;
}



// Function: FUN_10004ba0 at 10004ba0

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __thiscall
FUN_10004ba0(void *this,
            basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1)

{
  byte bVar1;
  int iVar2;
  char *pcVar3;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar4;
  uint uVar5;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_1044 [24];
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_102c [24];
  char local_1014;
  undefined1 local_1013 [4095];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a1eb;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  iVar2 = FUN_10015520((int *)((int)this + 0x58));
  if ((iVar2 == 0) &&
     (pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](param_1,0), *pcVar3 != 'B')) {
    local_1014 = '\0';
    memset(local_1013,0,0xfff);
    sprintf(&local_1014,
            "CSubFileComponent::IsInSequence - Business Header Record missing.                          Form file :%s  From File no. : %d"
           );
    FUN_100254a0((uchar *)"SubFileComponent.cpp");
  }
  if (*(int *)((int)this + 0x44) == 3) {
    uVar5 = 0;
    pbVar4 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
             std::
             basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>::
             back((basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>
                   *)((int)this + 0x58));
    pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](pbVar4,uVar5);
    if (*pcVar3 == '*') {
      uVar5 = 1;
      pbVar4 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
               std::
               basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>
               ::back((basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>
                       *)((int)this + 0x58));
      pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](pbVar4,uVar5);
      if (*pcVar3 == 'B') goto LAB_10004f57;
    }
  }
  pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
           operator[](param_1,0);
  if (*pcVar3 != 'B') {
    pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](param_1,1);
    if (*pcVar3 == 'C') {
      iVar2 = FUN_10015520((int *)((int)this + 0x58));
      if (iVar2 == 0) {
        FUN_1000e770(&stack0xffffef88,
                     "Business Header Record missing. As Business Header Record is optional              for ECI so this Subfile is expected as an ECI subfile"
                    );
        local_8 = 0xffffffff;
        FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                     ((int)this + 0x70));
        *(undefined1 *)((int)this + 0xa8) = 1;
        FUN_1000f480((void *)((int)this + 0xa4),(int *)&DAT_100403e4);
      }
    }
    else {
      pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](param_1,1);
      if (((*pcVar3 != 'H') &&
          (pcVar3 = std::
                    basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                    operator[](param_1,1), *pcVar3 != 'V')) &&
         (pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                   ::operator[](param_1,1), *pcVar3 != 'R')) {
        pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                 operator[](param_1,1);
        if (*pcVar3 == 'D') {
          bVar1 = *(byte *)((int)this + 0xa8);
          pbVar4 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
                   FUN_1000fbb0((void *)((int)this + 0x58),-(uint)bVar1 + 4);
          std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
          basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                    (local_102c,pbVar4);
          local_8 = 1;
          pbVar4 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
                   FUN_1000fbb0((void *)((int)this + 0x58),-(uint)bVar1 + 5);
          std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
          basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                    (local_1044,pbVar4);
          local_8 = CONCAT31(local_8._1_3_,2);
          pcVar3 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                   ::operator[](local_102c,1);
          if (*pcVar3 == 'L') {
            std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
            operator[](local_1044,1);
          }
          local_8 = CONCAT31(local_8._1_3_,1);
          ~basic_string<>(local_1044);
          local_8 = 0xffffffff;
          ~basic_string<>(local_102c);
        }
        else {
          FUN_10015520((int *)((int)this + 0x58));
        }
      }
    }
  }
  FUN_10015520((int *)((int)this + 0x58));
LAB_10004f57:
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10004f80 at 10004f80

int FUN_10004f80(int param_1,int param_2)

{
  bool bVar1;
  int *piVar2;
  int *piVar3;
  uint uVar4;
  undefined4 extraout_ECX;
  undefined4 uVar5;
  int *piVar6;
  int *piVar7;
  undefined1 local_40 [4];
  void *local_3c;
  undefined1 *local_38;
  undefined1 local_34 [4];
  undefined1 local_30 [4];
  void *local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a21b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_1c = 0;
  FUN_1000ddd0(&local_14);
  local_24 = 0;
  local_20 = 0;
  local_28 = 0;
  piVar2 = (int *)FID_conflict_begin((void *)(local_18 + 0x4c),local_30);
  local_14 = *piVar2;
  while( true ) {
    piVar2 = (int *)FID_conflict_begin((void *)(local_18 + 0x4c),local_34);
    bVar1 = FID_conflict_operator__(&local_14,piVar2);
    if (!bVar1) break;
    piVar2 = &local_28;
    piVar7 = &local_20;
    piVar6 = &local_24;
    piVar3 = (int *)FUN_1000ff90(&local_14);
    local_38 = &stack0xffffffac;
    uVar5 = extraout_ECX;
    local_3c = FUN_1000d830(&stack0xffffffac,piVar3);
    local_8 = 0xffffffff;
    local_2c = local_3c;
    FUN_10005fb0(uVar5,piVar6,piVar7,piVar2);
    if (((param_1 == local_24) && (local_20 <= param_2)) && (param_2 <= local_20 + local_28)) break;
    FUN_10010030(&local_14);
    local_1c = local_1c + 1;
  }
  piVar2 = (int *)FID_conflict_begin((void *)(local_18 + 0x4c),local_40);
  uVar4 = FID_conflict_operator__(&local_14,piVar2);
  if ((uVar4 & 0xff) != 0) {
    local_1c = -1;
  }
  ExceptionList = local_10;
  return local_1c;
}



// Function: FUN_100050b0 at 100050b0

int FUN_100050b0(void)

{
  undefined4 *extraout_EAX;
  undefined4 *puVar1;
  int *piVar2;
  undefined4 uVar3;
  undefined4 extraout_ECX;
  undefined4 extraout_var;
  int iVar4;
  undefined1 local_68 [4];
  undefined4 local_64;
  undefined4 local_60;
  void *local_5c;
  undefined1 *local_58;
  void *local_54;
  undefined1 *local_50;
  void *local_4c;
  undefined1 *local_48;
  void *local_44;
  undefined1 *local_40;
  int local_3c;
  int *local_38;
  void *local_30;
  void *local_2c;
  void *local_28;
  void *local_24;
  int *local_20;
  int local_1c;
  void *local_18;
  char local_13;
  char local_12;
  char local_11;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002a25e;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  local_1c = 0;
  iVar4 = -1;
  local_40 = &stack0xffffff8c;
  local_44 = FUN_1000d830(&stack0xffffff8c,(int *)&stack0x00000004);
  local_8 = local_8 & 0xffffff00;
  local_24 = local_44;
  local_11 = FUN_10004580(local_18,extraout_var,iVar4);
  if (local_11 == '\x01') {
    local_1c = 2;
  }
  if (local_1c == 0) {
    iVar4 = -1;
    local_48 = &stack0xffffff8c;
    uVar3 = extraout_ECX;
    local_4c = FUN_1000d830(&stack0xffffff8c,(int *)&stack0x00000004);
    local_8 = local_8 & 0xffffff00;
    local_28 = local_4c;
    local_12 = FUN_10004850(local_18,uVar3,iVar4);
    if (local_12 == '\x01') {
      local_50 = &stack0xffffff90;
      local_54 = FUN_1000d830(&stack0xffffff90,(int *)&stack0x00000004);
      local_8 = local_8 & 0xffffff00;
      local_2c = local_54;
      local_13 = FUN_10005250();
      if (local_13 == '\x01') {
        local_1c = 1;
      }
    }
  }
  if (local_1c == 0) {
    FUN_1000ddd0(&local_20);
    local_58 = &stack0xffffff90;
    local_5c = FUN_1000d830(&stack0xffffff90,(int *)&stack0x00000004);
    local_8 = local_8 & 0xffffff00;
    local_30 = local_5c;
    FUN_10005530((int)local_18,&local_60);
    local_38 = (int *)*extraout_EAX;
    local_20 = local_38;
    puVar1 = FUN_10014d30((void *)((int)local_18 + 0x4c),&local_64,local_38,(int *)&stack0x00000004)
    ;
    local_20 = (int *)*puVar1;
    piVar2 = (int *)FID_conflict_begin((void *)((int)local_18 + 0x4c),local_68);
    uVar3 = FID_conflict_operator_(&local_20,piVar2);
    *(undefined4 *)((int)local_18 + 0x48) = uVar3;
  }
  local_3c = local_1c;
  local_8 = 0xffffffff;
  FID_conflict__bad_alloc((int *)&stack0x00000004);
  ExceptionList = local_10;
  return local_3c;
}



// Function: FUN_10005250 at 10005250

undefined1 FUN_10005250(void)

{
  bool bVar1;
  char cVar2;
  int *piVar3;
  void *pvVar4;
  int *piVar5;
  int iVar6;
  undefined4 extraout_ECX;
  int *piVar7;
  undefined4 uVar8;
  int *piVar9;
  undefined1 local_8c [4];
  undefined1 local_88 [4];
  undefined1 *local_84;
  undefined1 local_80 [4];
  undefined1 *local_7c;
  undefined1 local_78 [4];
  undefined1 *local_74;
  undefined1 local_70 [4];
  undefined1 local_6c [4];
  undefined1 local_68 [4];
  void *local_64;
  void *local_60;
  void *local_5c;
  void *local_58;
  void *local_54;
  void *local_50;
  int local_4c;
  void *local_48;
  int local_44;
  int local_40;
  void *local_3c;
  int local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  undefined1 local_1d;
  int local_1c;
  int local_18;
  undefined1 local_12;
  char local_11;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002a2ba;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  local_12 = 0;
  FUN_1000e2c0(&local_1c);
  local_28 = 0;
  local_24 = 0;
  local_38 = 0;
  local_34 = 0;
  local_30 = 0;
  local_2c = 0;
  local_11 = '\x01';
  piVar3 = &local_34;
  piVar7 = &local_2c;
  piVar9 = &local_30;
  piVar5 = piVar7;
  local_5c = FUN_1000d830(&stack0xffffff44,(int *)&stack0x00000004);
  local_8 = local_8 & 0xffffff00;
  FUN_10005fb0(piVar7,piVar9,piVar5,piVar3);
  piVar3 = (int *)FUN_10015390((void *)(local_18 + 0x4c),local_6c);
  local_1c = *piVar3;
  while (local_11 == '\x01') {
    pvVar4 = FUN_100153c0((void *)(local_18 + 0x4c),local_8c);
    bVar1 = operator!=<>(&local_1c,pvVar4);
    if (!bVar1) break;
    piVar3 = &local_38;
    piVar7 = &local_24;
    piVar9 = &local_28;
    piVar5 = (int *)FUN_1000ff40(&local_1c);
    local_74 = &stack0xffffff44;
    uVar8 = extraout_ECX;
    local_60 = FUN_1000d830(&stack0xffffff44,piVar5);
    local_8 = local_8 & 0xffffff00;
    local_50 = local_60;
    FUN_10005fb0(uVar8,piVar9,piVar7,piVar3);
    if (local_30 == local_28) {
      if (local_2c + local_34 == local_24) {
        piVar3 = (int *)FUN_1000ff40(&local_1c);
        local_7c = &stack0xffffff50;
        local_48 = FUN_1000d830(&stack0xffffff50,piVar3);
        local_8._0_1_ = 3;
        local_84 = &stack0xffffff4c;
        local_64 = FUN_1000d830(&stack0xffffff4c,(int *)&stack0x00000004);
        local_8 = (uint)local_8._1_3_ << 8;
        local_58 = local_64;
        FUN_100028f0();
        piVar3 = &local_1c;
        pvVar4 = FUN_100153c0((void *)(local_18 + 0x4c),local_68);
        iVar6 = operator-<>(pvVar4,piVar3);
        iVar6 = iVar6 + -1;
        piVar3 = &local_44;
        local_40 = iVar6;
        pvVar4 = FID_conflict_begin((void *)(local_18 + 0x4c),local_70);
        FID_conflict_operator_(pvVar4,piVar3,iVar6);
        local_4c = local_44;
        FUN_10014c50((void *)(local_18 + 0x4c),local_78,local_44);
        piVar3 = (int *)FUN_10015390((void *)(local_18 + 0x4c),local_80);
        local_1c = *piVar3;
        pvVar4 = FUN_100153c0((void *)(local_18 + 0x4c),local_88);
        cVar2 = operator==<>(&local_1c,pvVar4);
        if (cVar2 != '\0') break;
      }
      else if (local_2c == local_24 + local_38) {
        local_54 = FUN_1000d830(&stack0xffffff50,(int *)&stack0x00000004);
        local_8._0_1_ = 5;
        piVar3 = (int *)FUN_1000ff40(&local_1c);
        local_3c = FUN_1000d830(&stack0xffffff4c,piVar3);
        local_8 = (uint)local_8._1_3_ << 8;
        FUN_100028f0();
        local_12 = 1;
        local_11 = '\0';
      }
    }
    else if (local_28 < local_30) {
      local_11 = '\0';
    }
    FUN_10010070(&local_1c);
  }
  local_1d = local_12;
  local_8 = 0xffffffff;
  FID_conflict__bad_alloc((int *)&stack0x00000004);
  ExceptionList = local_10;
  return local_1d;
}



// Function: FUN_10005530 at 10005530

/* WARNING: Variable defined which should be unmapped: param_2 */

undefined4 * __thiscall FUN_10005530(int param_1,undefined4 *param_2)

{
  bool bVar1;
  int *piVar2;
  void *pvVar3;
  IUnknown *pIVar4;
  int iVar5;
  int *piVar6;
  int *piVar7;
  undefined4 *puVar8;
  _GUID *p_Var9;
  undefined1 local_68 [4];
  undefined1 local_64 [4];
  undefined1 local_60 [4];
  undefined1 local_5c [4];
  void *local_58;
  undefined1 *local_54;
  undefined4 local_50;
  undefined4 local_4c;
  void *local_48;
  undefined4 local_44;
  int local_40;
  int local_3c;
  long local_38;
  int *local_34;
  long local_30;
  int *local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002a2f0;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  local_14 = param_1;
  bVar1 = FUN_10014a50((int *)(param_1 + 0x4c));
  if (bVar1) {
    FID_conflict_begin((void *)(local_14 + 0x4c),param_2);
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc((int *)&stack0x00000008);
  }
  else {
    local_20 = 0;
    local_28 = 0;
    local_40 = 0;
    local_50 = 0;
    local_44 = 0;
    local_24 = 0;
    local_3c = 0;
    FUN_1000d8f0(&local_18);
    local_8._0_1_ = 1;
    puVar8 = &local_44;
    piVar2 = &local_3c;
    piVar6 = &local_24;
    local_54 = &stack0xffffff84;
    piVar7 = piVar6;
    local_58 = FUN_1000d830(&stack0xffffff84,(int *)&stack0x00000008);
    local_8 = CONCAT31(local_8._1_3_,1);
    local_48 = local_58;
    FUN_10005fb0(piVar6,piVar7,piVar2,puVar8);
    FUN_1000e2c0(&local_1c);
    piVar2 = (int *)FUN_10015390((void *)(local_14 + 0x4c),local_5c);
    local_1c = *piVar2;
    while( true ) {
      pvVar3 = FUN_100153c0((void *)(local_14 + 0x4c),local_60);
      bVar1 = operator!=<>(&local_1c,pvVar3);
      if (!bVar1) break;
      piVar2 = (int *)FUN_1000ff40(&local_1c);
      FUN_1000f350(piVar2);
      local_2c = (int *)FUN_1000fd70(&local_18);
      local_30 = (**(code **)(*local_2c + 0x1c))();
      local_20 = local_30;
      if (local_30 < 0) {
        p_Var9 = (_GUID *)&DAT_1002f4e0;
        pIVar4 = (IUnknown *)FUN_1000fbf0(&local_18);
        _com_issue_errorex(local_30,pIVar4,p_Var9);
      }
      if (local_28 < local_24) break;
      if (local_24 == local_28) {
        local_34 = (int *)FUN_1000fd70(&local_18);
        local_38 = (**(code **)(*local_34 + 0x24))();
        local_20 = local_38;
        if (local_38 < 0) {
          p_Var9 = (_GUID *)&DAT_1002f4e0;
          pIVar4 = (IUnknown *)FUN_1000fbf0(&local_18);
          _com_issue_errorex(local_38,pIVar4,p_Var9);
        }
        if (local_40 < local_3c) break;
      }
      FUN_10010070(&local_1c);
    }
    piVar2 = &local_1c;
    pvVar3 = FUN_100153c0((void *)(local_14 + 0x4c),local_64);
    iVar5 = operator-<>(pvVar3,piVar2);
    puVar8 = &local_4c;
    pvVar3 = FID_conflict_begin((void *)(local_14 + 0x4c),local_68);
    FID_conflict_operator_(pvVar3,puVar8,iVar5);
    *param_2 = local_4c;
    local_8 = local_8 & 0xffffff00;
    FID_conflict__bad_alloc(&local_18);
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc((int *)&stack0x00000008);
  }
  ExceptionList = local_10;
  return param_2;
}



// Function: FUN_10005780 at 10005780

void __thiscall FUN_10005780(void *this,int *param_1)

{
  char local_5c [84];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  sprintf(local_5c,"*E%04X",(uint)*(ushort *)((int)this + 0x38));
  FUN_100237d0(local_5c,0);
  FUN_100033d0(param_1,local_5c);
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100057e0 at 100057e0

void FUN_100057e0(int param_1,uint param_2,int param_3)

{
  bool bVar1;
  uint uVar2;
  uint uVar3;
  char acStackY_70 [28];
  undefined4 uStackY_54;
  uint local_44;
  
  uVar2 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  bVar1 = true;
  local_44 = 0;
  do {
    if ((!bVar1) || (param_2 <= local_44)) {
      __security_check_cookie(uVar2 ^ (uint)&stack0xfffffffc);
      return;
    }
    uStackY_54 = 0x1000590c;
    uVar3 = FUN_10014cc0((char *)(param_1 + local_44 * 2));
    if ((uVar3 & 0xff) == 0) {
LAB_1000595d:
      bVar1 = false;
    }
    else {
      uStackY_54 = 0x10005926;
      uVar3 = FUN_10014cc0((char *)(param_1 + 1 + local_44 * 2));
      if ((uVar3 & 0xff) == 0) goto LAB_1000595d;
      *(char *)(param_3 + local_44) =
           *(char *)((int)&PTR_DAT_1003331c + (int)*(char *)(param_1 + local_44 * 2)) +
           acStackY_70[*(char *)(param_1 + 1 + local_44 * 2)];
    }
    local_44 = local_44 + 1;
  } while( true );
}



// Function: FUN_10005980 at 10005980

void FUN_10005980(int param_1,int param_2,
                 basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                 *param_3)

{
  ushort local_8;
  
  for (local_8 = 0; (int)(uint)local_8 < param_2; local_8 = local_8 + 1) {
    (&DAT_10040408)[(uint)local_8 * 2] =
         (&DAT_10033388)[(uint)*(byte *)(param_1 + (uint)local_8) * 4];
    (&DAT_10040409)[(uint)local_8 * 2] =
         (&DAT_10033389)[(uint)*(byte *)(param_1 + (uint)local_8) * 4];
  }
  if (0x52 < (uint)local_8 * 2) {
    ___report_rangecheckfailure();
  }
  (&DAT_10040408)[(uint)local_8 * 2] = 0;
  std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::operator=
            (param_3,&DAT_10040408);
  return;
}



// Function: FUN_10005a30 at 10005a30

void FUN_10005a30(refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  IUnknown *pIVar1;
  void *this;
  LPCSTR in_stack_0000001c;
  IID *in_stack_00000024;
  LPCSTR in_stack_00000028;
  int *piVar2;
  _GUID *p_Var3;
  int local_40;
  refcount_ptr<struct_boost::exception_detail::error_info_container> *local_3c;
  refcount_ptr<struct_boost::exception_detail::error_info_container> *local_38;
  undefined4 local_34;
  int *local_30;
  int *local_2c;
  ULONG local_28;
  int *local_24;
  long local_20;
  int local_1c;
  ULONG local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002a343;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  local_18 = 0;
  FUN_1000df90(&local_14);
  local_8._0_1_ = 1;
  local_2c = FUN_1000e770(&stack0xffffff98,in_stack_0000001c);
  local_8._0_1_ = 2;
  local_30 = FUN_1000e770(&stack0xffffff90,in_stack_00000028);
  local_8._0_1_ = 3;
  local_34 = boost::exception_detail::
             refcount_ptr<struct_boost::exception_detail::error_info_container>::
             refcount_ptr<struct_boost::exception_detail::error_info_container>
                       ((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                        &stack0xffffff8c,
                        (refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                        &stack0x00000018);
  local_8._0_1_ = 4;
  piVar2 = &local_40;
  FUN_1000fdf0((int *)param_1);
  local_8._0_1_ = 1;
  local_3c = (refcount_ptr<struct_boost::exception_detail::error_info_container> *)
             FUN_10010d60(piVar2);
  local_8._0_1_ = 5;
  local_38 = local_3c;
  FUN_1000c070(&local_14,local_3c);
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_1000ee40(&local_40);
  local_20 = local_18;
  if ((int)local_18 < 0) {
    p_Var3 = (_GUID *)&DAT_1002f440;
    pIVar1 = (IUnknown *)FUN_1000fc50((undefined4 *)param_1);
    _com_issue_errorex(local_20,pIVar1,p_Var3);
  }
  if (in_stack_00000024 != (IID *)0x0) {
    this = (void *)FUN_1000fdc0(&local_14);
    FUN_100129a0(this,in_stack_00000024);
  }
  local_24 = (int *)FUN_1000fdc0(&local_14);
  (**(code **)(*local_24 + 0x38))();
  FUN_1000bd50(&local_1c,param_1);
  local_8 = CONCAT31(local_8._1_3_,6);
  FUN_1000fc40(&local_14);
  pIVar1 = (IUnknown *)FUN_1000fe20(&local_1c);
  local_28 = FUN_10012960(pIVar1);
  local_18 = local_28;
  if ((int)local_28 < 0) {
    p_Var3 = (_GUID *)&DAT_1002f450;
    pIVar1 = (IUnknown *)FUN_1000fc60(&local_1c);
    _com_issue_errorex(local_28,pIVar1,p_Var3);
  }
  local_8._0_1_ = 1;
  FUN_1000eec0(&local_1c);
  local_8 = (uint)local_8._1_3_ << 8;
  FUN_1000ee80(&local_14);
  local_8 = 0xffffffff;
  FUN_1000f220((int *)&stack0x00000018);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10005c00 at 10005c00

void FUN_10005c00(refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  void *this;
  undefined4 uVar1;
  IUnknown *pIVar2;
  int *piVar3;
  _GUID *p_Var4;
  refcount_ptr<struct_boost::exception_detail::error_info_container> local_40 [4];
  int *local_3c;
  int *local_38;
  int local_34;
  refcount_ptr<struct_boost::exception_detail::error_info_container> *local_30;
  refcount_ptr<struct_boost::exception_detail::error_info_container> *local_2c;
  ULONG local_28;
  long local_24;
  int *local_20;
  int local_1c;
  int local_18;
  ULONG local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002a386;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  local_14 = 0;
  piVar3 = &local_34;
  this = (void *)FUN_1000fdf0((int *)param_1);
  local_30 = (refcount_ptr<struct_boost::exception_detail::error_info_container> *)
             FUN_10011550(this,piVar3);
  local_8._0_1_ = 1;
  local_2c = local_30;
  FUN_1000bdf0(&local_18,local_30);
  local_8._0_1_ = 3;
  FUN_1000ef20(&local_34);
  local_20 = (int *)FUN_1000fdc0(&local_18);
  local_3c = (int *)boost::exception_detail::
                    refcount_ptr<struct_boost::exception_detail::error_info_container>::
                    refcount_ptr<struct_boost::exception_detail::error_info_container>
                              (local_40,(refcount_ptr<struct_boost::exception_detail::error_info_container>
                                         *)&stack0x00000014);
  local_8._0_1_ = 4;
  local_38 = local_3c;
  uVar1 = FUN_1000fce0(local_3c);
  local_14 = (**(code **)(*local_20 + 0x50))(local_20,uVar1);
  local_8 = CONCAT31(local_8._1_3_,3);
  FUN_1000f220((int *)local_40);
  local_24 = local_14;
  if ((int)local_14 < 0) {
    p_Var4 = (_GUID *)&DAT_10030614;
    pIVar2 = (IUnknown *)FUN_1000fc40(&local_18);
    _com_issue_errorex(local_24,pIVar2,p_Var4);
  }
  FUN_1000bd50(&local_1c,param_1);
  local_8 = CONCAT31(local_8._1_3_,5);
  FUN_1000fc40(&local_18);
  pIVar2 = (IUnknown *)FUN_1000fe20(&local_1c);
  local_28 = FUN_10012960(pIVar2);
  local_14 = local_28;
  if ((int)local_28 < 0) {
    p_Var4 = (_GUID *)&DAT_1002f450;
    pIVar2 = (IUnknown *)FUN_1000fc60(&local_1c);
    _com_issue_errorex(local_28,pIVar2,p_Var4);
  }
  local_8._0_1_ = 3;
  FUN_1000eec0(&local_1c);
  local_8 = (uint)local_8._1_3_ << 8;
  FUN_1000ee80(&local_18);
  local_8 = 0xffffffff;
  FUN_1000f220((int *)&stack0x00000014);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10005d80 at 10005d80

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void FUN_10005d80(char *param_1,void *param_2)

{
  char *pcVar1;
  CHAR local_2010 [4100];
  char local_100c [4100];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  pcVar1 = strstr(param_1,PTR_s_CalibrationVersion_1003f0c0);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = strstr(param_1,PTR_s_<calibration_version>_1003f0c4);
    if (pcVar1 != (char *)0x0) {
      sscanf(param_1,"%[^>]>%[^<]",local_100c,local_2010);
      FUN_1000f4c0(param_2,local_2010);
    }
  }
  else {
    strcpy(local_100c,param_1);
    strtok(local_100c,"=");
    pcVar1 = strtok((char *)0x0,"=");
    FUN_1000f4c0(param_2,pcVar1);
  }
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10005e70 at 10005e70

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void FUN_10005e70(char *param_1,void *param_2)

{
  char *pcVar1;
  CHAR local_2010;
  undefined1 local_200f [4099];
  char local_100c;
  undefined1 local_100b [4099];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_100c = '\0';
  memset(local_100b,0,0x1000);
  local_2010 = '\0';
  memset(local_200f,0,0x1000);
  pcVar1 = strstr(param_1,PTR_s_FileDescriptor_1003f0c8);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = strstr(param_1,PTR_s_<file_descriptor>_1003f0cc);
    if (pcVar1 != (char *)0x0) {
      sscanf(param_1,"%[^>]>%[^<]",&local_100c,&local_2010);
      FUN_1000f4c0(param_2,&local_2010);
    }
  }
  else {
    strcpy(&local_100c,param_1);
    strtok(&local_100c,"=");
    pcVar1 = strtok((char *)0x0,"=");
    FUN_1000f4c0(param_2,pcVar1);
  }
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10005fb0 at 10005fb0

void FUN_10005fb0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  IUnknown *pIVar4;
  _GUID *p_Var5;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002a3a9;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  piVar2 = (int *)FUN_1000fd70(&param_1);
  iVar3 = (**(code **)(*piVar2 + 0x1c))(piVar2,param_2,uVar1);
  if (iVar3 < 0) {
    p_Var5 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0(&param_1);
    _com_issue_errorex(iVar3,pIVar4,p_Var5);
  }
  piVar2 = (int *)FUN_1000fd70(&param_1);
  iVar3 = (**(code **)(*piVar2 + 0x24))(piVar2,param_3);
  if (iVar3 < 0) {
    p_Var5 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0(&param_1);
    _com_issue_errorex(iVar3,pIVar4,p_Var5);
  }
  piVar2 = (int *)FUN_1000fd70(&param_1);
  iVar3 = (**(code **)(*piVar2 + 0x2c))(piVar2,param_4);
  if (iVar3 < 0) {
    p_Var5 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0(&param_1);
    _com_issue_errorex(iVar3,pIVar4,p_Var5);
  }
  local_8 = 0xffffffff;
  FID_conflict__bad_alloc(&param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_100060d0 at 100060d0

char * FUN_100060d0(undefined4 *param_1,char *param_2)

{
  switch(*param_1) {
  case 0xf0:
    strcpy(param_2,"Released");
    break;
  default:
    strcpy(param_2,"Unknown");
    break;
  case 0xfc:
    strcpy(param_2,"Obsolete");
    break;
  case 0xfd:
    strcpy(param_2,"Successfully assembled");
    break;
  case 0xfe:
    strcpy(param_2,"Passed rule check");
    break;
  case 0xff:
    strcpy(param_2,"Not released");
  }
  return param_2;
}



// Function: FUN_100061b0 at 100061b0

void FUN_100061b0(int *param_1,void *param_2,char param_3)

{
  int *piVar1;
  char *pcVar2;
  void *this;
  undefined4 *puVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 local_90 [7];
  undefined4 local_74 [4];
  undefined1 *local_64;
  int *local_60;
  int *local_5c;
  undefined1 *local_58;
  int *local_54;
  undefined1 *local_50;
  int *local_4c;
  int *local_48;
  int *local_44;
  int local_40;
  int local_3c;
  int local_38;
  void *local_34;
  char local_2d;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_2c [24];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a407;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_3c = 0;
  FUN_100025c0(&local_40,param_1);
  local_8 = 0;
  iVar4 = 0x400000;
  piVar1 = (int *)FUN_1000fca0(&local_40);
  FUN_1001f1f0(local_90,piVar1,iVar4);
  local_8._0_1_ = 1;
  local_2d = '\x01';
  basic_string<>(local_2c,"");
  local_8._0_1_ = 2;
  local_50 = &stack0xffffff64;
  local_60 = FUN_1000e770(&stack0xffffff64,"Loading header records");
  local_8 = CONCAT31(local_8._1_3_,2);
  local_4c = local_60;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               ((int)local_34 + 0x70));
  *(undefined4 *)((int)local_34 + 0xac) = 4;
  *(undefined1 *)((int)local_34 + 0xa8) = 0;
  *(undefined4 *)((int)local_34 + 0xb0) = 6;
  while (local_2d != '\0') {
    local_3c = FUN_1001fa80(local_90,local_2c);
    if (local_3c < 0) {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
    pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_2c,0);
    if ((*pcVar2 == '*') &&
       (pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                 operator[](local_2c,1), *pcVar2 == 'E')) {
      FUN_1000e000(&local_38);
      local_8._0_1_ = 4;
      FUN_10011310(&local_38,(IID *)&DAT_1002fea8,(LPUNKNOWN)0x0,0x17);
      FUN_1000e8d0(local_74,param_1);
      local_8._0_1_ = 5;
      puVar3 = local_74;
      local_58 = &stack0xffffff64;
      puVar5 = puVar3;
      local_5c = FUN_1000e770(&stack0xffffff64,"fileName");
      local_8._0_1_ = 6;
      local_48 = local_5c;
      this = (void *)FUN_1000fe50(&local_38);
      local_8._0_1_ = 5;
      FUN_100105d0(this,puVar3,puVar5);
      local_8._0_1_ = 4;
      FUN_1000f240(local_74);
      FUN_1000fc70(&local_38);
      local_64 = &stack0xffffff54;
      local_54 = FUN_1000e770(&stack0xffffff54,"EOF record found before data record");
      local_8._0_1_ = 4;
      local_44 = local_54;
      FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                   ((int)local_34 + 0x70));
      local_2d = '\0';
      local_8 = CONCAT31(local_8._1_3_,2);
      FUN_1000eee0(&local_38);
    }
    else {
      pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](local_2c,0);
      if ((*pcVar2 == ':') ||
         (pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                   ::operator[](local_2c,0), *pcVar2 == '+')) {
        local_2d = '\0';
      }
      else {
        if (param_3 != '\0') {
          FUN_10003ab0(local_34,local_2c);
        }
        FUN_10015280(param_2,local_2c);
      }
    }
  }
  local_8._0_1_ = 1;
  ~basic_string<>(local_2c);
  local_8 = (uint)local_8._1_3_ << 8;
  FUN_1000f0a0(local_90);
  local_8 = 0xffffffff;
  FUN_1000ef60(&local_40);
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10006470 at 10006470

void FUN_10006470(int *param_1)

{
  int *piVar1;
  char *pcVar2;
  int iVar3;
  undefined4 local_6c [7];
  undefined1 *local_50;
  int *local_4c;
  void *local_48;
  int *local_44;
  void *local_40;
  int local_3c;
  int local_38;
  int local_34;
  char local_2d;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_2c [24];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a44f;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_38 = 0;
  FUN_100025c0(&local_3c,param_1);
  local_8 = 0;
  iVar3 = 0x400000;
  piVar1 = (int *)FUN_1000fca0(&local_3c);
  FUN_1001f1f0(local_6c,piVar1,iVar3);
  local_8._0_1_ = 1;
  local_2d = '\x01';
  basic_string<>(local_2c);
  local_8._0_1_ = 2;
  local_50 = &stack0xffffff88;
  local_4c = FUN_1000e770(&stack0xffffff88,"Loading data records");
  local_8 = CONCAT31(local_8._1_3_,2);
  local_44 = local_4c;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (local_34 + 0x70));
  local_40 = operator_new__(*(uint *)(local_34 + 0xa0));
  *(void **)(local_34 + 0x8c) = local_40;
  if (*(int *)(local_34 + 0x8c) == 0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  while (local_2d != '\0') {
    local_38 = FUN_1001fa80(local_6c,local_2c);
    if (local_38 < 0) {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
    pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_2c,0);
    if ((*pcVar2 == ':') ||
       (pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                 operator[](local_2c,0), *pcVar2 == '+')) {
      FUN_10003d70(local_2c);
    }
    else {
      pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](local_2c,0);
      if ((*pcVar2 == '*') &&
         (pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                   ::operator[](local_2c,1), *pcVar2 == 'E')) {
        local_2d = '\0';
      }
    }
  }
  FUN_10007150(local_34);
  local_48 = *(void **)(local_34 + 0x8c);
  operator_delete__(local_48);
  local_8._0_1_ = 1;
  ~basic_string<>(local_2c);
  local_8 = (uint)local_8._1_3_ << 8;
  FUN_1000f0a0(local_6c);
  local_8 = 0xffffffff;
  FUN_1000ef60(&local_3c);
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10006680 at 10006680

/* WARNING: Type propagation algorithm not settling */

void FUN_10006680(void *param_1,void *param_2)

{
  bool bVar1;
  char cVar2;
  int *piVar3;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar4;
  char *pcVar5;
  undefined1 local_168 [4];
  undefined1 local_164 [4];
  int local_160;
  int local_15c;
  int local_158;
  int local_154 [2];
  void *local_14c;
  int local_148;
  int local_144;
  int local_140;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_13c [24];
  char local_124 [256];
  char local_24 [16];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a4b6;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_1000de10(&local_140);
  basic_string<>(local_13c);
  local_8 = 0;
  piVar3 = (int *)FID_conflict_begin(param_1,local_168);
  local_140 = *piVar3;
  while( true ) {
    piVar3 = (int *)FID_conflict_begin(param_1,local_164);
    bVar1 = FID_conflict_operator__(&local_140,piVar3);
    if (!bVar1) break;
    pbVar4 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
             FUN_1000ffb0(&local_140);
    FID_conflict_operator_(local_13c,pbVar4);
    pcVar5 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_13c,0);
    if ((*pcVar5 == '*') &&
       (pcVar5 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                 operator[](local_13c,1), *pcVar5 == 'C')) {
      local_154[1] = 0;
      local_148 = 0;
      FUN_10002cf0(local_14c,(_String_val<struct_std::_Simple_types<char>_> *)local_13c,
                   local_154 + 1,&local_148);
      local_24[0] = '\0';
      local_24[1] = '\0';
      local_24[2] = '\0';
      local_24[3] = '\0';
      local_24[4] = '\0';
      local_24[5] = '\0';
      local_24[6] = '\0';
      local_24[7] = '\0';
      local_24[8] = '\0';
      local_24[9] = '\0';
      local_24[10] = '\0';
      local_24[0xb] = '\0';
      local_24[0xc] = '\0';
      local_24[0xd] = '\0';
      local_24[0xe] = '\0';
      local_24[0xf] = 0;
      sprintf(local_24," Type : %02X",local_148);
      FUN_1000e770(&local_160,local_24);
      local_8._0_1_ = 1;
      FUN_10010300(param_2,&local_160);
      local_8._0_1_ = 0;
      FUN_1000f220(&local_160);
      FUN_1000e770(&local_158,", Release level : ");
      local_8._0_1_ = 2;
      FUN_10010300(param_2,&local_158);
      local_8._0_1_ = 0;
      FUN_1000f220(&local_158);
      pcVar5 = FUN_100060d0(local_154 + 1,local_124);
      FUN_1000e770(&local_15c,pcVar5);
      local_8._0_1_ = 3;
      FUN_10010300(param_2,&local_15c);
      local_8 = (uint)local_8._1_3_ << 8;
      FUN_1000f220(&local_15c);
      if (local_148 != 3) break;
    }
    else {
      pcVar5 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](local_13c,1);
      if (*pcVar5 == 'G') {
        FUN_1000e8b0(&local_144);
        local_8._0_1_ = 4;
        piVar3 = &local_144;
        pcVar5 = (char *)FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)local_13c);
        cVar2 = FUN_10005e70(pcVar5,piVar3);
        if (cVar2 == '\x01') {
          FUN_1000e770(local_154," ");
          local_8._0_1_ = 5;
          FUN_10010300(param_2,local_154);
          local_8._0_1_ = 4;
          FUN_1000f220(local_154);
          FUN_10010300(param_2,&local_144);
        }
        local_8 = (uint)local_8._1_3_ << 8;
        FUN_1000f220(&local_144);
      }
    }
    FUN_10010050(&local_140);
  }
  local_8 = 0xffffffff;
  ~basic_string<>(local_13c);
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10006960 at 10006960

void FUN_10006960(void *param_1,void *param_2)

{
  bool bVar1;
  char cVar2;
  int *piVar3;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar4;
  char *pcVar5;
  void *pvVar6;
  undefined1 local_40 [4];
  undefined1 local_3c [8];
  int local_34;
  char local_2d;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_2c [24];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a4e6;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_1000de10(&local_34);
  local_2d = '\0';
  basic_string<>(local_2c);
  local_8 = 0;
  piVar3 = (int *)FID_conflict_begin(param_1,local_40);
  local_34 = *piVar3;
  do {
    piVar3 = (int *)FID_conflict_begin(param_1,local_3c);
    bVar1 = FID_conflict_operator__(&local_34,piVar3);
    if (!bVar1) {
LAB_10006a4b:
      if (local_2d == '\0') {
        FUN_10025510((uchar *)"SubFileComponent.cpp");
      }
      local_8 = 0xffffffff;
      ~basic_string<>(local_2c);
      ExceptionList = local_10;
      __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
      return;
    }
    pbVar4 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
             FUN_1000ffb0(&local_34);
    FID_conflict_operator_(local_2c,pbVar4);
    pcVar5 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_2c,1);
    if (*pcVar5 == 'R') {
      FUN_1000f480(param_2,(int *)&DAT_100403f0);
      local_2d = '\x01';
      goto LAB_10006a4b;
    }
    pcVar5 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_2c,1);
    if (*pcVar5 == 'G') {
      pvVar6 = param_2;
      pcVar5 = (char *)FUN_100146c0((_String_val<struct_std::_Simple_types<char>_> *)local_2c);
      cVar2 = FUN_10005d80(pcVar5,pvVar6);
      if (cVar2 == '\x01') {
        local_2d = '\x01';
      }
    }
    FUN_10010050(&local_34);
  } while( true );
}



// Function: FUN_10006aa0 at 10006aa0

void __thiscall FUN_10006aa0(void *this,void *param_1)

{
  uint uVar1;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar2;
  int iVar3;
  char *pcVar4;
  uint local_30;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_2c [24];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a513;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  basic_string<>(local_2c);
  local_8 = 0;
  local_30 = *(uint *)((int)this + 0xac);
  do {
    uVar1 = FUN_10015520((int *)((int)this + 0x58));
    if (uVar1 <= local_30) {
      local_8 = 0xffffffff;
      ~basic_string<>(local_2c);
      ExceptionList = local_10;
      __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
      return;
    }
    pbVar2 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
             FUN_1000fbd0(param_1,local_30);
    FID_conflict_operator_(local_2c,pbVar2);
    iVar3 = FUN_10014d60((int)local_2c);
    if (iVar3 == 0) {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
    pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_2c,1);
    if (*pcVar4 == 'D') {
LAB_10006b84:
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
    else {
      pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](local_2c,1);
      if (*pcVar4 == 'G') goto LAB_10006b84;
      pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](local_2c,1);
      if (*pcVar4 == 'B') goto LAB_10006b84;
    }
    local_30 = local_30 + 1;
  } while( true );
}



// Function: FUN_10006be0 at 10006be0

void __thiscall FUN_10006be0(void *this,void *param_1)

{
  uint uVar1;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar2;
  int iVar3;
  char *pcVar4;
  uint local_30;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_2c [24];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a540;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  basic_string<>(local_2c);
  local_8 = 0;
  local_30 = *(uint *)((int)this + 0xb0);
  while( true ) {
    local_30 = local_30 + 1;
    uVar1 = FUN_10015520((int *)((int)this + 0x58));
    if (uVar1 <= local_30) break;
    pbVar2 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
             FUN_1000fbd0(param_1,local_30);
    FID_conflict_operator_(local_2c,pbVar2);
    iVar3 = FUN_10014d60((int)local_2c);
    if (iVar3 == 0) {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
    pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_2c,1);
    if (*pcVar4 == 'G') {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
  }
  local_8 = 0xffffffff;
  ~basic_string<>(local_2c);
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10006d00 at 10006d00

void __thiscall FUN_10006d00(void *this,int *param_1)

{
  uint uVar1;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar2;
  int iVar3;
  char *pcVar4;
  uint local_30;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_2c [24];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a56d;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  basic_string<>(local_2c);
  local_8 = 0;
  local_30 = *(uint *)((int)this + 0xb0);
  while( true ) {
    local_30 = local_30 + 1;
    uVar1 = FUN_10015520(param_1);
    if (uVar1 <= local_30) break;
    pbVar2 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
             FUN_1000fbd0(param_1,local_30);
    FID_conflict_operator_(local_2c,pbVar2);
    iVar3 = FUN_10014d60((int)local_2c);
    if (iVar3 == 0) {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
    pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_2c,1);
    if (*pcVar4 == 'F') {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
  }
  local_8 = 0xffffffff;
  ~basic_string<>(local_2c);
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10006e20 at 10006e20

void __thiscall FUN_10006e20(void *this,void *param_1,size_t param_2)

{
  if (*(uint *)((int)this + 0xa0) <= *(int *)((int)this + 0x90) + param_2) {
    FUN_10007270((int)this);
  }
  memcpy((void *)(*(int *)((int)this + 0x8c) + *(int *)((int)this + 0x90)),param_1,param_2);
  *(size_t *)((int)this + 0x90) = *(int *)((int)this + 0x90) + param_2;
  *(undefined1 *)(*(int *)((int)this + 0x8c) + *(int *)((int)this + 0x90)) = 0;
  return;
}



// Function: FUN_10006ea0 at 10006ea0

void * FUN_10006ea0(void *param_1,undefined4 *param_2,undefined4 *param_3,int param_4,uint *param_5)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  IUnknown *pIVar4;
  uint uVar5;
  _GUID *p_Var6;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  uint local_54 [3];
  uint local_48;
  long local_44;
  int *local_40;
  long local_3c;
  int *local_38;
  int local_34;
  long local_30;
  int *local_2c;
  long local_28;
  int *local_24;
  long local_20;
  uint local_1c;
  int local_18;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  local_14 [4];
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a5bb;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_48 = 0;
  local_18 = 0;
  FUN_1000d8f0((undefined4 *)local_14);
  local_8 = 1;
  puVar3 = (undefined4 *)FUN_100101b0(local_14);
  local_20 = FUN_1000c3e0(puVar3);
  local_18 = local_20;
  if (local_20 < 0) {
    p_Var6 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0((undefined4 *)local_14);
    _com_issue_errorex(local_20,pIVar4,p_Var6);
  }
  local_24 = (int *)FUN_1000fd70((undefined4 *)local_14);
  local_28 = (**(code **)(*local_24 + 0x20))(local_24,*param_2);
  local_18 = local_28;
  if (local_28 < 0) {
    p_Var6 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0((undefined4 *)local_14);
    _com_issue_errorex(local_28,pIVar4,p_Var6);
  }
  local_2c = (int *)FUN_1000fd70((undefined4 *)local_14);
  local_30 = (**(code **)(*local_2c + 0x28))(local_2c,*param_3);
  local_18 = local_30;
  if (local_30 < 0) {
    p_Var6 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0((undefined4 *)local_14);
    _com_issue_errorex(local_30,pIVar4,p_Var6);
  }
  local_1c = *param_5 >> 1;
  FUN_10001e90(&local_64);
  local_8 = CONCAT31(local_8._1_3_,2);
  local_54[0] = local_1c;
  local_54[1] = 0;
  local_64 = CONCAT22(local_64._2_2_,0x2011);
  local_5c = Ordinal_15(0x11,1,local_54);
  local_34 = 0;
  Ordinal_23(local_5c,&local_34);
  uVar5 = FUN_100057e0(param_4,local_1c,local_34);
  if (uVar5 != local_1c) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  Ordinal_24(local_5c);
  uVar2 = local_5c;
  uVar1 = local_64;
  local_38 = (int *)FUN_1000fd70((undefined4 *)local_14);
  local_3c = (**(code **)(*local_38 + 0x38))(local_38,uVar1,local_60,uVar2,local_58);
  local_18 = local_3c;
  if (local_3c < 0) {
    p_Var6 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0((undefined4 *)local_14);
    _com_issue_errorex(local_3c,pIVar4,p_Var6);
  }
  local_40 = (int *)FUN_1000fd70((undefined4 *)local_14);
  local_44 = (**(code **)(*local_40 + 0x30))(local_40,local_1c);
  local_18 = local_44;
  if (local_44 < 0) {
    p_Var6 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0((undefined4 *)local_14);
    _com_issue_errorex(local_44,pIVar4,p_Var6);
  }
  local_8._0_1_ = 1;
  FUN_100020f0(&local_64);
  function<>(param_1,local_14);
  local_48 = local_48 | 1;
  local_8 = (uint)local_8._1_3_ << 8;
  FID_conflict__bad_alloc((int *)local_14);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10007150 at 10007150

void __fastcall FUN_10007150(int param_1)

{
  int iVar1;
  int local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a5e6;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (*(int *)(param_1 + 0x90) != 0) {
    local_14 = param_1;
    FUN_10006ea0(&local_18,(undefined4 *)(param_1 + 0x94),(undefined4 *)(param_1 + 0x98),
                 *(int *)(param_1 + 0x8c),(uint *)(param_1 + 0x90));
    local_8 = 0;
    FUN_1000d830(&stack0xffffffd0,&local_18);
    local_8 = local_8 & 0xffffff00;
    iVar1 = FUN_100050b0();
    if (iVar1 == 2) {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
    *(undefined4 *)(local_14 + 0x90) = 0;
    *(undefined4 *)(local_14 + 0x98) = 0xffffffff;
    *(undefined4 *)(local_14 + 0x94) = 0xffffffff;
    *(undefined4 *)(local_14 + 0x9c) = 0xffffffff;
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&local_18);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10007270 at 10007270

void __fastcall FUN_10007270(int param_1)

{
  void *_Dst;
  
  *(int *)(param_1 + 0xa0) = *(int *)(param_1 + 0xa0) + 0x100000;
  _Dst = operator_new__(*(uint *)(param_1 + 0xa0));
  if (_Dst == (void *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  memcpy(_Dst,*(void **)(param_1 + 0x8c),*(int *)(param_1 + 0xa0) - 0x100000);
  operator_delete__(*(void **)(param_1 + 0x8c));
  *(void **)(param_1 + 0x8c) = _Dst;
  return;
}



// Function: CSubFileComponent_FinalConstruct at 10007330

void __fastcall CSubFileComponent_FinalConstruct(void *param_1)

{
  bool bVar1;
  uint uVar2;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar3;
  char *pcVar4;
  int iVar5;
  undefined4 extraout_ECX;
  undefined4 uStack_68;
  CHAR local_40 [4];
  undefined2 local_3c;
  undefined2 local_3a;
  uint local_38;
  uint local_34;
  void *local_30;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_2c [24];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a611;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_30 = param_1;
  bVar1 = FUN_10014a80((int *)((int)param_1 + 0x58));
  if (bVar1) {
    uStack_68 = 0x1000738d;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_34 = 0;
  local_38 = 0;
  do {
    uVar2 = FUN_10015520((int *)((int)local_30 + 0x58));
    if (uVar2 <= local_38) {
LAB_100075d1:
      ExceptionList = local_10;
      __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
      return;
    }
    pbVar3 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
             FUN_1000fbb0((void *)((int)local_30 + 0x58),local_38);
    std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
    basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>(local_2c,pbVar3);
    local_8 = 0;
    if ((local_34 == 0) &&
       (pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                 operator[](local_2c,0), *pcVar4 != 'B')) {
      *(undefined1 *)((int)local_30 + 0xa8) = 1;
      uStack_68 = extraout_ECX;
      FUN_1000e770(&uStack_68,"Business Header Record not present and this is expected for ECI");
      local_8 = local_8 & 0xffffff00;
      FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                   ((int)local_30 + 0x70));
      FUN_1000f480((void *)((int)local_30 + 0xa4),(int *)&DAT_100403e4);
    }
    else {
      pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
               operator[](local_2c,local_34);
      if (*pcVar4 == 'B') {
        local_40[0] = '\0';
        local_40[1] = '\0';
        local_40[2] = '\0';
        local_40[3] = '\0';
        FUN_10013320(local_2c,local_40,4,3,0x20);
        FUN_1000f4c0((void *)((int)local_30 + 0xa4),local_40);
      }
      else {
        pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
                 operator[](local_2c,local_34);
        if (*pcVar4 == 'C') {
          FUN_10002cf0(local_30,(_String_val<struct_std::_Simple_types<char>_> *)local_2c,
                       (int)local_30 + 0x40,(int)local_30 + 0x44);
          iVar5 = FUN_10014db0((int *)((int)local_30 + 0xa4));
          if (iVar5 != 0) {
            local_8 = 0xffffffff;
            ~basic_string<>(local_2c);
            goto LAB_100075d1;
          }
        }
        else {
          pcVar4 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                   ::operator[](local_2c,local_34);
          if (*pcVar4 == 'D') {
            iVar5 = FUN_10014db0((int *)((int)local_30 + 0xa4));
            if (iVar5 == 0) {
              local_3c = 0;
              local_3a = 0;
              FUN_10013320(local_2c,&local_3c,4,3,10);
              FUN_1000f4c0((void *)((int)local_30 + 0xa4),(LPCSTR)&local_3c);
            }
            bVar1 = FUN_1000f840((void *)((int)local_30 + 0xa4),(int *)&DAT_100403e4);
            if (bVar1) {
              *(uint *)((int)local_30 + 0xb0) = 5 - (uint)*(byte *)((int)local_30 + 0xa8);
            }
            local_8 = 0xffffffff;
            ~basic_string<>(local_2c);
            goto LAB_100075d1;
          }
        }
      }
    }
    local_8 = 0xffffffff;
    ~basic_string<>(local_2c);
    local_38 = local_38 + 1;
    local_34 = 1;
  } while( true );
}



// Function: CSubFileComponent_FinalConstruct at 100075f0

void CSubFileComponent_FinalConstruct(int param_1)

{
  HMODULE pHVar1;
  int iVar2;
  IUnknown *pIVar3;
  LPCSTR pCVar4;
  LPCSTR pCVar5;
  _GUID *p_Var6;
  uint uStack_98;
  undefined4 local_60 [12];
  _String_val<struct_std::_Simple_types<char>_> local_30 [24];
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002a649;
  local_10 = ExceptionList;
  uStack_98 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_98;
  ExceptionList = &local_10;
  local_8 = 0;
  pCVar5 = (LPCSTR)0x0;
  pCVar4 = (LPCSTR)0x0;
  local_18 = uStack_98;
  pHVar1 = (HMODULE)FUN_10011ac0();
  FUN_10023970(local_60,pHVar1,pCVar4,pCVar5);
  local_8 = CONCAT31(local_8._1_3_,1);
  pCVar4 = (LPCSTR)FUN_100146c0(local_30);
  FUN_1000f4c0((void *)(param_1 + 0x34),pCVar4);
  iVar2 = FUN_10011190((void *)(param_1 + 0x6c),(IID *)&DAT_10030550,(LPUNKNOWN)0x0,0x17);
  if (iVar2 < 0) {
    p_Var6 = (_GUID *)&DAT_100304e0;
    pIVar3 = (IUnknown *)FUN_1000fc30((undefined4 *)(param_1 + 0x6c));
    _com_issue_errorex(iVar2,pIVar3,p_Var6);
  }
  iVar2 = FUN_10011250((void *)(param_1 + 0x70),(IID *)&DAT_1002fec8,(LPUNKNOWN)0x0,0x17);
  if (iVar2 < 0) {
    p_Var6 = (_GUID *)&DAT_1002f440;
    pIVar3 = (IUnknown *)FUN_1000fc50((undefined4 *)(param_1 + 0x70));
    _com_issue_errorex(iVar2,pIVar3,p_Var6);
  }
  local_8 = local_8 & 0xffffff00;
  FUN_10023a90(local_60);
  FUN_100077a9();
  return;
}



// Function: Catch@100076e7 at 100076e7

undefined * Catch_100076e7(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x74),"SubFileComponent.cpp",0x112,
                       "CSubFileComponent::FinalConstruct",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x70) = uVar2;
  return &DAT_100077c0;
}



// Function: Catch@10007733 at 10007733

undefined * Catch_10007733(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x84),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x84),"SubFileComponent.cpp",0x112,
                       "CSubFileComponent::FinalConstruct",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x6c) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x1000779d;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x84));
  return &DAT_100077b2;
}



// Function: FUN_100077a9 at 100077a9

void FUN_100077a9(void)

{
  uint unaff_EBP;
  undefined4 uStack0000000c;
  
  *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uStack0000000c = 0x100077e7;
  __security_check_cookie(*(uint *)(unaff_EBP - 0x14) ^ unaff_EBP);
  return;
}



// Function: CSubFileComponent_ReadFile at 100077f0

undefined4 CSubFileComponent_ReadFile(undefined4 param_1,int *param_2)

{
  int iVar1;
  uint local_8;
  
  local_8 = 0;
  while( true ) {
    if (3 < local_8) {
      return 1;
    }
    iVar1 = FUN_100022c0((int *)(&PTR_DAT_1003f164)[local_8],param_2);
    if (iVar1 != 0) break;
    local_8 = local_8 + 1;
  }
  return 0;
}



// Function: CSubFileComponent_ReadFile at 10007840

void CSubFileComponent_ReadFile(int param_1,int param_2)

{
  uint uStack_78;
  undefined1 local_58 [12];
  int *local_4c;
  undefined1 *local_48;
  int *local_44;
  undefined1 *local_40;
  int *local_3c;
  undefined1 *local_38;
  undefined4 local_34;
  int *local_24;
  int *local_20;
  int *local_1c;
  int local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a6a1;
  local_10 = ExceptionList;
  uStack_78 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_78;
  ExceptionList = &local_10;
  FUN_1000db90(local_58,param_1 + 0x70);
  local_34 = 0;
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  *(undefined4 *)(param_1 + 0x8c) = 0;
  *(undefined4 *)(param_1 + 0x94) = 0xffffffff;
  *(undefined4 *)(param_1 + 0x90) = 0xffffffff;
  *(undefined4 *)(param_1 + 0x98) = 0xffffffff;
  FUN_10014760((_Container_base0 *)(param_1 + 0x48));
  FUN_100147a0((_Container_base0 *)(param_1 + 0x54));
  *(undefined4 *)(param_1 + 0x44) = 0xffffffff;
  *(undefined4 *)(param_1 + 0x40) = 0;
  *(undefined4 *)(param_1 + 0x3c) = 0;
  FUN_1000f4c0((void *)(param_1 + 0x60),"");
  FUN_1000f4c0((void *)(param_1 + 100),"Cummins Subfile");
  *(undefined2 *)(param_1 + 0x34) = 0;
  FUN_1000f570((void *)(param_1 + 0xb0),param_2);
  local_38 = &stack0xffffff80;
  local_3c = FUN_1000e770(&stack0xffffff80,"The file read process has begun");
  local_8._0_1_ = 1;
  local_1c = local_3c;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (param_1 + 0x6c));
  FUN_1000e810(&local_18,param_2);
  local_8._0_1_ = 3;
  FUN_100035f0(&local_18);
  local_40 = &stack0xffffff80;
  local_44 = FUN_1000e770(&stack0xffffff80,"Starting to read the file");
  local_8 = CONCAT31(local_8._1_3_,3);
  local_20 = local_44;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (param_1 + 0x6c));
  FUN_100061b0(&local_18,(void *)(param_1 + 0x54),'\x01');
  FUN_10002e00((int *)(param_1 + 0x54));
  FUN_10006680((void *)(param_1 + 0x54),(void *)(param_1 + 100));
  if (*(int *)(param_1 + 0x40) == 3) {
    FUN_10006960((void *)(param_1 + 0x54),(void *)(param_1 + 0x60));
  }
  FUN_10006470(&local_18);
  local_48 = &stack0xffffff80;
  local_4c = FUN_1000e770(&stack0xffffff80,"The file read process has completed successfully.");
  local_8._1_3_ = (undefined3)((uint)local_8 >> 8);
  local_8._0_1_ = 3;
  local_24 = local_4c;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (param_1 + 0x6c));
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_1000f220(&local_18);
  CSubFileComponent_WriteFile();
  return;
}



// Function: Catch@10007a97 at 10007a97

undefined * Catch_10007a97(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x4c),"SubFileComponent.cpp",0x14f,
                       "CSubFileComponent::ReadFile",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x28) = uVar2;
  return &DAT_10007b6f;
}



// Function: Catch@10007ae3 at 10007ae3

undefined * Catch_10007ae3(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -100),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 7;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -100),"SubFileComponent.cpp",0x14f,
                       "CSubFileComponent::ReadFile",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x24) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 6;
  uStack0000001c = 0x10007b44;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -100));
  return &DAT_10007b59;
}



// Function: CSubFileComponent_WriteFile at 10007b50

undefined4 CSubFileComponent_WriteFile(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x2c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x54));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x2c);
}



// Function: CSubFileComponent_WriteFile at 10007bb0

void CSubFileComponent_WriteFile(int param_1,int param_2)

{
  wchar_t *pwVar1;
  IUnknown *pIVar2;
  void *pvVar3;
  int *piVar4;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar5;
  undefined4 extraout_ECX_01;
  undefined4 uVar6;
  int iVar7;
  _GUID *p_Var8;
  void **ppvVar9;
  uint uStack_bc;
  undefined1 local_40 [8];
  ULONG local_38;
  ULONG local_30;
  long local_2c;
  int *local_28;
  long local_24;
  refcount_ptr<struct_boost::exception_detail::error_info_container> local_20 [4];
  int local_1c;
  refcount_ptr<struct_boost::exception_detail::error_info_container> local_18 [4];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a71a;
  local_10 = ExceptionList;
  uStack_bc = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_bc;
  ExceptionList = &local_10;
  FUN_1000db90(local_40,param_1 + 0x70);
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  FUN_1000e770(&stack0xffffff3c,"Starting to write the file.");
  local_8._0_1_ = 1;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (param_1 + 0x6c));
  FUN_1000e810(local_20,param_2);
  local_8 = CONCAT31(local_8._1_3_,3);
  iVar7 = 0;
  pwVar1 = (wchar_t *)FUN_1000fd40((int *)local_20);
  iVar7 = _waccess(pwVar1,iVar7);
  if (iVar7 != -1) {
    iVar7 = 2;
    pwVar1 = (wchar_t *)FUN_1000fd40((int *)local_20);
    iVar7 = _waccess(pwVar1,iVar7);
    if (iVar7 == -1) {
      FUN_10025510((uchar *)"SubFileComponent.cpp");
    }
  }
  FUN_1000e050((undefined4 *)local_18);
  local_8 = CONCAT31(local_8._1_3_,4);
  local_24 = FUN_100113d0(local_18,(IID *)&DAT_100304ac,(LPUNKNOWN)0x0,0x17);
  uVar5 = extraout_ECX;
  if (local_24 < 0) {
    p_Var8 = (_GUID *)&DAT_10030458;
    pIVar2 = (IUnknown *)FUN_1000fc80((undefined4 *)local_18);
    _com_issue_errorex(local_24,pIVar2,p_Var8);
    uVar5 = extraout_ECX_00;
  }
  ppvVar9 = (void **)0x1;
  boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
  refcount_ptr<struct_boost::exception_detail::error_info_container>
            ((refcount_ptr<struct_boost::exception_detail::error_info_container> *)&stack0xffffff3c,
             local_20);
  local_8._0_1_ = 5;
  pvVar3 = (void *)FUN_1000fe80((int *)local_18);
  local_8 = CONCAT31(local_8._1_3_,4);
  local_2c = FUN_10012590(pvVar3,uVar5,ppvVar9);
  if (local_2c < 0) {
    p_Var8 = (_GUID *)&DAT_10030458;
    pIVar2 = (IUnknown *)FUN_1000fc80((undefined4 *)local_18);
    _com_issue_errorex(local_2c,pIVar2,p_Var8);
  }
  FUN_1000e120(&local_1c);
  local_8._0_1_ = 6;
  FUN_1000c100(&local_1c,local_18);
  *(undefined2 *)(param_1 + 0x34) = 0;
  FUN_1000e770(&stack0xffffff3c,"Writing header records.");
  local_8._0_1_ = 6;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (param_1 + 0x6c));
  piVar4 = (int *)FUN_1000fca0(&local_1c);
  FUN_10004050((void *)(param_1 + -4),piVar4);
  FUN_1000e770(&stack0xffffff3c,"Writing data records.");
  local_8._0_1_ = 6;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (param_1 + 0x6c));
  piVar4 = (int *)FUN_1000fca0(&local_1c);
  FUN_100041c0(piVar4);
  piVar4 = (int *)FUN_1000fca0(&local_1c);
  FUN_10005780((void *)(param_1 + -4),piVar4);
  local_28 = (int *)FUN_1000ff10(&local_1c);
  (**(code **)(*local_28 + 0x20))();
  uVar6 = 1;
  uVar5 = extraout_ECX_01;
  FUN_1000e770(&stack0xffffff34,"");
  local_8._0_1_ = 9;
  pvVar3 = (void *)FUN_1000fe80((int *)local_18);
  local_8 = CONCAT31(local_8._1_3_,6);
  local_38 = FUN_10012bd0(pvVar3,uVar5,uVar6);
  local_30 = local_38;
  if ((int)local_38 < 0) {
    p_Var8 = (_GUID *)&DAT_10030458;
    pIVar2 = (IUnknown *)FUN_1000fc80((undefined4 *)local_18);
    _com_issue_errorex(local_30,pIVar2,p_Var8);
  }
  FUN_1000e770(&stack0xffffff34,"The file write process has completed successfully.");
  local_8._1_3_ = (undefined3)((uint)local_8 >> 8);
  local_8._0_1_ = 6;
  FUN_10005c00((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
               (param_1 + 0x6c));
  local_8._0_1_ = 4;
  FUN_1000ef60(&local_1c);
  local_8._0_1_ = 3;
  FUN_1000ef00((int *)local_18);
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_1000f220((int *)local_20);
  CSubFileComponent_ReadFileDescription();
  return;
}



// Function: Catch@10007f06 at 10007f06

undefined * Catch_10007f06(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x8c),"SubFileComponent.cpp",0x197,
                       "CSubFileComponent::WriteFile",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x30) = uVar2;
  return &DAT_10007fea;
}



// Function: Catch@10007f55 at 10007f55

undefined * Catch_10007f55(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0xa8),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 0xc;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0xa8),"SubFileComponent.cpp",0x197,
                       "CSubFileComponent::WriteFile",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x48) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 0xb;
  uStack0000001c = 0x10007fbf;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0xa8));
  return &DAT_10007fd4;
}



// Function: CSubFileComponent_ReadFileDescription at 10007fcb

undefined4 CSubFileComponent_ReadFileDescription(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x58) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x3c));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x58);
}



// Function: CSubFileComponent_ReadFileDescription at 10008030

void CSubFileComponent_ReadFileDescription(int param_1,int param_2,int *param_3)

{
  int iVar1;
  uint uStack_64;
  _Container_base0 local_44 [12];
  undefined1 local_38 [12];
  undefined4 local_2c;
  int local_1c;
  int local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a760;
  local_10 = ExceptionList;
  uStack_64 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_64;
  ExceptionList = &local_10;
  FUN_1000db90(local_38,param_1 + 0x70);
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  if (param_3 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_2c = 0;
  FUN_1000e810(&local_1c,param_2);
  local_8._0_1_ = 2;
  FUN_100035f0(&local_1c);
  vector<>((undefined4 *)local_44);
  local_8._0_1_ = 3;
  FUN_100061b0(&local_1c,local_44,'\0');
  FUN_1000e770(&local_18,"Cummins Subfile");
  local_8._0_1_ = 4;
  FUN_10006680(local_44,&local_18);
  iVar1 = FUN_100148d0(&local_18,'\x01');
  *param_3 = iVar1;
  local_8._0_1_ = 3;
  FUN_1000f220(&local_18);
  local_8._0_1_ = 2;
  FUN_1000efc0(local_44);
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_1000f220(&local_1c);
  CSubFileComponent_VerifyFile();
  return;
}



// Function: Catch@10008142 at 10008142

undefined * Catch_10008142(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x2c),"SubFileComponent.cpp",0x1bd,
                       "CSubFileComponent::ReadFileDescription",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x20) = uVar2;
  return &DAT_1000821a;
}



// Function: Catch@1000818e at 1000818e

undefined * Catch_1000818e(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x50),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 6;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x50),"SubFileComponent.cpp",0x1bd,
                       "CSubFileComponent::ReadFileDescription",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x1c) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 5;
  uStack0000001c = 0x100081ef;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x50));
  return &DAT_10008204;
}



// Function: CSubFileComponent_VerifyFile at 100081fb

undefined4 CSubFileComponent_VerifyFile(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x24) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x34));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x24);
}



// Function: CSubFileComponent_VerifyFile at 10008260

void CSubFileComponent_VerifyFile(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uStack_70;
  undefined1 local_50 [24];
  int local_38;
  int local_34;
  int *local_30;
  int *local_2c;
  int *local_28;
  int *local_24;
  int local_20;
  int local_1c;
  char local_15;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a79b;
  local_10 = ExceptionList;
  uStack_70 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_70;
  ExceptionList = &local_10;
  FUN_1000db90(local_50,param_1 + 0x1c);
  local_20 = 0;
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  local_1c = 0;
  local_20 = (**(code **)(*param_1 + 0x2c))(param_1,param_2,&local_1c);
  if (-1 < local_20) {
    piVar1 = FUN_1000e810(&local_38,local_1c);
    local_8._0_1_ = 2;
    local_28 = piVar1;
    local_24 = piVar1;
    local_30 = FUN_1000e810(&local_34,param_3);
    local_8._0_1_ = 3;
    local_2c = local_30;
    local_15 = FUN_1000fb10(local_30,piVar1);
    local_8._0_1_ = 2;
    FUN_1000f220(&local_34);
    local_8._0_1_ = 1;
    FUN_1000f220(&local_38);
    if (local_15 != '\0') {
      local_20 = -0x7fffbffb;
    }
  }
  iVar2 = Ordinal_149(local_1c);
  if (iVar2 != 0) {
    Ordinal_6(local_1c);
  }
  CSubFileComponent_ReadFileVersion();
  return;
}



// Function: Catch@10008358 at 10008358

undefined * Catch_10008358(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x44),"SubFileComponent.cpp",0x1d9,
                       "CSubFileComponent::VerifyFile",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x3c) = uVar2;
  return &DAT_10008430;
}



// Function: Catch@100083a4 at 100083a4

undefined * Catch_100083a4(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x5c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 5;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x5c),"SubFileComponent.cpp",0x1d9,
                       "CSubFileComponent::VerifyFile",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x38) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 4;
  uStack0000001c = 0x10008405;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x5c));
  return &DAT_1000841a;
}



// Function: CSubFileComponent_ReadFileVersion at 10008411

undefined4 CSubFileComponent_ReadFileVersion(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x40) = *(undefined4 *)(unaff_EBP + -0x1c);
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x4c));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x40);
}



// Function: CSubFileComponent_ReadFileVersion at 10008470

void CSubFileComponent_ReadFileVersion(int param_1,int param_2,int *param_3)

{
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar1;
  char *pcVar2;
  int iVar3;
  uint uStack_8c;
  _Container_base0 local_64 [12];
  int local_58;
  undefined1 local_54 [8];
  undefined4 local_4c [4];
  int local_3c;
  int local_38;
  int local_34;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_30 [24];
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a7ee;
  local_10 = ExceptionList;
  uStack_8c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_8c;
  ExceptionList = &local_10;
  local_18 = uStack_8c;
  FUN_1000db90(local_54,param_1 + 0x70);
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  if (param_3 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  FUN_1000e810(&local_34,param_2);
  local_8._0_1_ = 2;
  FUN_100035f0(&local_34);
  FUN_1000e770(&local_38,"");
  local_8._0_1_ = 3;
  vector<>((undefined4 *)local_64);
  local_8._0_1_ = 4;
  FUN_100061b0(&local_34,local_64,'\0');
  FUN_1000e770(&local_58,"Cummins Subfile");
  local_8._0_1_ = 5;
  pbVar1 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
           FUN_1000fbb0(local_64,1);
  std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>(local_30,pbVar1);
  local_8 = CONCAT31(local_8._1_3_,6);
  pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
           operator[](local_30,0);
  if (*pcVar2 == '*') {
    pcVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
             operator[](local_30,1);
    if (*pcVar2 == 'C') {
      local_4c[0] = 0;
      local_3c = 0;
      FUN_10002cf0((void *)(param_1 + -4),(_String_val<struct_std::_Simple_types<char>_> *)local_30,
                   local_4c,&local_3c);
      if (local_3c != 3) {
        FUN_10025510((uchar *)"SubFileComponent.cpp");
      }
    }
  }
  FUN_10006960(local_64,&local_38);
  iVar3 = FUN_100148d0(&local_38,'\x01');
  *param_3 = iVar3;
  local_8._0_1_ = 5;
  ~basic_string<>(local_30);
  local_8._0_1_ = 4;
  FUN_1000f220(&local_58);
  local_8._0_1_ = 3;
  FUN_1000efc0(local_64);
  local_8._0_1_ = 2;
  FUN_1000f220(&local_38);
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_1000f220(&local_34);
  FUN_100086f0();
  return;
}



// Function: Catch@10008637 at 10008637

undefined * Catch_10008637(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -100),"SubFileComponent.cpp",0x213,
                       "CSubFileComponent::ReadFileVersion",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x3c) = uVar2;
  return &DAT_1000870f;
}



// Function: Catch@10008683 at 10008683

undefined * Catch_10008683(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x78),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 8;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x78),"SubFileComponent.cpp",0x213,
                       "CSubFileComponent::ReadFileVersion",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x44) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 7;
  uStack0000001c = 0x100086e4;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x78));
  return &DAT_100086f9;
}



// Function: FUN_100086f0 at 100086f0

void FUN_100086f0(void)

{
  uint unaff_EBP;
  undefined4 uStack0000000c;
  
  *(undefined4 *)(unaff_EBP - 4) = 0;
  *(undefined4 *)(unaff_EBP - 0x40) = 0;
  *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP - 0x50));
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uStack0000000c = 0x10008754;
  __security_check_cookie(*(uint *)(unaff_EBP - 0x14) ^ unaff_EBP);
  return;
}



// Function: CSubFileComponent_get_FileExtensions at 10008760

void CSubFileComponent_get_FileExtensions(int param_1,undefined2 *param_2)

{
  int iVar1;
  uint uStack_50;
  undefined1 local_30 [24];
  int local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a82b;
  local_10 = ExceptionList;
  uStack_50 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_50;
  ExceptionList = &local_10;
  FUN_1000db90(local_30,param_1 + 0x70);
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  if (param_2 == (undefined2 *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  FUN_1000e770(&local_18,"*.*");
  local_8._0_1_ = 2;
  *param_2 = 8;
  iVar1 = FUN_100148d0(&local_18,'\x01');
  *(int *)(param_2 + 4) = iVar1;
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_1000f220(&local_18);
  FUN_100088c5();
  return;
}



// Function: Catch@1000880c at 1000880c

undefined * Catch_1000880c(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x24),"SubFileComponent.cpp",0x22d,
                       "CSubFileComponent::get_FileExtensions",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x1c) = uVar2;
  return &DAT_100088e4;
}



// Function: Catch@10008858 at 10008858

undefined * Catch_10008858(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x3c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 4;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x3c),"SubFileComponent.cpp",0x22d,
                       "CSubFileComponent::get_FileExtensions",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 3;
  uStack0000001c = 0x100088b9;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x3c));
  return &DAT_100088ce;
}



// Function: FUN_100088c5 at 100088c5

undefined4 FUN_100088c5(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x20) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x2c));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x20);
}



// Function: FUN_10008930 at 10008930

undefined4 FUN_10008930(void)

{
  return 0x80004001;
}



// Function: FUN_10008940 at 10008940

undefined4 FUN_10008940(void)

{
  return 0x80004001;
}



// Function: CSubFileComponent_get_FileDescription at 10008950

void CSubFileComponent_get_FileDescription(int param_1,int *param_2)

{
  int iVar1;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a856;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x70);
  local_8 = 1;
  if (param_2 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  iVar1 = FUN_100148d0((void *)(param_1 + 100),'\x01');
  *param_2 = iVar1;
  FUN_10008a8f();
  return;
}



// Function: Catch@100089d6 at 100089d6

undefined * Catch_100089d6(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x24e,
                       "CSubFileComponent::get_FileDescription",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10008aae;
}



// Function: Catch@10008a22 at 10008a22

undefined * Catch_10008a22(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x24e,
                       "CSubFileComponent::get_FileDescription",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x10008a83;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_10008a98;
}



// Function: FUN_10008a8f at 10008a8f

undefined4 FUN_10008a8f(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_get_FileVersion at 10008af0

void CSubFileComponent_get_FileVersion(int param_1,int *param_2)

{
  int iVar1;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a881;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x70);
  local_8 = 1;
  if (param_2 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  if ((*(int *)(param_1 + 0x40) != 0) && (*(int *)(param_1 + 0x40) != 3)) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  iVar1 = FUN_100148d0((void *)(param_1 + 0x60),'\x01');
  *param_2 = iVar1;
  FUN_10008c64();
  return;
}



// Function: Catch@10008bab at 10008bab

undefined * Catch_10008bab(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x26f,
                       "CSubFileComponent::get_FileVersion",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10008c83;
}



// Function: Catch@10008bf7 at 10008bf7

undefined * Catch_10008bf7(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x26f,
                       "CSubFileComponent::get_FileVersion",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x10008c58;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_10008c6d;
}



// Function: FUN_10008c64 at 10008c64

undefined4 FUN_10008c64(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_get_Description at 10008cd0

void CSubFileComponent_get_Description(int param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  uint uStack_50;
  undefined1 local_30 [24];
  int local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a8b4;
  local_10 = ExceptionList;
  uStack_50 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_50;
  ExceptionList = &local_10;
  FUN_1000db90(local_30,param_1 + 0x70);
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  if (param_2 == (undefined4 *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  FUN_1000e770(&local_18,"Cummins SubFileComponent Class");
  local_8._0_1_ = 2;
  uVar1 = FUN_1000fce0(&local_18);
  *param_2 = uVar1;
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_1000f220(&local_18);
  FUN_10008e27();
  return;
}



// Function: Catch@10008d6e at 10008d6e

undefined * Catch_10008d6e(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x24),"SubFileComponent.cpp",0x287,
                       "CSubFileComponent::get_Description",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x1c) = uVar2;
  return &DAT_10008e46;
}



// Function: Catch@10008dba at 10008dba

undefined * Catch_10008dba(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x3c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 4;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x3c),"SubFileComponent.cpp",0x287,
                       "CSubFileComponent::get_Description",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 3;
  uStack0000001c = 0x10008e1b;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x3c));
  return &DAT_10008e30;
}



// Function: FUN_10008e27 at 10008e27

undefined4 FUN_10008e27(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x20) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x2c));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x20);
}



// Function: CSubFileComponent_get_Version at 10008e90

void CSubFileComponent_get_Version(int param_1,int *param_2)

{
  int iVar1;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a8df;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x70);
  local_8 = 1;
  if (param_2 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  iVar1 = FUN_100148d0((void *)(param_1 + 0x30),'\x01');
  *param_2 = iVar1;
  FUN_10008fcf();
  return;
}



// Function: Catch@10008f16 at 10008f16

undefined * Catch_10008f16(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x29d,
                       "CSubFileComponent::get_Version",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10008fee;
}



// Function: Catch@10008f62 at 10008f62

undefined * Catch_10008f62(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x29d,
                       "CSubFileComponent::get_Version",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x10008fc3;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_10008fd8;
}



// Function: FUN_10008fcf at 10008fcf

undefined4 FUN_10008fcf(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_get_CanRead at 10009030

void CSubFileComponent_get_CanRead(int param_1,undefined4 *param_2)

{
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a90a;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x70);
  local_8 = 1;
  if (param_2 == (undefined4 *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  *param_2 = 1;
  FUN_10009166();
  return;
}



// Function: Catch@100090ad at 100090ad

undefined * Catch_100090ad(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x2b4,
                       "CSubFileComponent::get_CanRead",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10009185;
}



// Function: Catch@100090f9 at 100090f9

undefined * Catch_100090f9(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x2b4,
                       "CSubFileComponent::get_CanRead",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x1000915a;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_1000916f;
}



// Function: FUN_10009166 at 10009166

undefined4 FUN_10009166(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_get_CanWrite at 100091d0

void CSubFileComponent_get_CanWrite(int param_1,undefined4 *param_2)

{
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a935;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x70);
  local_8 = 1;
  if (param_2 == (undefined4 *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  *param_2 = 1;
  FUN_10009306();
  return;
}



// Function: Catch@1000924d at 1000924d

undefined * Catch_1000924d(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x2cb,
                       "CSubFileComponent::get_CanWrite",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10009325;
}



// Function: Catch@10009299 at 10009299

undefined * Catch_10009299(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x2cb,
                       "CSubFileComponent::get_CanWrite",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x100092fa;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_1000930f;
}



// Function: FUN_10009306 at 10009306

undefined4 FUN_10009306(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_get_Group at 10009370

void CSubFileComponent_get_Group(int param_1,undefined4 *param_2)

{
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a960;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x6c);
  local_8 = 1;
  if (param_2 == (undefined4 *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  *param_2 = *(undefined4 *)(param_1 + 0x34);
  FUN_100094a8();
  return;
}



// Function: Catch@100093ef at 100093ef

undefined * Catch_100093ef(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x2e4,
                       "CSubFileComponent::get_Group",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_100094c7;
}



// Function: Catch@1000943b at 1000943b

undefined * Catch_1000943b(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x2e4,
                       "CSubFileComponent::get_Group",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x1000949c;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_100094b1;
}



// Function: FUN_100094a8 at 100094a8

undefined4 FUN_100094a8(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_put_Group at 10009510

void CSubFileComponent_put_Group(int param_1,undefined4 param_2)

{
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a98b;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x6c);
  local_8 = 1;
  *(undefined4 *)(param_1 + 0x34) = param_2;
  FUN_1000961d();
  return;
}



// Function: Catch@10009564 at 10009564

undefined * Catch_10009564(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x2f2,
                       "CSubFileComponent::put_Group",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_1000963c;
}



// Function: Catch@100095b0 at 100095b0

undefined * Catch_100095b0(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x2f2,
                       "CSubFileComponent::put_Group",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x10009611;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_10009626;
}



// Function: FUN_1000961d at 1000961d

undefined4 FUN_1000961d(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_GetCalHeader at 10009680

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */
/* WARNING: Unable to track spacebase fully for stack */

void CSubFileComponent_GetCalHeader(int param_1,int param_2,undefined4 *param_3)

{
  bool bVar1;
  int iVar2;
  _String_val<struct_std::_Simple_types<char>_> *p_Var3;
  size_t sVar4;
  undefined4 uVar5;
  undefined *apuStack_78 [2];
  int iStack_70;
  uint uStack_68;
  undefined1 local_40 [12];
  undefined4 local_34;
  undefined1 *local_2c;
  LPWSTR local_28;
  LPWSTR local_24;
  int local_20;
  char *local_1c;
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a9b6;
  local_10 = ExceptionList;
  uStack_68 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_68;
  ExceptionList = &local_10;
  iStack_70 = 0x100096be;
  local_18 = uStack_68;
  FUN_1000db90(local_40,param_1 + 100);
  local_8 = 1;
  if (param_3 == (undefined4 *)0x0) {
    iStack_70 = (int)&DAT_10033970;
    apuStack_78[1] = (undefined *)0x80004003;
    apuStack_78[0] = (undefined *)0x304;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  bVar1 = FUN_10014a80((int *)(param_1 + 0x48));
  if (bVar1) {
    iStack_70 = (int)&DAT_10033970;
    apuStack_78[1] = (undefined *)0x80004005;
    apuStack_78[0] = (undefined *)0x30d;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  if (-1 < param_2) {
    iVar2 = FUN_10015520((int *)(param_1 + 0x48));
    if (param_2 <= iVar2 + -1) goto LAB_10009762;
  }
  iStack_70 = (int)&DAT_10033950;
  apuStack_78[1] = (undefined *)0x80070057;
  apuStack_78[0] = (undefined *)0x316;
  FUN_10025510((uchar *)"SubFileComponent.cpp");
LAB_10009762:
  local_34 = FUN_10012f50();
  iStack_70 = 0x10009779;
  p_Var3 = (_String_val<struct_std::_Simple_types<char>_> *)
           FUN_1000fbb0((void *)(param_1 + 0x48),param_2);
  local_1c = (char *)FUN_100146c0(p_Var3);
  if (local_1c == (char *)0x0) {
    local_28 = (LPWSTR)0x0;
  }
  else {
    iStack_70 = 0x1000979b;
    sVar4 = strlen(local_1c);
    local_20 = sVar4 + 1;
    if (local_20 < 0x40000000) {
      iVar2 = local_20 * -2;
      local_2c = (undefined1 *)&uStack_68;
      local_14 = (undefined1 *)&uStack_68;
      *(undefined4 *)(&stack0xffffff94 + iVar2) = local_34;
      *(int *)((int)&iStack_70 + iVar2) = local_20;
      *(char **)((int)apuStack_78 + iVar2 + 4) = local_1c;
      *(undefined1 **)((int)apuStack_78 + iVar2) = local_2c;
      *(undefined4 *)(&stack0xffffff84 + iVar2) = 0x100097db;
      local_24 = FUN_100107c0(*(LPWSTR *)((int)apuStack_78 + iVar2),
                              *(LPCSTR *)((int)apuStack_78 + iVar2 + 4),
                              *(int *)((int)&iStack_70 + iVar2),*(UINT *)(&stack0xffffff94 + iVar2))
      ;
    }
    else {
      local_24 = (LPWSTR)0x0;
    }
    local_28 = local_24;
  }
  iStack_70 = 0x100097ee;
  uVar5 = Ordinal_2();
  *param_3 = uVar5;
  FUN_100098b1();
  return;
}



// Function: Catch@100097f8 at 100097f8

undefined * Catch_100097f8(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x44),"SubFileComponent.cpp",800,
                       "CSubFileComponent::GetCalHeader",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x40) = uVar2;
  return &DAT_100098d0;
}



// Function: Catch@10009844 at 10009844

undefined * Catch_10009844(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x54),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x54),"SubFileComponent.cpp",800,
                       "CSubFileComponent::GetCalHeader",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x34) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x100098a5;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x54));
  return &DAT_100098ba;
}



// Function: FUN_100098b1 at 100098b1

/* WARNING: Unable to track spacebase fully for stack */

void FUN_100098b1(void)

{
  uint uVar1;
  uint unaff_EBP;
  
  *(undefined4 *)(unaff_EBP - 4) = 0;
  *(undefined4 *)(unaff_EBP - 0x2c) = 0;
  *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP - 0x3c));
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uVar1 = *(uint *)(unaff_EBP - 0x14);
  *(undefined4 *)(unaff_EBP - 0x58) = 0x10009918;
  __security_check_cookie(uVar1 ^ unaff_EBP);
  return;
}



// Function: CSubFileComponent_AppendCalHeader at 10009920

void CSubFileComponent_AppendCalHeader(int param_1,int param_2)

{
  char *pcVar1;
  uint uStack_7c;
  undefined1 local_58 [8];
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *local_50;
  int *local_4c;
  int *local_48;
  int local_44;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *local_40;
  undefined1 local_30 [24];
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002a9fb;
  local_10 = ExceptionList;
  uStack_7c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_7c;
  ExceptionList = &local_10;
  local_18 = uStack_7c;
  FUN_1000db90(local_58,param_1 + 100);
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  local_4c = FUN_1000e810(&local_44,param_2);
  local_8._0_1_ = 2;
  local_48 = local_4c;
  pcVar1 = (char *)FUN_1000fd10(local_4c);
  local_50 = basic_string<>(local_30,pcVar1);
  local_8._0_1_ = 3;
  local_40 = local_50;
  FUN_10015160((void *)(param_1 + 0x48),local_50);
  local_8._0_1_ = 2;
  ~basic_string<>(local_30);
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_1000f220(&local_44);
  FUN_10009a85();
  return;
}



// Function: Catch@100099cc at 100099cc

undefined * Catch_100099cc(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x58),"SubFileComponent.cpp",0x330,
                       "CSubFileComponent::AppendCalHeader",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x34) = uVar2;
  return &DAT_10009aa4;
}



// Function: Catch@10009a18 at 10009a18

undefined * Catch_10009a18(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x68),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 5;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x68),"SubFileComponent.cpp",0x330,
                       "CSubFileComponent::AppendCalHeader",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x30) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 4;
  uStack0000001c = 0x10009a79;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x68));
  return &DAT_10009a8e;
}



// Function: FUN_10009a85 at 10009a85

void FUN_10009a85(void)

{
  uint unaff_EBP;
  undefined4 uStack0000000c;
  
  *(undefined4 *)(unaff_EBP - 4) = 0;
  *(undefined4 *)(unaff_EBP - 0x38) = 0;
  *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP - 0x54));
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uStack0000000c = 0x10009ae9;
  __security_check_cookie(*(uint *)(unaff_EBP - 0x14) ^ unaff_EBP);
  return;
}



// Function: CSubFileComponent_ClearCalHeaders at 10009af0

void CSubFileComponent_ClearCalHeaders(int param_1)

{
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002aa30;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 100);
  local_8 = 1;
  FUN_100147a0((_Container_base0 *)(param_1 + 0x48));
  FUN_10009bff();
  return;
}



// Function: Catch@10009b46 at 10009b46

undefined * Catch_10009b46(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x33f,
                       "CSubFileComponent::ClearCalHeaders",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10009c1e;
}



// Function: Catch@10009b92 at 10009b92

undefined * Catch_10009b92(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x33f,
                       "CSubFileComponent::ClearCalHeaders",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x10009bf3;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_10009c08;
}



// Function: FUN_10009bff at 10009bff

undefined4 FUN_10009bff(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_get_CalHeaderCount at 10009c60

void CSubFileComponent_get_CalHeaderCount(int param_1,int *param_2)

{
  int iVar1;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002aa5b;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 100);
  local_8 = 1;
  if (param_2 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  iVar1 = FUN_10015520((int *)(param_1 + 0x48));
  *param_2 = iVar1;
  FUN_10009d9d();
  return;
}



// Function: Catch@10009ce4 at 10009ce4

undefined * Catch_10009ce4(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x357,
                       "CSubFileComponent::get_CalHeaderCount",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10009dbc;
}



// Function: Catch@10009d30 at 10009d30

undefined * Catch_10009d30(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x357,
                       "CSubFileComponent::get_CalHeaderCount",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x10009d91;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_10009da6;
}



// Function: FUN_10009d9d at 10009d9d

undefined4 FUN_10009d9d(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_get_ImageCount at 10009e00

void CSubFileComponent_get_ImageCount(int param_1,int *param_2)

{
  int iVar1;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002aa86;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x68);
  local_8 = 1;
  if (param_2 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  iVar1 = size((int *)(param_1 + 0x40));
  *param_2 = iVar1;
  FUN_10009f3d();
  return;
}



// Function: Catch@10009e84 at 10009e84

undefined * Catch_10009e84(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x371,
                       "CSubFileComponent::get_ImageCount",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_10009f5c;
}



// Function: Catch@10009ed0 at 10009ed0

undefined * Catch_10009ed0(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x371,
                       "CSubFileComponent::get_ImageCount",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x10009f31;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_10009f46;
}



// Function: FUN_10009f3d at 10009f3d

undefined4 FUN_10009f3d(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_get_CurrentImage at 10009fa0

void CSubFileComponent_get_CurrentImage(int param_1,int *param_2)

{
  bool bVar1;
  void *this;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002aab1;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x68);
  local_8 = 1;
  if (param_2 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  bVar1 = FUN_10014a50((int *)(param_1 + 0x40));
  if (bVar1) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  this = (void *)FUN_1000fb90((void *)(param_1 + 0x40),*(int *)(param_1 + 0x3c));
  FUN_10010d20(this,param_2);
  CSubFileComponent_SetCurrentImageByIndex();
  return;
}



// Function: Catch@1000a065 at 1000a065

undefined * Catch_1000a065(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x394,
                       "CSubFileComponent::get_CurrentImage",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_1000a13d;
}



// Function: Catch@1000a0b1 at 1000a0b1

undefined * Catch_1000a0b1(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x394,
                       "CSubFileComponent::get_CurrentImage",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x1000a112;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_1000a127;
}



// Function: CSubFileComponent_SetCurrentImageByIndex at 1000a11e

undefined4 CSubFileComponent_SetCurrentImageByIndex(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_SetCurrentImageByIndex at 1000a180

void CSubFileComponent_SetCurrentImageByIndex(int param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002aadc;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x68);
  local_8 = 1;
  bVar1 = FUN_10014a50((int *)(param_1 + 0x40));
  if (bVar1) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  if (-1 < param_2) {
    iVar2 = size((int *)(param_1 + 0x40));
    if (param_2 <= iVar2 + -1) goto LAB_1000a236;
  }
  FUN_10025510((uchar *)"SubFileComponent.cpp");
LAB_1000a236:
  *(int *)(param_1 + 0x3c) = param_2;
  CSubFileComponent_SetCurrentImageByLocation();
  return;
}



// Function: Catch@1000a244 at 1000a244

undefined * Catch_1000a244(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x3b9,
                       "CSubFileComponent::SetCurrentImageByIndex",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_1000a31c;
}



// Function: Catch@1000a290 at 1000a290

undefined * Catch_1000a290(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x3b9,
                       "CSubFileComponent::SetCurrentImageByIndex",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x1000a2f1;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_1000a306;
}



// Function: CSubFileComponent_SetCurrentImageByLocation at 1000a2fd

undefined4 CSubFileComponent_SetCurrentImageByLocation(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_SetCurrentImageByLocation at 1000a360

void CSubFileComponent_SetCurrentImageByLocation(int param_1,int param_2,int param_3)

{
  bool bVar1;
  uint uStack_50;
  undefined1 local_30 [24];
  int local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ab07;
  local_10 = ExceptionList;
  uStack_50 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_50;
  ExceptionList = &local_10;
  FUN_1000db90(local_30,param_1 + 0x68);
  local_8 = 1;
  bVar1 = FUN_10014a50((int *)(param_1 + 0x40));
  if (bVar1) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_18 = FUN_10004f80(param_2,param_3);
  if (local_18 == -1) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  *(int *)(param_1 + 0x3c) = local_18;
  FUN_1000a4e1();
  return;
}



// Function: Catch@1000a428 at 1000a428

undefined * Catch_1000a428(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x24),"SubFileComponent.cpp",0x3e0,
                       "CSubFileComponent::SetCurrentImageByLocation",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x1c) = uVar2;
  return &DAT_1000a500;
}



// Function: Catch@1000a474 at 1000a474

undefined * Catch_1000a474(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x3c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x3c),"SubFileComponent.cpp",0x3e0,
                       "CSubFileComponent::SetCurrentImageByLocation",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x1000a4d5;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x3c));
  return &DAT_1000a4ea;
}



// Function: FUN_1000a4e1 at 1000a4e1

undefined4 FUN_1000a4e1(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x20) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x2c));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x20);
}



// Function: CSubFileComponent_ClearImages at 1000a550

void CSubFileComponent_ClearImages(int param_1)

{
  int iVar1;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ab32;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x68);
  local_8 = 1;
  iVar1 = size((int *)(param_1 + 0x40));
  if (iVar1 != 0) {
    FUN_10014760((_Container_base0 *)(param_1 + 0x40));
  }
  *(undefined4 *)(param_1 + 0x3c) = 0xffffffff;
  FUN_1000a678();
  return;
}



// Function: Catch@1000a5bf at 1000a5bf

undefined * Catch_1000a5bf(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x3f6,
                       "CSubFileComponent::ClearImages",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_1000a697;
}



// Function: Catch@1000a60b at 1000a60b

undefined * Catch_1000a60b(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x3f6,
                       "CSubFileComponent::ClearImages",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x1000a66c;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_1000a681;
}



// Function: FUN_1000a678 at 1000a678

undefined4 FUN_1000a678(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_GetImage at 1000a6e0

void CSubFileComponent_GetImage(int param_1,int param_2,int *param_3)

{
  bool bVar1;
  int iVar2;
  void *this;
  uint uStack_4c;
  undefined1 local_2c [24];
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ab5d;
  local_10 = ExceptionList;
  uStack_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_4c;
  ExceptionList = &local_10;
  FUN_1000db90(local_2c,param_1 + 0x68);
  local_8 = 1;
  if (param_3 == (int *)0x0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  bVar1 = FUN_10014a50((int *)(param_1 + 0x40));
  if (bVar1) {
    *param_3 = 0;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  if (-1 < param_2) {
    iVar2 = size((int *)(param_1 + 0x40));
    if (param_2 <= iVar2 + -1) goto LAB_1000a7c9;
  }
  FUN_10025510((uchar *)"SubFileComponent.cpp");
LAB_1000a7c9:
  *(int *)(param_1 + 0x3c) = param_2;
  this = (void *)FUN_1000fb90((void *)(param_1 + 0x40),*(int *)(param_1 + 0x3c));
  FUN_10010d20(this,param_3);
  FUN_1000a8ad();
  return;
}



// Function: Catch@1000a7f4 at 1000a7f4

undefined * Catch_1000a7f4(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x20),"SubFileComponent.cpp",0x427,
                       "CSubFileComponent::GetImage",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
  return &DAT_1000a8cc;
}



// Function: Catch@1000a840 at 1000a840

undefined * Catch_1000a840(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x38),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 3;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x38),"SubFileComponent.cpp",0x427,
                       "CSubFileComponent::GetImage",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x14) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uStack0000001c = 0x1000a8a1;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return &DAT_1000a8b6;
}



// Function: FUN_1000a8ad at 1000a8ad

undefined4 FUN_1000a8ad(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x1c) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x1c);
}



// Function: CSubFileComponent_PutImage at 1000a910

void CSubFileComponent_PutImage(int param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  IUnknown *pIVar4;
  void *pvVar5;
  undefined4 *puVar6;
  undefined4 extraout_ECX;
  uint uVar7;
  int iVar8;
  int *piVar9;
  undefined4 uVar10;
  undefined4 *puVar11;
  _GUID *p_Var12;
  uint uStack_108;
  undefined1 local_d4 [4];
  undefined1 *local_d0;
  undefined1 local_cc [4];
  undefined1 *local_c8;
  undefined4 local_c4;
  undefined1 *local_c0;
  void *local_bc;
  void *local_b8;
  undefined1 *local_b4;
  void *local_b0;
  void *local_ac;
  void *local_a8;
  undefined1 *local_a4;
  void *local_a0;
  undefined1 local_9c [4];
  void *local_98;
  undefined1 local_94 [4];
  void *local_90;
  undefined4 local_8c;
  undefined4 local_88;
  undefined1 *local_84;
  undefined4 local_80;
  void *local_7c;
  void *local_74;
  undefined4 local_70;
  void *local_6c;
  undefined1 local_64 [8];
  int local_5c;
  void *local_58;
  void *local_54;
  void *local_50;
  void *local_4c;
  void *local_48;
  int local_44;
  void *local_40;
  int local_38;
  int local_34;
  int local_30;
  long local_2c;
  int *local_28;
  int local_24;
  byte local_20;
  char local_1f;
  byte local_1e;
  char local_1d;
  int local_1c;
  char local_17;
  char local_16;
  char local_15;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002abfb;
  local_10 = ExceptionList;
  uStack_108 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_108;
  ExceptionList = &local_10;
  FUN_1000db90(local_64,param_1 + 0x68);
  local_34 = 0;
  local_8 = 1;
  if (param_3 == 0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  bVar1 = FUN_10014a50((int *)(param_1 + 0x40));
  if (bVar1) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  if (-1 < param_2) {
    iVar2 = size((int *)(param_1 + 0x40));
    if (param_2 <= iVar2 + -1) goto LAB_1000a9f9;
  }
  FUN_10025510((uchar *)"SubFileComponent.cpp");
LAB_1000a9f9:
  local_30 = 0;
  local_80 = 0;
  local_70 = 0;
  local_38 = 0;
  FUN_1000d8f0(&local_24);
  local_8._0_1_ = 2;
  FUN_1000d890(&local_1c,param_3);
  local_8 = CONCAT31(local_8._1_3_,3);
  piVar3 = (int *)FUN_1000fb90((void *)(param_1 + 0x40),param_2);
  FUN_1000f350(piVar3);
  local_28 = (int *)FUN_1000fd70(&local_24);
  local_34 = (**(code **)(*local_28 + 0x1c))();
  local_2c = local_34;
  if (local_34 < 0) {
    p_Var12 = (_GUID *)&DAT_1002f4e0;
    pIVar4 = (IUnknown *)FUN_1000fbf0(&local_24);
    _com_issue_errorex(local_2c,pIVar4,p_Var12);
  }
  puVar11 = &local_70;
  puVar6 = &local_80;
  piVar3 = &local_30;
  piVar9 = piVar3;
  local_48 = FUN_1000d830(&stack0xfffffee0,&local_1c);
  local_8._1_3_ = (undefined3)((uint)local_8 >> 8);
  local_8._0_1_ = 3;
  FUN_10005fb0(piVar3,piVar9,puVar6,puVar11);
  if (local_30 != local_38) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_15 = '\0';
  local_16 = '\0';
  local_17 = '\0';
  iVar2 = size((int *)(param_1 + 0x40));
  if (param_2 + 1 < iVar2) {
    iVar2 = param_2 + 1;
    uVar10 = extraout_ECX;
    local_90 = FUN_1000d830(&stack0xfffffee8,&local_1c);
    local_8._0_1_ = 3;
    local_74 = local_90;
    local_1e = FUN_10004580((void *)(param_1 + -0xc),uVar10,iVar2);
    uVar7 = (uint)local_1e;
    if (uVar7 == 0) {
      iVar2 = param_2 + 1;
      local_c0 = &stack0xfffffee8;
      local_98 = FUN_1000d830(&stack0xfffffee8,&local_1c);
      local_8._0_1_ = 3;
      local_50 = local_98;
      local_1f = FUN_10004850((void *)(param_1 + -0xc),uVar7,iVar2);
      if (local_1f != '\0') {
        local_17 = '\x01';
      }
    }
    else {
      local_15 = '\x01';
    }
  }
  if ((local_15 == '\0') && (0 < param_2)) {
    iVar8 = param_2 + -1;
    local_84 = &stack0xfffffee8;
    iVar2 = iVar8;
    local_a0 = FUN_1000d830(&stack0xfffffee8,&local_1c);
    local_8._0_1_ = 3;
    local_6c = local_a0;
    local_20 = FUN_10004580((void *)(param_1 + -0xc),iVar8,iVar2);
    uVar7 = (uint)local_20;
    if (uVar7 == 0) {
      iVar2 = param_2 + -1;
      local_c8 = &stack0xfffffee8;
      local_a8 = FUN_1000d830(&stack0xfffffee8,&local_1c);
      local_8._0_1_ = 3;
      local_58 = local_a8;
      local_1d = FUN_10004850((void *)(param_1 + -0xc),uVar7,iVar2);
      if (local_1d != '\0') {
        local_16 = '\x01';
      }
    }
    else {
      local_15 = '\x01';
    }
  }
  if (local_15 != '\0') {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  if (local_17 != '\0') {
    piVar3 = (int *)FUN_1000fb90((void *)(param_1 + 0x40),param_2 + 1);
    local_b0 = FUN_1000d830(&stack0xfffffeec,piVar3);
    local_8._0_1_ = 9;
    local_d0 = &stack0xfffffee8;
    local_7c = local_b0;
    local_b8 = FUN_1000d830(&stack0xfffffee8,&local_1c);
    local_8._0_1_ = 3;
    local_40 = local_b8;
    FUN_100028f0();
    iVar8 = 1;
    puVar11 = &local_88;
    puVar6 = &local_8c;
    iVar2 = param_2;
    pvVar5 = FID_conflict_begin((void *)(param_1 + 0x40),local_94);
    puVar6 = FID_conflict_operator_(pvVar5,puVar6,iVar2);
    piVar3 = FID_conflict_operator_(puVar6,puVar11,iVar8);
    local_44 = *piVar3;
    FUN_10014c50((void *)(param_1 + 0x40),local_9c,local_44);
  }
  if (local_16 != '\0') {
    local_a4 = &stack0xfffffeec;
    local_ac = FUN_1000d830(&stack0xfffffeec,&local_1c);
    local_8._0_1_ = 0xb;
    local_4c = local_ac;
    piVar3 = (int *)FUN_1000fb90((void *)(param_1 + 0x40),param_2 + -1);
    local_b4 = &stack0xfffffee8;
    local_bc = FUN_1000d830(&stack0xfffffee8,piVar3);
    local_8._0_1_ = 3;
    local_54 = local_bc;
    FUN_100028f0();
    puVar11 = &local_c4;
    iVar2 = param_2;
    pvVar5 = FID_conflict_begin((void *)(param_1 + 0x40),local_cc);
    piVar3 = FID_conflict_operator_(pvVar5,puVar11,iVar2);
    local_5c = *piVar3;
    FUN_10014c50((void *)(param_1 + 0x40),local_d4,local_5c);
  }
  if (local_16 == '\0') {
    piVar3 = &local_1c;
    FUN_1000fb90((void *)(param_1 + 0x40),param_2);
    FUN_1000f350(piVar3);
  }
  local_8._0_1_ = 2;
  FID_conflict__bad_alloc(&local_1c);
  local_8 = CONCAT31(local_8._1_3_,1);
  FID_conflict__bad_alloc(&local_24);
  FUN_1000aee5();
  return;
}



// Function: Catch@1000ae20 at 1000ae20

undefined * Catch_1000ae20(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0xd8),"SubFileComponent.cpp",0x4a8,
                       "CSubFileComponent::PutImage",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x38) = uVar2;
  return &DAT_1000af04;
}



// Function: Catch@1000ae6f at 1000ae6f

undefined * Catch_1000ae6f(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0xf4),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 0xe;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0xf4),"SubFileComponent.cpp",0x4a8,
                       "CSubFileComponent::PutImage",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -100) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 0xd;
  uStack0000001c = 0x1000aed9;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0xf4));
  return &DAT_1000aeee;
}



// Function: FUN_1000aee5 at 1000aee5

undefined4 FUN_1000aee5(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x74) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x60));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x74);
}



// Function: CSubFileComponent_AddImage at 1000af50

void CSubFileComponent_AddImage(int param_1,int param_2)

{
  uint uStack_5c;
  undefined1 local_3c [12];
  void *local_30;
  undefined1 *local_2c;
  int local_1c;
  void *local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ac31;
  local_10 = ExceptionList;
  uStack_5c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_5c;
  ExceptionList = &local_10;
  FUN_1000db90(local_3c,param_1 + 0x68);
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  if (param_2 == 0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_2c = &stack0xffffffa0;
  local_30 = FUN_1000d890(&stack0xffffffa0,param_2);
  local_8 = CONCAT31(local_8._1_3_,1);
  local_18 = local_30;
  local_1c = FUN_100050b0();
  if (local_1c == 2) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  FUN_1000b0d4();
  return;
}



// Function: Catch@1000b01b at 1000b01b

undefined * Catch_1000b01b(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x30),"SubFileComponent.cpp",0x4c8,
                       "CSubFileComponent::AddImage",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x20) = uVar2;
  return &DAT_1000b0f3;
}



// Function: Catch@1000b067 at 1000b067

undefined * Catch_1000b067(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x48),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 4;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x48),"SubFileComponent.cpp",0x4c8,
                       "CSubFileComponent::AddImage",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x1c) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 3;
  uStack0000001c = 0x1000b0c8;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x48));
  return &DAT_1000b0dd;
}



// Function: FUN_1000b0d4 at 1000b0d4

undefined4 FUN_1000b0d4(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x24) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x38));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x24);
}



// Function: FUN_1000b140 at 1000b140

void FUN_1000b140(int param_1,int param_2,int param_3,size_t param_4,undefined2 *param_5)

{
  bool bVar1;
  int *piVar2;
  undefined4 uVar3;
  int iVar4;
  IUnknown *pIVar5;
  _GUID *p_Var6;
  char *pcStack_d8;
  undefined4 *puVar7;
  int *piVar8;
  int *piVar9;
  uint uStack_c0;
  char local_74 [8];
  undefined4 local_6c;
  int *local_64;
  int *local_60;
  undefined1 local_58 [12];
  void *local_4c;
  undefined4 local_48;
  int local_44;
  int *local_40;
  void *local_38;
  int local_34;
  int local_30;
  int local_2c;
  long local_28;
  int *local_24;
  int local_20;
  int local_1c;
  int local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ac98;
  local_10 = ExceptionList;
  uStack_c0 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_c0;
  ExceptionList = &local_10;
  FUN_1000db90(local_58,param_1 + 0x68);
  local_34 = 0;
  local_8._0_1_ = 1;
  local_8._1_3_ = 0;
  if (param_5 == (undefined2 *)0x0) {
    pcStack_d8 = (char *)0x1000b1b6;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  bVar1 = FUN_10014a50((int *)(param_1 + 0x40));
  if (bVar1) {
    local_40 = FUN_1000e770(&pcStack_d8,
                            "The requested data is not found or the requested number of bytes of data is not available."
                           );
    local_8._0_1_ = 1;
    FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                 (param_1 + 100));
    pcStack_d8 = (char *)0x1000b244;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_20 = FUN_10004f80(param_2,param_3);
  if (local_20 == -1) {
    local_64 = FUN_1000e770(&pcStack_d8,
                            "The requested data is not found or the requested number of bytes of data is not available."
                           );
    local_8._0_1_ = 1;
    FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                 (param_1 + 100));
    pcStack_d8 = (char *)0x1000b2d9;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  piVar2 = (int *)FUN_1000fb90((void *)(param_1 + 0x40),local_20);
  FUN_1000d830(&local_18,piVar2);
  local_8._0_1_ = 4;
  local_48 = 0;
  local_1c = 0;
  local_2c = 0;
  piVar2 = &local_2c;
  piVar8 = &local_1c;
  puVar7 = &local_48;
  pcStack_d8 = (char *)0x1000b32b;
  piVar9 = piVar2;
  local_4c = FUN_1000d830(&stack0xffffff30,&local_18);
  local_8._0_1_ = 4;
  FUN_10005fb0(piVar2,puVar7,piVar8,piVar9);
  if (local_1c + local_2c < (int)(param_3 + param_4)) {
    pcStack_d8 = (char *)(param_3 + param_4);
    local_60 = FUN_1000e770(&pcStack_d8,
                            "The requested data is not found or the requested number of bytes of data is not available."
                           );
    local_8._0_1_ = 4;
    FUN_10005a30((refcount_ptr<struct_boost::exception_detail::error_info_container> *)
                 (param_1 + 100));
    pcStack_d8 = (char *)0x1000b3d3;
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  *param_5 = 0x2011;
  uVar3 = Ordinal_15();
  *(undefined4 *)(param_5 + 4) = uVar3;
  local_38 = (void *)0x0;
  pcStack_d8 = (char *)0x1000b41a;
  iVar4 = Ordinal_23();
  if (iVar4 < 0) {
    pcStack_d8 = "Unable to copy data into the return variant.";
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  else {
    pcStack_d8 = (char *)0x1000b42a;
    FUN_10001e90(local_74);
    local_8 = CONCAT31(local_8._1_3_,7);
    pcStack_d8 = (char *)0x1000b436;
    local_24 = (int *)FUN_1000fd70(&local_18);
    pcStack_d8 = local_74;
    local_34 = (**(code **)(*local_24 + 0x34))(local_24);
    local_28 = local_34;
    if (local_34 < 0) {
      p_Var6 = (_GUID *)&DAT_1002f4e0;
      pIVar5 = (IUnknown *)FUN_1000fbf0(&local_18);
      _com_issue_errorex(local_28,pIVar5,p_Var6);
    }
    local_30 = 0;
    iVar4 = Ordinal_23(local_6c,&local_30);
    if (-1 < iVar4) {
      local_8 = CONCAT31(local_8._1_3_,8);
      local_44 = param_3 - local_1c;
      memcpy(local_38,(void *)(local_30 + local_44),param_4);
      CSubFileComponent_GetDataValues();
      return;
    }
    FUN_10025510((uchar *)"SubFileComponent.cpp");
    Ordinal_24(*(undefined4 *)(param_5 + 4));
    local_8._0_1_ = 4;
    pcStack_d8 = (char *)0x1000b548;
    FUN_100020f0(local_74);
  }
  *(int *)(param_1 + 0x3c) = local_20;
  local_8 = CONCAT31(local_8._1_3_,1);
  pcStack_d8 = (char *)0x1000b580;
  FID_conflict__bad_alloc(&local_18);
  FUN_1000b647();
  return;
}



// Function: Catch@1000b4b4 at 1000b4b4

undefined * Catch_1000b4b4(void)

{
  int unaff_EBP;
  
  Ordinal_24(*(undefined4 *)(unaff_EBP + -0x68));
  Ordinal_24(*(undefined4 *)(*(int *)(unaff_EBP + 0x18) + 8));
  FUN_10025510((uchar *)"SubFileComponent.cpp");
  return &DAT_1000b4fb;
}



// Function: CSubFileComponent_GetDataValues at 1000b4f2

void CSubFileComponent_GetDataValues(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 7;
  Ordinal_24(*(undefined4 *)(unaff_EBP + -0x68));
  Ordinal_24(*(undefined4 *)(*(int *)(unaff_EBP + 0x18) + 8));
  *(undefined1 *)(unaff_EBP + -4) = 4;
  FUN_100020f0(unaff_EBP + -0x70);
  *(undefined4 *)(*(int *)(unaff_EBP + 8) + 0x3c) = *(undefined4 *)(unaff_EBP + -0x1c);
  *(undefined1 *)(unaff_EBP + -4) = 1;
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x14));
  FUN_1000b647();
  return;
}



// Function: Catch@1000b585 at 1000b585

undefined * Catch_1000b585(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x80),"SubFileComponent.cpp",0x54d,
                       "CSubFileComponent::GetDataValues",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x4c) = uVar2;
  return &DAT_1000b666;
}



// Function: Catch@1000b5d1 at 1000b5d1

undefined * Catch_1000b5d1(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0xac),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 0xb;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0xac),"SubFileComponent.cpp",0x54d,
                       "CSubFileComponent::GetDataValues",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x38) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 10;
  uStack0000001c = 0x1000b63b;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0xac));
  return &DAT_1000b650;
}



// Function: FUN_1000b647 at 1000b647

undefined4 FUN_1000b647(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x58) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x54));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x58);
}



// Function: CSubFileComponent_WriteDataValues at 1000b6b0

void CSubFileComponent_WriteDataValues(int param_1,int param_2,int param_3,size_t param_4,int param_5)

{
  char cVar1;
  int *piVar2;
  IUnknown *pIVar3;
  int iVar4;
  _GUID *p_Var5;
  uint uStack_a0;
  undefined4 local_70;
  undefined4 uStack_6c;
  undefined4 local_68;
  undefined4 uStack_64;
  undefined1 local_60 [24];
  int local_48;
  long lStack_44;
  int *piStack_40;
  void *local_3c;
  int local_38;
  long local_34;
  int *local_30;
  long local_2c;
  int *local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002acd9;
  local_10 = ExceptionList;
  uStack_a0 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_a0;
  ExceptionList = &local_10;
  FUN_1000db90(local_60,param_1 + 0x68);
  local_1c = 0;
  local_8 = 1;
  if (param_5 == 0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  local_20 = FUN_10004f80(param_2,param_3);
  if (local_20 == -1) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  cVar1 = FUN_10004a80((void *)(param_1 + -0xc),param_2,param_3,param_4,local_20);
  if (cVar1 != '\0') {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  piVar2 = (int *)FUN_1000fb90((void *)(param_1 + 0x40),local_20);
  FUN_1000d830(&local_18,piVar2);
  local_8._0_1_ = 2;
  FUN_10001e90(&local_70);
  local_8 = CONCAT31(local_8._1_3_,3);
  local_28 = (int *)FUN_1000fd70(&local_18);
  local_2c = (**(code **)(*local_28 + 0x34))(local_28,&local_70);
  local_1c = local_2c;
  if (local_2c < 0) {
    p_Var5 = (_GUID *)&DAT_1002f4e0;
    pIVar3 = (IUnknown *)FUN_1000fbf0(&local_18);
    _com_issue_errorex(local_2c,pIVar3,p_Var5);
  }
  local_24 = 0;
  local_3c = (void *)0x0;
  iVar4 = Ordinal_23(local_68,&local_24);
  if (iVar4 < 0) {
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  else {
    iVar4 = Ordinal_23(*(undefined4 *)(param_5 + 8),&local_3c);
    if (-1 < iVar4) {
      local_8 = CONCAT31(local_8._1_3_,4);
      local_38 = 0;
      local_30 = (int *)FUN_1000fd70(&local_18);
      local_34 = (**(code **)(*local_30 + 0x24))(local_30,&local_38);
      local_1c = local_34;
      if (local_34 < 0) {
        p_Var5 = (_GUID *)&DAT_1002f4e0;
        pIVar3 = (IUnknown *)FUN_1000fbf0(&local_18);
        _com_issue_errorex(local_34,pIVar3,p_Var5);
      }
      local_48 = param_3 - local_38;
      memcpy((void *)(local_24 + local_48),local_3c,param_4);
      iVar4 = Ordinal_23(local_68,&local_24);
      if (iVar4 < 0) {
        FUN_10025510((uchar *)"SubFileComponent.cpp");
      }
      Ordinal_24(local_68);
      Ordinal_24(*(undefined4 *)(param_5 + 8));
      CSubFileComponent_WriteDataValues();
      return;
    }
    FUN_10025510((uchar *)"SubFileComponent.cpp");
  }
  piStack_40 = (int *)FUN_1000fd70(&local_18);
  lStack_44 = (**(code **)(*piStack_40 + 0x38))(piStack_40,local_70,uStack_6c,local_68,uStack_64);
  local_1c = lStack_44;
  if (lStack_44 < 0) {
    p_Var5 = (_GUID *)&DAT_1002f4e0;
    pIVar3 = (IUnknown *)FUN_1000fbf0(&local_18);
    _com_issue_errorex(lStack_44,pIVar3,p_Var5);
  }
  *(int *)(param_1 + 0x3c) = local_20;
  local_8._0_1_ = 2;
  FUN_100020f0(&local_70);
  local_8 = CONCAT31(local_8._1_3_,1);
  FID_conflict__bad_alloc(&local_18);
  FUN_1000bafb();
  return;
}



// Function: Catch@1000b90c at 1000b90c

undefined * Catch_1000b90c(void)

{
  int unaff_EBP;
  
  Ordinal_24(*(undefined4 *)(unaff_EBP + -100));
  Ordinal_24(*(undefined4 *)(*(int *)(unaff_EBP + 0x18) + 8));
  FUN_10025510((uchar *)"SubFileComponent.cpp");
  return &DAT_1000b953;
}



// Function: CSubFileComponent_WriteDataValues at 1000b94a

void CSubFileComponent_WriteDataValues(void)

{
  undefined4 uVar1;
  IUnknown *pIVar2;
  int unaff_EBP;
  _GUID *p_Var3;
  
  *(undefined4 *)(unaff_EBP + -4) = 3;
  *(undefined4 *)(unaff_EBP + -0x7c) = *(undefined4 *)(unaff_EBP + -0x6c);
  *(undefined4 *)(unaff_EBP + -0x78) = *(undefined4 *)(unaff_EBP + -0x68);
  *(undefined4 *)(unaff_EBP + -0x74) = *(undefined4 *)(unaff_EBP + -100);
  *(undefined4 *)(unaff_EBP + -0x70) = *(undefined4 *)(unaff_EBP + -0x60);
  uVar1 = FUN_1000fd70((undefined4 *)(unaff_EBP + -0x14));
  *(undefined4 *)(unaff_EBP + -0x3c) = uVar1;
  uVar1 = (**(code **)(**(int **)(unaff_EBP + -0x3c) + 0x38))
                    (*(undefined4 *)(unaff_EBP + -0x3c),*(undefined4 *)(unaff_EBP + -0x7c),
                     *(undefined4 *)(unaff_EBP + -0x78),*(undefined4 *)(unaff_EBP + -0x74),
                     *(undefined4 *)(unaff_EBP + -0x70));
  *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
  *(undefined4 *)(unaff_EBP + -0x40) = *(undefined4 *)(unaff_EBP + -0x18);
  if (*(int *)(unaff_EBP + -0x40) < 0) {
    p_Var3 = (_GUID *)&DAT_1002f4e0;
    pIVar2 = (IUnknown *)FUN_1000fbf0((undefined4 *)(unaff_EBP + -0x14));
    _com_issue_errorex(*(long *)(unaff_EBP + -0x40),pIVar2,p_Var3);
  }
  *(undefined4 *)(*(int *)(unaff_EBP + 8) + 0x3c) = *(undefined4 *)(unaff_EBP + -0x1c);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  FUN_100020f0(unaff_EBP + -0x6c);
  *(undefined1 *)(unaff_EBP + -4) = 1;
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x14));
  FUN_1000bafb();
  return;
}



// Function: Catch@1000ba39 at 1000ba39

undefined * Catch_1000ba39(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40(*(void **)(unaff_EBP + -0x54),"SubFileComponent.cpp",0x5b7,
                       "CSubFileComponent::WriteDataValues",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x4c) = uVar2;
  return &DAT_1000bb1a;
}



// Function: Catch@1000ba85 at 1000ba85

undefined * Catch_1000ba85(void)

{
  undefined8 *puVar1;
  undefined4 uVar2;
  int unaff_EBP;
  undefined4 uStack0000001c;
  
  _com_error::_com_error((_com_error *)(unaff_EBP + -0x8c),-0x7fff0001,(IErrorInfo *)0x0,false);
  *(undefined1 *)(unaff_EBP + -4) = 7;
  puVar1 = (undefined8 *)FUN_10011ad0();
  uVar2 = FUN_10024d40((void *)(unaff_EBP + -0x8c),"SubFileComponent.cpp",0x5b7,
                       "CSubFileComponent::WriteDataValues",*puVar1,puVar1[1]);
  *(undefined4 *)(unaff_EBP + -0x48) = uVar2;
  *(undefined1 *)(unaff_EBP + -4) = 6;
  uStack0000001c = 0x1000baef;
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x8c));
  return &DAT_1000bb04;
}



// Function: FUN_1000bafb at 1000bafb

undefined4 FUN_1000bafb(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0;
  *(undefined4 *)(unaff_EBP + -0x50) = 0;
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x5c));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x50);
}



// Function: FUN_1000bb60 at 1000bb60

int FUN_1000bb60(int param_1,undefined4 param_2,undefined4 *param_3,int param_4,undefined4 param_5,
                uint *param_6)

{
  int iVar1;
  
  iVar1 = FUN_10011800(param_1,param_2,param_3,param_4,param_5,param_6);
  if (iVar1 < 0) {
    iVar1 = FUN_10011830(param_1 + 0xc,param_2,param_3,param_4,param_5,param_6);
    if (iVar1 < 0) {
      iVar1 = FUN_100117d0(param_1 + 8,param_2,param_3,param_4,param_5,param_6);
      if (-1 < iVar1) {
        *param_6 = *param_6 | 0x30000;
      }
    }
    else {
      *param_6 = *param_6 | 0x20000;
    }
  }
  else {
    *param_6 = *param_6 | 0x10000;
  }
  return iVar1;
}



// Function: FUN_1000bc70 at 1000bc70

undefined4
FUN_1000bc70(int param_1,uint param_2,undefined4 param_3,undefined4 param_4,undefined2 param_5,
            undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)

{
  uint uVar1;
  undefined4 uVar2;
  uint uVar3;
  
  uVar1 = param_2 & 0xffff0000;
  uVar3 = param_2 & 0xffff;
  if (uVar1 == 0x10000) {
    uVar2 = FUN_10012390(param_1,uVar3,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  }
  else if (uVar1 == 0x20000) {
    uVar2 = FUN_100123d0(param_1 + 0xc,uVar3,param_3,param_4,param_5,param_6,param_7,param_8,param_9
                        );
  }
  else if (uVar1 == 0x30000) {
    uVar2 = FUN_10012350(param_1 + 8,uVar3,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  }
  else {
    uVar2 = 0x80020003;
  }
  return uVar2;
}



// Function: FUN_1000bd50 at 1000bd50

undefined4 * __thiscall
FUN_1000bd50(void *this,refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ad08;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)this = 0;
  boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
  refcount_ptr<struct_boost::exception_detail::error_info_container>
            ((refcount_ptr<struct_boost::exception_detail::error_info_container> *)&stack0xffffffd0,
             param_1);
  local_8 = 0xffffffff;
  iVar1 = FUN_1000c850();
  if ((iVar1 < 0) && (iVar1 != -0x7fffbffe)) {
    _com_issue_error(iVar1);
  }
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_1000bdf0 at 1000bdf0

undefined4 * __thiscall
FUN_1000bdf0(void *this,refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ad38;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)this = 0;
  boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
  refcount_ptr<struct_boost::exception_detail::error_info_container>
            ((refcount_ptr<struct_boost::exception_detail::error_info_container> *)&stack0xffffffd0,
             param_1);
  local_8 = 0xffffffff;
  iVar1 = FUN_1000c9f0();
  if ((iVar1 < 0) && (iVar1 != -0x7fffbffe)) {
    _com_issue_error(iVar1);
  }
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_1000be90 at 1000be90

undefined4 * __thiscall
FUN_1000be90(void *this,refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ad68;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)this = 0;
  boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
  refcount_ptr<struct_boost::exception_detail::error_info_container>
            ((refcount_ptr<struct_boost::exception_detail::error_info_container> *)&stack0xffffffd0,
             param_1);
  local_8 = 0xffffffff;
  iVar1 = FUN_1000cac0();
  if ((iVar1 < 0) && (iVar1 != -0x7fffbffe)) {
    _com_issue_error(iVar1);
  }
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FID_conflict:operator= at 1000bf30

/* Library Function - Multiple Matches With Different Base Names
    public: class _CIP<struct IBindCtx,&struct _GUID const IID_IBindCtx> & __thiscall _CIP<struct
   IBindCtx,&struct _GUID const IID_IBindCtx>::operator=(struct IBindCtx *)
    public: class _CIP<struct IBindHost,&struct _GUID const IID_IBindHost> & __thiscall _CIP<struct
   IBindHost,&struct _GUID const IID_IBindHost>::operator=(struct IBindHost *)
    public: class _CIP<struct IBindStatusCallback,&struct _GUID const IID_IBindStatusCallback> &
   __thiscall _CIP<struct IBindStatusCallback,&struct _GUID const
   IID_IBindStatusCallback>::operator=(struct IBindStatusCallback *)
    public: class _CIP<struct IBinding,&struct _GUID const IID_IBinding> & __thiscall _CIP<struct
   IBinding,&struct _GUID const IID_IBinding>::operator=(struct IBinding *)
     6 names - too many to list
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

int * __thiscall FID_conflict_operator_(void *this,int param_1)

{
  int *piVar1;
  
                    /* WARNING: Load size is inaccurate */
  if (*this != param_1) {
                    /* WARNING: Load size is inaccurate */
    piVar1 = *this;
    *(int *)this = param_1;
    FUN_10012d40((int *)this);
    if (piVar1 != (int *)0x0) {
      (**(code **)(*piVar1 + 8))(piVar1);
    }
  }
  return (int *)this;
}



// Function: FID_conflict:operator= at 1000bf80

/* Library Function - Multiple Matches With Different Base Names
    public: class _CIP<struct IBindCtx,&struct _GUID const IID_IBindCtx> & __thiscall _CIP<struct
   IBindCtx,&struct _GUID const IID_IBindCtx>::operator=(struct IBindCtx *)
    public: class _CIP<struct IBindHost,&struct _GUID const IID_IBindHost> & __thiscall _CIP<struct
   IBindHost,&struct _GUID const IID_IBindHost>::operator=(struct IBindHost *)
    public: class _CIP<struct IBindStatusCallback,&struct _GUID const IID_IBindStatusCallback> &
   __thiscall _CIP<struct IBindStatusCallback,&struct _GUID const
   IID_IBindStatusCallback>::operator=(struct IBindStatusCallback *)
    public: class _CIP<struct IBinding,&struct _GUID const IID_IBinding> & __thiscall _CIP<struct
   IBinding,&struct _GUID const IID_IBinding>::operator=(struct IBinding *)
     6 names - too many to list
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

int * __thiscall FID_conflict_operator_(void *this,int param_1)

{
  int *piVar1;
  
                    /* WARNING: Load size is inaccurate */
  if (*this != param_1) {
                    /* WARNING: Load size is inaccurate */
    piVar1 = *this;
    *(int *)this = param_1;
    FUN_10012da0((int *)this);
    if (piVar1 != (int *)0x0) {
      (**(code **)(*piVar1 + 8))(piVar1);
    }
  }
  return (int *)this;
}



// Function: FID_conflict:operator= at 1000bfd0

/* Library Function - Multiple Matches With Different Base Names
    public: class _CIP<struct IBindCtx,&struct _GUID const IID_IBindCtx> & __thiscall _CIP<struct
   IBindCtx,&struct _GUID const IID_IBindCtx>::operator=(struct IBindCtx *)
    public: class _CIP<struct IBindHost,&struct _GUID const IID_IBindHost> & __thiscall _CIP<struct
   IBindHost,&struct _GUID const IID_IBindHost>::operator=(struct IBindHost *)
    public: class _CIP<struct IBindStatusCallback,&struct _GUID const IID_IBindStatusCallback> &
   __thiscall _CIP<struct IBindStatusCallback,&struct _GUID const
   IID_IBindStatusCallback>::operator=(struct IBindStatusCallback *)
    public: class _CIP<struct IBinding,&struct _GUID const IID_IBinding> & __thiscall _CIP<struct
   IBinding,&struct _GUID const IID_IBinding>::operator=(struct IBinding *)
     6 names - too many to list
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

int * __thiscall FID_conflict_operator_(void *this,int param_1)

{
  int *piVar1;
  
                    /* WARNING: Load size is inaccurate */
  if (*this != param_1) {
                    /* WARNING: Load size is inaccurate */
    piVar1 = *this;
    *(int *)this = param_1;
    FUN_10012e60((int *)this);
    if (piVar1 != (int *)0x0) {
      (**(code **)(*piVar1 + 8))(piVar1);
    }
  }
  return (int *)this;
}



// Function: FUN_1000c020 at 1000c020

void __thiscall FUN_1000c020(void *this,undefined4 *param_1)

{
  char cVar1;
  undefined4 *puVar2;
  undefined *puVar3;
  
  puVar2 = (undefined4 *)FUN_1000fc00(param_1);
  cVar1 = FUN_10012470(this,puVar2);
  if (cVar1 == '\0') {
    puVar3 = &DAT_1002fb58;
    puVar2 = (undefined4 *)FUN_1000fc00(param_1);
    FUN_10010810((int *)this,puVar2,puVar3);
  }
  else {
    FUN_1000fc10((undefined4 *)this);
  }
  return;
}



// Function: FUN_1000c070 at 1000c070

void * __thiscall
FUN_1000c070(void *this,refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ad98;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
  refcount_ptr<struct_boost::exception_detail::error_info_container>
            ((refcount_ptr<struct_boost::exception_detail::error_info_container> *)&stack0xffffffd0,
             param_1);
  local_8 = 0xffffffff;
  iVar1 = FUN_1000c780();
  if ((iVar1 < 0) && (iVar1 != -0x7fffbffe)) {
    _com_issue_error(iVar1);
  }
  ExceptionList = local_10;
  return this;
}



// Function: FUN_1000c100 at 1000c100

void * __thiscall
FUN_1000c100(void *this,refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002adc8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
  refcount_ptr<struct_boost::exception_detail::error_info_container>
            ((refcount_ptr<struct_boost::exception_detail::error_info_container> *)&stack0xffffffd0,
             param_1);
  local_8 = 0xffffffff;
  iVar1 = FUN_1000c920();
  if ((iVar1 < 0) && (iVar1 != -0x7fffbffe)) {
    _com_issue_error(iVar1);
  }
  ExceptionList = local_10;
  return this;
}



// Function: operator==<> at 1000c190

/* Library Function - Multiple Matches With Same Base Name
    bool __cdecl std::operator==<char,char>(class std::allocator<char> const &,class
   std::allocator<char> const &)
    bool __cdecl std::operator==<unsigned short,unsigned short>(class std::allocator<unsigned short>
   const &,class std::allocator<unsigned short> const &)
    bool __cdecl std::operator==<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > const &,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   const &)
    bool __cdecl std::operator==<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > const &,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > const &)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined1 operator==<>(void)

{
  return 1;
}



// Function: operator==<> at 1000c1a0

/* Library Function - Multiple Matches With Same Base Name
    bool __cdecl std::operator==<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >,class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > >(class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > > const &,class std::move_iterator<class std::_Vector_iterator<class
   std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > > > const &)
    bool __cdecl std::operator==<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >,class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > >(class std::move_iterator<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > > const &,class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > > > const
   &)
   
   Library: Visual Studio 2012 Release */

void __cdecl operator==<>(undefined4 param_1,void *param_2)

{
  _Equal<>(param_2);
  return;
}



// Function: operator==<> at 1000c1c0

/* Library Function - Multiple Matches With Same Base Name
    bool __cdecl std::operator==<class std::allocator<char>,class std::allocator<char> >(struct
   std::_Wrap_alloc<class std::allocator<char> > const &,struct std::_Wrap_alloc<class
   std::allocator<char> > const &)
    bool __cdecl std::operator==<class std::allocator<unsigned short>,class std::allocator<unsigned
   short> >(struct std::_Wrap_alloc<class std::allocator<unsigned short> > const &,struct
   std::_Wrap_alloc<class std::allocator<unsigned short> > const &)
    bool __cdecl std::operator==<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >(struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > const &,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >
   const &)
    bool __cdecl std::operator==<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >(struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > const
   &,struct std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > const &)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void operator==<>(void)

{
  undefined1 local_6;
  undefined1 local_5;
  
  allocator<>(&local_5);
  allocator<>(&local_6);
  operator==<>();
  return;
}



// Function: operator!=<> at 1000c1f0

/* Library Function - Multiple Matches With Same Base Name
    bool __cdecl std::operator!=<char,struct std::char_traits<char> >(class
   std::istreambuf_iterator<char,struct std::char_traits<char> > const &,class
   std::istreambuf_iterator<char,struct std::char_traits<char> > const &)
    bool __cdecl std::operator!=<unsigned short,struct std::char_traits<unsigned short> >(class
   std::istreambuf_iterator<unsigned short,struct std::char_traits<unsigned short> > const &,class
   std::istreambuf_iterator<unsigned short,struct std::char_traits<unsigned short> > const &)
    bool __cdecl std::operator!=<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >,class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > >(class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > > const &,class std::move_iterator<class std::_Vector_iterator<class
   std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > > > const &)
    bool __cdecl std::operator!=<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >,class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > >(class std::move_iterator<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > > const &,class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > > > const
   &)
     5 names - too many to list
   
   Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */

bool __cdecl operator!=<>(undefined4 param_1,void *param_2)

{
  char cVar1;
  
  cVar1 = operator==<>(param_1,param_2);
  return cVar1 == '\0';
}



// Function: operator!=<> at 1000c230

/* Library Function - Multiple Matches With Same Base Name
    bool __cdecl std::operator!=<class std::allocator<char>,class std::allocator<char> >(struct
   std::_Wrap_alloc<class std::allocator<char> > const &,struct std::_Wrap_alloc<class
   std::allocator<char> > const &)
    bool __cdecl std::operator!=<class std::allocator<unsigned short>,class std::allocator<unsigned
   short> >(struct std::_Wrap_alloc<class std::allocator<unsigned short> > const &,struct
   std::_Wrap_alloc<class std::allocator<unsigned short> > const &)
    bool __cdecl std::operator!=<class std::allocator<wchar_t>,class std::allocator<wchar_t>
   >(struct std::_Wrap_alloc<class std::allocator<wchar_t> > const &,struct std::_Wrap_alloc<class
   std::allocator<wchar_t> > const &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

bool operator!=<>(void)

{
  char cVar1;
  
  cVar1 = operator==<>();
  return cVar1 == '\0';
}



// Function: operator-<> at 1000c270

/* Library Function - Multiple Matches With Same Base Name
    int __cdecl std::operator-<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >,class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > >(class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > > &,class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > > const &)
    int __cdecl std::operator-<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >,class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > >(class std::move_iterator<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > > &,class std::move_iterator<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > > const &)
   
   Library: Visual Studio 2012 Release */

void __cdecl operator-<>(void *param_1,void *param_2)

{
  int *piVar1;
  undefined4 *this;
  undefined4 local_c;
  undefined4 local_8;
  
  piVar1 = base(param_1,&local_8);
  this = base(param_2,&local_c);
  FID_conflict_operator_(this,piVar1);
  return;
}



// Function: operator==<> at 1000c2a0

/* Library Function - Multiple Matches With Same Base Name
    bool __cdecl std::operator==<char,struct std::char_traits<char> >(class
   std::istreambuf_iterator<char,struct std::char_traits<char> > const &,class
   std::istreambuf_iterator<char,struct std::char_traits<char> > const &)
    bool __cdecl std::operator==<unsigned short,struct std::char_traits<unsigned short> >(class
   std::istreambuf_iterator<unsigned short,struct std::char_traits<unsigned short> > const &,class
   std::istreambuf_iterator<unsigned short,struct std::char_traits<unsigned short> > const &)
    bool __cdecl std::operator==<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >,class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > >(class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > > const &,class std::move_iterator<class std::_Vector_iterator<class
   std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > > > const &)
    bool __cdecl std::operator==<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >,class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > >(class std::move_iterator<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > > const &,class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > > > const
   &)
     5 names - too many to list
   
   Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */

void __cdecl operator==<>(undefined4 param_1,void *param_2)

{
  FUN_1000c6b0(param_2);
  return;
}



// Function: operator!=<> at 1000c2c0

/* Library Function - Multiple Matches With Same Base Name
    bool __cdecl std::operator!=<char,struct std::char_traits<char> >(class
   std::istreambuf_iterator<char,struct std::char_traits<char> > const &,class
   std::istreambuf_iterator<char,struct std::char_traits<char> > const &)
    bool __cdecl std::operator!=<unsigned short,struct std::char_traits<unsigned short> >(class
   std::istreambuf_iterator<unsigned short,struct std::char_traits<unsigned short> > const &,class
   std::istreambuf_iterator<unsigned short,struct std::char_traits<unsigned short> > const &)
    bool __cdecl std::operator!=<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >,class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > >(class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > > const &,class std::move_iterator<class std::_Vector_iterator<class
   std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > > > const &)
    bool __cdecl std::operator!=<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >,class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > >(class std::move_iterator<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > > const &,class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > > > const
   &)
     5 names - too many to list
   
   Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */

bool __cdecl operator!=<>(void *param_1,undefined4 param_2)

{
  char cVar1;
  
  cVar1 = operator==<>(param_2,param_1);
  return cVar1 == '\0';
}



// Function: AtlAdd<> at 1000c300

/* Library Function - Multiple Matches With Same Base Name
    long __cdecl ATL::AtlAdd<unsigned int>(unsigned int *,unsigned int,unsigned int)
    long __cdecl ATL::AtlAdd<unsigned long>(unsigned long *,unsigned long,unsigned long)
   
   Library: Visual Studio 2010 Debug */

HRESULT __cdecl AtlAdd<>(int *param_1,int param_2,uint param_3)

{
  HRESULT HVar1;
  
  if (-param_2 - 1U < param_3) {
    HVar1 = _HRESULT_FROM_WIN32(0x216);
  }
  else {
    *param_1 = param_2 + param_3;
    HVar1 = 0;
  }
  return HVar1;
}



// Function: AtlAddThrow<unsigned_long> at 1000c330

/* Library Function - Single Match
    unsigned long __cdecl ATL::AtlAddThrow<unsigned long>(unsigned long,unsigned long)
   
   Library: Visual Studio 2010 Debug */

ulong __cdecl ATL::AtlAddThrow<unsigned_long>(ulong param_1,ulong param_2)

{
  ulong local_c;
  HRESULT local_8;
  
  local_8 = AtlAdd<>((int *)&local_c,param_1,param_2);
  if (local_8 < 0) {
    FUN_10010aa0(local_8);
  }
  return local_c;
}



// Function: AtlMultiply<int> at 1000c370

/* Library Function - Single Match
    long __cdecl ATL::AtlMultiply<int>(int *,int,int)
   
   Library: Visual Studio 2010 Debug */

long __cdecl ATL::AtlMultiply<int>(int *param_1,int param_2,int param_3)

{
  long lVar1;
  longlong lVar2;
  undefined4 local_c;
  undefined4 local_8;
  
  lVar2 = __allmul(param_2,param_2 >> 0x1f,param_3,param_3 >> 0x1f);
  local_8 = (uint)((ulonglong)lVar2 >> 0x20);
  if ((((int)local_8 < 1) && ((local_c = (uint)lVar2, lVar2 < 0 || (local_c < 0x80000000)))) &&
     ((local_8 < 0x80000000 || ((-2 < (int)local_8 && (0x7fffffff < local_c)))))) {
    *param_1 = local_c;
    lVar1 = 0;
  }
  else {
    lVar1 = _HRESULT_FROM_WIN32(0x216);
  }
  return lVar1;
}



// Function: FUN_1000c3e0 at 1000c3e0

void __cdecl FUN_1000c3e0(undefined4 *param_1)

{
  FUN_10010e50(0,&DAT_1002f4e0,param_1);
  return;
}



// Function: QueryInterface<> at 1000c400

/* Library Function - Multiple Matches With Same Base Name
    public: long __stdcall CMFCComObject<class ATL::CAccessibleProxy>::QueryInterface<struct
   IAccessibleProxy>(struct IAccessibleProxy * *)
    public: long __stdcall IUnknown::QueryInterface<struct IAccessor>(struct IAccessor * *)
    public: long __stdcall IUnknown::QueryInterface<struct IColumnsInfo>(struct IColumnsInfo * *)
    public: long __stdcall IUnknown::QueryInterface<struct IHTMLDocument2>(struct IHTMLDocument2 *
   *)
     8 names - too many to list
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void QueryInterface<>(undefined4 *param_1,undefined4 param_2)

{
  (**(code **)*param_1)(param_1,&DAT_1002fb68,param_2);
  return;
}



// Function: FUN_1000c420 at 1000c420

void * __cdecl FUN_1000c420(uint param_1)

{
  void *local_8;
  
  local_8 = (void *)0x0;
  if ((param_1 != 0) && (local_8 = operator_new(param_1), local_8 == (void *)0x0)) {
    std::_Xbad_alloc();
  }
  return local_8;
}



// Function: FUN_1000c460 at 1000c460

void * __cdecl FUN_1000c460(uint param_1)

{
  void *local_8;
  
  local_8 = (void *)0x0;
  if ((param_1 != 0) &&
     ((0x3fffffff < param_1 || (local_8 = operator_new(param_1 << 2), local_8 == (void *)0x0)))) {
    std::_Xbad_alloc();
  }
  return local_8;
}



// Function: FUN_1000c4b0 at 1000c4b0

void * __cdecl FUN_1000c4b0(uint param_1)

{
  void *local_8;
  
  local_8 = (void *)0x0;
  if ((param_1 != 0) &&
     ((0xaaaaaaa < param_1 || (local_8 = operator_new(param_1 * 0x18), local_8 == (void *)0x0)))) {
    std::_Xbad_alloc();
  }
  return local_8;
}



// Function: _Move<> at 1000c500

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > * __cdecl
   std::_Move<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *>(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __cdecl std::_Move<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Move<>(int *param_1,int *param_2,int param_3)

{
  _Ptr_cat<>(param_1);
  FUN_1000c540(param_1,param_2,param_3);
  return;
}



// Function: FUN_1000c540 at 1000c540

int __cdecl FUN_1000c540(int *param_1,int *param_2,int param_3)

{
  while (param_1 != param_2) {
    param_2 = param_2 + -1;
    param_3 = param_3 + -4;
    FUN_1000f350(param_2);
  }
  return param_3;
}



// Function: _Destroy_range<> at 1000c570

/* Library Function - Multiple Matches With Same Base Name
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > &)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > &)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > >(class Concurrency::details::_ContextCallback *,class
   Concurrency::details::_ContextCallback *,struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Destroy_range<>(void *param_1,void *param_2,void *param_3)

{
  _Ptr_cat<>(param_1);
  _Destroy_range<>(param_1,param_2,param_3);
  return;
}



// Function: _Destroy_range<> at 1000c5b0

/* Library Function - Multiple Matches With Same Base Name
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > &,struct std::_Nonscalar_ptr_iterator_tag)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > &,struct
   std::_Nonscalar_ptr_iterator_tag)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > >(class Concurrency::details::_ContextCallback *,class
   Concurrency::details::_ContextCallback *,struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > &,struct std::_Nonscalar_ptr_iterator_tag)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Destroy_range<>(void *param_1,void *param_2,void *param_3)

{
  for (; param_1 != param_2; param_1 = (void *)((int)param_1 + 4)) {
    destroy<>(param_3,param_1);
  }
  return;
}



// Function: _Destroy_range<> at 1000c5e0

/* Library Function - Multiple Matches With Same Base Name
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > &)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > &)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > >(class Concurrency::details::_ContextCallback *,class
   Concurrency::details::_ContextCallback *,struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Destroy_range<>(void *param_1,void *param_2,void *param_3)

{
  _Ptr_cat<>(param_1);
  _Destroy_range<>(param_1,param_2,param_3);
  return;
}



// Function: _Destroy_range<> at 1000c620

/* Library Function - Multiple Matches With Same Base Name
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > &,struct std::_Nonscalar_ptr_iterator_tag)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > &,struct
   std::_Nonscalar_ptr_iterator_tag)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > >(class Concurrency::details::_ContextCallback *,class
   Concurrency::details::_ContextCallback *,struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > &,struct std::_Nonscalar_ptr_iterator_tag)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Destroy_range<>(void *param_1,void *param_2,void *param_3)

{
  for (; param_1 != param_2; param_1 = (void *)((int)param_1 + 0x18)) {
    destroy<>(param_3,param_1);
  }
  return;
}



// Function: _Equal<> at 1000c650

/* Library Function - Multiple Matches With Same Base Name
    public: bool __thiscall std::move_iterator<class std::_Vector_iterator<class
   std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > > >::_Equal<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > >(class
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > > const &)const 
    public: bool __thiscall std::move_iterator<class std::_Vector_iterator<class
   std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > >::_Equal<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > >(class std::move_iterator<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > > const &)const 
   
   Library: Visual Studio 2012 Release */

void _Equal<>(void *param_1)

{
  int *piVar1;
  undefined4 local_c;
  void *local_8;
  
  piVar1 = base(param_1,&local_c);
  FID_conflict_operator__(local_8,piVar1);
  return;
}



// Function: _Destroy_range<> at 1000c680

/* Library Function - Multiple Matches With Same Base Name
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > &,struct std::_Nonscalar_ptr_iterator_tag)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > &,struct
   std::_Nonscalar_ptr_iterator_tag)
    void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > >(class Concurrency::details::_ContextCallback *,class
   Concurrency::details::_ContextCallback *,struct std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> > &,struct std::_Nonscalar_ptr_iterator_tag)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Destroy_range<>(int param_1,int param_2,int *param_3)

{
  for (; param_1 != param_2; param_1 = param_1 + 4) {
    FUN_1000f350(param_3);
  }
  return;
}



// Function: FUN_1000c6b0 at 1000c6b0

void FUN_1000c6b0(void *param_1)

{
  undefined4 *this;
  uint *extraout_var;
  undefined4 local_c [2];
  
  this = base(param_1,local_c);
  FUN_10010200(this,extraout_var);
  return;
}



// Function: _Move<> at 1000c6e0

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > * __cdecl
   std::_Move<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *>(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __cdecl std::_Move<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Move<>(int param_1,int param_2,int param_3)

{
  _Ptr_cat<>(param_1);
  _Move<>(param_1,param_2,param_3);
  return;
}



// Function: _Move<> at 1000c720

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > * __cdecl
   std::_Move<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *>(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Nonscalar_ptr_iterator_tag)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __cdecl std::_Move<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Nonscalar_ptr_iterator_tag)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

int __cdecl _Move<>(int param_1,int param_2,int param_3)

{
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *pLVar1;
  
  for (; param_1 != param_2; param_1 = param_1 + 4) {
    pLVar1 = (List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
              *)move<>(param_1);
    FUN_1000f2c0(pLVar1);
    param_3 = param_3 + 4;
  }
  return param_3;
}



// Function: _Ptr_cat<> at 1000c760

/* Library Function - Multiple Matches With Same Base Name
    struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *)
    struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined1 __fastcall _Ptr_cat<>(undefined4 param_1)

{
  undefined1 local_5;
  
  local_5 = (undefined1)((uint)param_1 >> 0x18);
  return local_5;
}



// Function: _Ptr_cat<> at 1000c770

/* Library Function - Multiple Matches With Same Base Name
    struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *)
    struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined1 __fastcall _Ptr_cat<>(undefined4 param_1)

{
  undefined1 local_5;
  
  local_5 = (undefined1)((uint)param_1 >> 0x18);
  return local_5;
}



// Function: FUN_1000c780 at 1000c780

int FUN_1000c780(void)

{
  int iVar1;
  bool bVar2;
  uint uVar3;
  undefined4 uVar4;
  int *piVar5;
  int local_24;
  void *local_20;
  int local_1c;
  undefined4 *local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002adf8;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  bVar2 = FUN_1000f9d0(&stack0x00000004,0);
  if (bVar2) {
    local_18 = (undefined4 *)FUN_1000fd90((int *)&stack0x00000004);
    piVar5 = &local_24;
    uVar4 = FUN_10011a30();
    local_14 = (**(code **)*local_18)(local_18,uVar4,piVar5,uVar3);
    if (local_14 < 0) {
      local_1c = 0;
    }
    else {
      local_1c = local_24;
    }
    Attach(local_20,local_1c);
  }
  else {
    FID_conflict_operator_(local_20,0);
    local_14 = -0x7fffbffe;
  }
  iVar1 = local_14;
  local_8 = 0xffffffff;
  FUN_1000ee40((int *)&stack0x00000004);
  ExceptionList = local_10;
  return iVar1;
}



// Function: FUN_1000c850 at 1000c850

int FUN_1000c850(void)

{
  int iVar1;
  bool bVar2;
  uint uVar3;
  undefined4 uVar4;
  int *piVar5;
  int local_24;
  void *local_20;
  int local_1c;
  undefined4 *local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002ae28;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  bVar2 = FUN_1000fa10(&stack0x00000004,0);
  if (bVar2) {
    local_18 = (undefined4 *)FUN_1000fdf0((int *)&stack0x00000004);
    piVar5 = &local_24;
    uVar4 = FUN_10011a50();
    local_14 = (**(code **)*local_18)(local_18,uVar4,piVar5,uVar3);
    if (local_14 < 0) {
      local_1c = 0;
    }
    else {
      local_1c = local_24;
    }
    Attach(local_20,local_1c);
  }
  else {
    FID_conflict_operator_(local_20,0);
    local_14 = -0x7fffbffe;
  }
  iVar1 = local_14;
  local_8 = 0xffffffff;
  FUN_1000eea0((int *)&stack0x00000004);
  ExceptionList = local_10;
  return iVar1;
}



// Function: FUN_1000c920 at 1000c920

int FUN_1000c920(void)

{
  int iVar1;
  bool bVar2;
  uint uVar3;
  undefined4 uVar4;
  int *piVar5;
  int local_24;
  void *local_20;
  int local_1c;
  undefined4 *local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002ae58;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  bVar2 = FUN_1000fa50(&stack0x00000004,0);
  if (bVar2) {
    local_18 = (undefined4 *)FUN_1000fe80((int *)&stack0x00000004);
    piVar5 = &local_24;
    uVar4 = FUN_10011a90();
    local_14 = (**(code **)*local_18)(local_18,uVar4,piVar5,uVar3);
    if (local_14 < 0) {
      local_1c = 0;
    }
    else {
      local_1c = local_24;
    }
    Attach(local_20,local_1c);
  }
  else {
    FID_conflict_operator_(local_20,0);
    local_14 = -0x7fffbffe;
  }
  iVar1 = local_14;
  local_8 = 0xffffffff;
  FUN_1000ef00((int *)&stack0x00000004);
  ExceptionList = local_10;
  return iVar1;
}



// Function: FUN_1000c9f0 at 1000c9f0

int FUN_1000c9f0(void)

{
  int iVar1;
  bool bVar2;
  uint uVar3;
  undefined4 uVar4;
  int *piVar5;
  int local_24;
  void *local_20;
  int local_1c;
  undefined4 *local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002ae88;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  bVar2 = FUN_1000fa90(&stack0x00000004,0);
  if (bVar2) {
    local_18 = (undefined4 *)FUN_1000feb0((int *)&stack0x00000004);
    piVar5 = &local_24;
    uVar4 = FUN_10011a30();
    local_14 = (**(code **)*local_18)(local_18,uVar4,piVar5,uVar3);
    if (local_14 < 0) {
      local_1c = 0;
    }
    else {
      local_1c = local_24;
    }
    Attach(local_20,local_1c);
  }
  else {
    FID_conflict_operator_(local_20,0);
    local_14 = -0x7fffbffe;
  }
  iVar1 = local_14;
  local_8 = 0xffffffff;
  FUN_1000ef20((int *)&stack0x00000004);
  ExceptionList = local_10;
  return iVar1;
}



// Function: FUN_1000cac0 at 1000cac0

int FUN_1000cac0(void)

{
  int iVar1;
  bool bVar2;
  uint uVar3;
  undefined4 uVar4;
  int *piVar5;
  int local_24;
  void *local_20;
  int local_1c;
  undefined4 *local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002aeb8;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  bVar2 = FUN_1000fad0(&stack0x00000004,0);
  if (bVar2) {
    local_18 = (undefined4 *)FUN_1000fee0((int *)&stack0x00000004);
    piVar5 = &local_24;
    uVar4 = FUN_10011a90();
    local_14 = (**(code **)*local_18)(local_18,uVar4,piVar5,uVar3);
    if (local_14 < 0) {
      local_1c = 0;
    }
    else {
      local_1c = local_24;
    }
    Attach(local_20,local_1c);
  }
  else {
    FID_conflict_operator_(local_20,0);
    local_14 = -0x7fffbffe;
  }
  iVar1 = local_14;
  local_8 = 0xffffffff;
  FUN_1000ef40((int *)&stack0x00000004);
  ExceptionList = local_10;
  return iVar1;
}



// Function: _Umove<> at 1000cb90

/* Library Function - Multiple Matches With Same Base Name
    protected: class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *
   __thiscall std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> >,class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::_Umove<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *)
    protected: class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > * __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > >
   >::_Umove<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void _Umove<>(int param_1,int param_2,int param_3)

{
  undefined1 local_5;
  
  Getal(&local_5);
  _Uninitialized_move<>(param_1,param_2,param_3,&local_5);
  return;
}



// Function: _Umove<> at 1000cbd0

/* Library Function - Multiple Matches With Same Base Name
    protected: class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *
   __thiscall std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> >,class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::_Umove<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *)
    protected: class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > * __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > >
   >::_Umove<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void _Umove<>(int param_1,int param_2,int param_3)

{
  undefined1 local_5;
  
  Getal(&local_5);
  _Uninitialized_move<>(param_1,param_2,param_3,&local_5);
  return;
}



// Function: FUN_1000cc10 at 1000cc10

undefined4 __cdecl FUN_1000cc10(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_1000cc20 at 1000cc20

void FUN_1000cc20(int param_1,int param_2,undefined4 param_3,void *param_4)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002aee0;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  for (; param_2 != 0; param_2 = param_2 + -1) {
    construct<>(param_4,param_1,param_3);
    param_1 = param_1 + 4;
  }
  FUN_1000ccb5();
  return;
}



// Function: FUN_1000cc87 at 1000cc87

void FUN_1000cc87(void)

{
  int unaff_EBP;
  
  *(int *)(unaff_EBP + -0x14) = *(int *)(unaff_EBP + -0x14) + 4;
  if (*(int *)(unaff_EBP + -0x14) != *(int *)(unaff_EBP + 8)) {
    destroy<>(*(void **)(unaff_EBP + 0x14),*(void **)(unaff_EBP + -0x14));
    FUN_1000cc87();
    return;
  }
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_1000cc90 at 1000cc90

void FUN_1000cc90(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x14) != *(int *)(unaff_EBP + 8)) {
    destroy<>(*(void **)(unaff_EBP + 0x14),*(void **)(unaff_EBP + -0x14));
    FUN_1000cc87();
    return;
  }
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_1000ccb5 at 1000ccb5

void FUN_1000ccb5(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return;
}



// Function: FUN_1000cce0 at 1000cce0

void FUN_1000cce0(int param_1,int param_2,int param_3,void *param_4)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002af00;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  for (; param_1 != param_2; param_1 = param_1 + 4) {
    construct<>(param_4,param_3,param_1);
    param_3 = param_3 + 4;
  }
  FUN_1000cd77();
  return;
}



// Function: FUN_1000cd49 at 1000cd49

void FUN_1000cd49(void)

{
  int unaff_EBP;
  
  *(int *)(unaff_EBP + -0x14) = *(int *)(unaff_EBP + -0x14) + 4;
  if (*(int *)(unaff_EBP + -0x14) != *(int *)(unaff_EBP + 0x10)) {
    destroy<>(*(void **)(unaff_EBP + 0x14),*(void **)(unaff_EBP + -0x14));
    FUN_1000cd49();
    return;
  }
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_1000cd52 at 1000cd52

void FUN_1000cd52(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x14) != *(int *)(unaff_EBP + 0x10)) {
    destroy<>(*(void **)(unaff_EBP + 0x14),*(void **)(unaff_EBP + -0x14));
    FUN_1000cd49();
    return;
  }
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_1000cd77 at 1000cd77

undefined4 FUN_1000cd77(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + 0x10);
}



// Function: FUN_1000cda0 at 1000cda0

void FUN_1000cda0(int param_1,int param_2,int param_3,void *param_4)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002af20;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  for (; param_1 != param_2; param_1 = param_1 + 0x18) {
    construct<>(param_4,param_3,param_1);
    param_3 = param_3 + 0x18;
  }
  FUN_1000ce37();
  return;
}



// Function: FUN_1000ce09 at 1000ce09

void FUN_1000ce09(void)

{
  int unaff_EBP;
  
  *(int *)(unaff_EBP + -0x14) = *(int *)(unaff_EBP + -0x14) + 0x18;
  if (*(int *)(unaff_EBP + -0x14) != *(int *)(unaff_EBP + 0x10)) {
    destroy<>(*(void **)(unaff_EBP + 0x14),*(void **)(unaff_EBP + -0x14));
    FUN_1000ce09();
    return;
  }
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_1000ce12 at 1000ce12

void FUN_1000ce12(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x14) != *(int *)(unaff_EBP + 0x10)) {
    destroy<>(*(void **)(unaff_EBP + 0x14),*(void **)(unaff_EBP + -0x14));
    FUN_1000ce09();
    return;
  }
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_1000ce37 at 1000ce37

undefined4 FUN_1000ce37(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + 0x10);
}



// Function: _Uninitialized_move<> at 1000ce60

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > * __cdecl
   std::_Uninitialized_move<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> > *,class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >
   &)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __cdecl
   std::_Uninitialized_move<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Uninitialized_move<>(int param_1,int param_2,undefined4 param_3,void *param_4)

{
  _Ptr_cat<>(param_1);
  _Val_type<>();
  FUN_1000cc20(param_1,param_2,param_3,param_4);
  return;
}



// Function: _Uninitialized_move<> at 1000ceb0

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > * __cdecl
   std::_Uninitialized_move<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> > *,class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >
   &)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __cdecl
   std::_Uninitialized_move<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Uninitialized_move<>(int param_1,int param_2,int param_3,void *param_4)

{
  _Ptr_cat<>(param_1);
  _Val_type<>();
  FUN_1000cce0(param_1,param_2,param_3,param_4);
  return;
}



// Function: _Uninitialized_move<> at 1000cf00

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > * __cdecl
   std::_Uninitialized_move<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> > *,class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >
   &)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __cdecl
   std::_Uninitialized_move<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Wrap_alloc<class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl _Uninitialized_move<>(int param_1,int param_2,int param_3,void *param_4)

{
  _Ptr_cat<>(param_1);
  _Val_type<>();
  FUN_1000cda0(param_1,param_2,param_3,param_4);
  return;
}



// Function: _Val_type<> at 1000cf50

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > * __cdecl
   std::_Val_type<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   *>(class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __cdecl std::_Val_type<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 _Val_type<>(void)

{
  return 0;
}



// Function: _Val_type<> at 1000cf60

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > * __cdecl
   std::_Val_type<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   *>(class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __cdecl std::_Val_type<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 _Val_type<>(void)

{
  return 0;
}



// Function: FUN_1000cf70 at 1000cf70

undefined4 __cdecl FUN_1000cf70(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_1000cf80 at 1000cf80

undefined4 __cdecl FUN_1000cf80(undefined4 param_1)

{
  return param_1;
}



// Function: addressof<> at 1000cf90

/* Library Function - Multiple Matches With Same Base Name
    char * __cdecl std::addressof<char>(char &)
    unsigned short * __cdecl std::addressof<unsigned short>(unsigned short &)
    wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
   
   Library: Visual Studio 2012 Release */

undefined4 __cdecl addressof<>(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_1000cfa0 at 1000cfa0

undefined4 __cdecl FUN_1000cfa0(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_1000cfb0 at 1000cfb0

undefined4 __cdecl FUN_1000cfb0(undefined4 param_1)

{
  return param_1;
}



// Function: construct<> at 1000cfc0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::construct<char *,char *
   &>(char * *,char * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(unsigned short * *,unsigned short * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t> >::construct<wchar_t
   *,wchar_t * &>(wchar_t * *,wchar_t * &)
   
   Library: Visual Studio 2012 Release */

void __thiscall construct<>(void *this,undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_2);
  construct<>(this,param_1,uVar1);
  return;
}



// Function: construct<> at 1000cff0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<char>::construct<char *,char * &>(char * *,char * &)
    public: void __thiscall std::allocator<unsigned short>::construct<unsigned short *,unsigned
   short * &>(unsigned short * *,unsigned short * &)
    public: void __thiscall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t *
   *,wchar_t * &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void construct<>(undefined4 param_1,undefined4 param_2)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002af51;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  puVar1 = (undefined4 *)forward<>(4,param_1);
  local_8 = 0;
  if (puVar1 != (undefined4 *)0x0) {
    puVar2 = (undefined4 *)forward<>(param_2);
    *puVar1 = *puVar2;
  }
  ExceptionList = local_10;
  return;
}



// Function: construct<> at 1000d080

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<char> >::construct<char
   *,char * &>(class std::allocator<char> &,char * *,char * &)
    public: static void __cdecl std::allocator_traits<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(class std::allocator<unsigned short> &,unsigned
   short * *,unsigned short * &)
    public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>
   >::construct<wchar_t *,wchar_t * &>(class std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl construct<>(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_3);
  construct<>(param_2,uVar1);
  return;
}



// Function: construct<> at 1000d0a0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::construct<char *,char *
   &>(char * *,char * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(unsigned short * *,unsigned short * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t> >::construct<wchar_t
   *,wchar_t * &>(wchar_t * *,wchar_t * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>
   >::construct<struct std::_Container_proxy,struct std::_Container_proxy>(struct
   std::_Container_proxy *,struct std::_Container_proxy &&)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __thiscall construct<>(void *this,undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_2);
  construct<>(this,param_1,uVar1);
  return;
}



// Function: construct<> at 1000d0d0

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<char> >::construct<char
   *,char * &>(class std::allocator<char> &,char * *,char * &)
    public: static void __cdecl std::allocator_traits<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(class std::allocator<unsigned short> &,unsigned
   short * *,unsigned short * &)
    public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>
   >::construct<wchar_t *,wchar_t * &>(class std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
    public: static void __cdecl std::allocator_traits<class std::allocator<struct
   std::_Container_proxy> >::construct<struct std::_Container_proxy,struct
   std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &,struct
   std::_Container_proxy *,struct std::_Container_proxy &&)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __cdecl construct<>(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  int *piVar1;
  
  piVar1 = (int *)forward<>(param_3);
  FUN_100147e0(param_2,piVar1);
  return;
}



// Function: construct<> at 1000d0f0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::construct<char *,char *
   &>(char * *,char * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(unsigned short * *,unsigned short * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t> >::construct<wchar_t
   *,wchar_t * &>(wchar_t * *,wchar_t * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>
   >::construct<struct std::_Container_proxy,struct std::_Container_proxy>(struct
   std::_Container_proxy *,struct std::_Container_proxy &&)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __thiscall construct<>(void *this,undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_2);
  construct<>(this,param_1,uVar1);
  return;
}



// Function: construct<> at 1000d120

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > &&)
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &&)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void construct<>(undefined4 param_1,undefined4 param_2)

{
  void *this;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *pLVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002af81;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  this = (void *)forward<>(4,param_1);
  local_8 = 0;
  if (this != (void *)0x0) {
    pLVar1 = (List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
              *)forward<>(param_2);
    function<>(this,pLVar1);
  }
  ExceptionList = local_10;
  return;
}



// Function: construct<> at 1000d1b0

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::construct<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   &,class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > &&)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > &,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &&)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl construct<>(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_3);
  construct<>(param_2,uVar1);
  return;
}



// Function: construct<> at 1000d1d0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::construct<char *,char *
   &>(char * *,char * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(unsigned short * *,unsigned short * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t> >::construct<wchar_t
   *,wchar_t * &>(wchar_t * *,wchar_t * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>
   >::construct<struct std::_Container_proxy,struct std::_Container_proxy>(struct
   std::_Container_proxy *,struct std::_Container_proxy &&)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __thiscall construct<>(void *this,undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_2);
  construct<>(this,param_1,uVar1);
  return;
}



// Function: construct<> at 1000d200

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > &&)
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &&)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void construct<>(undefined4 param_1,undefined4 param_2)

{
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002afb1;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  this = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
         forward<>(0x18,param_1);
  local_8 = 0;
  if (this != (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)0x0) {
    pbVar1 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
             forward<>(param_2);
    std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
    basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>(this,pbVar1);
  }
  ExceptionList = local_10;
  return;
}



// Function: construct<> at 1000d290

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::construct<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   &,class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > &&)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > &,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &&)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl construct<>(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_3);
  construct<>(param_2,uVar1);
  return;
}



// Function: construct<> at 1000d2b0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::construct<char *,char *
   &>(char * *,char * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(unsigned short * *,unsigned short * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t> >::construct<wchar_t
   *,wchar_t * &>(wchar_t * *,wchar_t * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>
   >::construct<struct std::_Container_proxy,struct std::_Container_proxy>(struct
   std::_Container_proxy *,struct std::_Container_proxy &&)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __thiscall construct<>(void *this,undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_2);
  construct<>(this,param_1,uVar1);
  return;
}



// Function: construct<> at 1000d2e0

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<char> >::construct<char
   *,char * &>(class std::allocator<char> &,char * *,char * &)
    public: static void __cdecl std::allocator_traits<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(class std::allocator<unsigned short> &,unsigned
   short * *,unsigned short * &)
    public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>
   >::construct<wchar_t *,wchar_t * &>(class std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
    public: static void __cdecl std::allocator_traits<class std::allocator<struct
   std::_Container_proxy> >::construct<struct std::_Container_proxy,struct
   std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &,struct
   std::_Container_proxy *,struct std::_Container_proxy &&)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __cdecl construct<>(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar1;
  
  pbVar1 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
           forward<>(param_3);
  FUN_10014820(param_2,pbVar1);
  return;
}



// Function: construct<> at 1000d300

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::construct<char *,char *
   &>(char * *,char * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::construct<unsigned short *,unsigned short * &>(unsigned short * *,unsigned short * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t> >::construct<wchar_t
   *,wchar_t * &>(wchar_t * *,wchar_t * &)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>
   >::construct<struct std::_Container_proxy,struct std::_Container_proxy>(struct
   std::_Container_proxy *,struct std::_Container_proxy &&)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __thiscall construct<>(void *this,undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_2);
  construct<>(this,param_1,uVar1);
  return;
}



// Function: construct<> at 1000d330

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > &&)
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &&)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void construct<>(undefined4 param_1,undefined4 param_2)

{
  void *this;
  undefined4 uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002afe1;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  this = (void *)forward<>(0x18,param_1);
  local_8 = 0;
  if (this != (void *)0x0) {
    uVar1 = forward<>(param_2);
    basic_string<>(this,uVar1);
  }
  ExceptionList = local_10;
  return;
}



// Function: construct<> at 1000d3c0

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::construct<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   &,class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > &&)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::construct<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > &,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &&)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __cdecl construct<>(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 uVar1;
  
  uVar1 = forward<>(param_3);
  construct<>(param_2,uVar1);
  return;
}



// Function: destroy<> at 1000d3e0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::destroy<char *>(char * *)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::destroy<unsigned short *>(unsigned short * *)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t> >::destroy<wchar_t
   *>(wchar_t * *)
   
   Library: Visual Studio 2012 Release */

void destroy<>(void)

{
  destroy<>();
  return;
}



// Function: FUN_1000d400 at 1000d400

void FUN_1000d400(void)

{
  return;
}



// Function: destroy<> at 1000d410

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<char> >::destroy<char
   *>(class std::allocator<char> &,char * *)
    public: static void __cdecl std::allocator_traits<class std::allocator<unsigned short>
   >::destroy<unsigned short *>(class std::allocator<unsigned short> &,unsigned short * *)
    public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>
   >::destroy<wchar_t *>(class std::allocator<wchar_t> &,wchar_t * *)
    public: static void __cdecl std::allocator_traits<class std::allocator<struct
   std::_Container_proxy> >::destroy<struct std::_Container_proxy>(class std::allocator<struct
   std::_Container_proxy> &,struct std::_Container_proxy *)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void destroy<>(void)

{
  FUN_1000d400();
  return;
}



// Function: destroy<> at 1000d430

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::destroy<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::destroy<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> >::destroy<class
   Concurrency::details::_ContextCallback>(class Concurrency::details::_ContextCallback *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __thiscall destroy<>(void *this,void *param_1)

{
  destroy<>(this,param_1);
  return;
}



// Function: destroy<> at 1000d450

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::destroy<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *)
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::destroy<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void destroy<>(void *param_1)

{
  FUN_10010450(param_1,0);
  return;
}



// Function: destroy<> at 1000d470

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::_Func_impl<bool (__cdecl*)(enum Concurrency::agent_status const &),class
   std::allocator<int>,bool,enum Concurrency::agent_status const &> > >::destroy<class
   std::_Func_impl<bool (__cdecl*)(enum Concurrency::agent_status const &),class
   std::allocator<int>,bool,enum Concurrency::agent_status const &> >(class std::allocator<class
   std::_Func_impl<bool (__cdecl*)(enum Concurrency::agent_status const &),class
   std::allocator<int>,bool,enum Concurrency::agent_status const &> > &,class std::_Func_impl<bool
   (__cdecl*)(enum Concurrency::agent_status const &),class std::allocator<int>,bool,enum
   Concurrency::agent_status const &> *)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::_Func_impl<class <lambda_0b644b0099f9cbc573e00435de85ed83>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> > >::destroy<class
   std::_Func_impl<class <lambda_0b644b0099f9cbc573e00435de85ed83>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> >(class std::allocator<class
   std::_Func_impl<class <lambda_0b644b0099f9cbc573e00435de85ed83>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> > &,class
   std::_Func_impl<class <lambda_0b644b0099f9cbc573e00435de85ed83>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> *)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::_Func_impl<class <lambda_4471c1faea23acf00f5de6f001106c5d>,class
   std::allocator<int>,void,class Concurrency::message<enum Concurrency::agent_status> *> >
   >::destroy<class std::_Func_impl<class <lambda_4471c1faea23acf00f5de6f001106c5d>,class
   std::allocator<int>,void,class Concurrency::message<enum Concurrency::agent_status> *> >(class
   std::allocator<class std::_Func_impl<class <lambda_4471c1faea23acf00f5de6f001106c5d>,class
   std::allocator<int>,void,class Concurrency::message<enum Concurrency::agent_status> *> > &,class
   std::_Func_impl<class <lambda_4471c1faea23acf00f5de6f001106c5d>,class
   std::allocator<int>,void,class Concurrency::message<enum Concurrency::agent_status> *> *)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::_Func_impl<class <lambda_585d1183dd7288406f8b545e733d6ea7>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> > >::destroy<class
   std::_Func_impl<class <lambda_585d1183dd7288406f8b545e733d6ea7>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> >(class std::allocator<class
   std::_Func_impl<class <lambda_585d1183dd7288406f8b545e733d6ea7>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> > &,class
   std::_Func_impl<class <lambda_585d1183dd7288406f8b545e733d6ea7>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> *)
     9 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __cdecl destroy<>(undefined4 param_1,void *param_2)

{
  destroy<>(param_2);
  return;
}



// Function: destroy<> at 1000d490

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::destroy<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::destroy<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<class
   Concurrency::details::_ContextCallback> >::destroy<class
   Concurrency::details::_ContextCallback>(class Concurrency::details::_ContextCallback *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __thiscall destroy<>(void *this,void *param_1)

{
  destroy<>(this,param_1);
  return;
}



// Function: destroy<> at 1000d4b0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::destroy<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *)
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::destroy<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void destroy<>(void *param_1)

{
  FUN_10010480(param_1,0);
  return;
}



// Function: destroy<> at 1000d4d0

/* Library Function - Multiple Matches With Same Base Name
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::_Func_impl<bool (__cdecl*)(enum Concurrency::agent_status const &),class
   std::allocator<int>,bool,enum Concurrency::agent_status const &> > >::destroy<class
   std::_Func_impl<bool (__cdecl*)(enum Concurrency::agent_status const &),class
   std::allocator<int>,bool,enum Concurrency::agent_status const &> >(class std::allocator<class
   std::_Func_impl<bool (__cdecl*)(enum Concurrency::agent_status const &),class
   std::allocator<int>,bool,enum Concurrency::agent_status const &> > &,class std::_Func_impl<bool
   (__cdecl*)(enum Concurrency::agent_status const &),class std::allocator<int>,bool,enum
   Concurrency::agent_status const &> *)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::_Func_impl<class <lambda_0b644b0099f9cbc573e00435de85ed83>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> > >::destroy<class
   std::_Func_impl<class <lambda_0b644b0099f9cbc573e00435de85ed83>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> >(class std::allocator<class
   std::_Func_impl<class <lambda_0b644b0099f9cbc573e00435de85ed83>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> > &,class
   std::_Func_impl<class <lambda_0b644b0099f9cbc573e00435de85ed83>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> *)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::_Func_impl<class <lambda_4471c1faea23acf00f5de6f001106c5d>,class
   std::allocator<int>,void,class Concurrency::message<enum Concurrency::agent_status> *> >
   >::destroy<class std::_Func_impl<class <lambda_4471c1faea23acf00f5de6f001106c5d>,class
   std::allocator<int>,void,class Concurrency::message<enum Concurrency::agent_status> *> >(class
   std::allocator<class std::_Func_impl<class <lambda_4471c1faea23acf00f5de6f001106c5d>,class
   std::allocator<int>,void,class Concurrency::message<enum Concurrency::agent_status> *> > &,class
   std::_Func_impl<class <lambda_4471c1faea23acf00f5de6f001106c5d>,class
   std::allocator<int>,void,class Concurrency::message<enum Concurrency::agent_status> *> *)
    public: static void __cdecl std::allocator_traits<class std::allocator<class
   std::_Func_impl<class <lambda_585d1183dd7288406f8b545e733d6ea7>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> > >::destroy<class
   std::_Func_impl<class <lambda_585d1183dd7288406f8b545e733d6ea7>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> >(class std::allocator<class
   std::_Func_impl<class <lambda_585d1183dd7288406f8b545e733d6ea7>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> > &,class
   std::_Func_impl<class <lambda_585d1183dd7288406f8b545e733d6ea7>,class
   std::allocator<int>,void,class Concurrency::message<unsigned int> *> *)
     9 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

void __cdecl destroy<>(undefined4 param_1,void *param_2)

{
  destroy<>(param_2);
  return;
}



// Function: FUN_1000d4f0 at 1000d4f0

void __cdecl FUN_1000d4f0(undefined4 param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  int iVar2;
  
  iVar1 = FUN_1000cc10(param_2);
  iVar2 = FUN_1000cc10(param_1);
  _Destroy_range<>(iVar2,iVar1,param_3);
  return;
}



// Function: forward<> at 1000d520

/* Library Function - Multiple Matches With Same Base Name
    char * & __cdecl std::forward<char * &>(char * &)
    unsigned short * & __cdecl std::forward<unsigned short * &>(unsigned short * &)
    wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __cdecl forward<>(undefined4 param_1)

{
  return param_1;
}



// Function: forward<> at 1000d530

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > && __cdecl
   std::forward<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   >(class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > &)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > && __cdecl std::forward<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __cdecl forward<>(undefined4 param_1)

{
  return param_1;
}



// Function: forward<> at 1000d540

/* Library Function - Multiple Matches With Same Base Name
    char * & __cdecl std::forward<char * &>(char * &)
    unsigned short * & __cdecl std::forward<unsigned short * &>(unsigned short * &)
    wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
    struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct
   std::_Container_proxy &)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

undefined4 __cdecl forward<>(undefined4 param_1)

{
  return param_1;
}



// Function: forward<> at 1000d550

/* Library Function - Multiple Matches With Same Base Name
    char * & __cdecl std::forward<char * &>(char * &)
    unsigned short * & __cdecl std::forward<unsigned short * &>(unsigned short * &)
    wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
    struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct
   std::_Container_proxy &)
     6 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release, Visual Studio 2015 Debug, Visual
   Studio 2015 Release */

undefined4 __cdecl forward<>(undefined4 param_1)

{
  return param_1;
}



// Function: forward<> at 1000d560

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > && __cdecl
   std::forward<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   >(class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > &)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > && __cdecl std::forward<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __cdecl forward<>(undefined4 param_1)

{
  return param_1;
}



// Function: forward<> at 1000d570

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > && __cdecl
   std::forward<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   >(class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > &)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > && __cdecl std::forward<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __cdecl forward<>(undefined4 param_1)

{
  return param_1;
}



// Function: move<> at 1000d580

/* Library Function - Multiple Matches With Same Base Name
    class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > && __cdecl
   std::move<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > &>(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > &)
    class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > && __cdecl std::move<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &>(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __cdecl move<>(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_1000d590 at 1000d590

undefined4 * __fastcall FUN_1000d590(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000d5b0 at 1000d5b0

undefined4 * __thiscall FUN_1000d5b0(void *this,undefined4 param_1)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b016;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_10001f20(this);
  FUN_1000d780((undefined4 *)((int)this + 4));
  local_8 = 0;
  *(undefined ***)this = ATL::CComAggObject<class_CBinaryData>::vftable;
  FUN_1000d640((void *)((int)this + 0x10),param_1);
  local_8 = CONCAT31(local_8._1_3_,1);
  (**(code **)(*DAT_100403a8 + 4))(uVar1);
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_1000d640 at 1000d640

undefined4 * __thiscall FUN_1000d640(void *this,undefined4 param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b048;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10001000((int)this);
  *(undefined ***)this = ATL::CComContainedObject<class_CBinaryData>::vftable;
  *(undefined ***)((int)this + 4) = ATL::CComContainedObject<class_CBinaryData>::vftable;
  *(undefined4 *)((int)this + 8) = param_1;
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: CComCritSecLock<class_ATL::CComCriticalSection> at 1000d6b0

/* Library Function - Single Match
    public: __thiscall ATL::CComCritSecLock<class ATL::CComCriticalSection>::CComCritSecLock<class
   ATL::CComCriticalSection>(class ATL::CComCriticalSection &,bool)
   
   Library: Visual Studio 2012 Debug */

CComCritSecLock<class_ATL::CComCriticalSection> * __thiscall
ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
CComCritSecLock<class_ATL::CComCriticalSection>
          (CComCritSecLock<class_ATL::CComCriticalSection> *this,CComCriticalSection *param_1,
          bool param_2)

{
  int iVar1;
  
  *(CComCriticalSection **)this = param_1;
  this[4] = (CComCritSecLock<class_ATL::CComCriticalSection>)0x0;
  if (param_2) {
    iVar1 = FUN_10012860((undefined4 *)this);
    if (iVar1 < 0) {
      FUN_10010aa0(iVar1);
    }
  }
  return this;
}



// Function: FUN_1000d700 at 1000d700

undefined4 * __fastcall FUN_1000d700(undefined4 *param_1)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b078;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_10001000((int)param_1);
  local_8 = 0;
  *param_1 = ATL::CComObject<class_CBinaryData>::vftable;
  param_1[1] = ATL::CComObject<class_CBinaryData>::vftable;
  (**(code **)(*DAT_100403a8 + 4))(uVar1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1000d780 at 1000d780

undefined4 * __fastcall FUN_1000d780(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b0a8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10001e10(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: function<> at 1000d7d0

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::function<void __cdecl(unsigned int const &)>::function<void
   __cdecl(unsigned int const &)>(class std::function<void __cdecl(unsigned int const &)> const &)
    public: __thiscall std::function<void __cdecl(class Concurrency::message<unsigned int>
   *)>::function<void __cdecl(class Concurrency::message<unsigned int> *)>(class std::function<void
   __cdecl(class Concurrency::message<unsigned int> *)> const &)
    public: __thiscall std::function<void __cdecl(class Concurrency::message<enum
   Concurrency::agent_status> *)>::function<void __cdecl(class Concurrency::message<enum
   Concurrency::agent_status> *)>(class std::function<void __cdecl(class Concurrency::message<enum
   Concurrency::agent_status> *)> const &)
    public: __thiscall std::function<void __cdecl(void)>::function<void __cdecl(void)>(class
   std::function<void __cdecl(void)> const &)
     6 names - too many to list
   
   Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */

List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount> *
__thiscall
function<>(void *this,
          List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
          *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b0d8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000dad0((undefined4 *)this);
  local_8 = 0;
  Concurrency::details::
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  ::Swap(param_1,(List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
                  *)this);
  ExceptionList = local_10;
  return (List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
          *)this;
}



// Function: FUN_1000d830 at 1000d830

void * __thiscall FUN_1000d830(void *this,int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b108;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  CComPtrBase<>(this,*param_1);
  ExceptionList = local_10;
  return this;
}



// Function: FUN_1000d890 at 1000d890

void * __thiscall FUN_1000d890(void *this,int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b138;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  CComPtrBase<>(this,param_1);
  ExceptionList = local_10;
  return this;
}



// Function: FUN_1000d8f0 at 1000d8f0

undefined4 * __fastcall FUN_1000d8f0(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b168;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000dad0(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1000d940 at 1000d940

undefined4 * __fastcall FUN_1000d940(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b198;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000daf0(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1000d990 at 1000d990

void * __thiscall FUN_1000d990(void *this,int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b1c8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  CComPtrBase<>(this,*param_1);
  ExceptionList = local_10;
  return this;
}



// Function: FUN_1000d9f0 at 1000d9f0

undefined4 * __fastcall FUN_1000d9f0(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b1f8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000db50(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1000da40 at 1000da40

undefined4 * __fastcall FUN_1000da40(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b228;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000db70(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: CComPtrBase<> at 1000da90

/* Library Function - Multiple Matches With Same Base Name
    protected: __thiscall ATL::CComPtrBase<struct IShellItem>::CComPtrBase<struct IShellItem>(struct
   IShellItem *)
    protected: __thiscall ATL::CComPtrBase<struct IUnknown>::CComPtrBase<struct IUnknown>(struct
   IUnknown *)
    protected: __thiscall ATL::CComPtrBase<struct IXMLDOMNode>::CComPtrBase<struct
   IXMLDOMNode>(struct IXMLDOMNode *)
    protected: __thiscall ATL::CComPtrBase<struct IXMLDOMNodeList>::CComPtrBase<struct
   IXMLDOMNodeList>(struct IXMLDOMNodeList *)
   
   Library: Visual Studio 2010 Debug */

int * __thiscall CComPtrBase<>(void *this,int param_1)

{
  *(int *)this = param_1;
                    /* WARNING: Load size is inaccurate */
  if (*this != 0) {
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
    (**(code **)(**this + 4))(*this);
  }
  return (int *)this;
}



// Function: FUN_1000dad0 at 1000dad0

undefined4 * __fastcall FUN_1000dad0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000daf0 at 1000daf0

undefined4 * __fastcall FUN_1000daf0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: CComPtrBase<> at 1000db10

/* Library Function - Multiple Matches With Same Base Name
    protected: __thiscall ATL::CComPtrBase<struct IShellItem>::CComPtrBase<struct IShellItem>(struct
   IShellItem *)
    protected: __thiscall ATL::CComPtrBase<struct IUnknown>::CComPtrBase<struct IUnknown>(struct
   IUnknown *)
    protected: __thiscall ATL::CComPtrBase<struct IXMLDOMNode>::CComPtrBase<struct
   IXMLDOMNode>(struct IXMLDOMNode *)
    protected: __thiscall ATL::CComPtrBase<struct IXMLDOMNodeList>::CComPtrBase<struct
   IXMLDOMNodeList>(struct IXMLDOMNodeList *)
   
   Library: Visual Studio 2010 Debug */

int * __thiscall CComPtrBase<>(void *this,int param_1)

{
  *(int *)this = param_1;
                    /* WARNING: Load size is inaccurate */
  if (*this != 0) {
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
    (**(code **)(**this + 4))(*this);
  }
  return (int *)this;
}



// Function: FUN_1000db50 at 1000db50

undefined4 * __fastcall FUN_1000db50(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000db70 at 1000db70

undefined4 * __fastcall FUN_1000db70(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000db90 at 1000db90

undefined4 * __thiscall FUN_1000db90(void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  *(undefined1 *)((int)this + 4) = 0;
  FUN_100128a0((undefined4 *)this);
  return (undefined4 *)this;
}



// Function: FUN_1000dbc0 at 1000dbc0

undefined4 __fastcall FUN_1000dbc0(undefined4 param_1)

{
  FUN_1000e5a0(param_1);
  return param_1;
}



// Function: FUN_1000dbe0 at 1000dbe0

undefined4 __fastcall FUN_1000dbe0(undefined4 param_1)

{
  FUN_1000e5c0(param_1);
  return param_1;
}



// Function: FUN_1000dc00 at 1000dc00

undefined4 __fastcall FUN_1000dc00(undefined4 param_1)

{
  FUN_1000e5e0(param_1);
  return param_1;
}



// Function: FUN_1000dc20 at 1000dc20

undefined4 __fastcall FUN_1000dc20(undefined4 param_1)

{
  FUN_1000e600(param_1);
  return param_1;
}



// Function: FUN_1000dc40 at 1000dc40

undefined4 * __thiscall FUN_1000dc40(void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  return (undefined4 *)this;
}



// Function: FUN_1000dc60 at 1000dc60

undefined4 * __fastcall FUN_1000dc60(undefined4 *param_1)

{
  FUN_1000ddd0(param_1);
  return param_1;
}



// Function: _String_alloc<> at 1000dc80

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::_String_alloc<0,struct std::_String_base_types<char,class
   std::allocator<char> > >::_String_alloc<0,struct std::_String_base_types<char,class
   std::allocator<char> > >(class std::allocator<char> const &)
    public: __thiscall std::_String_alloc<0,struct std::_String_base_types<unsigned short,class
   std::allocator<unsigned short> > >::_String_alloc<0,struct std::_String_base_types<unsigned
   short,class std::allocator<unsigned short> > >(class std::allocator<unsigned short> const &)
    public: __thiscall std::_String_alloc<0,struct std::_String_base_types<wchar_t,class
   std::allocator<wchar_t> > >::_String_alloc<0,struct std::_String_base_types<wchar_t,class
   std::allocator<wchar_t> > >(class std::allocator<wchar_t> const &)
   
   Library: Visual Studio 2012 Release */

int __fastcall _String_alloc<>(int param_1)

{
  _String_val<>(param_1);
  return param_1;
}



// Function: _String_val<> at 1000dca0

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::_String_val<struct std::_Simple_types<char> >::_String_val<struct
   std::_Simple_types<char> >(void)
    public: __thiscall std::_String_val<struct std::_Simple_types<unsigned short>
   >::_String_val<struct std::_Simple_types<unsigned short> >(void)
    public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t> >::_String_val<struct
   std::_Simple_types<wchar_t> >(void)
   
   Library: Visual Studio 2012 Release */

int __fastcall _String_val<>(int param_1)

{
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  return param_1;
}



// Function: _Vector_alloc<> at 1000dcd0

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::_Vector_alloc<0,struct std::_Vec_base_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >
   >::_Vector_alloc<0,struct std::_Vec_base_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   const &)
    public: __thiscall std::_Vector_alloc<0,struct std::_Vec_base_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >::_Vector_alloc<0,struct
   std::_Vec_base_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > const &)
   
   Library: Visual Studio 2012 Release */

undefined4 * __fastcall _Vector_alloc<>(undefined4 *param_1)

{
  _Vector_val<>(param_1);
  return param_1;
}



// Function: _Vector_alloc<> at 1000dcf0

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::_Vector_alloc<0,struct std::_Vec_base_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >
   >::_Vector_alloc<0,struct std::_Vec_base_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   const &)
    public: __thiscall std::_Vector_alloc<0,struct std::_Vec_base_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >::_Vector_alloc<0,struct
   std::_Vec_base_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > >(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > const &)
   
   Library: Visual Studio 2012 Release */

undefined4 * __fastcall _Vector_alloc<>(undefined4 *param_1)

{
  _Vector_val<>(param_1);
  return param_1;
}



// Function: FID_conflict:_Vector_const_iterator<class_std::_Vector_val<struct_std::_Simple_types<class_std::shared_ptr<struct_Concurrency::details::_Task_impl<struct_std::pair<unsigned_char,class_Concurrency::details::_CancellationTokenState*>_>_>_>_>_> at 1000dd10

/* Library Function - Multiple Matches With Different Base Names
    public: __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<char> > >::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<char> > >(char const *,struct std::_Container_base0 const *)
    public: __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >(unsigned short const *,struct std::_Container_base0 const
   *)
    public: __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<wchar_t> > >::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<wchar_t> > >(wchar_t const *,struct std::_Container_base0 const *)
    public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Container_base0 const *)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

undefined4 * __thiscall
FID_conflict__Vector_const_iterator<class_std::_Vector_val<struct_std::_Simple_types<class_std::shared_ptr<struct_Concurrency::details::_Task_impl<struct_std::pair<unsigned_char,class_Concurrency::details::_CancellationTokenState*>_>_>_>_>_>
          (void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  FUN_10012eb0();
  return (undefined4 *)this;
}



// Function: FUN_1000dd40 at 1000dd40

undefined4 * __fastcall FUN_1000dd40(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FID_conflict:_Vector_const_iterator<class_std::_Vector_val<struct_std::_Simple_types<class_std::shared_ptr<struct_Concurrency::details::_Task_impl<struct_std::pair<unsigned_char,class_Concurrency::details::_CancellationTokenState*>_>_>_>_>_> at 1000dd60

/* Library Function - Multiple Matches With Different Base Names
    public: __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<char> > >::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<char> > >(char const *,struct std::_Container_base0 const *)
    public: __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >(unsigned short const *,struct std::_Container_base0 const
   *)
    public: __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<wchar_t> > >::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<wchar_t> > >(wchar_t const *,struct std::_Container_base0 const *)
    public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > >(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,struct
   std::_Container_base0 const *)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

undefined4 * __thiscall
FID_conflict__Vector_const_iterator<class_std::_Vector_val<struct_std::_Simple_types<class_std::shared_ptr<struct_Concurrency::details::_Task_impl<struct_std::pair<unsigned_char,class_Concurrency::details::_CancellationTokenState*>_>_>_>_>_>
          (void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  FUN_10012eb0();
  return (undefined4 *)this;
}



// Function: FUN_1000dd90 at 1000dd90

undefined4 * __fastcall FUN_1000dd90(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: _Vector_iterator<> at 1000ddb0

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >
   >::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,struct std::_Container_base0 const *)
    public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >::_Vector_iterator<class
   std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Container_base0 const *)
   
   Library: Visual Studio 2012 Release */

void * __thiscall _Vector_iterator<>(void *this,undefined4 param_1)

{
  FID_conflict__Vector_const_iterator<class_std::_Vector_val<struct_std::_Simple_types<class_std::shared_ptr<struct_Concurrency::details::_Task_impl<struct_std::pair<unsigned_char,class_Concurrency::details::_CancellationTokenState*>_>_>_>_>_>
            (this,param_1);
  return this;
}



// Function: FUN_1000ddd0 at 1000ddd0

undefined4 * __fastcall FUN_1000ddd0(undefined4 *param_1)

{
  FUN_1000dd40(param_1);
  return param_1;
}



// Function: _Vector_iterator<> at 1000ddf0

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >
   >::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,struct std::_Container_base0 const *)
    public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >::_Vector_iterator<class
   std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,struct std::_Container_base0 const *)
   
   Library: Visual Studio 2012 Release */

void * __thiscall _Vector_iterator<>(void *this,undefined4 param_1)

{
  FID_conflict__Vector_const_iterator<class_std::_Vector_val<struct_std::_Simple_types<class_std::shared_ptr<struct_Concurrency::details::_Task_impl<struct_std::pair<unsigned_char,class_Concurrency::details::_CancellationTokenState*>_>_>_>_>_>
            (this,param_1);
  return this;
}



// Function: FUN_1000de10 at 1000de10

undefined4 * __fastcall FUN_1000de10(undefined4 *param_1)

{
  FUN_1000dd90(param_1);
  return param_1;
}



// Function: _Vector_val<> at 1000de30

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > >(void)
    public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > >(void)
   
   Library: Visual Studio 2012 Release */

undefined4 * __fastcall _Vector_val<>(undefined4 *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  return param_1;
}



// Function: _Vector_val<> at 1000de60

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > >(void)
    public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > >(void)
   
   Library: Visual Studio 2012 Release */

undefined4 * __fastcall _Vector_val<>(undefined4 *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  return param_1;
}



// Function: FUN_1000de90 at 1000de90

undefined4 __fastcall FUN_1000de90(undefined4 param_1)

{
  allocator<>(param_1);
  return param_1;
}



// Function: FUN_1000deb0 at 1000deb0

undefined4 __fastcall FUN_1000deb0(undefined4 param_1)

{
  allocator<>(param_1);
  return param_1;
}



// Function: FUN_1000ded0 at 1000ded0

undefined4 __fastcall FUN_1000ded0(undefined4 param_1)

{
  allocator<>(param_1);
  return param_1;
}



// Function: FUN_1000def0 at 1000def0

undefined4 __fastcall FUN_1000def0(undefined4 param_1)

{
  allocator<>(param_1);
  return param_1;
}



// Function: refcount_ptr<struct_boost::exception_detail::error_info_container> at 1000df10

/* Library Function - Single Match
    public: __thiscall boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container>::refcount_ptr<struct
   boost::exception_detail::error_info_container>(class boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container> const &)
   
   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
   Studio 2019 Release */

refcount_ptr<struct_boost::exception_detail::error_info_container> * __thiscall
boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
refcount_ptr<struct_boost::exception_detail::error_info_container>
          (refcount_ptr<struct_boost::exception_detail::error_info_container> *this,
          refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  *(undefined4 *)this = *(undefined4 *)param_1;
  FUN_10012d10((int *)this);
  return this;
}



// Function: FUN_1000df40 at 1000df40

int * __thiscall FUN_1000df40(void *this,int param_1,char param_2)

{
  *(int *)this = param_1;
  if (param_2 != '\0') {
    FUN_10012d10((int *)this);
  }
  return (int *)this;
}



// Function: FUN_1000df70 at 1000df70

undefined4 * __fastcall FUN_1000df70(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000df90 at 1000df90

undefined4 * __fastcall FUN_1000df90(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: refcount_ptr<struct_boost::exception_detail::error_info_container> at 1000dfb0

/* Library Function - Single Match
    public: __thiscall boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container>::refcount_ptr<struct
   boost::exception_detail::error_info_container>(class boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container> const &)
   
   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
   Studio 2019 Release */

refcount_ptr<struct_boost::exception_detail::error_info_container> * __thiscall
boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
refcount_ptr<struct_boost::exception_detail::error_info_container>
          (refcount_ptr<struct_boost::exception_detail::error_info_container> *this,
          refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  *(undefined4 *)this = *(undefined4 *)param_1;
  FUN_10012d70((int *)this);
  return this;
}



// Function: FUN_1000dfe0 at 1000dfe0

undefined4 * __fastcall FUN_1000dfe0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000e000 at 1000e000

undefined4 * __fastcall FUN_1000e000(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: refcount_ptr<struct_boost::exception_detail::error_info_container> at 1000e020

/* Library Function - Single Match
    public: __thiscall boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container>::refcount_ptr<struct
   boost::exception_detail::error_info_container>(class boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container> const &)
   
   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
   Studio 2019 Release */

refcount_ptr<struct_boost::exception_detail::error_info_container> * __thiscall
boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
refcount_ptr<struct_boost::exception_detail::error_info_container>
          (refcount_ptr<struct_boost::exception_detail::error_info_container> *this,
          refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  *(undefined4 *)this = *(undefined4 *)param_1;
  FUN_10012dd0((int *)this);
  return this;
}



// Function: FUN_1000e050 at 1000e050

undefined4 * __fastcall FUN_1000e050(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: refcount_ptr<struct_boost::exception_detail::error_info_container> at 1000e070

/* Library Function - Single Match
    public: __thiscall boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container>::refcount_ptr<struct
   boost::exception_detail::error_info_container>(class boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container> const &)
   
   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
   Studio 2019 Release */

refcount_ptr<struct_boost::exception_detail::error_info_container> * __thiscall
boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
refcount_ptr<struct_boost::exception_detail::error_info_container>
          (refcount_ptr<struct_boost::exception_detail::error_info_container> *this,
          refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  *(undefined4 *)this = *(undefined4 *)param_1;
  FUN_10012e00((int *)this);
  return this;
}



// Function: FUN_1000e0a0 at 1000e0a0

int * __thiscall FUN_1000e0a0(void *this,int param_1,char param_2)

{
  *(int *)this = param_1;
  if (param_2 != '\0') {
    FUN_10012e00((int *)this);
  }
  return (int *)this;
}



// Function: refcount_ptr<struct_boost::exception_detail::error_info_container> at 1000e0d0

/* Library Function - Single Match
    public: __thiscall boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container>::refcount_ptr<struct
   boost::exception_detail::error_info_container>(class boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container> const &)
   
   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
   Studio 2019 Release */

refcount_ptr<struct_boost::exception_detail::error_info_container> * __thiscall
boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
refcount_ptr<struct_boost::exception_detail::error_info_container>
          (refcount_ptr<struct_boost::exception_detail::error_info_container> *this,
          refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  *(undefined4 *)this = *(undefined4 *)param_1;
  FUN_10012e30((int *)this);
  return this;
}



// Function: FUN_1000e100 at 1000e100

undefined4 * __fastcall FUN_1000e100(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000e120 at 1000e120

undefined4 * __fastcall FUN_1000e120(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: allocator<> at 1000e140

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::allocator<char>::allocator<char>(class std::allocator<char> const &)
    public: __thiscall std::allocator<unsigned short>::allocator<unsigned short>(class
   std::allocator<unsigned short> const &)
    public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t>
   const &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __fastcall allocator<>(undefined4 param_1)

{
  return param_1;
}



// Function: allocator<> at 1000e150

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::allocator<char>::allocator<char>(void)
    public: __thiscall std::allocator<unsigned short>::allocator<unsigned short>(void)
    public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
   
   Library: Visual Studio 2012 Release */

undefined4 __fastcall allocator<>(undefined4 param_1)

{
  return param_1;
}



// Function: allocator<> at 1000e160

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(void)
    public: __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(void)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __fastcall allocator<>(undefined4 param_1)

{
  return param_1;
}



// Function: allocator<> at 1000e170

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >(void)
    public: __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >(void)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __fastcall allocator<>(undefined4 param_1)

{
  return param_1;
}



// Function: basic_string<> at 1000e180

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::basic_string<unsigned short,struct std::char_traits<unsigned
   short>,class std::allocator<unsigned short> >::basic_string<unsigned short,struct
   std::char_traits<unsigned short>,class std::allocator<unsigned short> >(class
   std::basic_string<unsigned short,struct std::char_traits<unsigned short>,class
   std::allocator<unsigned short> > &&)
    public: __thiscall std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >(class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> > &&)
   
   Library: Visual Studio 2012 Release */

void * __thiscall basic_string<>(void *this,undefined4 param_1)

{
  undefined4 *puVar1;
  undefined1 local_5;
  
  Getal(&local_5);
  _String_alloc<>((int)this);
  FID_conflict__Tidy(this,'\0',0);
  puVar1 = (undefined4 *)forward<>(param_1);
  FID_conflict__Assign_rv(this,puVar1);
  return this;
}



// Function: basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> at 1000e1d0

/* Library Function - Single Match
    public: __thiscall std::basic_string<char,struct std::char_traits<char>,class
   std::allocator<char> >::basic_string<char,struct std::char_traits<char>,class
   std::allocator<char> >(class std::basic_string<char,struct std::char_traits<char>,class
   std::allocator<char> > const &)
   
   Library: Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1)

{
  undefined1 *puVar1;
  undefined1 local_6;
  undefined1 local_5;
  
  puVar1 = &local_5;
  Getal(&local_6);
  select_on_container_copy_construction(puVar1);
  _String_alloc<>((int)this);
  FID_conflict__Tidy(this,'\0',0);
  assign(this,param_1,0,0xffffffff);
  return this;
}



// Function: basic_string<> at 1000e230

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::basic_string<unsigned short,struct std::char_traits<unsigned
   short>,class std::allocator<unsigned short> >::basic_string<unsigned short,struct
   std::char_traits<unsigned short>,class std::allocator<unsigned short> >(unsigned short const *)
    public: __thiscall std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >(wchar_t const *)
   
   Library: Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
basic_string<>(void *this,char *param_1)

{
  undefined1 local_5;
  
  allocator<>(&local_5);
  _String_alloc<>((int)this);
  FID_conflict__Tidy(this,'\0',0);
  std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
            ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this,
             param_1);
  return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this;
}



// Function: basic_string<> at 1000e270

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::basic_string<unsigned short,struct std::char_traits<unsigned
   short>,class std::allocator<unsigned short> >::basic_string<unsigned short,struct
   std::char_traits<unsigned short>,class std::allocator<unsigned short> >(void)
    public: __thiscall std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >(void)
   
   Library: Visual Studio 2012 Release */

void * __fastcall basic_string<>(void *param_1)

{
  undefined1 local_5;
  
  allocator<>(&local_5);
  _String_alloc<>((int)param_1);
  FID_conflict__Tidy(param_1,'\0',0);
  return param_1;
}



// Function: FUN_1000e2a0 at 1000e2a0

void * __thiscall FUN_1000e2a0(void *this,undefined4 param_1)

{
  FUN_1000dc40(this,param_1);
  return this;
}



// Function: FUN_1000e2c0 at 1000e2c0

undefined4 * __fastcall FUN_1000e2c0(undefined4 *param_1)

{
  FUN_1000dc60(param_1);
  return param_1;
}



// Function: vector<> at 1000e2e0

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >(void)
    public: __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >(void)
   
   Library: Visual Studio 2012 Release */

undefined4 * __fastcall vector<>(undefined4 *param_1)

{
  undefined1 local_5;
  
  allocator<>(&local_5);
  _Vector_alloc<>(param_1);
  return param_1;
}



// Function: vector<> at 1000e310

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >(void)
    public: __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >(void)
   
   Library: Visual Studio 2012 Release */

undefined4 * __fastcall vector<>(undefined4 *param_1)

{
  undefined1 local_5;
  
  allocator<>(&local_5);
  _Vector_alloc<>(param_1);
  return param_1;
}



// Function: FUN_1000e340 at 1000e340

undefined4 * __thiscall FUN_1000e340(void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  return (undefined4 *)this;
}



// Function: FUN_1000e360 at 1000e360

CComCriticalSection * __fastcall FUN_1000e360(CComCriticalSection *param_1)

{
  long lVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b258;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  ATL::CComCriticalSection::CComCriticalSection(param_1);
  local_8 = 0;
  lVar1 = ATL::CComCriticalSection::Init(param_1);
  if (lVar1 < 0) {
    FUN_10010aa0(lVar1);
  }
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1000e3d0 at 1000e3d0

undefined4 * __fastcall FUN_1000e3d0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000e3f0 at 1000e3f0

int * __thiscall FUN_1000e3f0(void *this,int *param_1,int *param_2)

{
  int iVar1;
  void *pvVar2;
  uint local_14;
  int local_10;
  uint local_c;
  int *local_8;
  
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 1;
  local_8 = (int *)this;
  local_10 = FUN_10014db0(param_1);
  local_c = FUN_10014db0(param_2);
  iVar1 = FUN_10002360(local_10,local_c,(int *)&local_14);
  if ((iVar1 < 0) || (iVar1 = FUN_10002390(local_14,2,&local_14), iVar1 < 0)) {
    _com_issue_error(-0x7ff8fff2);
  }
  else {
    iVar1 = Ordinal_150(0,(local_10 + local_c) * 2);
    *local_8 = iVar1;
    if (*local_8 == 0) {
      if (local_10 + local_c != 0) {
        _com_issue_error(-0x7ff8fff2);
      }
    }
    else {
      pvVar2 = (void *)FUN_1000fd40(param_1);
      if (pvVar2 != (void *)0x0) {
        memcpy_s((void *)*local_8,(local_10 + local_c) * 2 + 2,pvVar2,local_10 * 2 + 2);
      }
      pvVar2 = (void *)FUN_1000fd40(param_2);
      if (pvVar2 != (void *)0x0) {
        memcpy_s((void *)(*local_8 + local_10 * 2),local_c * 2 + 2,pvVar2,local_c * 2 + 2);
      }
    }
  }
  return local_8;
}



// Function: FUN_1000e510 at 1000e510

undefined4 * __thiscall FUN_1000e510(void *this,LPCSTR param_1)

{
  undefined4 uVar1;
  
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 1;
  uVar1 = ConvertStringToBSTR(param_1);
  *(undefined4 *)this = uVar1;
  return (undefined4 *)this;
}



// Function: FUN_1000e550 at 1000e550

int * __thiscall FUN_1000e550(void *this,int param_1)

{
  undefined4 uVar1;
  
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 1;
  uVar1 = Ordinal_2(param_1);
  *(undefined4 *)this = uVar1;
                    /* WARNING: Load size is inaccurate */
  if ((*this == 0) && (param_1 != 0)) {
    _com_issue_error(-0x7ff8fff2);
  }
  return (int *)this;
}



// Function: FUN_1000e5a0 at 1000e5a0

undefined4 __fastcall FUN_1000e5a0(undefined4 param_1)

{
  FUN_10001ee0(param_1);
  return param_1;
}



// Function: FUN_1000e5c0 at 1000e5c0

undefined4 __fastcall FUN_1000e5c0(undefined4 param_1)

{
  FUN_10001ee0(param_1);
  return param_1;
}



// Function: FUN_1000e5e0 at 1000e5e0

undefined4 __fastcall FUN_1000e5e0(undefined4 param_1)

{
  FUN_10001ee0(param_1);
  return param_1;
}



// Function: FUN_1000e600 at 1000e600

undefined4 __fastcall FUN_1000e600(undefined4 param_1)

{
  FUN_10001ee0(param_1);
  return param_1;
}



// Function: FUN_1000e620 at 1000e620

undefined4 * __fastcall FUN_1000e620(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b288;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000e940(param_1);
  *param_1 = std::_Generic_error_category::vftable;
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1000e680 at 1000e680

undefined4 * __fastcall FUN_1000e680(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b2b8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000e620(param_1);
  *param_1 = std::_Iostream_error_category::vftable;
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1000e6e0 at 1000e6e0

undefined4 * __fastcall FUN_1000e6e0(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b2e8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000e620(param_1);
  *param_1 = std::_System_error_category::vftable;
  ExceptionList = local_10;
  return param_1;
}



// Function: refcount_ptr<struct_boost::exception_detail::error_info_container> at 1000e740

/* Library Function - Single Match
    public: __thiscall boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container>::refcount_ptr<struct
   boost::exception_detail::error_info_container>(class boost::exception_detail::refcount_ptr<struct
   boost::exception_detail::error_info_container> const &)
   
   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
   Studio 2019 Release */

refcount_ptr<struct_boost::exception_detail::error_info_container> * __thiscall
boost::exception_detail::refcount_ptr<struct_boost::exception_detail::error_info_container>::
refcount_ptr<struct_boost::exception_detail::error_info_container>
          (refcount_ptr<struct_boost::exception_detail::error_info_container> *this,
          refcount_ptr<struct_boost::exception_detail::error_info_container> *param_1)

{
  *(undefined4 *)this = *(undefined4 *)param_1;
  FUN_10012e90((int *)this);
  return this;
}



// Function: FUN_1000e770 at 1000e770

int * __thiscall FUN_1000e770(void *this,LPCSTR param_1)

{
  void *this_00;
  undefined4 *local_1c;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b31b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  this_00 = (void *)FUN_1000f290(0xc);
  local_8 = 0;
  if (this_00 == (void *)0x0) {
    local_1c = (undefined4 *)0x0;
  }
  else {
    local_1c = FUN_1000e510(this_00,param_1);
  }
  local_8 = 0xffffffff;
  *(undefined4 **)this = local_1c;
                    /* WARNING: Load size is inaccurate */
  if (*this == 0) {
    _com_issue_error(-0x7ff8fff2);
  }
  ExceptionList = local_10;
  return (int *)this;
}



// Function: FUN_1000e810 at 1000e810

int * __thiscall FUN_1000e810(void *this,int param_1)

{
  void *this_00;
  int *local_1c;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b34b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  this_00 = (void *)FUN_1000f290(0xc);
  local_8 = 0;
  if (this_00 == (void *)0x0) {
    local_1c = (int *)0x0;
  }
  else {
    local_1c = FUN_1000e550(this_00,param_1);
  }
  local_8 = 0xffffffff;
  *(int **)this = local_1c;
                    /* WARNING: Load size is inaccurate */
  if (*this == 0) {
    _com_issue_error(-0x7ff8fff2);
  }
  ExceptionList = local_10;
  return (int *)this;
}



// Function: FUN_1000e8b0 at 1000e8b0

undefined4 * __fastcall FUN_1000e8b0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_1000e8d0 at 1000e8d0

undefined2 * __thiscall FUN_1000e8d0(void *this,int *param_1)

{
  int iVar1;
  undefined4 uVar2;
  
  *(undefined2 *)this = 8;
  iVar1 = FUN_1000fce0(param_1);
  if (iVar1 == 0) {
    *(undefined4 *)((int)this + 8) = 0;
  }
  else {
    uVar2 = Ordinal_149(iVar1);
    uVar2 = Ordinal_150(iVar1,uVar2);
    *(undefined4 *)((int)this + 8) = uVar2;
    if (*(int *)((int)this + 8) == 0) {
      _com_issue_error(-0x7ff8fff2);
    }
  }
  return (undefined2 *)this;
}



// Function: FUN_1000e940 at 1000e940

undefined4 * __fastcall FUN_1000e940(undefined4 *param_1)

{
  *param_1 = std::error_category::vftable;
  return param_1;
}



// Function: FUN_1000e960 at 1000e960

undefined4 * __thiscall FUN_1000e960(void *this,undefined4 param_1,undefined4 param_2)

{
  *(undefined4 *)this = param_1;
  *(undefined4 *)((int)this + 4) = param_2;
  return (undefined4 *)this;
}



// Function: FUN_1000e990 at 1000e990

undefined4 * __fastcall FUN_1000e990(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b378;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000e3d0(param_1);
  param_1[1] = 0;
  param_1[2] = 0xffffffff;
  ExceptionList = local_10;
  return param_1;
}



// Function: ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> at 1000ea00

/* Library Function - Single Match
    public: __thiscall ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class
   ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<class ATL::CCRTAllocator>(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __thiscall
ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
          (CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *this)

{
  void *pvVar1;
  
  while (*(int *)this != 0) {
    pvVar1 = *(void **)this;
    *(undefined4 *)this = **(undefined4 **)this;
    FUN_10011760(pvVar1);
  }
  return;
}



// Function: FUN_1000ea40 at 1000ea40

void __fastcall FUN_1000ea40(undefined4 *param_1)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002b3b6;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  *param_1 = ATL::CComAggObject<class_CBinaryData>::vftable;
  local_8 = 1;
  param_1[1] = 0xc0000001;
  FUN_10011720();
  (**(code **)(*DAT_100403a8 + 8))(uVar1);
  local_8 = local_8 & 0xffffff00;
  FID_conflict__bad_alloc((int)(param_1 + 4));
  local_8 = 0xffffffff;
  _anon_026BA49F::_ExceptionPtr_normal::~_ExceptionPtr_normal((_ExceptionPtr_normal *)(param_1 + 1))
  ;
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 1000ead0

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b3e8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_1000efe0(param_1);
  ExceptionList = local_10;
  return;
}



// Function: ~CComCritSecLock<class_ATL::CComCriticalSection> at 1000eb20

/* Library Function - Single Match
    public: __thiscall ATL::CComCritSecLock<class ATL::CComCriticalSection>::~CComCritSecLock<class
   ATL::CComCriticalSection>(void)
   
   Library: Visual Studio */

void __thiscall
ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
~CComCritSecLock<class_ATL::CComCriticalSection>
          (CComCritSecLock<class_ATL::CComCriticalSection> *this)

{
  if (this[4] != (CComCritSecLock<class_ATL::CComCriticalSection>)0x0) {
    FUN_10012ca0((undefined4 *)this);
  }
  return;
}



// Function: FUN_1000eb40 at 1000eb40

void __fastcall FUN_1000eb40(undefined4 *param_1)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b418;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  *param_1 = ATL::CComObject<class_CBinaryData>::vftable;
  param_1[1] = ATL::CComObject<class_CBinaryData>::vftable;
  local_8 = 0;
  param_1[2] = 0xc0000001;
  FUN_10011750();
  (**(code **)(*DAT_100403a8 + 8))(uVar1);
  local_8 = 0xffffffff;
  FUN_1000efe0((int)param_1);
  ExceptionList = local_10;
  return;
}



// Function: ~_ExceptionPtr_normal at 1000ebd0

/* Library Function - Single Match
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __thiscall
_anon_026BA49F::_ExceptionPtr_normal::~_ExceptionPtr_normal(_ExceptionPtr_normal *this)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b448;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_10002070();
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 1000ec20

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b478;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_1000ed60(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 1000ec70

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b4a8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_1000ed90(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 1000ecc0

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b4d8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_1000edc0(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 1000ed10

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b508;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_1000edf0(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1000ed60 at 1000ed60

void __fastcall FUN_1000ed60(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_1000ed90 at 1000ed90

void __fastcall FUN_1000ed90(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_1000edc0 at 1000edc0

void __fastcall FUN_1000edc0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_1000edf0 at 1000edf0

void __fastcall FUN_1000edf0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_1000ee20 at 1000ee20

void __fastcall FUN_1000ee20(undefined4 *param_1)

{
  FUN_10012cc0(param_1);
  return;
}



// Function: FUN_1000ee40 at 1000ee40

void __fastcall FUN_1000ee40(int *param_1)

{
  FUN_10013ed0(param_1);
  return;
}



// Function: FUN_1000ee60 at 1000ee60

void __fastcall FUN_1000ee60(int *param_1)

{
  FUN_10013f00(param_1);
  return;
}



// Function: FUN_1000ee80 at 1000ee80

void __fastcall FUN_1000ee80(int *param_1)

{
  FUN_10013f30(param_1);
  return;
}



// Function: FUN_1000eea0 at 1000eea0

void __fastcall FUN_1000eea0(int *param_1)

{
  FUN_10013f60(param_1);
  return;
}



// Function: FUN_1000eec0 at 1000eec0

void __fastcall FUN_1000eec0(int *param_1)

{
  FUN_10013f90(param_1);
  return;
}



// Function: FUN_1000eee0 at 1000eee0

void __fastcall FUN_1000eee0(int *param_1)

{
  FUN_10013fc0(param_1);
  return;
}



// Function: FUN_1000ef00 at 1000ef00

void __fastcall FUN_1000ef00(int *param_1)

{
  FUN_10013ff0(param_1);
  return;
}



// Function: FUN_1000ef20 at 1000ef20

void __fastcall FUN_1000ef20(int *param_1)

{
  FUN_10014020(param_1);
  return;
}



// Function: FUN_1000ef40 at 1000ef40

void __fastcall FUN_1000ef40(int *param_1)

{
  FUN_10014050(param_1);
  return;
}



// Function: FUN_1000ef60 at 1000ef60

void __fastcall FUN_1000ef60(int *param_1)

{
  FUN_10014080(param_1);
  return;
}



// Function: ~basic_string<> at 1000ef80

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::basic_string<unsigned short,struct std::char_traits<unsigned
   short>,class std::allocator<unsigned short> >::~basic_string<unsigned short,struct
   std::char_traits<unsigned short>,class std::allocator<unsigned short> >(void)
    public: __thiscall std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >::~basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >(void)
   
   Library: Visual Studio 2012 Release */

void __fastcall ~basic_string<>(void *param_1)

{
  FID_conflict__Tidy(param_1,'\x01',0);
  return;
}



// Function: FUN_1000efa0 at 1000efa0

void __fastcall FUN_1000efa0(_Container_base0 *param_1)

{
  FUN_100141b0(param_1);
  return;
}



// Function: FUN_1000efc0 at 1000efc0

void __fastcall FUN_1000efc0(_Container_base0 *param_1)

{
  FUN_10014230(param_1);
  return;
}



// Function: FUN_1000efe0 at 1000efe0

void __fastcall FUN_1000efe0(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b546;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  FUN_100020f0(param_1 + 0x38);
  local_8 = 0xffffffff;
  ~_ExceptionPtr_static<>(param_1 + 8);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~CAtlWinModule at 1000f040

/* Library Function - Multiple Matches With Different Base Names
    public: __thiscall ATL::CAtlWinModule::~CAtlWinModule(void)
    public: __thiscall CPaneContainerGC::~CPaneContainerGC(void)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2010 Debug */

void __fastcall FID_conflict__CAtlWinModule(LPCRITICAL_SECTION param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b578;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  FUN_10002280(param_1);
  local_8 = 0xffffffff;
  FUN_10002060();
  ExceptionList = local_10;
  return;
}



// Function: FUN_1000f0a0 at 1000f0a0

void __fastcall FUN_1000f0a0(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b5ab;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *param_1 = CStreamReader::vftable;
  local_8 = 0;
  operator_delete__((void *)param_1[2]);
  local_8 = 0xffffffff;
  FUN_1000ef60(param_1 + 1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1000f110 at 1000f110

void __fastcall FUN_1000f110(int *param_1)

{
  FUN_10013450(param_1);
  return;
}



// Function: FID_conflict:~bad_alloc at 1000f130

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b5d8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_1000f260(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 1000f180

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b608;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FID_conflict__bad_alloc(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 1000f1d0

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b638;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FID_conflict__bad_alloc(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1000f220 at 1000f220

void __fastcall FUN_1000f220(int *param_1)

{
  Clear(param_1);
  return;
}



// Function: FUN_1000f240 at 1000f240

void __fastcall FUN_1000f240(undefined4 param_1)

{
  Ordinal_9(param_1);
  return;
}



// Function: FUN_1000f260 at 1000f260

void __fastcall FUN_1000f260(undefined4 *param_1)

{
  *param_1 = std::error_category::vftable;
  return;
}



// Function: forward<> at 1000f280

/* Library Function - Multiple Matches With Same Base Name
    char * & __cdecl std::forward<char * &>(char * &)
    unsigned short * & __cdecl std::forward<unsigned short * &>(unsigned short * &)
    wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __cdecl forward<>(undefined4 param_1,undefined4 param_2)

{
  return param_2;
}



// Function: FUN_1000f290 at 1000f290

void __cdecl FUN_1000f290(uint param_1)

{
  operator_new(param_1);
  return;
}



// Function: FUN_1000f2b0 at 1000f2b0

void FUN_1000f2b0(void)

{
  return;
}



// Function: FUN_1000f2c0 at 1000f2c0

void FUN_1000f2c0(List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
                  *param_1)

{
  bool bVar1;
  int iVar2;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *pLVar3;
  int local_20;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *local_1c;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *local_18;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b668;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  iVar2 = FUN_1000fbf0((undefined4 *)param_1);
  bVar1 = FUN_1000f910(local_14,iVar2);
  if (bVar1) {
    pLVar3 = local_14;
    local_1c = function<>(&local_20,param_1);
    local_8 = 0;
    local_18 = local_1c;
    Concurrency::details::
    List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
    ::Swap(local_1c,pLVar3);
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&local_20);
  }
  FUN_1000fbf0((undefined4 *)local_14);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1000f350 at 1000f350

void FUN_1000f350(int *param_1)

{
  bool bVar1;
  int iVar2;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *pLVar3;
  int local_20;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *local_1c;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *local_18;
  List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
  *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b698;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  iVar2 = FUN_1000fbf0(param_1);
  bVar1 = FUN_1000f910(local_14,iVar2);
  if (bVar1) {
    pLVar3 = local_14;
    local_1c = (List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
                *)FUN_1000d830(&local_20,param_1);
    local_8 = 0;
    local_18 = local_1c;
    Concurrency::details::
    List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
    ::Swap(local_1c,pLVar3);
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&local_20);
  }
  FUN_1000fbf0((undefined4 *)local_14);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:operator= at 1000f3e0

/* WARNING: Removing unreachable block (ram,0x1000f41e) */
/* Library Function - Multiple Matches With Different Base Names
    public: class std::basic_string<unsigned short,struct std::char_traits<unsigned short>,class
   std::allocator<unsigned short> > & __thiscall std::basic_string<unsigned short,struct
   std::char_traits<unsigned short>,class std::allocator<unsigned short> >::operator=(class
   std::basic_string<unsigned short,struct std::char_traits<unsigned short>,class
   std::allocator<unsigned short> > const &)
    public: class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> > & __thiscall std::basic_string<wchar_t,struct
   std::char_traits<wchar_t>,class std::allocator<wchar_t> >::operator=(class
   std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const
   &)
   
   Library: Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
FID_conflict_operator_
          (void *this,
          basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1)

{
  undefined1 local_6;
  undefined1 local_5;
  
  if ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this !=
      param_1) {
    Getal(&local_5);
    Getal(&local_6);
    operator!=<>();
    std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
              ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this,
               param_1);
  }
  return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this;
}



// Function: operator= at 1000f460

/* Library Function - Single Match
    public: class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   & __thiscall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char>
   >::operator=(char const *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::operator=
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          char *param_1)

{
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar1;
  
  pbVar1 = assign(this,param_1);
  return pbVar1;
}



// Function: FUN_1000f480 at 1000f480

int * __thiscall FUN_1000f480(void *this,int *param_1)

{
  if ((int *)this != param_1) {
    Clear((int *)this);
    *(int *)this = *param_1;
    FUN_10012e90((int *)this);
  }
  return (int *)this;
}



// Function: FUN_1000f4c0 at 1000f4c0

int * __thiscall FUN_1000f4c0(void *this,LPCSTR param_1)

{
  LPCSTR pCVar1;
  void *this_00;
  undefined4 *local_1c;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b6cb;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if ((param_1 != (LPCSTR)0x0) && (pCVar1 = (LPCSTR)FUN_1000fd10((int *)this), pCVar1 == param_1)) {
    ExceptionList = local_10;
    return (int *)this;
  }
  Clear((int *)this);
  this_00 = (void *)FUN_1000f290(0xc);
  local_8 = 0;
  if (this_00 == (void *)0x0) {
    local_1c = (undefined4 *)0x0;
  }
  else {
    local_1c = FUN_1000e510(this_00,param_1);
  }
  local_8 = 0xffffffff;
  *(undefined4 **)this = local_1c;
                    /* WARNING: Load size is inaccurate */
  if (*this == 0) {
    _com_issue_error(-0x7ff8fff2);
  }
  ExceptionList = local_10;
  return (int *)this;
}



// Function: FUN_1000f570 at 1000f570

int * __thiscall FUN_1000f570(void *this,int param_1)

{
  int iVar1;
  void *this_00;
  int *local_1c;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b6fb;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if ((param_1 != 0) && (iVar1 = FUN_1000fd40((int *)this), iVar1 == param_1)) {
    ExceptionList = local_10;
    return (int *)this;
  }
  Clear((int *)this);
  this_00 = (void *)FUN_1000f290(0xc);
  local_8 = 0;
  if (this_00 == (void *)0x0) {
    local_1c = (int *)0x0;
  }
  else {
    local_1c = FUN_1000e550(this_00,param_1);
  }
  local_8 = 0xffffffff;
  *(int **)this = local_1c;
                    /* WARNING: Load size is inaccurate */
  if (*this == 0) {
    _com_issue_error(-0x7ff8fff2);
  }
  ExceptionList = local_10;
  return (int *)this;
}



// Function: FUN_1000f620 at 1000f620

bool __thiscall FUN_1000f620(void *this,int param_1)

{
                    /* WARNING: Load size is inaccurate */
  return *this == param_1;
}



// Function: FUN_1000f650 at 1000f650

bool __thiscall FUN_1000f650(void *this,int param_1)

{
                    /* WARNING: Load size is inaccurate */
  return *this == param_1;
}



// Function: FID_conflict:operator== at 1000f680

/* Library Function - Multiple Matches With Different Base Names
    public: bool __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >::operator==(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > const &)const 
    public: bool __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > >
   >::operator==(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > > const
   &)const 
   
   Library: Visual Studio 2012 Release */

undefined4 __thiscall FID_conflict_operator__(void *this,int *param_1)

{
  FUN_10013150();
                    /* WARNING: Load size is inaccurate */
  return CONCAT31((int3)((uint)*this >> 8),*this == *param_1);
}



// Function: FID_conflict:operator== at 1000f6c0

/* Library Function - Multiple Matches With Different Base Names
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<char> > >::operator==(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<char> > > const &)const 
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >::operator==(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<unsigned short> > > const &)const 
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<wchar_t> > >::operator==(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<wchar_t> > > const &)const 
    public: bool __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >::operator==(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > const &)const 
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

undefined4 __thiscall FID_conflict_operator__(void *this,int *param_1)

{
  FUN_10013160();
                    /* WARNING: Load size is inaccurate */
  return CONCAT31((int3)((uint)*this >> 8),*this == *param_1);
}



// Function: FUN_1000f700 at 1000f700

bool __thiscall FUN_1000f700(void *this,int param_1)

{
  if (param_1 != 0) {
    _com_issue_error(-0x7fffbffd);
  }
                    /* WARNING: Load size is inaccurate */
  return *this == 0;
}



// Function: FUN_1000f740 at 1000f740

bool __thiscall FUN_1000f740(void *this,int param_1)

{
  if (param_1 != 0) {
    _com_issue_error(-0x7fffbffd);
  }
                    /* WARNING: Load size is inaccurate */
  return *this == 0;
}



// Function: FUN_1000f780 at 1000f780

bool __thiscall FUN_1000f780(void *this,int param_1)

{
  if (param_1 != 0) {
    _com_issue_error(-0x7fffbffd);
  }
                    /* WARNING: Load size is inaccurate */
  return *this == 0;
}



// Function: FUN_1000f7c0 at 1000f7c0

bool __thiscall FUN_1000f7c0(void *this,int param_1)

{
  if (param_1 != 0) {
    _com_issue_error(-0x7fffbffd);
  }
                    /* WARNING: Load size is inaccurate */
  return *this == 0;
}



// Function: FUN_1000f800 at 1000f800

bool __thiscall FUN_1000f800(void *this,int param_1)

{
  if (param_1 != 0) {
    _com_issue_error(-0x7fffbffd);
  }
                    /* WARNING: Load size is inaccurate */
  return *this == 0;
}



// Function: FUN_1000f840 at 1000f840

bool __thiscall FUN_1000f840(void *this,int *param_1)

{
  uint uVar1;
  
  uVar1 = FUN_100130e0(this,param_1);
  return uVar1 == 0;
}



// Function: operator== at 1000f880

/* Library Function - Single Match
    public: bool __thiscall std::error_category::operator==(class std::error_category const &)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

bool __thiscall std::error_category::operator==(error_category *this,error_category *param_1)

{
  return this == param_1;
}



// Function: operator== at 1000f8b0

/* Library Function - Single Match
    public: bool __thiscall std::error_condition::operator==(class std::error_condition const
   &)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

bool __thiscall std::error_condition::operator==(error_condition *this,error_condition *param_1)

{
  bool bVar1;
  error_category *peVar2;
  error_category *this_00;
  int iVar3;
  int iVar4;
  
  peVar2 = (error_category *)FUN_10014740((int)param_1);
  this_00 = (error_category *)FUN_10014740((int)this);
  bVar1 = error_category::operator==(this_00,peVar2);
  if (bVar1) {
    iVar3 = value(this);
    iVar4 = value(param_1);
    if (iVar3 == iVar4) {
      return true;
    }
  }
  return false;
}



// Function: FUN_1000f910 at 1000f910

bool __thiscall FUN_1000f910(void *this,int param_1)

{
  bool local_8;
  
  local_8 = FUN_1000f620(this,param_1);
  local_8 = !local_8;
  return local_8;
}



// Function: FID_conflict:operator!= at 1000f950

/* Library Function - Multiple Matches With Different Base Names
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<char> > >::operator!=(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<char> > > const &)const 
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >::operator!=(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<unsigned short> > > const &)const 
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<wchar_t> > >::operator!=(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<wchar_t> > > const &)const 
    public: bool __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >::operator!=(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > const &)const 
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

bool __thiscall FID_conflict_operator__(void *this,int *param_1)

{
  uint uVar1;
  
  uVar1 = FID_conflict_operator__(this,param_1);
  return (uVar1 & 0xff) == 0;
}



// Function: FID_conflict:operator!= at 1000f990

/* Library Function - Multiple Matches With Different Base Names
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<char> > >::operator!=(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<char> > > const &)const 
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >::operator!=(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<unsigned short> > > const &)const 
    public: bool __thiscall std::_String_const_iterator<class std::_String_val<struct
   std::_Simple_types<wchar_t> > >::operator!=(class std::_String_const_iterator<class
   std::_String_val<struct std::_Simple_types<wchar_t> > > const &)const 
    public: bool __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >::operator!=(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > const &)const 
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

bool __thiscall FID_conflict_operator__(void *this,int *param_1)

{
  uint uVar1;
  
  uVar1 = FID_conflict_operator__(this,param_1);
  return (uVar1 & 0xff) == 0;
}



// Function: FUN_1000f9d0 at 1000f9d0

bool __thiscall FUN_1000f9d0(void *this,int param_1)

{
  bool local_8;
  
  local_8 = FUN_1000f700(this,param_1);
  local_8 = !local_8;
  return local_8;
}



// Function: FUN_1000fa10 at 1000fa10

bool __thiscall FUN_1000fa10(void *this,int param_1)

{
  bool local_8;
  
  local_8 = FUN_1000f740(this,param_1);
  local_8 = !local_8;
  return local_8;
}



// Function: FUN_1000fa50 at 1000fa50

bool __thiscall FUN_1000fa50(void *this,int param_1)

{
  bool local_8;
  
  local_8 = FUN_1000f780(this,param_1);
  local_8 = !local_8;
  return local_8;
}



// Function: FUN_1000fa90 at 1000fa90

bool __thiscall FUN_1000fa90(void *this,int param_1)

{
  bool local_8;
  
  local_8 = FUN_1000f7c0(this,param_1);
  local_8 = !local_8;
  return local_8;
}



// Function: FUN_1000fad0 at 1000fad0

bool __thiscall FUN_1000fad0(void *this,int param_1)

{
  bool local_8;
  
  local_8 = FUN_1000f800(this,param_1);
  local_8 = !local_8;
  return local_8;
}



// Function: FUN_1000fb10 at 1000fb10

bool __thiscall FUN_1000fb10(void *this,int *param_1)

{
  uint uVar1;
  
  uVar1 = FUN_100130e0(this,param_1);
  return uVar1 != 0;
}



// Function: operator[] at 1000fb50

/* Library Function - Single Match
    public: char const & __thiscall std::basic_string<char,struct std::char_traits<char>,class
   std::allocator<char> >::operator[](unsigned int)const 
   
   Library: Visual Studio 2012 Release */

char * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::operator[]
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          uint param_1)

{
  char *pcVar1;
  
  pcVar1 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                     ((_String_val<struct_std::_Simple_types<char>_> *)this);
  return pcVar1 + param_1;
}



// Function: operator[] at 1000fb70

/* Library Function - Single Match
    public: char const & __thiscall std::basic_string<char,struct std::char_traits<char>,class
   std::allocator<char> >::operator[](unsigned int)const 
   
   Library: Visual Studio 2012 Release */

char * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::operator[]
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          uint param_1)

{
  char *pcVar1;
  
  pcVar1 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                     ((_String_val<struct_std::_Simple_types<char>_> *)this);
  return pcVar1 + param_1;
}



// Function: FUN_1000fb90 at 1000fb90

int __thiscall FUN_1000fb90(void *this,int param_1)

{
                    /* WARNING: Load size is inaccurate */
  return *this + param_1 * 4;
}



// Function: FUN_1000fbb0 at 1000fbb0

int __thiscall FUN_1000fbb0(void *this,int param_1)

{
                    /* WARNING: Load size is inaccurate */
  return param_1 * 0x18 + *this;
}



// Function: FUN_1000fbd0 at 1000fbd0

int __thiscall FUN_1000fbd0(void *this,int param_1)

{
                    /* WARNING: Load size is inaccurate */
  return param_1 * 0x18 + *this;
}



// Function: FUN_1000fbf0 at 1000fbf0

undefined4 __fastcall FUN_1000fbf0(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc00 at 1000fc00

undefined4 __fastcall FUN_1000fc00(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc10 at 1000fc10

undefined4 __fastcall FUN_1000fc10(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc20 at 1000fc20

undefined4 __fastcall FUN_1000fc20(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc30 at 1000fc30

undefined4 __fastcall FUN_1000fc30(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc40 at 1000fc40

undefined4 __fastcall FUN_1000fc40(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc50 at 1000fc50

undefined4 __fastcall FUN_1000fc50(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc60 at 1000fc60

undefined4 __fastcall FUN_1000fc60(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc70 at 1000fc70

undefined4 __fastcall FUN_1000fc70(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc80 at 1000fc80

undefined4 __fastcall FUN_1000fc80(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fc90 at 1000fc90

undefined4 __fastcall FUN_1000fc90(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fca0 at 1000fca0

int __fastcall FUN_1000fca0(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000fcd0 at 1000fcd0

undefined4 __fastcall FUN_1000fcd0(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fce0 at 1000fce0

undefined4 __fastcall FUN_1000fce0(int *param_1)

{
  undefined4 *puVar1;
  undefined4 local_c;
  
  if (*param_1 == 0) {
    local_c = 0;
  }
  else {
    puVar1 = (undefined4 *)FUN_100120c0(*param_1);
    local_c = *puVar1;
  }
  return local_c;
}



// Function: FUN_1000fd10 at 1000fd10

undefined4 __fastcall FUN_1000fd10(int *param_1)

{
  undefined4 local_c;
  
  if (*param_1 == 0) {
    local_c = 0;
  }
  else {
    local_c = FUN_10011ae0((undefined4 *)*param_1);
  }
  return local_c;
}



// Function: FUN_1000fd40 at 1000fd40

undefined4 __fastcall FUN_1000fd40(int *param_1)

{
  undefined4 *puVar1;
  undefined4 local_c;
  
  if (*param_1 == 0) {
    local_c = 0;
  }
  else {
    puVar1 = (undefined4 *)FUN_100120c0(*param_1);
    local_c = *puVar1;
  }
  return local_c;
}



// Function: FUN_1000fd70 at 1000fd70

undefined4 __fastcall FUN_1000fd70(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fd80 at 1000fd80

undefined4 __fastcall FUN_1000fd80(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000fd90 at 1000fd90

int __fastcall FUN_1000fd90(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000fdc0 at 1000fdc0

int __fastcall FUN_1000fdc0(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000fdf0 at 1000fdf0

int __fastcall FUN_1000fdf0(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000fe20 at 1000fe20

int __fastcall FUN_1000fe20(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000fe50 at 1000fe50

int __fastcall FUN_1000fe50(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000fe80 at 1000fe80

int __fastcall FUN_1000fe80(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000feb0 at 1000feb0

int __fastcall FUN_1000feb0(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000fee0 at 1000fee0

int __fastcall FUN_1000fee0(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000ff10 at 1000ff10

int __fastcall FUN_1000ff10(int *param_1)

{
  if (*param_1 == 0) {
    _com_issue_error(-0x7fffbffd);
  }
  return *param_1;
}



// Function: FUN_1000ff40 at 1000ff40

void __fastcall FUN_1000ff40(int *param_1)

{
  int *piVar1;
  int local_c;
  int *local_8;
  
  local_c = *param_1;
  local_8 = param_1;
  piVar1 = FUN_100100b0(&local_c);
  FUN_1000ff90(piVar1);
  return;
}



// Function: FUN_1000ff70 at 1000ff70

undefined4 __fastcall FUN_1000ff70(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000ff80 at 1000ff80

undefined4 __fastcall FUN_1000ff80(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_1000ff90 at 1000ff90

void __fastcall FUN_1000ff90(undefined4 *param_1)

{
  FUN_1000ff70(param_1);
  return;
}



// Function: FUN_1000ffb0 at 1000ffb0

void __fastcall FUN_1000ffb0(undefined4 *param_1)

{
  FUN_1000ff80(param_1);
  return;
}



// Function: FUN_1000ffd0 at 1000ffd0

int * __fastcall FUN_1000ffd0(int *param_1)

{
  FUN_100100b0(param_1);
  return param_1;
}



// Function: FUN_1000fff0 at 1000fff0

int * __fastcall FUN_1000fff0(int *param_1)

{
  *param_1 = *param_1 + 4;
  return param_1;
}



// Function: FUN_10010010 at 10010010

int * __fastcall FUN_10010010(int *param_1)

{
  *param_1 = *param_1 + 0x18;
  return param_1;
}



// Function: FUN_10010030 at 10010030

int * __fastcall FUN_10010030(int *param_1)

{
  FUN_1000fff0(param_1);
  return param_1;
}



// Function: FUN_10010050 at 10010050

int * __fastcall FUN_10010050(int *param_1)

{
  FUN_10010010(param_1);
  return param_1;
}



// Function: FUN_10010070 at 10010070

int * __fastcall FUN_10010070(int *param_1)

{
  FUN_1000ffd0(param_1);
  return param_1;
}



// Function: FUN_10010090 at 10010090

int * __fastcall FUN_10010090(int *param_1)

{
  *param_1 = *param_1 + -4;
  return param_1;
}



// Function: FUN_100100b0 at 100100b0

int * __fastcall FUN_100100b0(int *param_1)

{
  FUN_10010090(param_1);
  return param_1;
}



// Function: FID_conflict:operator- at 100100d0

/* Library Function - Multiple Matches With Different Base Names
    public: int __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >::operator-(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > const &)const 
    public: int __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > >
   >::operator-(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > > const
   &)const 
   
   Library: Visual Studio 2012 Release */

int __thiscall FID_conflict_operator_(void *this,int *param_1)

{
  FUN_10013150();
                    /* WARNING: Load size is inaccurate */
  return *this - *param_1 >> 2;
}



// Function: FID_conflict:operator- at 10010100

/* Library Function - Multiple Matches With Different Base Names
    public: int __thiscall std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >::operator-(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > const &)const 
    public: int __thiscall std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > >
   >::operator-(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > > > const
   &)const 
   
   Library: Visual Studio 2012 Release */

void __thiscall FID_conflict_operator_(void *this,int *param_1)

{
  FID_conflict_operator_(this,param_1);
  return;
}



// Function: operator- at 10010120

/* Library Function - Single Match
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t> >
   > __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t> >
   >::operator-(int)const 
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release */

int __thiscall
std::_String_iterator<class_std::_String_val<struct_std::_Simple_types<wchar_t>_>_>::operator-
          (_String_iterator<class_std::_String_val<struct_std::_Simple_types<wchar_t>_>_> *this,
          int param_1)

{
  undefined4 *puVar1;
  int in_stack_00000008;
  undefined4 local_c;
  _String_iterator<class_std::_String_val<struct_std::_Simple_types<wchar_t>_>_> *local_8;
  
  local_c = *(undefined4 *)this;
  local_8 = this;
  puVar1 = (undefined4 *)FID_conflict_operator__(&local_c,in_stack_00000008);
  *(undefined4 *)param_1 = *puVar1;
  return param_1;
}



// Function: FID_conflict:operator- at 10010150

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> > >
   __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> >
   >::operator-(int)const 
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<unsigned
   short> > > __thiscall std::_String_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >::operator-(int)const 
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t> >
   > __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t> >
   >::operator-(int)const 
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> > >
   __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> >
   >::operator+(int)const 
     8 names - too many to list
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

undefined4 * __thiscall FID_conflict_operator_(void *this,undefined4 *param_1,int param_2)

{
  undefined4 *puVar1;
  undefined4 local_c;
  void *local_8;
  
                    /* WARNING: Load size is inaccurate */
  local_c = *this;
  local_8 = this;
  puVar1 = (undefined4 *)FUN_100102a0(&local_c,param_2);
  *param_1 = *puVar1;
  return param_1;
}



// Function: FID_conflict:operator- at 10010180

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> > >
   __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> >
   >::operator-(int)const 
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<unsigned
   short> > > __thiscall std::_String_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >::operator-(int)const 
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t> >
   > __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t> >
   >::operator-(int)const 
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> > >
   __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> >
   >::operator+(int)const 
     8 names - too many to list
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

undefined4 * __thiscall FID_conflict_operator_(void *this,undefined4 *param_1,int param_2)

{
  undefined4 *puVar1;
  undefined4 local_c;
  void *local_8;
  
                    /* WARNING: Load size is inaccurate */
  local_c = *this;
  local_8 = this;
  puVar1 = (undefined4 *)FUN_100102e0(&local_c,param_2);
  *param_1 = *puVar1;
  return param_1;
}



// Function: FUN_100101b0 at 100101b0

undefined4 __fastcall FUN_100101b0(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_100101c0 at 100101c0

undefined4 __fastcall FUN_100101c0(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_100101d0 at 100101d0

undefined4 __fastcall FUN_100101d0(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_100101e0 at 100101e0

undefined4 __fastcall FUN_100101e0(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_100101f0 at 100101f0

undefined4 __fastcall FUN_100101f0(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_10010200 at 10010200

undefined4 __thiscall FUN_10010200(void *this,uint *param_1)

{
  FUN_10013150();
                    /* WARNING: Load size is inaccurate */
  return CONCAT31((int3)(*this >> 8),*this < *param_1);
}



// Function: FUN_10010240 at 10010240

void * __thiscall FUN_10010240(void *this,int param_1)

{
  FUN_100103b0(this,param_1);
  return this;
}



// Function: FUN_10010260 at 10010260

int * __thiscall FUN_10010260(void *this,int param_1)

{
                    /* WARNING: Load size is inaccurate */
  *(int *)this = *this + param_1 * 4;
  return (int *)this;
}



// Function: FUN_10010280 at 10010280

int * __thiscall FUN_10010280(void *this,int param_1)

{
                    /* WARNING: Load size is inaccurate */
  *(int *)this = param_1 * 0x18 + *this;
  return (int *)this;
}



// Function: FUN_100102a0 at 100102a0

void * __thiscall FUN_100102a0(void *this,int param_1)

{
  FUN_10010260(this,param_1);
  return this;
}



// Function: FUN_100102c0 at 100102c0

void * __thiscall FUN_100102c0(void *this,int param_1)

{
  FUN_10010280(this,param_1);
  return this;
}



// Function: FUN_100102e0 at 100102e0

void * __thiscall FUN_100102e0(void *this,int param_1)

{
  FUN_10010240(this,param_1);
  return this;
}



// Function: FUN_10010300 at 10010300

int * __thiscall FUN_10010300(void *this,int *param_1)

{
  void *this_00;
  int *local_1c;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b72b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  this_00 = (void *)FUN_1000f290(0xc);
  local_8 = 0;
  if (this_00 == (void *)0x0) {
    local_1c = (int *)0x0;
  }
  else {
    local_1c = FUN_1000e3f0(this_00,(int *)this,param_1);
  }
  local_8 = 0xffffffff;
  if (local_1c == (int *)0x0) {
    _com_issue_error(-0x7ff8fff2);
  }
  else {
    Clear((int *)this);
    *(int **)this = local_1c;
  }
  ExceptionList = local_10;
  return (int *)this;
}



// Function: FUN_100103b0 at 100103b0

void __thiscall FUN_100103b0(void *this,int param_1)

{
  FUN_100102a0(this,-param_1);
  return;
}



// Function: FID_conflict:operator-= at 100103d0

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_String_iterator<char,struct std::char_traits<char>,class
   std::allocator<char> > & __thiscall std::_String_iterator<char,struct
   std::char_traits<char>,class std::allocator<char> >::operator-=(int)
    public: class std::_String_iterator<unsigned short,struct std::char_traits<unsigned short>,class
   std::allocator<unsigned short> > & __thiscall std::_String_iterator<unsigned short,struct
   std::char_traits<unsigned short>,class std::allocator<unsigned short> >::operator-=(int)
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> > > &
   __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<char> >
   >::operator-=(int)
    public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<unsigned
   short> > > & __thiscall std::_String_iterator<class std::_String_val<struct
   std::_Simple_types<unsigned short> > >::operator-=(int)
     6 names - too many to list
   
   Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release, Visual Studio 2015 Release,
   Visual Studio 2017 Release */

void __thiscall FID_conflict_operator__(void *this,int param_1)

{
  FUN_100102c0(this,-param_1);
  return;
}



// Function: FUN_100103f0 at 100103f0

undefined4 * __thiscall FUN_100103f0(void *this,uint param_1)

{
  FUN_1000ea40((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_10010420 at 10010420

undefined4 * __thiscall FUN_10010420(void *this,uint param_1)

{
  FUN_1000eb40((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_10010450 at 10010450

int * __thiscall FUN_10010450(void *this,uint param_1)

{
  FID_conflict__bad_alloc((int *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (int *)this;
}



// Function: FUN_10010480 at 10010480

void * __thiscall FUN_10010480(void *this,uint param_1)

{
  ~basic_string<>(this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return this;
}



// Function: FUN_100104b0 at 100104b0

undefined4 * __thiscall FUN_100104b0(void *this,uint param_1)

{
  FUN_1000f0a0((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_100104e0 at 100104e0

int * __thiscall FUN_100104e0(void *this,uint param_1)

{
  FUN_1000f110((int *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (int *)this;
}



// Function: FUN_10010510 at 10010510

undefined4 * __thiscall FUN_10010510(void *this,uint param_1)

{
  FID_conflict__bad_alloc((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_10010540 at 10010540

undefined4 * __thiscall FUN_10010540(void *this,uint param_1)

{
  FID_conflict__bad_alloc((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_10010570 at 10010570

undefined4 * __thiscall FUN_10010570(void *this,uint param_1)

{
  FID_conflict__bad_alloc((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_100105a0 at 100105a0

undefined4 * __thiscall FUN_100105a0(void *this,uint param_1)

{
  FUN_1000f260((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_100105d0 at 100105d0

HRESULT __thiscall FUN_100105d0(void *this,undefined4 param_1,undefined4 *param_2)

{
  uint uVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b758;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  uVar4 = *param_2;
  uVar5 = param_2[1];
  uVar6 = param_2[2];
  uVar7 = param_2[3];
  uVar2 = FUN_1000fce0(&param_1);
                    /* WARNING: Load size is inaccurate */
  iVar3 = (**(code **)(*this + 0x30))(this,uVar2,uVar4,uVar5,uVar6,uVar7,uVar1);
  if (iVar3 < 0) {
    _com_issue_errorex(iVar3,(IUnknown *)this,(_GUID *)&DAT_10030604);
  }
  local_8 = 0xffffffff;
  FUN_1000f220(&param_1);
  ExceptionList = local_10;
  return iVar3;
}



// Function: FUN_10010690 at 10010690

void FUN_10010690(int param_1)

{
  FUN_10012220((LONG *)(param_1 + 4));
  return;
}



// Function: FUN_100106b0 at 100106b0

void FUN_100106b0(int param_1)

{
  FUN_100128f0((undefined4 *)(param_1 + 8));
  return;
}



// Function: FUN_100106c2 at 100106c2

void FUN_100106c2(int param_1)

{
  FUN_100106b0(param_1 + -4);
  return;
}



// Function: FUN_100106d0 at 100106d0

void FUN_100106d0(int param_1)

{
  FUN_10012200((LONG *)(param_1 + 8));
  return;
}



// Function: FUN_100106e2 at 100106e2

void FUN_100106e2(int param_1)

{
  FUN_100106d0(param_1 + -4);
  return;
}



// Function: FUN_100106f0 at 100106f0

undefined4 __fastcall FUN_100106f0(int param_1)

{
  InterlockedIncrement((LONG *)(param_1 + 8));
  return *(undefined4 *)(param_1 + 8);
}



// Function: FUN_10010710 at 10010710

void __thiscall FUN_10010710(void *this,undefined4 param_1,undefined4 param_2)

{
  undefined4 local_c;
  
  if (this == (void *)0x0) {
    local_c = 0;
  }
  else {
    local_c = (int)this + 4;
  }
  FUN_100109b0(local_c,param_1,param_2);
  return;
}



// Function: Allocate at 10010750

/* Library Function - Single Match
    public: void * __thiscall ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class
   ATL::CCRTAllocator>::Allocate(unsigned long)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void * __thiscall
ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
          (CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *this,ulong param_1)

{
  ulong uVar1;
  CAtlSafeAllocBufferNode *this_00;
  void *pvVar2;
  
  uVar1 = AtlAddThrow<unsigned_long>(param_1,8);
  this_00 = (CAtlSafeAllocBufferNode *)FUN_100107a0(uVar1);
  if (this_00 == (CAtlSafeAllocBufferNode *)0x0) {
    pvVar2 = (void *)0x0;
  }
  else {
    *(undefined4 *)this_00 = *(undefined4 *)this;
    *(CAtlSafeAllocBufferNode **)this = this_00;
    pvVar2 = CAtlSafeAllocBufferNode::GetData(this_00);
  }
  return pvVar2;
}



// Function: FUN_100107a0 at 100107a0

void __cdecl FUN_100107a0(size_t param_1)

{
  malloc(param_1);
  return;
}



// Function: FUN_100107c0 at 100107c0

LPWSTR FUN_100107c0(LPWSTR param_1,LPCSTR param_2,int param_3,UINT param_4)

{
  int iVar1;
  
  if ((param_1 == (LPWSTR)0x0) || (param_2 == (LPCSTR)0x0)) {
    param_1 = (LPWSTR)0x0;
  }
  else {
    *param_1 = L'\0';
    iVar1 = MultiByteToWideChar(param_4,0,param_2,-1,param_1,param_3);
    if (iVar1 == 0) {
      param_1 = (LPWSTR)0x0;
    }
  }
  return param_1;
}



// Function: FUN_10010810 at 10010810

int FUN_10010810(int *param_1,undefined4 *param_2,undefined4 param_3)

{
  int *piVar1;
  int iVar2;
  
  if (param_1 != (int *)0x0) {
    piVar1 = (int *)*param_1;
    if ((param_2 == (undefined4 *)0x0) ||
       (iVar2 = (**(code **)*param_2)(param_2,param_3,param_1), iVar2 < 0)) {
      *param_1 = 0;
    }
    if (piVar1 != (int *)0x0) {
      (**(code **)(*piVar1 + 8))(piVar1);
    }
    return *param_1;
  }
  return 0;
}



// Function: FUN_10010870 at 10010870

int FUN_10010870(int param_1,int *param_2,int *param_3,undefined4 *param_4)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int local_8;
  
  if ((param_1 == 0) || (param_2 == (int *)0x0)) {
    local_8 = -0x7ff8ffa9;
  }
  else if (param_4 == (undefined4 *)0x0) {
    local_8 = -0x7fffbffd;
  }
  else {
    iVar1 = FUN_10012190(param_3);
    if (iVar1 == 0) {
      for (; param_2[2] != 0; param_2 = param_2 + 3) {
        iVar1 = *param_2;
        if ((iVar1 == 0) || (iVar2 = FUN_100022c0((int *)*param_2,param_3), iVar2 != 0)) {
          if (param_2[2] == 1) {
            piVar3 = (int *)(param_1 + param_2[1]);
            (**(code **)(*piVar3 + 4))(piVar3);
            *param_4 = piVar3;
            return 0;
          }
          local_8 = (*(code *)param_2[2])(param_1,param_3,param_4,param_2[1]);
          if (local_8 == 0) {
            return 0;
          }
          if ((iVar1 != 0) && (local_8 < 0)) goto LAB_10010996;
        }
      }
      local_8 = -0x7fffbffe;
LAB_10010996:
      *param_4 = 0;
    }
    else {
      piVar3 = (int *)(param_1 + param_2[1]);
      (**(code **)(*piVar3 + 4))(piVar3);
      *param_4 = piVar3;
      local_8 = 0;
    }
  }
  return local_8;
}



// Function: FUN_100109b0 at 100109b0

int FUN_100109b0(int param_1,undefined4 param_2,undefined4 param_3)

{
  CComCritSecLock<class_ATL::CComCriticalSection> local_28 [8];
  undefined4 *local_20;
  undefined4 *local_1c;
  int local_18;
  undefined4 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b788;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (param_1 == 0) {
    local_18 = -0x7ff8ffa9;
  }
  else {
    local_18 = 0;
    local_1c = (undefined4 *)FUN_10028fa8(0xc);
    if (local_1c == (undefined4 *)0x0) {
      local_18 = -0x7ff8fff2;
    }
    else {
      *local_1c = param_2;
      local_1c[1] = param_3;
      local_14 = local_1c;
      ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
      CComCritSecLock<class_ATL::CComCriticalSection>
                (local_28,(CComCriticalSection *)(param_1 + 0xc),false);
      local_8 = 0;
      local_18 = FUN_10012860((undefined4 *)local_28);
      if (local_18 < 0) {
        local_20 = local_14;
        operator_delete(local_14);
      }
      else {
        local_14[2] = *(undefined4 *)(param_1 + 8);
        *(undefined4 **)(param_1 + 8) = local_14;
      }
      local_8 = 0xffffffff;
      ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
      ~CComCritSecLock<class_ATL::CComCriticalSection>(local_28);
    }
  }
  ExceptionList = local_10;
  return local_18;
}



// Function: FUN_10010aa0 at 10010aa0

void FUN_10010aa0(undefined4 param_1)

{
  undefined4 *puVar1;
  undefined1 local_c [4];
  undefined4 local_8;
  
  puVar1 = FUN_1000e340(local_c,param_1);
  local_8 = *puVar1;
                    /* WARNING: Subroutine does not return */
  _CxxThrowException(&local_8,(ThrowInfo *)&DAT_1003a7cc);
}



// Function: Attach at 10010ad0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall _CIP<struct IBindHost,&struct _GUID const IID_IBindHost>::Attach(struct
   IBindHost *)
    public: void __thiscall _CIP<struct IBindStatusCallback,&struct _GUID const
   IID_IBindStatusCallback>::Attach(struct IBindStatusCallback *)
    public: void __thiscall _CIP<struct IServiceProvider,&struct _GUID const
   IID_IServiceProvider>::Attach(struct IServiceProvider *)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void __thiscall Attach(void *this,int param_1)

{
  FUN_10013f30((int *)this);
  *(int *)this = param_1;
  return;
}



// Function: Attach at 10010af0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall _CIP<struct IBindHost,&struct _GUID const IID_IBindHost>::Attach(struct
   IBindHost *)
    public: void __thiscall _CIP<struct IBindStatusCallback,&struct _GUID const
   IID_IBindStatusCallback>::Attach(struct IBindStatusCallback *)
    public: void __thiscall _CIP<struct IServiceProvider,&struct _GUID const
   IID_IServiceProvider>::Attach(struct IServiceProvider *)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void __thiscall Attach(void *this,int param_1)

{
  FUN_10013f90((int *)this);
  *(int *)this = param_1;
  return;
}



// Function: Attach at 10010b10

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall _CIP<struct IBindHost,&struct _GUID const IID_IBindHost>::Attach(struct
   IBindHost *)
    public: void __thiscall _CIP<struct IBindStatusCallback,&struct _GUID const
   IID_IBindStatusCallback>::Attach(struct IBindStatusCallback *)
    public: void __thiscall _CIP<struct IServiceProvider,&struct _GUID const
   IID_IServiceProvider>::Attach(struct IServiceProvider *)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void __thiscall Attach(void *this,int param_1)

{
  FUN_10014080((int *)this);
  *(int *)this = param_1;
  return;
}



// Function: Attach at 10010b30

/* Library Function - Single Match
    public: void __thiscall ATL::CComBSTR::Attach(wchar_t *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __thiscall ATL::CComBSTR::Attach(CComBSTR *this,wchar_t *param_1)

{
  if (*(wchar_t **)this != param_1) {
    Ordinal_6(*(undefined4 *)this);
    *(wchar_t **)this = param_1;
  }
  return;
}



// Function: FUN_10010b60 at 10010b60

void FUN_10010b60(int param_1)

{
  if (param_1 != 0) {
    if (*(int *)(param_1 + 0xc) != 0) {
      (**(code **)(**(int **)(param_1 + 0xc) + 8))(*(undefined4 *)(param_1 + 0xc));
    }
    *(undefined4 *)(param_1 + 0xc) = 0;
    if (*(void **)(param_1 + 0x14) != (void *)0x0) {
      FID_conflict__vector_deleting_destructor_(*(void **)(param_1 + 0x14),3);
    }
    *(undefined4 *)(param_1 + 0x14) = 0;
  }
  return;
}



// Function: FUN_10010be0 at 10010be0

uint __thiscall FUN_10010be0(void *this,undefined4 *param_1)

{
  ushort *puVar1;
  ushort *puVar2;
  uint uVar3;
  uint uVar4;
  uint local_20;
  ushort *local_10;
  ushort *local_c;
  uint local_8;
  
                    /* WARNING: Load size is inaccurate */
  uVar3 = Ordinal_7(*this);
  uVar4 = Ordinal_7(*param_1);
  local_8 = uVar3;
  if (uVar4 < uVar3) {
    local_8 = uVar4;
  }
                    /* WARNING: Load size is inaccurate */
  puVar1 = (ushort *)*param_1;
  puVar2 = *this;
  do {
    local_c = puVar2;
    local_10 = puVar1;
    if (local_8 == 0) {
      if (uVar3 < uVar4) {
        return 0xffffffff;
      }
      local_20 = (uint)(uVar3 != uVar4);
      return local_20;
    }
    puVar1 = local_10 + 1;
    puVar2 = local_c + 1;
    local_8 = local_8 - 1;
  } while (*local_c == *local_10);
  return (uint)*local_c - (uint)*local_10;
}



// Function: FUN_10010cd0 at 10010cd0

int __fastcall FUN_10010cd0(int *param_1)

{
  undefined4 uVar1;
  int iVar2;
  
  if (*param_1 == 0) {
    iVar2 = 0;
  }
  else {
    uVar1 = Ordinal_149(*param_1);
    iVar2 = Ordinal_150(*param_1,uVar1);
    if (iVar2 == 0) {
      _com_issue_error(-0x7ff8fff2);
    }
  }
  return iVar2;
}



// Function: FUN_10010d20 at 10010d20

undefined4 __thiscall FUN_10010d20(void *this,int *param_1)

{
  undefined4 uVar1;
  
  if (param_1 == (int *)0x0) {
    uVar1 = 0x80004003;
  }
  else {
                    /* WARNING: Load size is inaccurate */
    *param_1 = *this;
                    /* WARNING: Load size is inaccurate */
    if (*this != 0) {
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
      (**(code **)(**this + 4))(*this);
    }
    uVar1 = 0;
  }
  return uVar1;
}



// Function: FUN_10010d60 at 10010d60

void * FUN_10010d60(void *param_1)

{
  ULONG UVar1;
  IUnknown *in_ECX;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002b7e1;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 3;
  FUN_1000fce0((int *)&stack0x00000024);
  FUN_1000fce0((int *)&stack0x0000001c);
  FUN_1000fce0((int *)&stack0x00000018);
  UVar1 = (*in_ECX->lpVtbl[3].AddRef)(in_ECX);
  if ((int)UVar1 < 0) {
    _com_issue_errorex(UVar1,in_ECX,(_GUID *)&DAT_1002f440);
  }
  FUN_1000df40(param_1,0,'\0');
  local_8._0_1_ = 2;
  FUN_1000f220((int *)&stack0x00000018);
  local_8._0_1_ = 1;
  FUN_1000f220((int *)&stack0x0000001c);
  local_8 = (uint)local_8._1_3_ << 8;
  FUN_1000f220((int *)&stack0x00000024);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10010e50 at 10010e50

undefined4 FUN_10010e50(int param_1,undefined4 param_2,undefined4 *param_3)

{
  undefined4 local_8;
  
  if (param_1 == 0) {
    local_8 = FUN_10011010(0,param_2,param_3);
  }
  else {
    local_8 = FUN_10010e90(param_1,param_2,param_3);
  }
  return local_8;
}



// Function: FUN_10010e90 at 10010e90

undefined4 FUN_10010e90(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  void *this;
  undefined4 uVar1;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002b812;
  local_10 = ExceptionList;
  if (param_3 != (undefined4 *)0x0) {
    ExceptionList = &local_10;
    *param_3 = 0;
    local_8 = 0;
    this = (void *)FUN_10028fa8(0x58);
    local_8._0_1_ = 1;
    if (this != (void *)0x0) {
      FUN_1000d5b0(this,param_1);
    }
    local_8 = (uint)local_8._1_3_ << 8;
    uVar1 = FUN_10010f36();
    return uVar1;
  }
  return 0x80004003;
}



// Function: Catch@10010f30 at 10010f30

undefined * Catch_10010f30(void)

{
  return &DAT_10010f3f;
}



// Function: FUN_10010f36 at 10010f36

undefined4 FUN_10010f36(void)

{
  int iVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  if (*(int *)(unaff_EBP + -0x14) != 0) {
    FUN_10012c60();
    FUN_10012260();
    iVar1 = FUN_10012f60(*(int *)(unaff_EBP + -0x14));
    *(int *)(unaff_EBP + -0x18) = iVar1;
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar2 = FUN_100116e0(*(int *)(unaff_EBP + -0x14));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
    }
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar2 = FUN_10012f40();
      *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
    }
    FUN_10012290();
    if (*(int *)(unaff_EBP + -0x18) == 0) {
      uVar2 = (**(code **)**(undefined4 **)(unaff_EBP + -0x14))
                        (*(undefined4 *)(unaff_EBP + -0x14),*(undefined4 *)(unaff_EBP + 0xc),
                         *(undefined4 *)(unaff_EBP + 0x10));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
    }
    if (*(int *)(unaff_EBP + -0x18) != 0) {
      *(undefined4 *)(unaff_EBP + -0x2c) = *(undefined4 *)(unaff_EBP + -0x14);
      *(undefined4 *)(unaff_EBP + -0x1c) = *(undefined4 *)(unaff_EBP + -0x2c);
      if (*(int *)(unaff_EBP + -0x1c) == 0) {
        *(undefined4 *)(unaff_EBP + -0x30) = 0;
      }
      else {
        uVar2 = (**(code **)(**(int **)(unaff_EBP + -0x1c) + 0xc))(1);
        *(undefined4 *)(unaff_EBP + -0x30) = uVar2;
      }
    }
  }
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x18);
}



// Function: FUN_10011010 at 10011010

undefined4 FUN_10011010(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002b842;
  local_10 = ExceptionList;
  if (param_3 != (undefined4 *)0x0) {
    ExceptionList = &local_10;
    *param_3 = 0;
    local_8 = 0;
    puVar1 = (undefined4 *)FUN_10028fa8(0x48);
    local_8._0_1_ = 1;
    if (puVar1 != (undefined4 *)0x0) {
      FUN_1000d700(puVar1);
    }
    local_8 = (uint)local_8._1_3_ << 8;
    uVar2 = FUN_100110b6();
    return uVar2;
  }
  return 0x80004003;
}



// Function: Catch@100110b0 at 100110b0

undefined * Catch_100110b0(void)

{
  return &DAT_100110bf;
}



// Function: FUN_100110b6 at 100110b6

undefined4 FUN_100110b6(void)

{
  undefined4 uVar1;
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  if (*(int *)(unaff_EBP + -0x14) != 0) {
    FUN_10012c60();
    FUN_10012240(*(int *)(unaff_EBP + -0x14));
    uVar1 = FUN_10012fa0(*(int *)(unaff_EBP + -0x14) + 8);
    *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar1 = (**(code **)(**(int **)(unaff_EBP + -0x14) + 0x10))
                        (*(undefined4 *)(unaff_EBP + -0x14));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar1 = FUN_10012f40();
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    FUN_10012270(*(int *)(unaff_EBP + -0x14));
    if (*(int *)(unaff_EBP + -0x18) == 0) {
      uVar1 = (**(code **)**(undefined4 **)(unaff_EBP + -0x14))
                        (*(undefined4 *)(unaff_EBP + -0x14),*(undefined4 *)(unaff_EBP + 0xc),
                         *(undefined4 *)(unaff_EBP + 0x10));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    if (*(int *)(unaff_EBP + -0x18) != 0) {
      *(undefined4 *)(unaff_EBP + -0x2c) = *(undefined4 *)(unaff_EBP + -0x14);
      *(undefined4 *)(unaff_EBP + -0x1c) = *(undefined4 *)(unaff_EBP + -0x2c);
      if (*(int *)(unaff_EBP + -0x1c) == 0) {
        *(undefined4 *)(unaff_EBP + -0x30) = 0;
      }
      else {
        uVar1 = (**(code **)(**(int **)(unaff_EBP + -0x1c) + 0x14))(1);
        *(undefined4 *)(unaff_EBP + -0x30) = uVar1;
      }
    }
  }
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x18);
}



// Function: FUN_10011190 at 10011190

int __thiscall FUN_10011190(void *this,IID *param_1,LPUNKNOWN param_2,uint param_3)

{
  IID *pIVar1;
  void **ppvObject;
  LPVOID *ppv;
  LPUNKNOWN local_c;
  HRESULT local_8;
  
  FUN_10013f00((int *)this);
  if ((param_3 & 0x14) == 0) {
    ppv = (LPVOID *)this;
    pIVar1 = (IID *)FUN_10011a20();
    local_8 = CoCreateInstance(param_1,param_2,param_3,pIVar1,ppv);
  }
  else {
    local_8 = CoCreateInstance(param_1,param_2,param_3,(IID *)&DAT_1002f4c4,&local_c);
    if (-1 < local_8) {
      local_8 = OleRun(local_c);
      if (-1 < local_8) {
        ppvObject = (void **)this;
        pIVar1 = (IID *)FUN_10011a20();
        local_8 = (*local_c->lpVtbl->QueryInterface)(local_c,pIVar1,ppvObject);
      }
      (*local_c->lpVtbl->Release)(local_c);
    }
  }
  if (local_8 < 0) {
    *(undefined4 *)this = 0;
  }
  return local_8;
}



// Function: FUN_10011250 at 10011250

int __thiscall FUN_10011250(void *this,IID *param_1,LPUNKNOWN param_2,uint param_3)

{
  IID *pIVar1;
  void **ppvObject;
  LPVOID *ppv;
  LPUNKNOWN local_c;
  HRESULT local_8;
  
  FUN_10013f60((int *)this);
  if ((param_3 & 0x14) == 0) {
    ppv = (LPVOID *)this;
    pIVar1 = (IID *)FUN_10011a40();
    local_8 = CoCreateInstance(param_1,param_2,param_3,pIVar1,ppv);
  }
  else {
    local_8 = CoCreateInstance(param_1,param_2,param_3,(IID *)&DAT_1002f4c4,&local_c);
    if (-1 < local_8) {
      local_8 = OleRun(local_c);
      if (-1 < local_8) {
        ppvObject = (void **)this;
        pIVar1 = (IID *)FUN_10011a40();
        local_8 = (*local_c->lpVtbl->QueryInterface)(local_c,pIVar1,ppvObject);
      }
      (*local_c->lpVtbl->Release)(local_c);
    }
  }
  if (local_8 < 0) {
    *(undefined4 *)this = 0;
  }
  return local_8;
}



// Function: FUN_10011310 at 10011310

int __thiscall FUN_10011310(void *this,IID *param_1,LPUNKNOWN param_2,uint param_3)

{
  IID *pIVar1;
  void **ppvObject;
  LPVOID *ppv;
  LPUNKNOWN local_c;
  HRESULT local_8;
  
  FUN_10013fc0((int *)this);
  if ((param_3 & 0x14) == 0) {
    ppv = (LPVOID *)this;
    pIVar1 = (IID *)FUN_10011a60();
    local_8 = CoCreateInstance(param_1,param_2,param_3,pIVar1,ppv);
  }
  else {
    local_8 = CoCreateInstance(param_1,param_2,param_3,(IID *)&DAT_1002f4c4,&local_c);
    if (-1 < local_8) {
      local_8 = OleRun(local_c);
      if (-1 < local_8) {
        ppvObject = (void **)this;
        pIVar1 = (IID *)FUN_10011a60();
        local_8 = (*local_c->lpVtbl->QueryInterface)(local_c,pIVar1,ppvObject);
      }
      (*local_c->lpVtbl->Release)(local_c);
    }
  }
  if (local_8 < 0) {
    *(undefined4 *)this = 0;
  }
  return local_8;
}



// Function: FUN_100113d0 at 100113d0

int __thiscall FUN_100113d0(void *this,IID *param_1,LPUNKNOWN param_2,uint param_3)

{
  IID *pIVar1;
  void **ppvObject;
  LPVOID *ppv;
  LPUNKNOWN local_c;
  HRESULT local_8;
  
  FUN_10013ff0((int *)this);
  if ((param_3 & 0x14) == 0) {
    ppv = (LPVOID *)this;
    pIVar1 = (IID *)FUN_10011a70();
    local_8 = CoCreateInstance(param_1,param_2,param_3,pIVar1,ppv);
  }
  else {
    local_8 = CoCreateInstance(param_1,param_2,param_3,(IID *)&DAT_1002f4c4,&local_c);
    if (-1 < local_8) {
      local_8 = OleRun(local_c);
      if (-1 < local_8) {
        ppvObject = (void **)this;
        pIVar1 = (IID *)FUN_10011a70();
        local_8 = (*local_c->lpVtbl->QueryInterface)(local_c,pIVar1,ppvObject);
      }
      (*local_c->lpVtbl->Release)(local_c);
    }
  }
  if (local_8 < 0) {
    *(undefined4 *)this = 0;
  }
  return local_8;
}



// Function: FUN_10011490 at 10011490

int __thiscall FUN_10011490(void *this,IID *param_1,LPUNKNOWN param_2,uint param_3)

{
  IID *pIVar1;
  void **ppvObject;
  LPVOID *ppv;
  LPUNKNOWN local_c;
  HRESULT local_8;
  
  FUN_10014050((int *)this);
  if ((param_3 & 0x14) == 0) {
    ppv = (LPVOID *)this;
    pIVar1 = (IID *)FUN_10011a80();
    local_8 = CoCreateInstance(param_1,param_2,param_3,pIVar1,ppv);
  }
  else {
    local_8 = CoCreateInstance(param_1,param_2,param_3,(IID *)&DAT_1002f4c4,&local_c);
    if (-1 < local_8) {
      local_8 = OleRun(local_c);
      if (-1 < local_8) {
        ppvObject = (void **)this;
        pIVar1 = (IID *)FUN_10011a80();
        local_8 = (*local_c->lpVtbl->QueryInterface)(local_c,pIVar1,ppvObject);
      }
      (*local_c->lpVtbl->Release)(local_c);
    }
  }
  if (local_8 < 0) {
    *(undefined4 *)this = 0;
  }
  return local_8;
}



// Function: FUN_10011550 at 10011550

void * __thiscall FUN_10011550(void *this,void *param_1)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b879;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
                    /* WARNING: Load size is inaccurate */
  iVar1 = (**(code **)(*this + 0x1c))(this);
  if (iVar1 < 0) {
    _com_issue_errorex(iVar1,(IUnknown *)this,(_GUID *)&DAT_1002f440);
  }
  FUN_1000e0a0(param_1,0,'\0');
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10011600 at 10011600

void FUN_10011600(LONG *param_1)

{
  InterlockedDecrement(param_1);
  return;
}



// Function: FUN_10011620 at 10011620

void FUN_10011620(LONG *param_1)

{
  InterlockedDecrement(param_1);
  return;
}



// Function: detach at 10011640

/* Library Function - Multiple Matches With Same Base Name
    public: char const * __thiscall __crt_unique_heap_ptr<char const ,struct
   __crt_internal_free_policy>::detach(void)
    public: wchar_t const * __thiscall __crt_unique_heap_ptr<wchar_t const ,struct
   __crt_internal_free_policy>::detach(void)
    public: char * __thiscall __crt_unique_heap_ptr<char,struct
   __crt_internal_free_policy>::detach(void)
    public: char * __thiscall __crt_unique_heap_ptr<char,struct
   __crt_public_free_policy>::detach(void)
     31 names - too many to list
   
   Libraries: Visual Studio 2015 Debug, Visual Studio 2017 Debug, Visual Studio 2019 Debug */

undefined4 __fastcall detach(undefined4 *param_1)

{
  undefined4 uVar1;
  
  uVar1 = *param_1;
  *param_1 = 0;
  return uVar1;
}



// Function: detach at 10011670

/* Library Function - Multiple Matches With Same Base Name
    public: char const * __thiscall __crt_unique_heap_ptr<char const ,struct
   __crt_internal_free_policy>::detach(void)
    public: wchar_t const * __thiscall __crt_unique_heap_ptr<wchar_t const ,struct
   __crt_internal_free_policy>::detach(void)
    public: char * __thiscall __crt_unique_heap_ptr<char,struct
   __crt_internal_free_policy>::detach(void)
    public: char * __thiscall __crt_unique_heap_ptr<char,struct
   __crt_public_free_policy>::detach(void)
     31 names - too many to list
   
   Libraries: Visual Studio 2015 Debug, Visual Studio 2017 Debug, Visual Studio 2019 Debug */

undefined4 __fastcall detach(undefined4 *param_1)

{
  undefined4 uVar1;
  
  uVar1 = *param_1;
  *param_1 = 0;
  return uVar1;
}



// Function: FUN_100116a0 at 100116a0

undefined4 __thiscall FUN_100116a0(void *this,undefined4 param_1)

{
  undefined4 local_c;
  
  local_c = 0;
  if ((*(int *)((int)this + 0xc) == 0) || (*(int *)((int)this + 0x14) == 0)) {
    local_c = FUN_10011b10(this,param_1);
  }
  return local_c;
}



// Function: FUN_100116e0 at 100116e0

void __fastcall FUN_100116e0(int param_1)

{
  FUN_10011710();
  (**(code **)(*(int *)(param_1 + 0x10) + 0x10))(param_1 + 0x10);
  return;
}



// Function: FUN_10011710 at 10011710

undefined4 FUN_10011710(void)

{
  return 0;
}



// Function: FUN_10011720 at 10011720

void FUN_10011720(void)

{
  FUN_10011750();
  FUN_10011750();
  return;
}



// Function: FUN_10011750 at 10011750

void FUN_10011750(void)

{
  return;
}



// Function: FUN_10011760 at 10011760

void __cdecl FUN_10011760(void *param_1)

{
  free(param_1);
  return;
}



// Function: GetData at 10011780

/* Library Function - Single Match
    public: void * __thiscall ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class
   ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData(void)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void * __thiscall
ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
CAtlSafeAllocBufferNode::GetData(CAtlSafeAllocBufferNode *this)

{
  return this + 8;
}



// Function: FUN_100117a0 at 100117a0

void FUN_100117a0(undefined4 param_1,undefined4 param_2,undefined4 *param_3,int param_4,
                 undefined4 param_5,undefined4 *param_6)

{
  FUN_10011860(&PTR_DAT_1003f0f4,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Function: FUN_100117d0 at 100117d0

void FUN_100117d0(undefined4 param_1,undefined4 param_2,undefined4 *param_3,int param_4,
                 undefined4 param_5,undefined4 *param_6)

{
  FUN_10011860(&PTR_DAT_1003f12c,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Function: FUN_10011800 at 10011800

void FUN_10011800(undefined4 param_1,undefined4 param_2,undefined4 *param_3,int param_4,
                 undefined4 param_5,undefined4 *param_6)

{
  FUN_10011860(&PTR_DAT_1003f110,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Function: FUN_10011830 at 10011830

void FUN_10011830(undefined4 param_1,undefined4 param_2,undefined4 *param_3,int param_4,
                 undefined4 param_5,undefined4 *param_6)

{
  FUN_10011860(&PTR_DAT_1003f148,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Function: FUN_10011860 at 10011860

int __thiscall
FUN_10011860(void *this,undefined4 param_1,undefined4 *param_2,int param_3,undefined4 param_4,
            undefined4 *param_5)

{
  size_t sVar1;
  void *_Buf1;
  int iVar2;
  size_t _Size;
  void *_Buf2;
  int local_10;
  int local_c;
  
  local_10 = FUN_100116a0(this,param_4);
  if (*(int *)((int)this + 0xc) != 0) {
    local_10 = -0x7fffbffb;
    if ((*(int *)((int)this + 0x14) != 0) && (param_3 == 1)) {
      sVar1 = FUN_10015140((wchar_t *)*param_2);
      local_c = *(int *)((int)this + 0x18);
      do {
        do {
          local_c = local_c + -1;
          if (local_c < 0) goto LAB_10011962;
        } while (sVar1 != *(size_t *)(*(int *)((int)this + 0x14) + 4 + local_c * 0xc));
        _Size = *(int *)(*(int *)((int)this + 0x14) + 4 + local_c * 0xc) << 1;
        _Buf2 = (void *)*param_2;
        _Buf1 = (void *)FUN_1000fcd0((undefined4 *)(*(int *)((int)this + 0x14) + local_c * 0xc));
        iVar2 = memcmp(_Buf1,_Buf2,_Size);
      } while (iVar2 != 0);
      *param_5 = *(undefined4 *)(*(int *)((int)this + 0x14) + 8 + local_c * 0xc);
      local_10 = 0;
    }
LAB_10011962:
    if (local_10 < 0) {
      local_10 = (**(code **)(**(int **)((int)this + 0xc) + 0x28))
                           (*(undefined4 *)((int)this + 0xc),param_2,param_3,param_5);
    }
  }
  return local_10;
}



// Function: FUN_100119a0 at 100119a0

undefined * FUN_100119a0(void)

{
  return &DAT_100304e0;
}



// Function: FUN_100119b0 at 100119b0

undefined * FUN_100119b0(void)

{
  return &DAT_10030614;
}



// Function: FUN_100119c0 at 100119c0

undefined * FUN_100119c0(void)

{
  return &DAT_1002f440;
}



// Function: FUN_100119d0 at 100119d0

undefined * FUN_100119d0(void)

{
  return &DAT_1002f450;
}



// Function: FUN_100119e0 at 100119e0

undefined * FUN_100119e0(void)

{
  return &DAT_10030604;
}



// Function: FUN_100119f0 at 100119f0

undefined * FUN_100119f0(void)

{
  return &DAT_10030458;
}



// Function: FUN_10011a00 at 10011a00

undefined * FUN_10011a00(void)

{
  return &DAT_1003302c;
}



// Function: FUN_10011a10 at 10011a10

undefined * FUN_10011a10(void)

{
  return &DAT_100330d0;
}



// Function: FUN_10011a20 at 10011a20

void FUN_10011a20(void)

{
  FUN_100119a0();
  return;
}



// Function: FUN_10011a30 at 10011a30

void FUN_10011a30(void)

{
  FUN_100119b0();
  return;
}



// Function: FUN_10011a40 at 10011a40

void FUN_10011a40(void)

{
  FUN_100119c0();
  return;
}



// Function: FUN_10011a50 at 10011a50

void FUN_10011a50(void)

{
  FUN_100119d0();
  return;
}



// Function: FUN_10011a60 at 10011a60

void FUN_10011a60(void)

{
  FUN_100119e0();
  return;
}



// Function: FUN_10011a70 at 10011a70

void FUN_10011a70(void)

{
  FUN_100119f0();
  return;
}



// Function: FUN_10011a80 at 10011a80

void FUN_10011a80(void)

{
  FUN_10011a00();
  return;
}



// Function: FUN_10011a90 at 10011a90

void FUN_10011a90(void)

{
  FUN_10011a10();
  return;
}



// Function: FUN_10011aa0 at 10011aa0

undefined4 __fastcall FUN_10011aa0(int param_1)

{
  return *(undefined4 *)(param_1 + 4);
}



// Function: FUN_10011ac0 at 10011ac0

undefined4 FUN_10011ac0(void)

{
  return DAT_10040524;
}



// Function: FUN_10011ad0 at 10011ad0

undefined * FUN_10011ad0(void)

{
  return &DAT_100339a0;
}



// Function: FUN_10011ae0 at 10011ae0

undefined4 __fastcall FUN_10011ae0(undefined4 *param_1)

{
  LPSTR pCVar1;
  
  if (param_1[1] == 0) {
    pCVar1 = ConvertBSTRToString((LPCWSTR)*param_1);
    param_1[1] = pCVar1;
  }
  return param_1[1];
}



// Function: FUN_10011b10 at 10011b10

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void __thiscall FUN_10011b10(void *this,undefined4 param_1)

{
  char cVar1;
  int iVar2;
  HMODULE hModule;
  size_t sVar3;
  long lVar4;
  undefined4 uVar5;
  undefined4 *puVar6;
  CHAR *lpFilename;
  DWORD nSize;
  uint local_170;
  UINT local_16c;
  undefined4 local_168;
  int local_164;
  int local_160;
  undefined1 *local_15c;
  CComCritSecLock<class_ATL::CComCriticalSection> local_158 [8];
  LPWSTR local_150;
  LPWSTR local_14c;
  DWORD local_148;
  LPWSTR local_144;
  LPWSTR local_140;
  char *local_13c;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_138 [4];
  int local_134;
  int local_130;
  int local_12c;
  int *local_128;
  ulong local_124;
  int local_120;
  undefined4 *local_11c;
  CHAR local_118 [260];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b8d7;
  local_10 = ExceptionList;
  local_170 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_11c = (undefined4 *)this;
  local_14 = local_170;
  if ((*(int *)((int)this + 0xc) == 0) || (*(int *)((int)this + 0x14) == 0)) {
    ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
    CComCritSecLock<class_ATL::CComCriticalSection>
              (local_158,(CComCriticalSection *)((int)DAT_100403a8 + 0x10),false);
    local_8 = 0;
    local_120 = FUN_10012860((undefined4 *)local_158);
    if (local_120 < 0) {
      local_8 = 0xffffffff;
      local_164 = local_120;
      ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
      ~CComCritSecLock<class_ATL::CComCriticalSection>(local_158);
    }
    else {
      local_120 = -0x7fffbffb;
      if (local_11c[3] == 0) {
        local_128 = (int *)0x0;
        iVar2 = FUN_100022c0((int *)&DAT_100403ac,(int *)local_11c[1]);
        if (((iVar2 == 0) || (*(short *)(local_11c + 2) != -1)) ||
           (*(short *)((int)local_11c + 10) != -1)) {
          local_120 = Ordinal_162(local_11c[1],*(undefined2 *)(local_11c + 2),
                                  *(undefined2 *)((int)local_11c + 10),param_1,&local_128);
        }
        else {
          nSize = 0x104;
          lpFilename = local_118;
          hModule = (HMODULE)FUN_10011aa0(0x10040520);
          local_148 = GetModuleFileNameA(hModule,lpFilename,nSize);
          if ((local_148 != 0) && (local_148 != 0x104)) {
            local_16c = FUN_10012f50();
            FUN_1000d590((undefined4 *)local_138);
            local_8._0_1_ = 1;
            local_13c = local_118;
            if (local_13c == (char *)0x0) {
              local_150 = (LPWSTR)0x0;
            }
            else {
              sVar3 = strlen(local_13c);
              local_124 = sVar3 + 1;
              lVar4 = ATL::AtlMultiply<int>((int *)&local_124,local_124,2);
              if (lVar4 < 0) {
                local_14c = (LPWSTR)0x0;
              }
              else {
                if (((int)local_124 < 0x401) && (cVar1 = FUN_10012fe0(local_124), cVar1 != '\0')) {
                  local_15c = (undefined1 *)&local_170;
                  local_140 = (LPWSTR)&local_170;
                }
                else {
                  local_140 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                      CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                                (local_138,local_124);
                }
                local_14c = FUN_100107c0(local_140,local_13c,local_124 >> 1,local_16c);
              }
              local_150 = local_14c;
            }
            local_144 = local_150;
            if (local_150 == (LPWSTR)0x0) {
              local_168 = 0x8007000e;
              local_8 = (uint)local_8._1_3_ << 8;
              ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
              ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_138);
              local_8 = 0xffffffff;
              ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
              ~CComCritSecLock<class_ATL::CComCriticalSection>(local_158);
              goto LAB_10011fb1;
            }
            local_120 = Ordinal_161(local_150,&local_128);
            local_8 = (uint)local_8._1_3_ << 8;
            ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
            ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_138);
          }
        }
        if (-1 < local_120) {
          FUN_1000d9f0(&local_12c);
          local_8._0_1_ = 2;
          uVar5 = FUN_100101d0(&local_12c);
          local_120 = (**(code **)(*local_128 + 0x18))(local_128,*local_11c,uVar5);
          if (-1 < local_120) {
            FUN_1000d990(&local_134,&local_12c);
            local_8._0_1_ = 3;
            FUN_1000d940(&local_130);
            local_8 = CONCAT31(local_8._1_3_,4);
            uVar5 = FUN_100101c0(&local_130);
            puVar6 = (undefined4 *)FUN_1000fd80(&local_12c);
            iVar2 = QueryInterface<>(puVar6,uVar5);
            if (-1 < iVar2) {
              FUN_1000c020(&local_134,&local_130);
            }
            uVar5 = detach(&local_134);
            local_11c[3] = uVar5;
            FUN_10010710(DAT_100403a8,FUN_10010b60,local_11c);
            local_8._0_1_ = 3;
            FID_conflict__bad_alloc(&local_130);
            local_8._0_1_ = 2;
            FID_conflict__bad_alloc(&local_134);
          }
          (**(code **)(*local_128 + 8))(local_128);
          local_8 = (uint)local_8._1_3_ << 8;
          FID_conflict__bad_alloc(&local_12c);
        }
      }
      else {
        local_120 = 0;
      }
      if ((local_11c[3] != 0) && (local_11c[5] == 0)) {
        local_120 = FUN_10012620((int *)local_11c[3]);
      }
      local_160 = local_120;
      local_8 = 0xffffffff;
      ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
      ~CComCritSecLock<class_ATL::CComCriticalSection>(local_158);
    }
  }
LAB_10011fb1:
  ExceptionList = local_10;
  local_170 = 0x10011fcc;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10011fe0 at 10011fe0

undefined4 __thiscall FUN_10011fe0(void *this,undefined4 param_1,undefined4 *param_2)

{
  undefined4 local_c;
  
  if (param_2 == (undefined4 *)0x0) {
    local_c = 0x80004003;
  }
  else {
    local_c = 0;
    if (*(int *)((int)this + 0xc) == 0) {
      local_c = FUN_10011b10(this,param_1);
    }
    *param_2 = *(undefined4 *)((int)this + 0xc);
    if (*(int *)((int)this + 0xc) != 0) {
      (**(code **)(**(int **)((int)this + 0xc) + 4))(*(undefined4 *)((int)this + 0xc));
      local_c = 0;
    }
  }
  return local_c;
}



// Function: FUN_10012050 at 10012050

void FUN_10012050(undefined4 param_1,int param_2,undefined4 param_3,undefined4 *param_4)

{
  FUN_10012070(&PTR_DAT_1003f0f4,param_2,param_3,param_4);
  return;
}



// Function: FUN_10012070 at 10012070

undefined4 __thiscall FUN_10012070(void *this,int param_1,undefined4 param_2,undefined4 *param_3)

{
  undefined4 uVar1;
  
  if (param_1 == 0) {
    uVar1 = FUN_10011fe0(this,param_2,param_3);
  }
  else {
    uVar1 = 0x8002000b;
  }
  return uVar1;
}



// Function: GetTypeInfoCount at 100120a0

/* Library Function - Single Match
    public: virtual long __stdcall CWnd::XAccessible::GetTypeInfoCount(unsigned int *)
   
   Library: Visual Studio */

long CWnd::XAccessible::GetTypeInfoCount(uint *param_1)

{
  long lVar1;
  undefined4 *in_stack_00000008;
  
  if (in_stack_00000008 == (undefined4 *)0x0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    *in_stack_00000008 = 1;
    lVar1 = 0;
  }
  return lVar1;
}



// Function: FUN_100120c0 at 100120c0

undefined4 __fastcall FUN_100120c0(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_100120d0 at 100120d0

void FUN_100120d0(LONG *param_1)

{
  InterlockedIncrement(param_1);
  return;
}



// Function: FUN_100120f0 at 100120f0

void FUN_100120f0(LONG *param_1)

{
  InterlockedIncrement(param_1);
  return;
}



// Function: Init at 10012110

/* Library Function - Single Match
    public: long __thiscall ATL::CComCriticalSection::Init(void)
   
   Library: Visual Studio 2010 Debug */

long __thiscall ATL::CComCriticalSection::Init(CComCriticalSection *this)

{
  BOOL BVar1;
  DWORD x;
  undefined4 local_8;
  
  local_8 = 0;
  BVar1 = InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)this,0);
  if (BVar1 == 0) {
    x = GetLastError();
    local_8 = _HRESULT_FROM_WIN32(x);
  }
  return local_8;
}



// Function: FUN_10012150 at 10012150

undefined4 FUN_10012150(void)

{
  return 0;
}



// Function: FUN_10012160 at 10012160

long __fastcall FUN_10012160(CComCriticalSection *param_1)

{
  long lVar1;
  
  lVar1 = ATL::CComCriticalSection::Init(param_1);
  if (-1 < lVar1) {
    param_1[0x18] = (CComCriticalSection)0x1;
  }
  return lVar1;
}



// Function: FUN_10012190 at 10012190

undefined4 FUN_10012190(int *param_1)

{
  undefined4 local_8;
  
  if ((((*param_1 == 0) && (param_1[1] == 0)) && (param_1[2] == 0xc0)) && (param_1[3] == 0x46000000)
     ) {
    local_8 = 1;
  }
  else {
    local_8 = 0;
  }
  return local_8;
}



// Function: FUN_10012200 at 10012200

void __fastcall FUN_10012200(LONG *param_1)

{
  FUN_100120d0(param_1);
  return;
}



// Function: FUN_10012220 at 10012220

void __fastcall FUN_10012220(LONG *param_1)

{
  FUN_100120f0(param_1);
  return;
}



// Function: FUN_10012240 at 10012240

void __fastcall FUN_10012240(int param_1)

{
  FUN_10012200((LONG *)(param_1 + 8));
  return;
}



// Function: FUN_10012260 at 10012260

void FUN_10012260(void)

{
  return;
}



// Function: FUN_10012270 at 10012270

void __fastcall FUN_10012270(int param_1)

{
  FUN_100122d0((LONG *)(param_1 + 8));
  return;
}



// Function: FUN_10012290 at 10012290

void FUN_10012290(void)

{
  return;
}



// Function: FUN_100122a0 at 100122a0

int FUN_100122a0(int param_1,int *param_2,int *param_3,undefined4 *param_4)

{
  int iVar1;
  
  iVar1 = FUN_10010870(param_1,param_2,param_3,param_4);
  return iVar1;
}



// Function: FUN_100122d0 at 100122d0

void __fastcall FUN_100122d0(LONG *param_1)

{
  FUN_10011600(param_1);
  return;
}



// Function: FUN_100122f0 at 100122f0

void __fastcall FUN_100122f0(LONG *param_1)

{
  FUN_10011620(param_1);
  return;
}



// Function: FUN_10012310 at 10012310

void FUN_10012310(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined2 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                 undefined4 param_9)

{
  FUN_10012410(&PTR_DAT_1003f0f4,param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,
               param_9);
  return;
}



// Function: FUN_10012350 at 10012350

void FUN_10012350(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined2 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                 undefined4 param_9)

{
  FUN_10012410(&PTR_DAT_1003f12c,param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,
               param_9);
  return;
}



// Function: FUN_10012390 at 10012390

void FUN_10012390(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined2 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                 undefined4 param_9)

{
  FUN_10012410(&PTR_DAT_1003f110,param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,
               param_9);
  return;
}



// Function: FUN_100123d0 at 100123d0

void FUN_100123d0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined2 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                 undefined4 param_9)

{
  FUN_10012410(&PTR_DAT_1003f148,param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,
               param_9);
  return;
}



// Function: FUN_10012410 at 10012410

undefined4 __thiscall
FUN_10012410(void *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
            undefined2 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
            undefined4 param_9)

{
  undefined4 local_c;
  
  local_c = FUN_100116a0(this,param_4);
  if (*(int *)((int)this + 0xc) != 0) {
    local_c = (**(code **)(**(int **)((int)this + 0xc) + 0x2c))
                        (*(undefined4 *)((int)this + 0xc),param_1,param_2,param_5,param_6,param_7,
                         param_8,param_9);
  }
  return local_c;
}



// Function: FUN_10012470 at 10012470

undefined1 __thiscall FUN_10012470(void *this,undefined4 *param_1)

{
  uint uVar1;
  undefined4 uVar2;
  int iVar3;
  int local_20;
  int local_1c;
  undefined4 *local_18;
  undefined1 local_11;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b910;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
                    /* WARNING: Load size is inaccurate */
  if ((*this == 0) && (param_1 == (undefined4 *)0x0)) {
    local_11 = 1;
  }
  else {
                    /* WARNING: Load size is inaccurate */
    if ((*this == 0) || (param_1 == (undefined4 *)0x0)) {
      local_11 = 0;
    }
    else {
      local_18 = (undefined4 *)this;
      FUN_1000da40(&local_20);
      local_8 = 0;
      FUN_1000da40(&local_1c);
      local_8._0_1_ = 1;
      uVar2 = FUN_100101e0(&local_20);
      (*(code *)**(undefined4 **)*local_18)(*local_18,&DAT_1002f4c4,uVar2,uVar1);
      uVar2 = FUN_100101e0(&local_1c);
      (**(code **)*param_1)(param_1,&DAT_1002f4c4,uVar2);
      iVar3 = FUN_1000fc20(&local_1c);
      local_11 = FUN_1000f650(&local_20,iVar3);
      local_8 = (uint)local_8._1_3_ << 8;
      FID_conflict__bad_alloc(&local_1c);
      local_8 = 0xffffffff;
      FID_conflict__bad_alloc(&local_20);
    }
  }
  ExceptionList = local_10;
  return local_11;
}



// Function: FUN_10012560 at 10012560

undefined4 __fastcall FUN_10012560(int *param_1)

{
  undefined4 local_c;
  
  if (*param_1 == 0) {
    local_c = 0;
  }
  else {
    local_c = Ordinal_7(*param_1);
  }
  return local_c;
}



// Function: FUN_10012590 at 10012590

HRESULT __thiscall FUN_10012590(void *this,undefined4 param_1,void **param_2)

{
  uint uVar1;
  undefined4 uVar2;
  int iVar3;
  void **ppvVar4;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b938;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  ppvVar4 = param_2;
  uVar2 = FUN_1000fce0(&param_1);
                    /* WARNING: Load size is inaccurate */
  iVar3 = (**(code **)(*this + 0x24))(this,uVar2,ppvVar4,uVar1);
  if (iVar3 < 0) {
    _com_issue_errorex(iVar3,(IUnknown *)this,(_GUID *)&DAT_10030458);
  }
  local_8 = 0xffffffff;
  FUN_1000f220(&param_1);
  ExceptionList = local_10;
  return iVar3;
}



// Function: FUN_10012620 at 10012620

undefined4 FUN_10012620(int *param_1)

{
  int iVar1;
  undefined4 uVar2;
  wchar_t *pwVar3;
  uint uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  uint *local_34;
  int local_30;
  undefined4 local_2c;
  uint *local_28;
  uint local_24;
  uint *local_20;
  int local_1c;
  uint *local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b97a;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  iVar1 = (**(code **)(*param_1 + 0xc))(param_1,&local_30,DAT_10040398 ^ (uint)&stack0xfffffffc);
  if (-1 < iVar1) {
    local_18 = (uint *)0x0;
    *(uint *)(local_1c + 0x18) = (uint)*(ushort *)(local_30 + 0x2c);
    *(undefined4 *)(local_1c + 0x14) = 0;
    if (*(int *)(local_1c + 0x18) != 0) {
      local_24 = *(uint *)(local_1c + 0x18);
      uVar4 = -(uint)((int)((ulonglong)local_24 * 0xc >> 0x20) != 0) |
              (uint)((ulonglong)local_24 * 0xc);
      local_20 = (uint *)FUN_10028fd6(-(uint)(0xfffffffb < uVar4) | uVar4 + 4);
      local_8 = 0;
      if (local_20 == (uint *)0x0) {
        local_34 = (uint *)0x0;
      }
      else {
        *local_20 = local_24;
        _eh_vector_constructor_iterator_
                  (local_20 + 1,0xc,local_24,FUN_1000e990,FID_conflict__bad_alloc);
        local_34 = local_20 + 1;
      }
      local_8 = 0xffffffff;
      local_18 = local_34;
      if (local_34 == (uint *)0x0) {
        (**(code **)(*param_1 + 0x4c))(param_1,local_30);
        ExceptionList = local_10;
        return 0x8007000e;
      }
    }
    for (local_14 = 0; local_14 < *(int *)(local_1c + 0x18); local_14 = local_14 + 1) {
      iVar1 = (**(code **)(*param_1 + 0x14))(param_1,local_14,&local_28);
      if (-1 < iVar1) {
        FUN_1000e3d0(&local_2c);
        local_8 = 1;
        uVar7 = 0;
        uVar6 = 0;
        uVar5 = 0;
        uVar2 = FUN_100101f0(&local_2c);
        iVar1 = (**(code **)(*param_1 + 0x30))(param_1,*local_28,uVar2,uVar5,uVar6,uVar7);
        if (-1 < iVar1) {
          pwVar3 = (wchar_t *)detach(&local_2c);
          ATL::CComBSTR::Attach((CComBSTR *)(local_18 + local_14 * 3),pwVar3);
          uVar2 = FUN_1000fcd0(local_18 + local_14 * 3);
          uVar4 = Ordinal_7(uVar2);
          local_18[local_14 * 3 + 1] = uVar4;
          local_18[local_14 * 3 + 2] = *local_28;
        }
        (**(code **)(*param_1 + 0x50))(param_1,local_28);
        local_8 = 0xffffffff;
        FUN_10002040(&local_2c);
      }
    }
    *(uint **)(local_1c + 0x14) = local_18;
    (**(code **)(*param_1 + 0x4c))(param_1,local_30);
  }
  ExceptionList = local_10;
  return 0;
}



// Function: FUN_10012860 at 10012860

int __fastcall FUN_10012860(undefined4 *param_1)

{
  int iVar1;
  
  iVar1 = FUN_100128d0((LPCRITICAL_SECTION)*param_1);
  if (-1 < iVar1) {
    *(undefined1 *)(param_1 + 1) = 1;
    iVar1 = 0;
  }
  return iVar1;
}



// Function: FUN_100128a0 at 100128a0

void __fastcall FUN_100128a0(undefined4 *param_1)

{
  if (*(char *)(param_1 + 1) == '\0') {
    FUN_100128d0((LPCRITICAL_SECTION)*param_1);
    *(undefined1 *)(param_1 + 1) = 1;
  }
  return;
}



// Function: FUN_100128d0 at 100128d0

undefined4 __fastcall FUN_100128d0(LPCRITICAL_SECTION param_1)

{
  EnterCriticalSection(param_1);
  return 0;
}



// Function: FUN_100128f0 at 100128f0

void __fastcall FUN_100128f0(undefined4 *param_1)

{
  (**(code **)(*(int *)*param_1 + 4))(*param_1);
  return;
}



// Function: FUN_10012910 at 10012910

void __thiscall FUN_10012910(void *this,undefined4 param_1,undefined4 param_2)

{
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
  (**(code **)**this)(*this,param_1,param_2);
  return;
}



// Function: FUN_10012940 at 10012940

void __fastcall FUN_10012940(undefined4 *param_1)

{
  (**(code **)(*(int *)*param_1 + 8))(*param_1);
  return;
}



// Function: FUN_10012960 at 10012960

ULONG __fastcall FUN_10012960(IUnknown *param_1)

{
  ULONG UVar1;
  
  UVar1 = (*param_1->lpVtbl[2].AddRef)(param_1);
  if ((int)UVar1 < 0) {
    _com_issue_errorex(UVar1,param_1,(_GUID *)&DAT_1002f450);
  }
  return UVar1;
}



// Function: FUN_100129a0 at 100129a0

void __thiscall FUN_100129a0(void *this,IID *param_1)

{
  int iVar1;
  
                    /* WARNING: Load size is inaccurate */
  iVar1 = (**(code **)(*this + 0x48))(this,param_1);
  if (iVar1 < 0) {
    _com_issue_errorex(iVar1,(IUnknown *)this,(_GUID *)&DAT_10030614);
  }
  return;
}



// Function: FUN_100129e0 at 100129e0

long FUN_100129e0(int *param_1,_GUID *param_2,void **param_3)

{
  int iVar1;
  long local_8;
  
  if (param_3 == (void **)0x0) {
    local_8 = -0x7fffbffd;
  }
  else {
    *param_3 = (void *)0x0;
    local_8 = 0;
    iVar1 = FUN_10012190((int *)param_2);
    if (iVar1 == 0) {
      local_8 = ATL::CAccessibleProxy::_InternalQueryInterface
                          ((CAccessibleProxy *)(param_1 + 4),param_2,param_3);
    }
    else {
      *param_3 = param_1;
      (**(code **)(*param_1 + 4))(param_1);
    }
  }
  return local_8;
}



// Function: FUN_10012a50 at 10012a50

void FUN_10012a50(int param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_10012910((void *)(param_1 + 8),param_2,param_3);
  return;
}



// Function: FUN_10012a6a at 10012a6a

void FUN_10012a6a(int param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_10012a50(param_1 + -4,param_2,param_3);
  return;
}



// Function: QueryInterface at 10012a80

/* Library Function - Single Match
    public: virtual long __stdcall CMFCComObject<class ATL::CAccessibleProxy>::QueryInterface(struct
   _GUID const &,void * *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

long CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface(_GUID *param_1,void **param_2)

{
  long lVar1;
  void **in_stack_0000000c;
  
  lVar1 = ATL::CAccessibleProxy::_InternalQueryInterface
                    ((CAccessibleProxy *)param_1,(_GUID *)param_2,in_stack_0000000c);
  return lVar1;
}



// Function: FUN_10012a97 at 10012a97

void FUN_10012a97(int param_1,void **param_2)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface((_GUID *)(param_1 + -4),param_2);
  return;
}



// Function: Release at 10012ab0

/* Library Function - Single Match
    public: virtual unsigned long __stdcall CMFCComObject<class
   ATL::CAccessibleProxy>::Release(void)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

ulong CMFCComObject<class_ATL::CAccessibleProxy>::Release(void)

{
  ulong uVar1;
  int *in_stack_00000004;
  
  uVar1 = FUN_100122f0(in_stack_00000004 + 1);
  if ((uVar1 == 0) && (in_stack_00000004 != (int *)0x0)) {
    (**(code **)(*in_stack_00000004 + 0xc))(1);
  }
  return uVar1;
}



// Function: FUN_10012b00 at 10012b00

void FUN_10012b00(int param_1)

{
  FUN_10012940((undefined4 *)(param_1 + 8));
  return;
}



// Function: FUN_10012b12 at 10012b12

void FUN_10012b12(int param_1)

{
  FUN_10012b00(param_1 + -4);
  return;
}



// Function: Release at 10012b20

/* Library Function - Single Match
    public: virtual unsigned long __stdcall CMFCComObject<class
   ATL::CAccessibleProxy>::Release(void)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

ulong CMFCComObject<class_ATL::CAccessibleProxy>::Release(void)

{
  ulong uVar1;
  int *in_stack_00000004;
  
  uVar1 = FUN_100122d0(in_stack_00000004 + 2);
  if ((uVar1 == 0) && (in_stack_00000004 != (int *)0x0)) {
    (**(code **)(*in_stack_00000004 + 0x14))(1);
  }
  return uVar1;
}



// Function: FUN_10012b70 at 10012b70

void FUN_10012b70(void)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::Release();
  return;
}



// Function: FUN_10012b80 at 10012b80

LONG __fastcall FUN_10012b80(void *param_1)

{
  LONG LVar1;
  
  LVar1 = InterlockedDecrement((LONG *)((int)param_1 + 8));
  if ((LVar1 == 0) && (param_1 != (void *)0x0)) {
    FUN_100104e0(param_1,1);
  }
  return LVar1;
}



// Function: FUN_10012bd0 at 10012bd0

ULONG __thiscall FUN_10012bd0(void *this,undefined4 param_1,undefined4 param_2)

{
  uint uVar1;
  undefined4 uVar2;
  ULONG UVar3;
  undefined4 uVar4;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002b9a8;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  uVar4 = param_2;
  uVar2 = FUN_1000fce0(&param_1);
                    /* WARNING: Load size is inaccurate */
  UVar3 = (**(code **)(*this + 0x28))(this,uVar2,uVar4,uVar1);
  if ((int)UVar3 < 0) {
    _com_issue_errorex(UVar3,(IUnknown *)this,(_GUID *)&DAT_10030458);
  }
  local_8 = 0xffffffff;
  FUN_1000f220(&param_1);
  ExceptionList = local_10;
  return UVar3;
}



// Function: FUN_10012c60 at 10012c60

void FUN_10012c60(void)

{
  return;
}



// Function: Swap at 10012c70

/* Library Function - Single Match
    public: void __thiscall Concurrency::details::List<struct Concurrency::details::ListEntry,class
   Concurrency::details::CollectionTypes::NoCount>::Swap(class Concurrency::details::List<struct
   Concurrency::details::ListEntry,class Concurrency::details::CollectionTypes::NoCount> *)
   
   Library: Visual Studio 2012 Debug */

void __thiscall
Concurrency::details::
List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>::
Swap(List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
     *this,List<struct_Concurrency::details::ListEntry,class_Concurrency::details::CollectionTypes::NoCount>
           *param_1)

{
  undefined4 uVar1;
  
  uVar1 = *(undefined4 *)this;
  *(undefined4 *)this = *(undefined4 *)param_1;
  *(undefined4 *)param_1 = uVar1;
  return;
}



// Function: FUN_10012ca0 at 10012ca0

void __fastcall FUN_10012ca0(undefined4 *param_1)

{
  FUN_10012cf0((LPCRITICAL_SECTION)*param_1);
  *(undefined1 *)(param_1 + 1) = 0;
  return;
}



// Function: FUN_10012cc0 at 10012cc0

void __fastcall FUN_10012cc0(undefined4 *param_1)

{
  if (*(char *)(param_1 + 1) != '\0') {
    FUN_10012cf0((LPCRITICAL_SECTION)*param_1);
    *(undefined1 *)(param_1 + 1) = 0;
  }
  return;
}



// Function: FUN_10012cf0 at 10012cf0

undefined4 __fastcall FUN_10012cf0(LPCRITICAL_SECTION param_1)

{
  LeaveCriticalSection(param_1);
  return 0;
}



// Function: FUN_10012d10 at 10012d10

void __fastcall FUN_10012d10(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 4))(*param_1);
  }
  return;
}



// Function: FUN_10012d40 at 10012d40

void __fastcall FUN_10012d40(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 4))(*param_1);
  }
  return;
}



// Function: FUN_10012d70 at 10012d70

void __fastcall FUN_10012d70(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 4))(*param_1);
  }
  return;
}



// Function: FUN_10012da0 at 10012da0

void __fastcall FUN_10012da0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 4))(*param_1);
  }
  return;
}



// Function: FUN_10012dd0 at 10012dd0

void __fastcall FUN_10012dd0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 4))(*param_1);
  }
  return;
}



// Function: FUN_10012e00 at 10012e00

void __fastcall FUN_10012e00(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 4))(*param_1);
  }
  return;
}



// Function: FUN_10012e30 at 10012e30

void __fastcall FUN_10012e30(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 4))(*param_1);
  }
  return;
}



// Function: FUN_10012e60 at 10012e60

void __fastcall FUN_10012e60(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 4))(*param_1);
  }
  return;
}



// Function: FUN_10012e90 at 10012e90

void __fastcall FUN_10012e90(int *param_1)

{
  if (*param_1 != 0) {
    FUN_100106f0(*param_1);
  }
  return;
}



// Function: FUN_10012eb0 at 10012eb0

void FUN_10012eb0(void)

{
  return;
}



// Function: FID_conflict:_Assign_rv at 10012ec0

/* Library Function - Multiple Matches With Different Base Names
    public: void __thiscall std::basic_string<unsigned short,struct std::char_traits<unsigned
   short>,class std::allocator<unsigned short> >::_Assign_rv(class std::basic_string<unsigned
   short,struct std::char_traits<unsigned short>,class std::allocator<unsigned short> > &&)
    public: void __thiscall std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >::_Assign_rv(class std::basic_string<wchar_t,struct
   std::char_traits<wchar_t>,class std::allocator<wchar_t> > &&)
   
   Library: Visual Studio 2012 Release */

void __thiscall FID_conflict__Assign_rv(void *this,undefined4 *param_1)

{
  void *this_00;
  void *pvVar1;
  undefined4 *puVar2;
  undefined1 local_5;
  
  if ((uint)param_1[5] < 0x10) {
    FUN_100150d0(this,param_1,param_1[4] + 1);
  }
  else {
    pvVar1 = this;
    puVar2 = param_1;
    this_00 = (void *)Getal(&local_5);
    construct<>(this_00,pvVar1,puVar2);
    *param_1 = 0;
  }
  *(undefined4 *)((int)this + 0x10) = param_1[4];
  *(undefined4 *)((int)this + 0x14) = param_1[5];
  FID_conflict__Tidy(param_1,'\0',0);
  return;
}



// Function: FUN_10012f40 at 10012f40

undefined4 FUN_10012f40(void)

{
  return 0;
}



// Function: FUN_10012f50 at 10012f50

undefined4 FUN_10012f50(void)

{
  return 3;
}



// Function: FUN_10012f60 at 10012f60

int __fastcall FUN_10012f60(int param_1)

{
  undefined4 local_8;
  
  local_8 = FUN_10012fa0(param_1 + 0x18);
  if (-1 < local_8) {
    local_8 = FUN_10012fc0();
  }
  return local_8;
}



// Function: FUN_10012fa0 at 10012fa0

void __fastcall FUN_10012fa0(int param_1)

{
  FUN_10012160((CComCriticalSection *)(param_1 + 4));
  return;
}



// Function: FUN_10012fc0 at 10012fc0

void FUN_10012fc0(void)

{
  FUN_10012150();
  return;
}



// Function: FUN_10012fe0 at 10012fe0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */
/* WARNING: Unable to track spacebase fully for stack */

void __cdecl FUN_10012fe0(int param_1)

{
  HRESULT HVar1;
  uint local_4c;
  int local_28;
  undefined1 local_21;
  uint local_20;
  undefined1 *local_1c;
  void *local_14;
  code *pcStack_10;
  uint local_c;
  undefined4 local_8;
  
  pcStack_10 = FUN_1002910b;
  local_14 = ExceptionList;
  local_c = DAT_10040398 ^ 0x10038118;
  local_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_1c = (undefined1 *)&local_4c;
  ExceptionList = &local_14;
  local_21 = 1;
  local_8 = 0;
  local_28 = 0;
  local_20 = local_4c;
  HVar1 = AtlAdd<>(&local_28,param_1,0x2000);
  if (HVar1 < 0) {
    local_21 = 0;
  }
  else {
    local_1c = (undefined1 *)((int)&local_4c - local_28);
  }
  local_8 = 0xfffffffe;
  ExceptionList = local_14;
  __security_check_cookie(local_20 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100130d0 at 100130d0

void FUN_100130d0(void)

{
  return;
}



// Function: FUN_100130e0 at 100130e0

uint __thiscall FUN_100130e0(void *this,int *param_1)

{
  uint uVar1;
  int iVar2;
  
                    /* WARNING: Load size is inaccurate */
  if (*this == *param_1) {
    uVar1 = 0;
  }
  else {
                    /* WARNING: Load size is inaccurate */
    if (*this == 0) {
      iVar2 = FUN_10014db0(param_1);
      if (iVar2 == 0) {
        uVar1 = 0;
      }
      else {
        uVar1 = 0xffffffff;
      }
    }
    else if (*param_1 == 0) {
      iVar2 = FUN_10014db0((int *)this);
      if (iVar2 == 0) {
        uVar1 = 0;
      }
      else {
        uVar1 = 1;
      }
    }
    else {
                    /* WARNING: Load size is inaccurate */
      uVar1 = FUN_10010be0(*this,(undefined4 *)*param_1);
    }
  }
  return uVar1;
}



// Function: FUN_10013150 at 10013150

void FUN_10013150(void)

{
  return;
}



// Function: FUN_10013160 at 10013160

void FUN_10013160(void)

{
  return;
}



// Function: FUN_10013170 at 10013170

void __thiscall FUN_10013170(void *this,uint param_1)

{
  uint uVar1;
  int iVar2;
  uint uStack_34;
  uint local_20;
  undefined1 local_15;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002b9d0;
  local_10 = ExceptionList;
  uStack_34 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_34;
  ExceptionList = &local_10;
  local_20 = param_1 | 0xf;
  uVar1 = FID_conflict_max_size();
  if (uVar1 < local_20) {
    local_20 = param_1;
  }
  else if (local_20 / 3 < *(uint *)((int)this + 0x14) >> 1) {
    iVar2 = FID_conflict_max_size();
    if (iVar2 - (*(uint *)((int)this + 0x14) >> 1) < *(uint *)((int)this + 0x14)) {
      local_20 = FID_conflict_max_size();
    }
    else {
      local_20 = (*(uint *)((int)this + 0x14) >> 1) + *(int *)((int)this + 0x14);
    }
  }
  local_8 = 0;
  local_20 = local_20 + 1;
  Getal(&local_15);
  allocate(local_20);
  FUN_10013292();
  return;
}



// Function: Catch@10013235 at 10013235

void Catch_10013235(void)

{
  uint uVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  *(BADSPACEBASE **)(unaff_EBP + -0x10) = register0x00000010;
  *(undefined4 *)(unaff_EBP + -0x1c) = *(undefined4 *)(unaff_EBP + 8);
  *(undefined1 *)(unaff_EBP + -4) = 2;
  uVar1 = *(int *)(unaff_EBP + -0x1c) + 1;
  Getal(unaff_EBP + -0x12);
  uVar2 = allocate(uVar1);
  *(undefined4 *)(unaff_EBP + -0x20) = uVar2;
  FUN_1001327c();
  return;
}



// Function: Catch@10013261 at 10013261

void Catch_10013261(void)

{
  int unaff_EBP;
  
  FID_conflict__Tidy(*(void **)(unaff_EBP + -0x18),'\x01',0);
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_1001327c at 1001327c

undefined * FUN_1001327c(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 1;
  return &DAT_1001329b;
}



// Function: FUN_10013292 at 10013292

void FUN_10013292(void)

{
  char *pcVar1;
  void *this;
  int unaff_EBP;
  undefined4 uVar2;
  uint uVar3;
  int iVar4;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  if (*(int *)(unaff_EBP + 0xc) != 0) {
    uVar3 = *(uint *)(unaff_EBP + 0xc);
    pcVar1 = std::_String_val<struct_std::_Simple_types<char>_>::_Myptr
                       (*(_String_val<struct_std::_Simple_types<char>_> **)(unaff_EBP + -0x18));
    std::char_traits<char>::copy(*(char **)(unaff_EBP + -0x20),pcVar1,uVar3);
  }
  FID_conflict__Tidy(*(void **)(unaff_EBP + -0x18),'\x01',0);
  iVar4 = unaff_EBP + -0x20;
  uVar2 = *(undefined4 *)(unaff_EBP + -0x18);
  this = (void *)Getal(unaff_EBP + -0x13);
  construct<>(this,uVar2,iVar4);
  *(undefined4 *)(*(int *)(unaff_EBP + -0x18) + 0x14) = *(undefined4 *)(unaff_EBP + -0x1c);
  std::basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
            (*(basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
               **)(unaff_EBP + -0x18),*(uint *)(unaff_EBP + 0xc));
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return;
}



// Function: FUN_10013320 at 10013320

uint __thiscall FUN_10013320(void *this,void *param_1,rsize_t param_2,uint param_3,uint param_4)

{
  char *pcVar1;
  uint uVar2;
  
  if (*(uint *)((int)this + 0x10) < param_4) {
    FUN_10014390();
  }
  if (*(int *)((int)this + 0x10) - param_4 < param_3) {
    param_3 = *(int *)((int)this + 0x10) - param_4;
  }
  uVar2 = param_3;
  pcVar1 = std::_String_val<struct_std::_Simple_types<char>_>::_Myptr
                     ((_String_val<struct_std::_Simple_types<char>_> *)this);
  FUN_10013380(param_1,param_2,pcVar1 + param_4,uVar2);
  return param_3;
}



// Function: FUN_10013380 at 10013380

void * __cdecl FUN_10013380(void *param_1,rsize_t param_2,void *param_3,rsize_t param_4)

{
  if (param_4 != 0) {
    memcpy_s(param_1,param_2,param_3,param_4);
  }
  return param_1;
}



// Function: FID_conflict:_Destroy at 100133b0

/* Library Function - Multiple Matches With Different Base Names
    protected: void __thiscall std::vector<unsigned char,class std::allocator<unsigned char>
   >::_Destroy(unsigned char *,unsigned char *)
    protected: void __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::_Destroy(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *)
    protected: void __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::_Destroy(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
    protected: void __thiscall std::vector<class Concurrency::details::_ContextCallback,class
   std::allocator<class Concurrency::details::_ContextCallback> >::_Destroy(class
   Concurrency::details::_ContextCallback *,class Concurrency::details::_ContextCallback *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void FID_conflict__Destroy(void *param_1,void *param_2)

{
  undefined1 local_5;
  
  Getal(&local_5);
  _Destroy_range<>(param_1,param_2,&local_5);
  return;
}



// Function: FID_conflict:_Destroy at 100133e0

/* Library Function - Multiple Matches With Different Base Names
    protected: void __thiscall std::vector<unsigned char,class std::allocator<unsigned char>
   >::_Destroy(unsigned char *,unsigned char *)
    protected: void __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::_Destroy(class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *,class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *)
    protected: void __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::_Destroy(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *,class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > *)
    protected: void __thiscall std::vector<class Concurrency::details::_ContextCallback,class
   std::allocator<class Concurrency::details::_ContextCallback> >::_Destroy(class
   Concurrency::details::_ContextCallback *,class Concurrency::details::_ContextCallback *)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void FID_conflict__Destroy(void *param_1,void *param_2)

{
  undefined1 local_5;
  
  Getal(&local_5);
  _Destroy_range<>(param_1,param_2,&local_5);
  return;
}



// Function: _Eos at 10013410

/* Library Function - Single Match
    protected: void __thiscall std::basic_string<char,struct std::char_traits<char>,class
   std::_DebugHeapAllocator<char> >::_Eos(unsigned int)
   
   Library: Visual Studio 2003 Debug */

void __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
          (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
           *this,uint param_1)

{
  char *pcVar1;
  undefined1 *puVar2;
  undefined1 local_5;
  
  local_5 = 0;
  *(uint *)(this + 0x10) = param_1;
  puVar2 = &local_5;
  pcVar1 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                     ((_String_val<struct_std::_Simple_types<char>_> *)this);
  FUN_10014600(pcVar1 + param_1,puVar2);
  return;
}



// Function: FUN_10013450 at 10013450

void __fastcall FUN_10013450(int *param_1)

{
  if (*param_1 != 0) {
    Ordinal_6(*param_1);
    *param_1 = 0;
  }
  if (param_1[1] != 0) {
    operator_delete__((void *)param_1[1]);
    param_1[1] = 0;
  }
  return;
}



// Function: Clear at 100134b0

/* Library Function - Multiple Matches With Same Base Name
    private: void __thiscall Concurrency::cancellation_token::_Clear(void)
    private: void __thiscall Concurrency::cancellation_token_registration::_Clear(void)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __fastcall Clear(int *param_1)

{
  if (*param_1 != 0) {
    FUN_10012b80((void *)*param_1);
    *param_1 = 0;
  }
  return;
}



// Function: _GetEntries at 100134e0

/* Library Function - Single Match
    public: static struct ATL::_ATL_INTMAP_ENTRY const * __stdcall
   ATL::CAccessibleProxy::_GetEntries(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

_ATL_INTMAP_ENTRY * ATL::CAccessibleProxy::_GetEntries(void)

{
  return (_ATL_INTMAP_ENTRY *)&PTR_DAT_1003331c;
}



// Function: Getal at 100134f0

/* Library Function - Multiple Matches With Same Base Name
    public: struct std::_Wrap_alloc<class std::allocator<char> > __thiscall
   std::_String_alloc<0,struct std::_String_base_types<char,class std::allocator<char> >
   >::_Getal(void)const 
    public: struct std::_Wrap_alloc<class std::allocator<unsigned short> > __thiscall
   std::_String_alloc<0,struct std::_String_base_types<unsigned short,class std::allocator<unsigned
   short> > >::_Getal(void)const 
    public: struct std::_Wrap_alloc<class std::allocator<wchar_t> > __thiscall
   std::_String_alloc<0,struct std::_String_base_types<wchar_t,class std::allocator<wchar_t> >
   >::_Getal(void)const 
   
   Library: Visual Studio 2012 Release */

undefined4 Getal(undefined4 param_1)

{
  FUN_1000deb0(param_1);
  return param_1;
}



// Function: Getal at 10013510

/* Library Function - Multiple Matches With Same Base Name
    public: struct std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > __thiscall std::_Vector_alloc<0,struct
   std::_Vec_base_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char>
   >,class std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> > > > >::_Getal(void)const 
    public: struct std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > __thiscall std::_Vector_alloc<0,struct
   std::_Vec_base_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > >
   >::_Getal(void)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 Getal(undefined4 param_1)

{
  FUN_1000ded0(param_1);
  return param_1;
}



// Function: Getal at 10013530

/* Library Function - Multiple Matches With Same Base Name
    public: struct std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > > __thiscall std::_Vector_alloc<0,struct
   std::_Vec_base_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char>
   >,class std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> > > > >::_Getal(void)const 
    public: struct std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > __thiscall std::_Vector_alloc<0,struct
   std::_Vec_base_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<struct
   std::pair<unsigned char,class Concurrency::details::_CancellationTokenState *> > > > >
   >::_Getal(void)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 Getal(undefined4 param_1)

{
  FUN_1000def0(param_1);
  return param_1;
}



// Function: _Grow at 10013550

/* Library Function - Single Match
    public: bool __thiscall std::basic_string<char,struct std::char_traits<char>,class
   std::allocator<char> >::_Grow(unsigned int,bool)
   
   Library: Visual Studio 2012 Release */

bool __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::_Grow
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          uint param_1,bool param_2)

{
  uint uVar1;
  uint local_c;
  
  uVar1 = FID_conflict_max_size();
  if (uVar1 < param_1) {
    FUN_10014330();
  }
  if (*(uint *)(this + 0x14) < param_1) {
    FUN_10013170(this,param_1);
  }
  else if ((param_2) && (param_1 < 0x10)) {
    if (param_1 < *(uint *)(this + 0x10)) {
      local_c = param_1;
    }
    else {
      local_c = *(uint *)(this + 0x10);
    }
    FID_conflict__Tidy(this,'\x01',local_c);
  }
  else if (param_1 == 0) {
    basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
              ((basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                *)this,0);
  }
  return param_1 != 0;
}



// Function: FID_conflict:_Grow_to at 10013600

/* Library Function - Multiple Matches With Different Base Names
    protected: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::_Grow_to(unsigned
   int)const 
    protected: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::_Grow_to(unsigned int)const 
   
   Library: Visual Studio 2012 Release */

uint __thiscall FID_conflict__Grow_to(void *this,uint param_1)

{
  int iVar1;
  undefined4 local_10;
  undefined4 local_8;
  
  local_10 = FID_conflict_capacity((int *)this);
  iVar1 = FID_conflict_max_size();
  if (iVar1 - (local_10 >> 1) < local_10) {
    local_10 = 0;
  }
  else {
    local_10 = (local_10 >> 1) + local_10;
  }
  local_8 = local_10;
  if (local_10 < param_1) {
    local_8 = param_1;
  }
  return local_8;
}



// Function: FID_conflict:_Grow_to at 10013660

/* Library Function - Multiple Matches With Different Base Names
    protected: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::_Grow_to(unsigned
   int)const 
    protected: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::_Grow_to(unsigned int)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

uint __thiscall FID_conflict__Grow_to(void *this,uint param_1)

{
  int iVar1;
  undefined4 local_10;
  undefined4 local_8;
  
  local_10 = FUN_10014700((int *)this);
  iVar1 = FID_conflict_max_size();
  if (iVar1 - (local_10 >> 1) < local_10) {
    local_10 = 0;
  }
  else {
    local_10 = (local_10 >> 1) + local_10;
  }
  local_8 = local_10;
  if (local_10 < param_1) {
    local_8 = param_1;
  }
  return local_8;
}



// Function: FUN_100136c0 at 100136c0

undefined4 * __thiscall
FUN_100136c0(void *this,undefined4 *param_1,int *param_2,uint param_3,int *param_4)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  undefined4 uVar5;
  undefined4 *puVar6;
  void *this_00;
  uint uStack_50;
  undefined1 auStack_40 [4];
  int local_3c;
  int iStack_38;
  undefined1 auStack_34 [4];
  uint local_30;
  int iStack_2c;
  int local_28;
  int local_24;
  int local_20;
  int *local_1c;
  undefined1 local_15;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ba00;
  local_10 = ExceptionList;
  uStack_50 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_50;
  ExceptionList = &local_10;
                    /* WARNING: Load size is inaccurate */
  local_3c = (int)param_2 - *this >> 2;
  local_1c = (int *)this;
  puVar1 = &uStack_50;
  if (param_3 != 0) {
    uVar2 = FUN_100142f0((int)this);
    if (uVar2 < param_3) {
      iVar3 = FID_conflict_max_size();
      iVar4 = size(local_1c);
      if ((uint)(iVar3 - iVar4) < param_3) {
        FUN_10014350();
      }
      iVar3 = size(local_1c);
      uVar2 = FID_conflict__Grow_to(local_1c,iVar3 + param_3);
      local_30 = uVar2;
      Getal(&local_15);
      local_20 = allocate(uVar2);
      local_28 = (int)param_2 - *local_1c >> 2;
      local_24 = 0;
      local_8 = 0;
      uVar5 = FUN_1000cf70(param_4);
      FUN_100142b0(local_20 + local_28 * 4,param_3,uVar5);
      local_24 = local_24 + 1;
      _Umove<>(*local_1c,(int)param_2,local_20);
      local_24 = local_24 + 1;
      _Umove<>((int)param_2,local_1c[1],local_20 + (local_28 + param_3) * 4);
      puVar6 = (undefined4 *)FUN_10013862();
      return puVar6;
    }
    if ((uint)(local_1c[1] - (int)param_2 >> 2) < param_3) {
      FUN_1000d830(auStack_34,param_4);
      local_8 = 2;
      _Umove<>((int)param_2,local_1c[1],(int)(param_2 + param_3));
      local_8 = CONCAT31(local_8._1_3_,3);
      uVar5 = FUN_1000cfa0(auStack_34);
      FUN_100142b0(local_1c[1],param_3 - (local_1c[1] - (int)param_2 >> 2),uVar5);
      puVar6 = (undefined4 *)FUN_100139a0();
      return puVar6;
    }
    FUN_1000d830(&iStack_38,param_4);
    local_8 = 5;
    iStack_2c = local_1c[1];
    iVar3 = _Umove<>(iStack_2c + param_3 * -4,iStack_2c,local_1c[1]);
    local_1c[1] = iVar3;
    FUN_10013c30();
    _Move<>(param_2,(int *)(iStack_2c + param_3 * -4),iStack_2c);
    FUN_1000d4f0(param_2,param_2 + param_3,&iStack_38);
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&iStack_38);
    puVar1 = (uint *)local_14;
  }
  local_14 = (undefined1 *)puVar1;
  puVar6 = param_1;
  iVar3 = local_3c;
  this_00 = FID_conflict_begin(local_1c,auStack_40);
  FID_conflict_operator_(this_00,puVar6,iVar3);
  ExceptionList = local_10;
  return param_1;
}



// Function: Catch@100137f4 at 100137f4

void Catch_100137f4(void)

{
  int unaff_EBP;
  void *pvVar1;
  
  if (1 < *(int *)(unaff_EBP + -0x20)) {
    FID_conflict__Destroy
              (*(void **)(unaff_EBP + -0x1c),
               (void *)(*(int *)(unaff_EBP + -0x1c) + *(int *)(unaff_EBP + -0x24) * 4));
  }
  if (0 < *(int *)(unaff_EBP + -0x20)) {
    FID_conflict__Destroy
              ((void *)(*(int *)(unaff_EBP + -0x1c) + *(int *)(unaff_EBP + -0x24) * 4),
               (void *)(*(int *)(unaff_EBP + -0x1c) + *(int *)(unaff_EBP + -0x24) * 4 +
                       *(int *)(unaff_EBP + 0x10) * 4));
  }
  pvVar1 = *(void **)(unaff_EBP + -0x1c);
  Getal(unaff_EBP + -0x12);
  deallocate(pvVar1);
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_10013862 at 10013862

undefined4 FUN_10013862(void)

{
  int iVar1;
  void *pvVar2;
  int unaff_EBP;
  undefined4 *puVar3;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  iVar1 = size(*(int **)(unaff_EBP + -0x18));
  *(int *)(unaff_EBP + 0x10) = iVar1 + *(int *)(unaff_EBP + 0x10);
  if (**(int **)(unaff_EBP + -0x18) != 0) {
    FID_conflict__Destroy
              ((void *)**(undefined4 **)(unaff_EBP + -0x18),
               *(void **)(*(int *)(unaff_EBP + -0x18) + 4));
    pvVar2 = (void *)**(undefined4 **)(unaff_EBP + -0x18);
    Getal(unaff_EBP + -0x13);
    deallocate(pvVar2);
  }
  std::_Container_base0::_Orphan_all(*(_Container_base0 **)(unaff_EBP + -0x18));
  *(int *)(*(int *)(unaff_EBP + -0x18) + 8) =
       *(int *)(unaff_EBP + -0x1c) + *(int *)(unaff_EBP + -0x2c) * 4;
  *(int *)(*(int *)(unaff_EBP + -0x18) + 4) =
       *(int *)(unaff_EBP + -0x1c) + *(int *)(unaff_EBP + 0x10) * 4;
  **(undefined4 **)(unaff_EBP + -0x18) = *(undefined4 *)(unaff_EBP + -0x1c);
  iVar1 = *(int *)(unaff_EBP + -0x38);
  puVar3 = *(undefined4 **)(unaff_EBP + 8);
  pvVar2 = FID_conflict_begin(*(void **)(unaff_EBP + -0x18),(void *)(unaff_EBP + -0x3c));
  FID_conflict_operator_(pvVar2,puVar3,iVar1);
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + 8);
}



// Function: Catch@10013972 at 10013972

void Catch_10013972(void)

{
  int unaff_EBP;
  
  FID_conflict__Destroy
            ((void *)(*(int *)(unaff_EBP + 0xc) + *(int *)(unaff_EBP + 0x10) * 4),
             (void *)(*(int *)(*(int *)(unaff_EBP + -0x18) + 4) + *(int *)(unaff_EBP + 0x10) * 4));
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_100139a0 at 100139a0

undefined4 FUN_100139a0(void)

{
  void *this;
  int unaff_EBP;
  undefined4 *puVar1;
  int iVar2;
  
  *(undefined4 *)(unaff_EBP + -4) = 2;
  *(int *)(*(int *)(unaff_EBP + -0x18) + 4) =
       *(int *)(*(int *)(unaff_EBP + -0x18) + 4) + *(int *)(unaff_EBP + 0x10) * 4;
  FUN_10013c30();
  FUN_1000d4f0(*(undefined4 *)(unaff_EBP + 0xc),
               *(int *)(*(int *)(unaff_EBP + -0x18) + 4) + *(int *)(unaff_EBP + 0x10) * -4,
               (int *)(unaff_EBP + -0x30));
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x30));
  iVar2 = *(int *)(unaff_EBP + -0x38);
  puVar1 = *(undefined4 **)(unaff_EBP + 8);
  this = FID_conflict_begin(*(void **)(unaff_EBP + -0x18),(void *)(unaff_EBP + -0x3c));
  FID_conflict_operator_(this,puVar1,iVar2);
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + 8);
}



// Function: _Inside at 10013ae0

/* Library Function - Single Match
    public: bool __thiscall std::basic_string<char,struct std::char_traits<char>,class
   std::allocator<char> >::_Inside(char const *)
   
   Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release */

bool __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::_Inside
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          char *param_1)

{
  char *pcVar1;
  
  if (((param_1 != (char *)0x0) &&
      (pcVar1 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                          ((_String_val<struct_std::_Simple_types<char>_> *)this), pcVar1 <= param_1
      )) && (pcVar1 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                                ((_String_val<struct_std::_Simple_types<char>_> *)this),
            param_1 < pcVar1 + *(int *)(this + 0x10))) {
    return true;
  }
  return false;
}



// Function: FUN_10013b20 at 10013b20

undefined1 __thiscall FUN_10013b20(void *this,uint param_1)

{
  undefined1 local_c;
  
                    /* WARNING: Load size is inaccurate */
  if ((param_1 < *(uint *)((int)this + 4)) && (*this <= param_1)) {
    local_c = 1;
  }
  else {
    local_c = 0;
  }
  return local_c;
}



// Function: _InternalQueryInterface at 10013b60

/* Library Function - Single Match
    public: long __thiscall ATL::CAccessibleProxy::_InternalQueryInterface(struct _GUID const &,void
   * *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

long __thiscall
ATL::CAccessibleProxy::_InternalQueryInterface(CAccessibleProxy *this,_GUID *param_1,void **param_2)

{
  _ATL_INTMAP_ENTRY *p_Var1;
  int iVar2;
  
  p_Var1 = _GetEntries();
  iVar2 = FUN_100122a0((int)this,(int *)p_Var1,(int *)param_1,param_2);
  return iVar2;
}



// Function: FID_conflict:_Make_iter at 10013b90

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >::_Make_iter(class std::_Vector_const_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > >)const 
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > __thiscall std::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::_Make_iter(class
   std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > >)const 
   
   Library: Visual Studio 2012 Release */

void * FID_conflict__Make_iter(void *param_1,undefined4 param_2)

{
  _Vector_iterator<>(param_1,param_2);
  return param_1;
}



// Function: _Myptr at 10013bb0

/* Library Function - Single Match
    public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>
   >::_Myptr(void)const 
   
   Library: Visual Studio 2012 Release */

char * __thiscall
std::_String_val<struct_std::_Simple_types<char>_>::_Myptr
          (_String_val<struct_std::_Simple_types<char>_> *this)

{
  _String_val<struct_std::_Simple_types<char>_> *local_c;
  
  local_c = this;
  if (0xf < *(uint *)(this + 0x14)) {
    local_c = (_String_val<struct_std::_Simple_types<char>_> *)addressof<>(*(undefined4 *)this);
  }
  return (char *)local_c;
}



// Function: _Myptr at 10013bf0

/* Library Function - Single Match
    public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>
   >::_Myptr(void)const 
   
   Library: Visual Studio 2012 Release */

char * __thiscall
std::_String_val<struct_std::_Simple_types<char>_>::_Myptr
          (_String_val<struct_std::_Simple_types<char>_> *this)

{
  _String_val<struct_std::_Simple_types<char>_> *local_c;
  
  local_c = this;
  if (0xf < *(uint *)(this + 0x14)) {
    local_c = (_String_val<struct_std::_Simple_types<char>_> *)addressof<>(*(undefined4 *)this);
  }
  return (char *)local_c;
}



// Function: FUN_10013c30 at 10013c30

void FUN_10013c30(void)

{
  return;
}



// Function: FUN_10013c40 at 10013c40

void FUN_10013c40(void)

{
  return;
}



// Function: FUN_10013c50 at 10013c50

void __thiscall FUN_10013c50(void *this,uint param_1)

{
  int iVar1;
  uint uStack_34;
  undefined1 local_15;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ba20;
  local_10 = ExceptionList;
  uStack_34 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_34;
  ExceptionList = &local_10;
  Getal(&local_15);
  iVar1 = allocate(param_1);
  local_8 = 0;
                    /* WARNING: Load size is inaccurate */
  _Umove<>(*this,*(int *)((int)this + 4),iVar1);
  FUN_10013ce5();
  return;
}



// Function: Catch@10013cbb at 10013cbb

void Catch_10013cbb(void)

{
  int unaff_EBP;
  void *pvVar1;
  
  pvVar1 = *(void **)(unaff_EBP + -0x1c);
  Getal(unaff_EBP + -0x12);
  deallocate(pvVar1);
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_10013ce5 at 10013ce5

void FUN_10013ce5(void)

{
  int iVar1;
  int unaff_EBP;
  void *pvVar2;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  iVar1 = size(*(int **)(unaff_EBP + -0x18));
  *(int *)(unaff_EBP + -0x20) = iVar1;
  if (**(int **)(unaff_EBP + -0x18) != 0) {
    FID_conflict__Destroy
              ((void *)**(undefined4 **)(unaff_EBP + -0x18),
               *(void **)(*(int *)(unaff_EBP + -0x18) + 4));
    pvVar2 = (void *)**(undefined4 **)(unaff_EBP + -0x18);
    Getal(unaff_EBP + -0x13);
    deallocate(pvVar2);
  }
  std::_Container_base0::_Orphan_all(*(_Container_base0 **)(unaff_EBP + -0x18));
  *(int *)(*(int *)(unaff_EBP + -0x18) + 8) =
       *(int *)(unaff_EBP + -0x1c) + *(int *)(unaff_EBP + 8) * 4;
  *(int *)(*(int *)(unaff_EBP + -0x18) + 4) =
       *(int *)(unaff_EBP + -0x1c) + *(int *)(unaff_EBP + -0x20) * 4;
  **(undefined4 **)(unaff_EBP + -0x18) = *(undefined4 *)(unaff_EBP + -0x1c);
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return;
}



// Function: FUN_10013d90 at 10013d90

void __thiscall FUN_10013d90(void *this,uint param_1)

{
  int iVar1;
  uint uStack_34;
  undefined1 local_15;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ba40;
  local_10 = ExceptionList;
  uStack_34 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_34;
  ExceptionList = &local_10;
  Getal(&local_15);
  iVar1 = allocate(param_1);
  local_8 = 0;
                    /* WARNING: Load size is inaccurate */
  _Umove<>(*this,*(int *)((int)this + 4),iVar1);
  FUN_10013e25();
  return;
}



// Function: Catch@10013dfb at 10013dfb

void Catch_10013dfb(void)

{
  int unaff_EBP;
  void *pvVar1;
  
  pvVar1 = *(void **)(unaff_EBP + -0x1c);
  Getal(unaff_EBP + -0x12);
  deallocate(pvVar1);
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_10013e25 at 10013e25

void FUN_10013e25(void)

{
  int iVar1;
  int unaff_EBP;
  void *pvVar2;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  iVar1 = FUN_10015520(*(int **)(unaff_EBP + -0x18));
  *(int *)(unaff_EBP + -0x20) = iVar1;
  if (**(int **)(unaff_EBP + -0x18) != 0) {
    FID_conflict__Destroy
              ((void *)**(undefined4 **)(unaff_EBP + -0x18),
               *(void **)(*(int *)(unaff_EBP + -0x18) + 4));
    pvVar2 = (void *)**(undefined4 **)(unaff_EBP + -0x18);
    Getal(unaff_EBP + -0x13);
    deallocate(pvVar2);
  }
  std::_Container_base0::_Orphan_all(*(_Container_base0 **)(unaff_EBP + -0x18));
  *(int *)(*(int *)(unaff_EBP + -0x18) + 8) =
       *(int *)(unaff_EBP + 8) * 0x18 + *(int *)(unaff_EBP + -0x1c);
  *(int *)(*(int *)(unaff_EBP + -0x18) + 4) =
       *(int *)(unaff_EBP + -0x20) * 0x18 + *(int *)(unaff_EBP + -0x1c);
  **(undefined4 **)(unaff_EBP + -0x18) = *(undefined4 *)(unaff_EBP + -0x1c);
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return;
}



// Function: FUN_10013ed0 at 10013ed0

void __fastcall FUN_10013ed0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10013f00 at 10013f00

void __fastcall FUN_10013f00(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10013f30 at 10013f30

void __fastcall FUN_10013f30(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10013f60 at 10013f60

void __fastcall FUN_10013f60(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10013f90 at 10013f90

void __fastcall FUN_10013f90(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10013fc0 at 10013fc0

void __fastcall FUN_10013fc0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10013ff0 at 10013ff0

void __fastcall FUN_10013ff0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10014020 at 10014020

void __fastcall FUN_10014020(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10014050 at 10014050

void __fastcall FUN_10014050(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10014080 at 10014080

void __fastcall FUN_10014080(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_100140b0 at 100140b0

void __thiscall FUN_100140b0(void *this,uint param_1)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  
  uVar1 = FUN_10014310((int)this);
  if (uVar1 < param_1) {
    iVar2 = FID_conflict_max_size();
    iVar3 = FUN_10015520((int *)this);
    if ((uint)(iVar2 - iVar3) < param_1) {
      FUN_10014370();
    }
    iVar2 = FUN_10015520((int *)this);
    uVar1 = FID_conflict__Grow_to(this,iVar2 + param_1);
    FUN_10013d90(this,uVar1);
  }
  return;
}



// Function: FID_conflict:_Tidy at 10014110

/* Library Function - Multiple Matches With Different Base Names
    public: void __thiscall std::basic_string<unsigned short,struct std::char_traits<unsigned
   short>,class std::allocator<unsigned short> >::_Tidy(bool,unsigned int)
    public: void __thiscall std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >::_Tidy(bool,unsigned int)
   
   Library: Visual Studio 2012 Release */

void __thiscall FID_conflict__Tidy(void *this,char param_1,uint param_2)

{
  char *pcVar1;
  void *pvVar2;
  uint uVar3;
  undefined1 local_6;
  undefined1 local_5;
  
  if ((param_1 != '\0') && (0xf < *(uint *)((int)this + 0x14))) {
                    /* WARNING: Load size is inaccurate */
    pvVar2 = *this;
    Getal(&local_5);
    destroy<>();
    if (param_2 != 0) {
      uVar3 = param_2;
      pcVar1 = (char *)addressof<>(pvVar2);
      std::char_traits<char>::copy((char *)this,pcVar1,uVar3);
    }
    Getal(&local_6);
    deallocate(pvVar2);
  }
  *(undefined4 *)((int)this + 0x14) = 0xf;
  std::basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
            ((basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
              *)this,param_2);
  return;
}



// Function: FUN_100141b0 at 100141b0

void __fastcall FUN_100141b0(_Container_base0 *param_1)

{
  void *pvVar1;
  undefined1 local_5;
  
  if (*(int *)param_1 != 0) {
    std::_Container_base0::_Orphan_all(param_1);
    FID_conflict__Destroy(*(void **)param_1,*(void **)(param_1 + 4));
    pvVar1 = *(void **)param_1;
    Getal(&local_5);
    deallocate(pvVar1);
    *(undefined4 *)param_1 = 0;
    *(undefined4 *)(param_1 + 4) = 0;
    *(undefined4 *)(param_1 + 8) = 0;
  }
  return;
}



// Function: FUN_10014230 at 10014230

void __fastcall FUN_10014230(_Container_base0 *param_1)

{
  void *pvVar1;
  undefined1 local_5;
  
  if (*(int *)param_1 != 0) {
    std::_Container_base0::_Orphan_all(param_1);
    FID_conflict__Destroy(*(void **)param_1,*(void **)(param_1 + 4));
    pvVar1 = *(void **)param_1;
    Getal(&local_5);
    deallocate(pvVar1);
    *(undefined4 *)param_1 = 0;
    *(undefined4 *)(param_1 + 4) = 0;
    *(undefined4 *)(param_1 + 8) = 0;
  }
  return;
}



// Function: FUN_100142b0 at 100142b0

int FUN_100142b0(int param_1,int param_2,undefined4 param_3)

{
  undefined1 local_5;
  
  Getal(&local_5);
  _Uninitialized_move<>(param_1,param_2,param_3,&local_5);
  return param_1 + param_2 * 4;
}



// Function: FUN_100142f0 at 100142f0

int __fastcall FUN_100142f0(int param_1)

{
  return *(int *)(param_1 + 8) - *(int *)(param_1 + 4) >> 2;
}



// Function: FUN_10014310 at 10014310

int __fastcall FUN_10014310(int param_1)

{
  return (*(int *)(param_1 + 8) - *(int *)(param_1 + 4)) / 0x18;
}



// Function: FUN_10014330 at 10014330

void FUN_10014330(void)

{
  std::_Xlength_error("string too long");
  return;
}



// Function: FUN_10014350 at 10014350

void FUN_10014350(void)

{
  std::_Xlength_error("vector<T> too long");
  return;
}



// Function: FUN_10014370 at 10014370

void FUN_10014370(void)

{
  std::_Xlength_error("vector<T> too long");
  return;
}



// Function: FUN_10014390 at 10014390

void FUN_10014390(void)

{
  std::_Xout_of_range("invalid string position");
  return;
}



// Function: allocate at 100143b0

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall std::_Wrap_alloc<class std::allocator<char> >::allocate(unsigned int)
    public: unsigned short * __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *
   __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __thiscall
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::allocate(unsigned int)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void allocate(uint param_1)

{
  allocate(param_1);
  return;
}



// Function: allocate at 100143d0

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall std::_Wrap_alloc<class std::allocator<char> >::allocate(unsigned int)
    public: unsigned short * __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *
   __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __thiscall
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::allocate(unsigned int)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void allocate(uint param_1)

{
  allocate(param_1);
  return;
}



// Function: allocate at 100143f0

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall std::_Wrap_alloc<class std::allocator<char> >::allocate(unsigned int)
    public: unsigned short * __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *
   __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __thiscall
   std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::allocate(unsigned int)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void allocate(uint param_1)

{
  allocate(param_1);
  return;
}



// Function: allocate at 10014410

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall std::allocator<char>::allocate(unsigned int)
    public: unsigned short * __thiscall std::allocator<unsigned short>::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *
   __thiscall std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> > >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __thiscall std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::allocate(unsigned int)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void allocate(uint param_1)

{
  FUN_1000c420(param_1);
  return;
}



// Function: allocate at 10014430

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall std::allocator<char>::allocate(unsigned int)
    public: unsigned short * __thiscall std::allocator<unsigned short>::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *
   __thiscall std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> > >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __thiscall std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::allocate(unsigned int)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void allocate(uint param_1)

{
  FUN_1000c460(param_1);
  return;
}



// Function: allocate at 10014450

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall std::allocator<char>::allocate(unsigned int)
    public: unsigned short * __thiscall std::allocator<unsigned short>::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > *
   __thiscall std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned
   char> > >::allocate(unsigned int)
    public: class std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned
   char,class Concurrency::details::_CancellationTokenState *> > > * __thiscall std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > >::allocate(unsigned int)
     5 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void allocate(uint param_1)

{
  FUN_1000c4b0(param_1);
  return;
}



// Function: assign at 10014470

/* Library Function - Single Match
    public: class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   & __thiscall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char>
   >::assign(class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   const &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1)

{
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar1;
  
  pbVar1 = assign(this,param_1,0,0xffffffff);
  return pbVar1;
}



// Function: assign at 100144a0

/* Library Function - Single Match
    public: class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   & __thiscall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char>
   >::assign(class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   const &,unsigned int,unsigned int)
   
   Library: Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1,
          uint param_2,uint param_3)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  uint local_c;
  
  uVar2 = FUN_100154e0((int)param_1);
  if (uVar2 < param_2) {
    FUN_10014390();
  }
  iVar3 = FUN_100154e0((int)param_1);
  local_c = iVar3 - param_2;
  if (param_3 < local_c) {
    local_c = param_3;
  }
  if (this == param_1) {
    erase(this,param_2 + local_c);
    erase(this,0,param_2);
  }
  else {
    bVar1 = _Grow(this,local_c,false);
    if (bVar1) {
      uVar2 = local_c;
      pcVar4 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                         ((_String_val<struct_std::_Simple_types<char>_> *)param_1);
      pcVar4 = pcVar4 + param_2;
      pcVar5 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                         ((_String_val<struct_std::_Simple_types<char>_> *)this);
      char_traits<char>::copy(pcVar5,pcVar4,uVar2);
      basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
                ((basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                  *)this,local_c);
    }
  }
  return this;
}



// Function: assign at 10014550

/* Library Function - Single Match
    public: class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   & __thiscall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char>
   >::assign(char const *)
   
   Library: Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          char *param_1)

{
  uint uVar1;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar2;
  
  uVar1 = char_traits<char>::length(param_1);
  pbVar2 = assign(this,param_1,uVar1);
  return pbVar2;
}



// Function: assign at 10014580

/* Library Function - Single Match
    public: class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   & __thiscall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char>
   >::assign(char const *,unsigned int)
   
   Library: Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          char *param_1,uint param_2)

{
  bool bVar1;
  char *pcVar2;
  uint uVar3;
  
  bVar1 = _Inside(this,param_1);
  if (bVar1) {
    pcVar2 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                       ((_String_val<struct_std::_Simple_types<char>_> *)this);
    this = assign(this,this,(int)param_1 - (int)pcVar2,param_2);
  }
  else {
    bVar1 = _Grow(this,param_2,false);
    if (bVar1) {
      uVar3 = param_2;
      pcVar2 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                         ((_String_val<struct_std::_Simple_types<char>_> *)this);
      char_traits<char>::copy(pcVar2,param_1,uVar3);
      basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
                ((basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                  *)this,param_2);
    }
  }
  return this;
}



// Function: FUN_10014600 at 10014600

void __cdecl FUN_10014600(undefined1 *param_1,undefined1 *param_2)

{
  *param_1 = *param_2;
  return;
}



// Function: back at 10014610

/* Library Function - Single Match
    public: wchar_t & __thiscall std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >::back(void)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release */

wchar_t * __thiscall
std::basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>::back
          (basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>
           *this)

{
  _String_iterator<class_std::_String_val<struct_std::_Simple_types<wchar_t>_>_> *this_00;
  undefined4 *puVar1;
  wchar_t *pwVar2;
  undefined1 *puVar3;
  undefined1 local_10 [4];
  undefined1 local_c [4];
  basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_> *local_8;
  
  puVar3 = local_c;
  local_8 = this;
  this_00 = (_String_iterator<class_std::_String_val<struct_std::_Simple_types<wchar_t>_>_> *)
            FID_conflict_begin(this,local_10);
  puVar1 = (undefined4 *)
           _String_iterator<class_std::_String_val<struct_std::_Simple_types<wchar_t>_>_>::operator-
                     (this_00,(int)puVar3);
  pwVar2 = (wchar_t *)FUN_1000ffb0(puVar1);
  return pwVar2;
}



// Function: base at 10014640

/* Library Function - Multiple Matches With Same Base Name
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > __thiscall
   std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct
   std::_Simple_types<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >
   > > > >::base(void)const 
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > __thiscall std::move_iterator<class
   std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > >::base(void)const 
   
   Library: Visual Studio 2012 Release */

undefined4 * __thiscall base(void *this,undefined4 *param_1)

{
                    /* WARNING: Load size is inaccurate */
  *param_1 = *this;
  return param_1;
}



// Function: FID_conflict:begin at 10014660

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >::begin(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > __thiscall std::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::begin(void)
   
   Library: Visual Studio 2012 Release */

void * __thiscall FID_conflict_begin(void *this,void *param_1)

{
                    /* WARNING: Load size is inaccurate */
  _Vector_iterator<>(param_1,*this);
  return param_1;
}



// Function: FID_conflict:begin at 10014690

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >::begin(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > __thiscall std::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::begin(void)
   
   Library: Visual Studio 2012 Release */

void * __thiscall FID_conflict_begin(void *this,void *param_1)

{
                    /* WARNING: Load size is inaccurate */
  _Vector_iterator<>(param_1,*this);
  return param_1;
}



// Function: FUN_100146c0 at 100146c0

void __fastcall FUN_100146c0(_String_val<struct_std::_Simple_types<char>_> *param_1)

{
  std::_String_val<struct_std::_Simple_types<char>_>::_Myptr(param_1);
  return;
}



// Function: FID_conflict:capacity at 100146e0

/* Library Function - Multiple Matches With Different Base Names
    public: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::capacity(void)const
   
    public: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::capacity(void)const 
   
   Library: Visual Studio 2012 Release */

int __fastcall FID_conflict_capacity(int *param_1)

{
  return param_1[2] - *param_1 >> 2;
}



// Function: FUN_10014700 at 10014700

int __fastcall FUN_10014700(int *param_1)

{
  return (param_1[2] - *param_1) / 0x18;
}



// Function: FUN_10014720 at 10014720

undefined4 __fastcall FUN_10014720(int param_1)

{
  return *(undefined4 *)(param_1 + 4);
}



// Function: FUN_10014740 at 10014740

undefined4 __fastcall FUN_10014740(int param_1)

{
  return *(undefined4 *)(param_1 + 4);
}



// Function: FUN_10014760 at 10014760

void __fastcall FUN_10014760(_Container_base0 *param_1)

{
  std::_Container_base0::_Orphan_all(param_1);
  FID_conflict__Destroy(*(void **)param_1,*(void **)(param_1 + 4));
  *(undefined4 *)(param_1 + 4) = *(undefined4 *)param_1;
  return;
}



// Function: FUN_100147a0 at 100147a0

void __fastcall FUN_100147a0(_Container_base0 *param_1)

{
  std::_Container_base0::_Orphan_all(param_1);
  FID_conflict__Destroy(*(void **)param_1,*(void **)(param_1 + 4));
  *(undefined4 *)(param_1 + 4) = *(undefined4 *)param_1;
  return;
}



// Function: FUN_100147e0 at 100147e0

void FUN_100147e0(undefined4 param_1,int *param_2)

{
  void *this;
  
  this = (void *)forward<>(4,param_1);
  if (this != (void *)0x0) {
    FUN_1000d830(this,param_2);
  }
  return;
}



// Function: FUN_10014820 at 10014820

void FUN_10014820(undefined4 param_1,
                 basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                 *param_2)

{
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ba71;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  this = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
         forward<>(0x18,param_1);
  local_8 = 0;
  if (this != (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)0x0) {
    std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
    basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>(this,param_2);
  }
  ExceptionList = local_10;
  return;
}



// Function: copy at 100148a0

/* Library Function - Single Match
    public: static char * __cdecl std::char_traits<char>::copy(char *,char const *,unsigned int)
   
   Library: Visual Studio 2012 Release */

char * __cdecl std::char_traits<char>::copy(char *param_1,char *param_2,uint param_3)

{
  undefined4 local_8;
  
  if (param_3 == 0) {
    local_8 = param_1;
  }
  else {
    local_8 = (char *)memcpy(param_1,param_2,param_3);
  }
  return local_8;
}



// Function: FUN_100148d0 at 100148d0

int __thiscall FUN_100148d0(void *this,char param_1)

{
  int *piVar1;
  undefined4 local_10;
  undefined4 local_c;
  
                    /* WARNING: Load size is inaccurate */
  if (*this == 0) {
    local_10 = 0;
  }
  else {
    if (param_1 == '\0') {
                    /* WARNING: Load size is inaccurate */
      piVar1 = (int *)FUN_100120c0(*this);
      local_c = *piVar1;
    }
    else {
                    /* WARNING: Load size is inaccurate */
      local_c = FUN_10010cd0(*this);
    }
    local_10 = local_c;
  }
  return local_10;
}



// Function: deallocate at 10014920

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::deallocate(char
   *,unsigned int)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::deallocate(unsigned short *,unsigned int)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t> >::deallocate(wchar_t
   *,unsigned int)
   
   Library: Visual Studio 2012 Release */

void deallocate(void *param_1)

{
  deallocate(param_1);
  return;
}



// Function: deallocate at 10014940

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::deallocate(char
   *,unsigned int)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned char>
   >::deallocate(unsigned char *,unsigned int)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::deallocate(unsigned short *,unsigned int)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::deallocate(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,unsigned int)
     7 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void deallocate(void *param_1)

{
  deallocate(param_1);
  return;
}



// Function: deallocate at 10014960

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::_Wrap_alloc<class std::allocator<char> >::deallocate(char
   *,unsigned int)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned char>
   >::deallocate(unsigned char *,unsigned int)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::deallocate(unsigned short *,unsigned int)
    public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > > >::deallocate(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,unsigned int)
     7 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void deallocate(void *param_1)

{
  deallocate(param_1);
  return;
}



// Function: deallocate at 10014980

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<char>::deallocate(char *,unsigned int)
    public: void __thiscall std::allocator<unsigned char>::deallocate(unsigned char *,unsigned int)
    public: void __thiscall std::allocator<unsigned short>::deallocate(unsigned short *,unsigned
   int)
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::deallocate(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,unsigned int)
     7 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void deallocate(void *param_1)

{
  operator_delete(param_1);
  return;
}



// Function: deallocate at 100149a0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<char>::deallocate(char *,unsigned int)
    public: void __thiscall std::allocator<unsigned char>::deallocate(unsigned char *,unsigned int)
    public: void __thiscall std::allocator<unsigned short>::deallocate(unsigned short *,unsigned
   int)
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::deallocate(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,unsigned int)
     7 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void deallocate(void *param_1)

{
  operator_delete(param_1);
  return;
}



// Function: deallocate at 100149c0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall std::allocator<char>::deallocate(char *,unsigned int)
    public: void __thiscall std::allocator<unsigned char>::deallocate(unsigned char *,unsigned int)
    public: void __thiscall std::allocator<unsigned short>::deallocate(unsigned short *,unsigned
   int)
    public: void __thiscall std::allocator<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > >::deallocate(class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> > *,unsigned int)
     7 names - too many to list
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void deallocate(void *param_1)

{
  operator_delete(param_1);
  return;
}



// Function: FUN_100149e0 at 100149e0

void * FUN_100149e0(void *param_1,int param_2)

{
  char *pcVar1;
  undefined *puVar2;
  
  pcVar1 = std::_Syserror_map(param_2);
  if (pcVar1 == (char *)0x0) {
    puVar2 = FUN_10015580();
    FUN_1000e960(param_1,param_2,puVar2);
  }
  else {
    puVar2 = FUN_10014d20();
    FUN_1000e960(param_1,param_2,puVar2);
  }
  return param_1;
}



// Function: default_error_condition at 10014a30

/* Library Function - Multiple Matches With Same Base Name
    public: virtual class std::error_condition __thiscall
   std::_System_error_category::default_error_condition(int)const 
    public: virtual class std::error_condition __thiscall
   std::error_category::default_error_condition(int)const 
   
   Library: Visual Studio */

void * __thiscall default_error_condition(void *this,void *param_1,undefined4 param_2)

{
  FUN_1000e960(param_1,param_2,this);
  return param_1;
}



// Function: FUN_10014a50 at 10014a50

bool __fastcall FUN_10014a50(int *param_1)

{
  return *param_1 == param_1[1];
}



// Function: FUN_10014a80 at 10014a80

bool __fastcall FUN_10014a80(int *param_1)

{
  return *param_1 == param_1[1];
}



// Function: FID_conflict:begin at 10014ab0

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >::begin(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > __thiscall std::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::begin(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >::end(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > __thiscall std::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::end(void)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void * __thiscall FID_conflict_begin(void *this,void *param_1)

{
  _Vector_iterator<>(param_1,*(undefined4 *)((int)this + 4));
  return param_1;
}



// Function: FID_conflict:begin at 10014ae0

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >::begin(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > __thiscall std::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::begin(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > > > __thiscall
   std::vector<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> >,class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   >::end(void)
    public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > > > __thiscall std::vector<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::end(void)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void * __thiscall FID_conflict_begin(void *this,void *param_1)

{
  _Vector_iterator<>(param_1,*(undefined4 *)((int)this + 4));
  return param_1;
}



// Function: equivalent at 10014b10

/* Library Function - Single Match
    public: virtual bool __thiscall std::error_category::equivalent(class std::error_code const
   &,int)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

bool __thiscall
std::error_category::equivalent(error_category *this,error_code *param_1,int param_2)

{
  bool bVar1;
  error_category *peVar2;
  int iVar3;
  
  peVar2 = (error_category *)FUN_10014720((int)param_1);
  bVar1 = operator==(this,peVar2);
  if ((bVar1) && (iVar3 = error_code::value(param_1), iVar3 == param_2)) {
    return true;
  }
  return false;
}



// Function: equivalent at 10014b60

/* Library Function - Single Match
    public: virtual bool __thiscall std::error_category::equivalent(int,class std::error_condition
   const &)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

bool __thiscall
std::error_category::equivalent(error_category *this,int param_1,error_condition *param_2)

{
  bool bVar1;
  error_condition *this_00;
  error_condition *peVar2;
  error_condition local_10 [8];
  error_category *local_8;
  
  peVar2 = local_10;
  local_8 = this;
  this_00 = (error_condition *)(**(code **)(*(int *)this + 0xc))(peVar2,param_1,param_2);
  bVar1 = error_condition::operator==(this_00,peVar2);
  return bVar1;
}



// Function: erase at 10014b90

/* Library Function - Single Match
    public: class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   & __thiscall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char>
   >::erase(unsigned int)
   
   Library: Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          uint param_1)

{
  if (*(uint *)(this + 0x10) < param_1) {
    FUN_10014390();
  }
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
            ((basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
              *)this,param_1);
  return this;
}



// Function: erase at 10014bc0

/* Library Function - Single Match
    public: class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   & __thiscall std::basic_string<char,struct std::char_traits<char>,class std::allocator<char>
   >::erase(unsigned int,unsigned int)
   
   Library: Visual Studio 2012 Release */

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          uint param_1,uint param_2)

{
  int iVar1;
  char *pcVar2;
  
  if (*(uint *)(this + 0x10) < param_1) {
    FUN_10014390();
  }
  if (param_2 < *(int *)(this + 0x10) - param_1) {
    if (param_2 != 0) {
      pcVar2 = _String_val<struct_std::_Simple_types<char>_>::_Myptr
                         ((_String_val<struct_std::_Simple_types<char>_> *)this);
      iVar1 = *(int *)(this + 0x10);
      FUN_100150d0(pcVar2 + param_1,pcVar2 + param_1 + param_2,(iVar1 - param_2) - param_1);
      basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
                ((basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                  *)this,iVar1 - param_2);
    }
  }
  else {
    basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::_Eos
              ((basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                *)this,param_1);
  }
  return this;
}



// Function: FUN_10014c50 at 10014c50

void * __thiscall FUN_10014c50(void *this,void *param_1,int param_2)

{
  _Move<>(param_2 + 4,*(int *)((int)this + 4),param_2);
  FID_conflict__Destroy((void *)(*(int *)((int)this + 4) + -4),*(void **)((int)this + 4));
  *(int *)((int)this + 4) = *(int *)((int)this + 4) + -4;
  FID_conflict__Make_iter(param_1,param_2);
  return param_1;
}



// Function: FUN_10014cc0 at 10014cc0

int __cdecl FUN_10014cc0(char *param_1)

{
  int iVar1;
  uint3 uVar2;
  
  if ((*param_1 < '0') || ('9' < *param_1)) {
    if ((*param_1 < 'A') || ('F' < *param_1)) {
      uVar2 = (uint3)(*param_1 >> 7);
      if ((*param_1 < 'a') || ('f' < *param_1)) {
        iVar1 = (uint)uVar2 << 8;
      }
      else {
        iVar1 = CONCAT31(uVar2,1);
      }
    }
    else {
      iVar1 = CONCAT31((int3)((uint)param_1 >> 8),1);
    }
  }
  else {
    iVar1 = CONCAT31(*param_1 >> 7,1);
  }
  return iVar1;
}



// Function: FUN_10014d20 at 10014d20

undefined * FUN_10014d20(void)

{
  return &DAT_100403f4;
}



// Function: FUN_10014d30 at 10014d30

undefined4 * __thiscall FUN_10014d30(void *this,undefined4 *param_1,int *param_2,int *param_3)

{
  FUN_100136c0(this,param_1,param_2,1,param_3);
  return param_1;
}



// Function: FUN_10014d60 at 10014d60

undefined4 __fastcall FUN_10014d60(int param_1)

{
  return *(undefined4 *)(param_1 + 0x10);
}



// Function: length at 10014d80

/* Library Function - Single Match
    public: static unsigned int __cdecl std::char_traits<char>::length(char const *)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release */

uint __cdecl std::char_traits<char>::length(char *param_1)

{
  undefined4 local_8;
  
  if (*param_1 == '\0') {
    local_8 = 0;
  }
  else {
    local_8 = strlen(param_1);
  }
  return local_8;
}



// Function: FUN_10014db0 at 10014db0

undefined4 __fastcall FUN_10014db0(int *param_1)

{
  undefined4 local_c;
  
  if (*param_1 == 0) {
    local_c = 0;
  }
  else {
    local_c = FUN_10012560((int *)*param_1);
  }
  return local_c;
}



// Function: max_size at 10014de0

/* Library Function - Multiple Matches With Same Base Name
    public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>
   >::max_size(void)const 
    public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>
   >::max_size(void)const 
    public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>
   >::max_size(void)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void __fastcall max_size(allocator<char> *param_1)

{
  std::allocator_traits<class_std::allocator<char>_>::max_size(param_1);
  return;
}



// Function: max_size at 10014e00

/* Library Function - Multiple Matches With Same Base Name
    public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::max_size(void)const
   
    public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::max_size(void)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void max_size(void)

{
  max_size();
  return;
}



// Function: max_size at 10014e20

/* Library Function - Multiple Matches With Same Base Name
    public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::max_size(void)const
   
    public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::max_size(void)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void max_size(void)

{
  max_size();
  return;
}



// Function: FUN_10014e40 at 10014e40

undefined4 FUN_10014e40(void)

{
  return 0xffffffff;
}



// Function: FUN_10014e50 at 10014e50

undefined4 FUN_10014e50(void)

{
  return 0x3fffffff;
}



// Function: FUN_10014e60 at 10014e60

undefined4 FUN_10014e60(void)

{
  return 0xaaaaaaa;
}



// Function: max_size at 10014e70

/* Library Function - Single Match
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>
   >::max_size(class std::allocator<char> const &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

uint __cdecl std::allocator_traits<class_std::allocator<char>_>::max_size(allocator<char> *param_1)

{
  uint uVar1;
  
  uVar1 = FUN_10014e40();
  return uVar1;
}



// Function: max_size at 10014e80

/* Library Function - Multiple Matches With Same Base Name
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<unsigned short>
   >::max_size(class std::allocator<unsigned short> const &)
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::max_size(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   const &)
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::max_size(class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > const &)
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>
   >::max_size(class std::allocator<wchar_t> const &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void max_size(void)

{
  FUN_10014e50();
  return;
}



// Function: max_size at 10014e90

/* Library Function - Multiple Matches With Same Base Name
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<unsigned short>
   >::max_size(class std::allocator<unsigned short> const &)
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::max_size(class
   std::allocator<class std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > >
   const &)
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::max_size(class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > const &)
    public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>
   >::max_size(class std::allocator<wchar_t> const &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void max_size(void)

{
  FUN_10014e60();
  return;
}



// Function: FID_conflict:max_size at 10014ea0

/* Library Function - Multiple Matches With Different Base Names
    public: unsigned int __thiscall std::basic_string<unsigned short,struct
   std::char_traits<unsigned short>,class std::allocator<unsigned short> >::max_size(void)const 
    public: unsigned int __thiscall std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> >::max_size(void)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

int FID_conflict_max_size(void)

{
  allocator<char> *paVar1;
  uint uVar2;
  int local_10;
  undefined1 local_5;
  
  paVar1 = (allocator<char> *)Getal(&local_5);
  uVar2 = max_size(paVar1);
  if (uVar2 < 2) {
    local_10 = 1;
  }
  else {
    local_10 = uVar2 - 1;
  }
  return local_10;
}



// Function: FID_conflict:max_size at 10014ee0

/* Library Function - Multiple Matches With Different Base Names
    public: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::max_size(void)const
   
    public: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::max_size(void)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void FID_conflict_max_size(void)

{
  undefined1 local_5;
  
  Getal(&local_5);
  max_size();
  return;
}



// Function: FID_conflict:max_size at 10014f00

/* Library Function - Multiple Matches With Different Base Names
    public: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<unsigned char> >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<unsigned char> > > >::max_size(void)const
   
    public: unsigned int __thiscall std::vector<class std::shared_ptr<struct
   Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > >,class std::allocator<class
   std::shared_ptr<struct Concurrency::details::_Task_impl<struct std::pair<unsigned char,class
   Concurrency::details::_CancellationTokenState *> > > > >::max_size(void)const 
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

void FID_conflict_max_size(void)

{
  undefined1 local_5;
  
  Getal(&local_5);
  max_size();
  return;
}



// Function: FUN_10014f20 at 10014f20

void * FUN_10014f20(void *param_1,int param_2)

{
  char *local_18;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002baa9;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_18 = std::_Syserror_map(param_2);
  if (local_18 == (char *)0x0) {
    local_18 = "unknown error";
  }
  basic_string<>(param_1,local_18);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10014fb0 at 10014fb0

void * FUN_10014fb0(void *param_1,int param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bae9;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (param_2 == 1) {
    basic_string<>(param_1,"iostream stream error");
  }
  else {
    FUN_10014f20(param_1,param_2);
  }
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10015040 at 10015040

void * FUN_10015040(void *param_1,int param_2)

{
  char *local_18;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bb29;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_18 = std::_Winerror_map(param_2);
  if (local_18 == (char *)0x0) {
    local_18 = "unknown error";
  }
  basic_string<>(param_1,local_18);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_100150d0 at 100150d0

void * __cdecl FUN_100150d0(void *param_1,void *param_2,size_t param_3)

{
  undefined4 local_8;
  
  if (param_3 == 0) {
    local_8 = param_1;
  }
  else {
    local_8 = memmove(param_1,param_2,param_3);
  }
  return local_8;
}



// Function: FUN_10015110 at 10015110

char * FUN_10015110(void)

{
  return "generic";
}



// Function: FUN_10015120 at 10015120

char * FUN_10015120(void)

{
  return "iostream";
}



// Function: FUN_10015130 at 10015130

char * FUN_10015130(void)

{
  return "system";
}



// Function: FUN_10015140 at 10015140

size_t __cdecl FUN_10015140(wchar_t *param_1)

{
  size_t sVar1;
  
  if (param_1 == (wchar_t *)0x0) {
    sVar1 = 0;
  }
  else {
    sVar1 = wcslen(param_1);
  }
  return sVar1;
}



// Function: FUN_10015160 at 10015160

void __thiscall FUN_10015160(void *this,undefined4 param_1)

{
  int iVar1;
  char cVar2;
  uint uVar3;
  int iVar4;
  undefined4 uVar5;
  void *pvVar6;
  undefined4 uVar7;
  undefined1 local_6;
  undefined1 local_5;
  
  uVar3 = FUN_1000cfb0(param_1);
  cVar2 = FUN_10013b20(this,uVar3);
  if (cVar2 == '\0') {
    if (*(int *)((int)this + 4) == *(int *)((int)this + 8)) {
      FUN_100140b0(this,1);
    }
    FUN_10013c40();
    uVar5 = forward<>(param_1);
    uVar7 = *(undefined4 *)((int)this + 4);
    pvVar6 = (void *)Getal(&local_6);
    construct<>(pvVar6,uVar7,uVar5);
    *(int *)((int)this + 4) = *(int *)((int)this + 4) + 0x18;
  }
  else {
    iVar4 = FUN_1000cfb0(param_1);
                    /* WARNING: Load size is inaccurate */
    iVar1 = *this;
    if (*(int *)((int)this + 4) == *(int *)((int)this + 8)) {
      FUN_100140b0(this,1);
    }
    FUN_10013c40();
                    /* WARNING: Load size is inaccurate */
    uVar5 = forward<>(((iVar4 - iVar1) / 0x18) * 0x18 + *this);
    uVar7 = *(undefined4 *)((int)this + 4);
    pvVar6 = (void *)Getal(&local_5);
    construct<>(pvVar6,uVar7,uVar5);
    *(int *)((int)this + 4) = *(int *)((int)this + 4) + 0x18;
  }
  return;
}



// Function: FUN_10015280 at 10015280

void __thiscall FUN_10015280(void *this,undefined4 param_1)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  void *pvVar5;
  undefined4 uVar6;
  undefined1 local_6;
  undefined1 local_5;
  
  uVar2 = FUN_1000cf80(param_1);
  cVar1 = FUN_10013b20(this,uVar2);
  if (cVar1 == '\0') {
    if (*(int *)((int)this + 4) == *(int *)((int)this + 8)) {
      FUN_100140b0(this,1);
    }
    FUN_10013c40();
    uVar6 = *(undefined4 *)((int)this + 4);
    pvVar5 = (void *)Getal(&local_6);
    construct<>(pvVar5,uVar6,param_1);
    *(int *)((int)this + 4) = *(int *)((int)this + 4) + 0x18;
  }
  else {
    iVar3 = FUN_1000cf80(param_1);
                    /* WARNING: Load size is inaccurate */
    iVar4 = *this;
    if (*(int *)((int)this + 4) == *(int *)((int)this + 8)) {
      FUN_100140b0(this,1);
    }
    FUN_10013c40();
                    /* WARNING: Load size is inaccurate */
    iVar4 = ((iVar3 - iVar4) / 0x18) * 0x18 + *this;
    uVar6 = *(undefined4 *)((int)this + 4);
    pvVar5 = (void *)Getal(&local_5);
    construct<>(pvVar5,uVar6,iVar4);
    *(int *)((int)this + 4) = *(int *)((int)this + 4) + 0x18;
  }
  return;
}



// Function: FUN_10015390 at 10015390

void * __thiscall FUN_10015390(void *this,void *param_1)

{
  undefined4 *puVar1;
  undefined1 local_c [4];
  void *local_8;
  
  local_8 = this;
  puVar1 = (undefined4 *)FID_conflict_begin(this,local_c);
  FUN_1000e2a0(param_1,*puVar1);
  return param_1;
}



// Function: FUN_100153c0 at 100153c0

void * __thiscall FUN_100153c0(void *this,void *param_1)

{
  undefined4 *puVar1;
  undefined1 local_c [4];
  void *local_8;
  
  local_8 = this;
  puVar1 = (undefined4 *)FID_conflict_begin(this,local_c);
  FUN_1000e2a0(param_1,*puVar1);
  return param_1;
}



// Function: FUN_100153f0 at 100153f0

void __thiscall FUN_100153f0(void *this,uint param_1)

{
  uint uVar1;
  
  uVar1 = FID_conflict_capacity((int *)this);
  if (uVar1 < param_1) {
    uVar1 = FID_conflict_max_size();
    if (uVar1 < param_1) {
      FUN_10014350();
    }
    FUN_10013c50(this,param_1);
  }
  return;
}



// Function: FUN_10015430 at 10015430

void __thiscall FUN_10015430(void *this,uint param_1)

{
  uint uVar1;
  
  uVar1 = FUN_10014700((int *)this);
  if (uVar1 < param_1) {
    uVar1 = FID_conflict_max_size();
    if (uVar1 < param_1) {
      FUN_10014370();
    }
    FUN_10013d90(this,param_1);
  }
  return;
}



// Function: select_on_container_copy_construction at 10015470

/* Library Function - Multiple Matches With Same Base Name
    public: struct std::_Wrap_alloc<class std::allocator<char> > __thiscall std::_Wrap_alloc<class
   std::allocator<char> >::select_on_container_copy_construction(void)const 
    public: struct std::_Wrap_alloc<class std::allocator<unsigned short> > __thiscall
   std::_Wrap_alloc<class std::allocator<unsigned short>
   >::select_on_container_copy_construction(void)const 
    public: struct std::_Wrap_alloc<class std::allocator<wchar_t> > __thiscall
   std::_Wrap_alloc<class std::allocator<wchar_t>
   >::select_on_container_copy_construction(void)const 
   
   Library: Visual Studio 2012 Release */

undefined4 select_on_container_copy_construction(undefined4 param_1)

{
  undefined1 local_5;
  
  select_on_container_copy_construction(&local_5);
  FUN_1000de90(param_1);
  return param_1;
}



// Function: FUN_100154a0 at 100154a0

undefined4 FUN_100154a0(undefined4 param_1)

{
  allocator<>(param_1);
  return param_1;
}



// Function: select_on_container_copy_construction at 100154c0

/* Library Function - Multiple Matches With Same Base Name
    public: static class std::allocator<char> __cdecl std::allocator_traits<class
   std::allocator<char> >::select_on_container_copy_construction(class std::allocator<char> const &)
    public: static class std::allocator<unsigned short> __cdecl std::allocator_traits<class
   std::allocator<unsigned short> >::select_on_container_copy_construction(class
   std::allocator<unsigned short> const &)
    public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class
   std::allocator<wchar_t> >::select_on_container_copy_construction(class std::allocator<wchar_t>
   const &)
   
   Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release */

undefined4 __cdecl select_on_container_copy_construction(undefined4 param_1)

{
  FUN_100154a0(param_1);
  return param_1;
}



// Function: FUN_100154e0 at 100154e0

undefined4 __fastcall FUN_100154e0(int param_1)

{
  return *(undefined4 *)(param_1 + 0x10);
}



// Function: size at 10015500

/* Library Function - Multiple Matches With Same Base Name
    public: unsigned int __thiscall `anonymous namespace'::argument_list<char>::size(void)const 
    public: unsigned int __thiscall `anonymous namespace'::argument_list<char>::size(void)const 
    public: unsigned int __thiscall `anonymous namespace'::argument_list<char>::size(void)const 
    public: unsigned int __thiscall `anonymous namespace'::argument_list<wchar_t>::size(void)const 
     6 names - too many to list
   
   Libraries: Visual Studio 2015 Debug, Visual Studio 2017 Debug, Visual Studio 2019 Debug */

int __fastcall size(int *param_1)

{
  return param_1[1] - *param_1 >> 2;
}



// Function: FUN_10015520 at 10015520

int __fastcall FUN_10015520(int *param_1)

{
  return (param_1[1] - *param_1) / 0x18;
}



// Function: FUN_10015540 at 10015540

int __cdecl FUN_10015540(wchar_t *param_1,size_t param_2)

{
  int iVar1;
  va_list in_stack_fffffff4;
  
  iVar1 = _vswprintf(param_1,param_2,(wchar_t *)&stack0x0000000c,in_stack_fffffff4);
  return iVar1;
}



// Function: FUN_10015580 at 10015580

undefined * FUN_10015580(void)

{
  return &DAT_100403fc;
}



// Function: value at 10015590

/* Library Function - Single Match
    public: int __thiscall std::error_code::value(void)const 
   
   Library: Visual Studio */

int __thiscall std::error_code::value(error_code *this)

{
  return *(int *)this;
}



// Function: value at 100155a0

/* Library Function - Single Match
    public: int __thiscall std::error_condition::value(void)const 
   
   Libraries: Visual Studio 2010 Debug, Visual Studio 2010 Release, Visual Studio 2012 Debug, Visual
   Studio 2012 Release */

int __thiscall std::error_condition::value(error_condition *this)

{
  return *(int *)this;
}



// Function: _HRESULT_FROM_WIN32 at 100155b0

/* Library Function - Single Match
    _HRESULT_FROM_WIN32
   
   Library: Visual Studio */

HRESULT __cdecl _HRESULT_FROM_WIN32(ulong x)

{
  undefined4 local_8;
  
  if ((int)x < 1) {
    local_8 = x;
  }
  else {
    local_8 = x & 0xffff | 0x80070000;
  }
  return local_8;
}



// Function: FUN_100155f0 at 100155f0

void FUN_100155f0(int param_1)

{
  FUN_1001eb90((int *)&DAT_100404dc,0x66,param_1,(int *)0x0);
  return;
}



// Function: FUN_10015610 at 10015610

undefined4 FUN_10015610(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  void *this;
  undefined4 uVar1;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002c572;
  local_10 = ExceptionList;
  if (param_3 != (undefined4 *)0x0) {
    ExceptionList = &local_10;
    *param_3 = 0;
    local_8 = 0;
    this = (void *)FUN_10028fa8(0x6c);
    local_8._0_1_ = 1;
    if (this != (void *)0x0) {
      FUN_10015ff0(this,param_1,1);
    }
    local_8 = (uint)local_8._1_3_ << 8;
    uVar1 = FUN_100156b8();
    return uVar1;
  }
  return 0x80004003;
}



// Function: Catch@100156b2 at 100156b2

undefined * Catch_100156b2(void)

{
  return &DAT_100156c1;
}



// Function: FUN_100156b8 at 100156b8

undefined4 FUN_100156b8(void)

{
  undefined4 uVar1;
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  if (*(int *)(unaff_EBP + -0x14) != 0) {
    FUN_1001da70(*(void **)(unaff_EBP + -0x14),*(undefined4 *)(unaff_EBP + 8));
    FUN_10012260();
    uVar1 = FUN_10012fa0(*(int *)(unaff_EBP + -0x14) + 4);
    *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar1 = FUN_10011710();
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar1 = FUN_10012f40();
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    FUN_10012290();
    if (*(int *)(unaff_EBP + -0x18) == 0) {
      uVar1 = (**(code **)**(undefined4 **)(unaff_EBP + -0x14))
                        (*(undefined4 *)(unaff_EBP + -0x14),*(undefined4 *)(unaff_EBP + 0xc),
                         *(undefined4 *)(unaff_EBP + 0x10));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    if (*(int *)(unaff_EBP + -0x18) != 0) {
      *(undefined4 *)(unaff_EBP + -0x2c) = *(undefined4 *)(unaff_EBP + -0x14);
      *(undefined4 *)(unaff_EBP + -0x1c) = *(undefined4 *)(unaff_EBP + -0x2c);
      if (*(int *)(unaff_EBP + -0x1c) == 0) {
        *(undefined4 *)(unaff_EBP + -0x30) = 0;
      }
      else {
        uVar1 = (*(code *)**(undefined4 **)
                            (*(int *)(unaff_EBP + -0x1c) + 0x24 +
                            *(int *)(*(int *)(*(int *)(unaff_EBP + -0x1c) + 0x24) + 4)))(1);
        *(undefined4 *)(unaff_EBP + -0x30) = uVar1;
      }
    }
  }
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x18);
}



// Function: FUN_100157b0 at 100157b0

undefined4 FUN_100157b0(int param_1,undefined4 param_2,undefined4 *param_3)

{
  undefined4 local_8;
  
  if (param_1 == 0) {
    local_8 = FUN_1001a2c0(0,param_2,param_3);
  }
  else {
    local_8 = FUN_1001a140(param_1,param_2,param_3);
  }
  return local_8;
}



// Function: FUN_100157f0 at 100157f0

undefined4 FUN_100157f0(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002c5a2;
  local_10 = ExceptionList;
  if (param_3 != (undefined4 *)0x0) {
    ExceptionList = &local_10;
    *param_3 = 0;
    local_8 = 0;
    puVar1 = (undefined4 *)FUN_10028fa8(0x28);
    local_8._0_1_ = 1;
    if (puVar1 != (undefined4 *)0x0) {
      FUN_100160e0(puVar1);
    }
    local_8 = (uint)local_8._1_3_ << 8;
    uVar2 = FUN_10015896();
    return uVar2;
  }
  return 0x80004003;
}



// Function: Catch@10015890 at 10015890

undefined * Catch_10015890(void)

{
  return &DAT_1001589f;
}



// Function: FUN_10015896 at 10015896

undefined4 FUN_10015896(void)

{
  undefined4 uVar1;
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  if (*(int *)(unaff_EBP + -0x14) != 0) {
    FUN_1001da90(*(void **)(unaff_EBP + -0x14),*(undefined4 *)(unaff_EBP + 8));
    FUN_10012260();
    uVar1 = FUN_10012fa0(*(int *)(unaff_EBP + -0x14) + 4);
    *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar1 = FUN_10011710();
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar1 = FUN_10012f40();
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    FUN_10012290();
    if (*(int *)(unaff_EBP + -0x18) == 0) {
      uVar1 = (**(code **)**(undefined4 **)(unaff_EBP + -0x14))
                        (*(undefined4 *)(unaff_EBP + -0x14),*(undefined4 *)(unaff_EBP + 0xc),
                         *(undefined4 *)(unaff_EBP + 0x10));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    if (*(int *)(unaff_EBP + -0x18) != 0) {
      *(undefined4 *)(unaff_EBP + -0x2c) = *(undefined4 *)(unaff_EBP + -0x14);
      *(undefined4 *)(unaff_EBP + -0x1c) = *(undefined4 *)(unaff_EBP + -0x2c);
      if (*(int *)(unaff_EBP + -0x1c) == 0) {
        *(undefined4 *)(unaff_EBP + -0x30) = 0;
      }
      else {
        uVar1 = (**(code **)(**(int **)(unaff_EBP + -0x1c) + 0x14))(1);
        *(undefined4 *)(unaff_EBP + -0x30) = uVar1;
      }
    }
  }
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x18);
}



// Function: FUN_10015970 at 10015970

undefined4 FUN_10015970(void)

{
  return 0;
}



// Function: FUN_10015980 at 10015980

void FUN_10015980(int param_1)

{
  FUN_1001eb90((int *)&DAT_100404dc,0x65,param_1,(int *)0x0);
  return;
}



// Function: FUN_100159a0 at 100159a0

void FUN_100159a0(void)

{
  return;
}



// Function: FUN_100159b0 at 100159b0

undefined4 FUN_100159b0(void)

{
  return 0;
}



// Function: FUN_100159c0 at 100159c0

undefined4 FUN_100159c0(void)

{
  return 0;
}



// Function: DllGetClassObject at 100159d0

HRESULT DllGetClassObject(IID *rclsid,IID *riid,LPVOID *ppv)

{
  int iVar1;
  
                    /* 0x159d0  2  DllGetClassObject */
  iVar1 = FUN_1001a970(&DAT_100404dc,(int *)rclsid,riid,(int *)ppv);
  return iVar1;
}



// Function: DllCanUnloadNow at 100159f0

HRESULT DllCanUnloadNow(void)

{
  int iVar1;
  uint local_8;
  
                    /* 0x159f0  1  DllCanUnloadNow */
  iVar1 = FUN_1001ac30(0x100404dc);
  local_8 = (uint)(iVar1 != 0);
  return local_8;
}



// Function: DllRegisterServer at 10015a20

void DllRegisterServer(void)

{
                    /* 0x15a20  3  DllRegisterServer */
  FUN_1001c430(&DAT_100404dc,1,(void *)0x0);
  return;
}



// Function: DllUnregisterServer at 10015a40

void DllUnregisterServer(void)

{
                    /* 0x15a40  4  DllUnregisterServer */
  FUN_1001de00(&DAT_100404dc,1,(void *)0x0);
  return;
}



// Function: FUN_10015a60 at 10015a60

LPCSTR __cdecl FUN_10015a60(LPSTR param_1)

{
  LPCSTR local_8;
  
  if (param_1 == (LPSTR)0x0) {
    local_8 = (LPCSTR)0x0;
  }
  else {
    local_8 = (LPCSTR)0x0;
    for (; *param_1 != '\0'; param_1 = CharNextA(param_1)) {
      if (*param_1 == '.') {
        local_8 = param_1;
      }
      else if (*param_1 == '\\') {
        local_8 = (LPCSTR)0x0;
      }
    }
    if (local_8 == (LPCSTR)0x0) {
      local_8 = param_1;
    }
  }
  return local_8;
}



// Function: FUN_10015ad0 at 10015ad0

int FUN_10015ad0(LPWSTR param_1)

{
  WCHAR WVar1;
  int iVar2;
  LPWSTR pWVar3;
  undefined4 local_10;
  undefined4 local_8;
  
  if (param_1 == (LPWSTR)0x0) {
    iVar2 = 0;
  }
  else {
    local_10 = param_1;
    local_8 = param_1;
    while (*local_8 != L'\0') {
      pWVar3 = CharNextW(local_8);
      if (((*local_8 == L'\\') || (*local_8 == L'/')) ||
         (WVar1 = *local_8, local_8 = pWVar3, WVar1 == L':')) {
        local_10 = pWVar3;
        local_8 = pWVar3;
      }
    }
    iVar2 = (int)local_10 - (int)param_1 >> 1;
  }
  return iVar2;
}



// Function: FUN_10015b40 at 10015b40

undefined4 FUN_10015b40(HMODULE param_1,int param_2)

{
  if (param_2 == 1) {
    FUN_1001aed0(&DAT_100404dc,0x1003f4f8,param_1,(undefined4 *)&DAT_10033990);
    DisableThreadLibraryCalls(param_1);
  }
  else if (param_2 == 0) {
    FUN_1001dcc0(0x100404dc);
  }
  return 1;
}



// Function: FUN_10015b90 at 10015b90

undefined4 __cdecl FUN_10015b90(undefined4 param_1,undefined4 param_2)

{
  return param_2;
}



// Function: FUN_10015ba0 at 10015ba0

undefined4 __cdecl FUN_10015ba0(undefined4 param_1,undefined4 param_2)

{
  return param_2;
}



// Function: FUN_10015bb0 at 10015bb0

void FUN_10015bb0(void)

{
  return;
}



// Function: FUN_10015bc0 at 10015bc0

void FUN_10015bc0(void)

{
  return;
}



// Function: AtlMultiply<> at 10015bd0

/* Library Function - Multiple Matches With Same Base Name
    long __cdecl ATL::AtlMultiply<unsigned int>(unsigned int *,unsigned int,unsigned int)
    long __cdecl ATL::AtlMultiply<unsigned long>(unsigned long *,unsigned long,unsigned long)
   
   Library: Visual Studio 2012 Debug */

HRESULT __cdecl AtlMultiply<>(undefined4 *param_1,uint param_2,uint param_3)

{
  HRESULT HVar1;
  undefined4 local_c;
  undefined4 local_8;
  
  local_8 = (int)((ulonglong)param_2 * (ulonglong)param_3 >> 0x20);
  if (local_8 == 0) {
    local_c = (undefined4)((ulonglong)param_2 * (ulonglong)param_3);
    *param_1 = local_c;
    HVar1 = 0;
  }
  else {
    HVar1 = _HRESULT_FROM_WIN32(0x216);
  }
  return HVar1;
}



// Function: AtlMultiply<> at 10015c10

/* Library Function - Multiple Matches With Same Base Name
    long __cdecl ATL::AtlMultiply<unsigned int>(unsigned int *,unsigned int,unsigned int)
    long __cdecl ATL::AtlMultiply<unsigned long>(unsigned long *,unsigned long,unsigned long)
   
   Library: Visual Studio 2012 Debug */

HRESULT __cdecl AtlMultiply<>(undefined4 *param_1,uint param_2,uint param_3)

{
  HRESULT HVar1;
  undefined4 local_c;
  undefined4 local_8;
  
  local_8 = (int)((ulonglong)param_2 * (ulonglong)param_3 >> 0x20);
  if (local_8 == 0) {
    local_c = (undefined4)((ulonglong)param_2 * (ulonglong)param_3);
    *param_1 = local_c;
    HVar1 = 0;
  }
  else {
    HVar1 = _HRESULT_FROM_WIN32(0x216);
  }
  return HVar1;
}



// Function: AtlMultiplyThrow<unsigned_int> at 10015c50

/* Library Function - Single Match
    unsigned int __cdecl ATL::AtlMultiplyThrow<unsigned int>(unsigned int,unsigned int)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

uint __cdecl ATL::AtlMultiplyThrow<unsigned_int>(uint param_1,uint param_2)

{
  uint local_c;
  HRESULT local_8;
  
  local_8 = AtlMultiply<>(&local_c,param_1,param_2);
  if (local_8 < 0) {
    FUN_10010aa0(local_8);
  }
  return local_c;
}



// Function: FUN_10015c90 at 10015c90

int __fastcall FUN_10015c90(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bb58;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10016380(param_1);
  local_8 = 0;
  FUN_1001af80();
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10015cf0 at 10015cf0

undefined4 * __fastcall FUN_10015cf0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10015d10 at 10015d10

undefined4 * __fastcall FUN_10015d10(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10015d30 at 10015d30

undefined4 * __thiscall FUN_10015d30(void *this,undefined4 param_1)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bb96;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_10001f20(this);
  FUN_1000d780((undefined4 *)((int)this + 4));
  local_8 = 0;
  *(undefined ***)this = ATL::CComAggObject<class_CSubFileComponent>::vftable;
  FUN_10015ec0((void *)((int)this + 0xc),param_1);
  local_8 = CONCAT31(local_8._1_3_,1);
  (**(code **)(*DAT_100403a8 + 4))(uVar1);
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_10015dc0 at 10015dc0

undefined4 * __thiscall FUN_10015dc0(void *this,int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bc0e;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (param_1 != 0) {
    *(undefined ***)((int)this + 0x24) = &PTR_10033dd4;
    *(undefined **)((int)this + 0x68) = &DAT_10033de0;
    FUN_100268e0((undefined4 *)((int)this + 0x34));
    local_8 = 0;
    FUN_10016220((void *)((int)this + 0x68),0);
    local_8 = 1;
  }
  FUN_100167d0(this);
  FUN_10001d20((undefined4 *)((int)this + 4));
  local_8 = 2;
  FUN_10016550((void *)((int)this + 0x24),0);
  *(undefined ***)this = ATL::CComClassFactory2<class_CLicenseKeySubFileComponent>::vftable;
  *(undefined ***)((int)this + *(int *)(*(int *)((int)this + 0x24) + 4) + 0x24) =
       ATL::CComClassFactory2<class_CLicenseKeySubFileComponent>::vftable;
  *(undefined4 *)((int)this + *(int *)(*(int *)((int)this + 0x24) + 4) + 0x20) = 0;
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_10015ec0 at 10015ec0

undefined4 * __thiscall FUN_10015ec0(void *this,undefined4 param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bc38;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100023d0((int)this);
  *(undefined ***)this = ATL::CComContainedObject<class_CSubFileComponent>::vftable;
  *(undefined ***)((int)this + 4) = ATL::CComContainedObject<class_CSubFileComponent>::vftable;
  *(undefined ***)((int)this + 8) = ATL::CComContainedObject<class_CSubFileComponent>::vftable;
  *(undefined ***)((int)this + 0xc) = ATL::CComContainedObject<class_CSubFileComponent>::vftable;
  *(undefined ***)((int)this + 0x10) = ATL::CComContainedObject<class_CSubFileComponent>::vftable;
  *(undefined4 *)((int)this + 0x14) = param_1;
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_10015f50 at 10015f50

undefined4 * __fastcall FUN_10015f50(undefined4 *param_1)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bc68;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_100023d0((int)param_1);
  local_8 = 0;
  *param_1 = ATL::CComObject<class_CSubFileComponent>::vftable;
  param_1[1] = ATL::CComObject<class_CSubFileComponent>::vftable;
  param_1[2] = ATL::CComObject<class_CSubFileComponent>::vftable;
  param_1[3] = ATL::CComObject<class_CSubFileComponent>::vftable;
  param_1[4] = ATL::CComObject<class_CSubFileComponent>::vftable;
  (**(code **)(*DAT_100403a8 + 4))(uVar1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10015ff0 at 10015ff0

undefined4 * __thiscall FUN_10015ff0(void *this,undefined4 param_1,int param_2)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bcd3;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (param_2 != 0) {
    *(undefined ***)((int)this + 0x24) = &PTR_10033e1c;
    *(undefined **)((int)this + 0x68) = &DAT_10033e28;
    FUN_100268e0((undefined4 *)((int)this + 0x34));
    local_8 = 0;
    FUN_10016220((void *)((int)this + 0x68),0);
    local_8 = 1;
  }
  FUN_10015dc0(this,0);
  *(undefined ***)this =
       ATL::CComObjectCached<class_ATL::CComClassFactory2<class_CLicenseKeySubFileComponent>_>::
       vftable;
  *(undefined ***)((int)this + *(int *)(*(int *)((int)this + 0x24) + 4) + 0x24) =
       ATL::CComObjectCached<class_ATL::CComClassFactory2<class_CLicenseKeySubFileComponent>_>::
       vftable;
  *(int *)((int)this + *(int *)(*(int *)((int)this + 0x24) + 4) + 0x20) =
       *(int *)(*(int *)((int)this + 0x24) + 4) + -0x10;
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_100160e0 at 100160e0

undefined4 * __fastcall FUN_100160e0(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bcf8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10016430(param_1);
  *param_1 = ATL::CComObjectCached<class_ATL::CComClassFactory>::vftable;
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10016140 at 10016140

undefined4 * __fastcall FUN_10016140(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bd28;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100161e0(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10016190 at 10016190

undefined4 * __fastcall FUN_10016190(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bd58;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10016200(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_100161e0 at 100161e0

undefined4 * __fastcall FUN_100161e0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10016200 at 10016200

undefined4 * __fastcall FUN_10016200(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10016220 at 10016220

int * __thiscall FUN_10016220(void *this,int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bd9c;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (param_1 != 0) {
    *(undefined ***)this = &PTR_10033d54;
    FUN_100268e0((undefined4 *)((int)this + 4));
  }
                    /* WARNING: Load size is inaccurate */
  *(undefined ***)((int)this + *(int *)(*this + 4)) =
       KSSecLibrary::CComSecLicense<&struct__GUID_const_CLSID_SubFileComponent>::vftable;
  ExceptionList = local_10;
  return (int *)this;
}



// Function: FUN_100162b0 at 100162b0

undefined4 * __fastcall FUN_100162b0(undefined4 *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  return param_1;
}



// Function: FUN_100162e0 at 100162e0

undefined4 * __fastcall FUN_100162e0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10016300 at 10016300

undefined4 * __fastcall FUN_10016300(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10016320 at 10016320

undefined4 * __fastcall FUN_10016320(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10016340 at 10016340

undefined4 * __thiscall FUN_10016340(void *this,undefined4 *param_1)

{
  *(undefined4 *)this = *param_1;
  return (undefined4 *)this;
}



// Function: FUN_10016360 at 10016360

undefined4 * __thiscall FUN_10016360(void *this,undefined4 *param_1)

{
  *(undefined4 *)this = *param_1;
  return (undefined4 *)this;
}



// Function: FUN_10016380 at 10016380

int __fastcall FUN_10016380(int param_1)

{
  long lVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bdcb;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10016830(param_1 + 4);
  local_8 = 0;
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  DAT_100403a8 = param_1;
  *(undefined4 *)(param_1 + 0x28) = 0;
  lVar1 = ATL::CComCriticalSection::Init((CComCriticalSection *)(param_1 + 0x10));
  if (lVar1 < 0) {
    DAT_100403bc = 1;
  }
  else {
    *(undefined4 *)(param_1 + 4) = 0x24;
  }
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10016430 at 10016430

undefined4 * __fastcall FUN_10016430(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bdfb;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100167f0(param_1);
  FUN_10001d20(param_1 + 1);
  *param_1 = ATL::CComClassFactory::vftable;
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_100164a0 at 100164a0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 * __fastcall FUN_100164a0(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002be28;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10015c90((int)param_1);
  *param_1 = ATL::CComModule::vftable;
  _DAT_100403c0 = param_1;
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10016500 at 10016500

undefined4 * __fastcall FUN_10016500(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002be58;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100162b0(param_1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10016550 at 10016550

int * __thiscall FUN_10016550(void *this,int param_1)

{
  char *pcVar1;
  undefined8 *puVar2;
  int *extraout_ECX;
  int *piVar3;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bec0;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (param_1 != 0) {
    *(undefined ***)this = &PTR_10033d6c;
    *(undefined **)((int)this + 0x40) = &DAT_10033d78;
    FUN_100268e0((undefined4 *)((int)this + 0xc));
    local_8 = 0;
    FUN_10016220((void *)((int)this + 0x40),0);
    local_8 = 1;
  }
                    /* WARNING: Load size is inaccurate */
  *(undefined ***)((int)this + *(int *)(*this + 4)) = CLicenseKeySubFileComponent::vftable;
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
  *(int *)((int)this + *(int *)(*this + 4) + -4) = *(int *)(*this + 4) + -0xc;
  pcVar1 = FUN_1001acb0();
  piVar3 = extraout_ECX;
  FUN_1000e770(&stack0xffffffd4,pcVar1);
  local_8 = 2;
  puVar2 = (undefined8 *)FUN_1001ac80();
                    /* WARNING: Load size is inaccurate */
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_10026c80((void *)((int)this + *(int *)(*this + 4)),puVar2,piVar3);
  ExceptionList = local_10;
  return (int *)this;
}



// Function: FUN_10016670 at 10016670

undefined4 * __thiscall FUN_10016670(void *this,int param_1)

{
  void *pvVar1;
  
  if (param_1 < 100) {
    param_1 = 1000;
  }
  *(undefined4 *)this = 0;
  *(int *)((int)this + 4) = param_1;
  pvVar1 = ATL::AtlCoTaskMemCAlloc(*(ulong *)((int)this + 4),1);
  *(void **)((int)this + 8) = pvVar1;
  if (*(int *)((int)this + 8) != 0) {
    **(undefined1 **)((int)this + 8) = 0;
  }
  return (undefined4 *)this;
}



// Function: CRegKey at 100166d0

/* Library Function - Single Match
    public: __thiscall ATL::CRegKey::CRegKey(struct HKEY__ *)
   
   Library: Visual Studio 2010 Debug */

CRegKey * __thiscall ATL::CRegKey::CRegKey(CRegKey *this,HKEY__ *param_1)

{
  *(HKEY__ **)this = param_1;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0;
  return this;
}



// Function: CRegKey at 10016700

/* Library Function - Single Match
    public: __thiscall ATL::CRegKey::CRegKey(class ATL::CAtlTransactionManager *)
   
   Library: Visual Studio 2010 Debug */

CRegKey * __thiscall ATL::CRegKey::CRegKey(CRegKey *this,CAtlTransactionManager *param_1)

{
  *(undefined4 *)this = 0;
  *(undefined4 *)(this + 4) = 0;
  *(CAtlTransactionManager **)(this + 8) = param_1;
  return this;
}



// Function: FUN_10016730 at 10016730

undefined4 * __fastcall FUN_10016730(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002beeb;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_10016810(param_1);
  *param_1 = ATL::CRegObject::vftable;
  FUN_10016500(param_1 + 1);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_100167a0 at 100167a0

undefined4 * __thiscall FUN_100167a0(void *this,undefined4 param_1)

{
  *(undefined4 *)((int)this + 4) = param_1;
  *(undefined4 *)this = 0;
  return (undefined4 *)this;
}



// Function: FUN_100167d0 at 100167d0

undefined4 __fastcall FUN_100167d0(undefined4 param_1)

{
  FUN_100167f0(param_1);
  return param_1;
}



// Function: FUN_100167f0 at 100167f0

undefined4 __fastcall FUN_100167f0(undefined4 param_1)

{
  FUN_10001f20(param_1);
  return param_1;
}



// Function: FUN_10016810 at 10016810

undefined4 __fastcall FUN_10016810(undefined4 param_1)

{
  FUN_10001f20(param_1);
  return param_1;
}



// Function: FUN_10016830 at 10016830

int __fastcall FUN_10016830(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002bf1b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  ATL::CComCriticalSection::CComCriticalSection((CComCriticalSection *)(param_1 + 0xc));
  ExceptionList = local_10;
  return param_1;
}



// Function: FID_conflict:~bad_alloc at 10016890

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002bf48;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_10016db0(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_100168e0 at 100168e0

void __fastcall FUN_100168e0(undefined4 *param_1)

{
  Free(param_1);
  return;
}



// Function: FUN_10016900 at 10016900

void __fastcall FUN_10016900(undefined4 *param_1)

{
  Free(param_1);
  return;
}



// Function: FUN_10016920 at 10016920

void __fastcall FUN_10016920(undefined4 *param_1)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002bf86;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  *param_1 = ATL::CComAggObject<class_CSubFileComponent>::vftable;
  local_8 = 1;
  param_1[1] = 0xc0000001;
  FUN_1001a7f0();
  (**(code **)(*DAT_100403a8 + 8))(uVar1);
  local_8 = local_8 & 0xffffff00;
  FID_conflict__bad_alloc((int)(param_1 + 3));
  local_8 = 0xffffffff;
  _anon_026BA49F::_ExceptionPtr_normal::~_ExceptionPtr_normal((_ExceptionPtr_normal *)(param_1 + 1))
  ;
  ExceptionList = local_10;
  return;
}



// Function: FUN_100169b0 at 100169b0

void __fastcall FUN_100169b0(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002bfc6;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  FUN_10016f30();
  local_8 = 0xffffffff;
  ~_ExceptionPtr_static<>(param_1 + -0x30);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 10016a10

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002bff8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_10016fe0(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10016a60 at 10016a60

void __fastcall FUN_10016a60(undefined4 *param_1)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c028;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  *param_1 = ATL::CComObject<class_CSubFileComponent>::vftable;
  param_1[1] = ATL::CComObject<class_CSubFileComponent>::vftable;
  param_1[2] = ATL::CComObject<class_CSubFileComponent>::vftable;
  param_1[3] = ATL::CComObject<class_CSubFileComponent>::vftable;
  param_1[4] = ATL::CComObject<class_CSubFileComponent>::vftable;
  local_8 = 0;
  param_1[5] = 0xc0000001;
  FUN_10011750();
  (**(code **)(*DAT_100403a8 + 8))(uVar1);
  local_8 = 0xffffffff;
  FUN_10016fe0((int)param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10016b10 at 10016b10

void __fastcall FUN_10016b10(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c058;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined ***)(param_1 + -0x34) =
       ATL::CComObjectCached<class_ATL::CComClassFactory2<class_CLicenseKeySubFileComponent>_>::
       vftable;
  *(undefined ***)(param_1 + -0x10 + *(int *)(*(int *)(param_1 + -0x10) + 4)) =
       ATL::CComObjectCached<class_ATL::CComClassFactory2<class_CLicenseKeySubFileComponent>_>::
       vftable;
  *(int *)(param_1 + -0x14 + *(int *)(*(int *)(param_1 + -0x10) + 4)) =
       *(int *)(*(int *)(param_1 + -0x10) + 4) + -0x10;
  local_8 = 0;
  *(undefined4 *)(param_1 + -0x30) = 0xc0000001;
  FUN_10011750();
  local_8 = 0xffffffff;
  FUN_100169b0(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10016bb0 at 10016bb0

void __fastcall FUN_10016bb0(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c088;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *param_1 = ATL::CComObjectCached<class_ATL::CComClassFactory>::vftable;
  local_8 = 0;
  param_1[1] = 0xc0000001;
  FUN_10011750();
  local_8 = 0xffffffff;
  FUN_10016e10(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 10016c20

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c0b8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_10016cc0(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~bad_alloc at 10016c70

/* Library Function - Multiple Matches With Different Base Names
    public: virtual __thiscall `anonymous
   namespace'::_ExceptionPtr_normal::~_ExceptionPtr_normal(void)
    public: virtual __thiscall std::bad_alloc::~bad_alloc(void)
    public: virtual __thiscall std::bad_exception::~bad_exception(void)
   
   Libraries: Visual Studio 2019 Debug, Visual Studio 2019 Release */

void __fastcall FID_conflict__bad_alloc(int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c0e8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_10016cf0(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10016cc0 at 10016cc0

void __fastcall FUN_10016cc0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10016cf0 at 10016cf0

void __fastcall FUN_10016cf0(int *param_1)

{
  if (*param_1 != 0) {
    (**(code **)(*(int *)*param_1 + 8))(*param_1);
  }
  return;
}



// Function: FUN_10016d20 at 10016d20

void FUN_10016d20(void)

{
  return;
}



// Function: FUN_10016d30 at 10016d30

void __fastcall FUN_10016d30(int *param_1)

{
  FUN_1001d0f0(param_1);
  return;
}



// Function: ~CTempBuffer<> at 10016d50

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall ATL::CTempBuffer<char,128,class
   ATL::CCRTAllocator>::~CTempBuffer<char,128,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::~CTempBuffer<unsigned char,128,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<wchar_t,10,class
   ATL::CCRTAllocator>::~CTempBuffer<wchar_t,10,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<wchar_t,128,class
   ATL::CCRTAllocator>::~CTempBuffer<wchar_t,128,class ATL::CCRTAllocator>(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __fastcall ~CTempBuffer<>(int *param_1)

{
  if ((int *)*param_1 != param_1 + 1) {
    FreeHeap(param_1);
  }
  return;
}



// Function: ~CTempBuffer<> at 10016d70

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall ATL::CTempBuffer<char,128,class
   ATL::CCRTAllocator>::~CTempBuffer<char,128,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::~CTempBuffer<unsigned char,128,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<wchar_t,10,class
   ATL::CCRTAllocator>::~CTempBuffer<wchar_t,10,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<wchar_t,128,class
   ATL::CCRTAllocator>::~CTempBuffer<wchar_t,128,class ATL::CCRTAllocator>(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __fastcall ~CTempBuffer<>(int *param_1)

{
  if ((int *)*param_1 != param_1 + 1) {
    FreeHeap(param_1);
  }
  return;
}



// Function: ~CTempBuffer<> at 10016d90

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall ATL::CTempBuffer<char,128,class
   ATL::CCRTAllocator>::~CTempBuffer<char,128,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::~CTempBuffer<unsigned char,128,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<wchar_t,10,class
   ATL::CCRTAllocator>::~CTempBuffer<wchar_t,10,class ATL::CCRTAllocator>(void)
    public: __thiscall ATL::CTempBuffer<wchar_t,128,class
   ATL::CCRTAllocator>::~CTempBuffer<wchar_t,128,class ATL::CCRTAllocator>(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __fastcall ~CTempBuffer<>(int *param_1)

{
  if ((int *)*param_1 != param_1 + 1) {
    FreeHeap(param_1);
  }
  return;
}



// Function: FUN_10016db0 at 10016db0

void __fastcall FUN_10016db0(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c11b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  FUN_1001dc40(param_1);
  local_8 = 0xffffffff;
  FUN_100170d0();
  ExceptionList = local_10;
  return;
}



// Function: FUN_10016e10 at 10016e10

void __fastcall FUN_10016e10(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c14b;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *param_1 = ATL::CComClassFactory::vftable;
  local_8 = 0xffffffff;
  ~_ExceptionPtr_static<>((int)(param_1 + 1));
  ExceptionList = local_10;
  return;
}



// Function: FUN_10016e70 at 10016e70

void __fastcall FUN_10016e70(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c178;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *param_1 = ATL::CComModule::vftable;
  local_8 = 0xffffffff;
  FID_conflict__bad_alloc((int)param_1);
  ExceptionList = local_10;
  return;
}



// Function: FID_conflict:~CAtlWinModule at 10016ed0

/* Library Function - Multiple Matches With Different Base Names
    public: __thiscall ATL::CAtlWinModule::~CAtlWinModule(void)
    public: __thiscall CPaneContainerGC::~CPaneContainerGC(void)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2010 Debug */

void __fastcall FID_conflict__CAtlWinModule(int *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c1a8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  FUN_10019f00(param_1);
  local_8 = 0xffffffff;
  FUN_10016d30(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10016f30 at 10016f30

void FUN_10016f30(void)

{
  return;
}



// Function: FUN_10016f40 at 10016f40

void __fastcall FUN_10016f40(int param_1)

{
  CoTaskMemFree(*(LPVOID *)(param_1 + 8));
  return;
}



// Function: FUN_10016f60 at 10016f60

void __fastcall FUN_10016f60(CRegKey *param_1)

{
  ATL::CRegKey::Close(param_1);
  return;
}



// Function: FUN_10016f80 at 10016f80

void __fastcall FUN_10016f80(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c1db;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *param_1 = ATL::CRegObject::vftable;
  local_8 = 0;
  FUN_10019f80((int)param_1);
  local_8 = 0xffffffff;
  FID_conflict__CAtlWinModule(param_1 + 1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10016fe0 at 10016fe0

void __fastcall FUN_10016fe0(int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002c27f;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8._0_1_ = 9;
  local_8._1_3_ = 0;
  FUN_1000f220((int *)(param_1 + 0xb4));
  local_8._0_1_ = 8;
  FUN_1000f220((int *)(param_1 + 0xa4));
  local_8._0_1_ = 7;
  FID_conflict__CAtlWinModule((LPCRITICAL_SECTION)(param_1 + 0x74));
  local_8._0_1_ = 6;
  FUN_1000eea0((int *)(param_1 + 0x70));
  local_8._0_1_ = 5;
  FUN_1000ee60((int *)(param_1 + 0x6c));
  local_8._0_1_ = 4;
  FUN_1000f220((int *)(param_1 + 0x68));
  local_8._0_1_ = 3;
  FUN_1000f220((int *)(param_1 + 100));
  local_8._0_1_ = 2;
  FUN_1000efc0((_Container_base0 *)(param_1 + 0x58));
  local_8._0_1_ = 1;
  FUN_1000efa0((_Container_base0 *)(param_1 + 0x4c));
  local_8 = (uint)local_8._1_3_ << 8;
  FUN_1000f220((int *)(param_1 + 0x34));
  local_8 = 0xffffffff;
  ~_ExceptionPtr_static<>(param_1 + 0x14);
  ExceptionList = local_10;
  return;
}



// Function: FUN_100170d0 at 100170d0

void FUN_100170d0(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c2ab;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  FUN_10002060();
  ExceptionList = local_10;
  return;
}



// Function: FUN_10017120 at 10017120

bool __fastcall FUN_10017120(int *param_1)

{
  return *param_1 == 0;
}



// Function: FUN_10017150 at 10017150

void __fastcall FUN_10017150(int *param_1)

{
  FUN_10017120(param_1);
  return;
}



// Function: FUN_10017170 at 10017170

bool __fastcall FUN_10017170(int *param_1)

{
  char cVar1;
  
  cVar1 = FUN_10017150(param_1);
  return cVar1 == '\0';
}



// Function: FUN_100171b0 at 100171b0

undefined4 __fastcall FUN_100171b0(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_100171c0 at 100171c0

undefined4 __fastcall FUN_100171c0(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_100171d0 at 100171d0

undefined4 __fastcall FUN_100171d0(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_100171e0 at 100171e0

undefined4 __fastcall FUN_100171e0(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_100171f0 at 100171f0

undefined4 __fastcall FUN_100171f0(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_10017200 at 10017200

undefined4 __fastcall FUN_10017200(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_10017210 at 10017210

undefined4 __fastcall FUN_10017210(undefined4 *param_1)

{
  return *param_1;
}



// Function: FUN_10017220 at 10017220

undefined4 __fastcall FUN_10017220(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_10017230 at 10017230

undefined4 __fastcall FUN_10017230(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_10017240 at 10017240

void __fastcall FUN_10017240(int param_1)

{
  FUN_100169b0(param_1 + 0x34);
  FUN_10016d20();
  FUN_100269c0((undefined4 *)(param_1 + 0x34));
  return;
}



// Function: FUN_10017270 at 10017270

void __fastcall FUN_10017270(int param_1)

{
  FUN_10016b10(param_1 + 0x34);
  FUN_10016d20();
  FUN_100269c0((undefined4 *)(param_1 + 0x34));
  return;
}



// Function: FID_conflict:`vbase_destructor' at 100172a0

/* Library Function - Multiple Matches With Different Base Names
    public: void __thiscall std::basic_ostream<char,struct std::char_traits<char> >::`vbase
   destructor'(void)
    public: void __thiscall std::basic_ostream<unsigned short,struct std::char_traits<unsigned
   short> >::`vbase destructor'(void)
    public: void __thiscall std::basic_ostream<wchar_t,struct std::char_traits<wchar_t> >::`vbase
   destructor'(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug */

void __fastcall FID_conflict__vbase_destructor_(int param_1)

{
  FUN_10016d20();
  FUN_100269c0((undefined4 *)(param_1 + 4));
  return;
}



// Function: FUN_100172d0 at 100172d0

void __fastcall FUN_100172d0(int param_1)

{
  FUN_10016f30();
  FUN_10016d20();
  FUN_100269c0((undefined4 *)(param_1 + 0xc));
  return;
}



// Function: FUN_100172fc at 100172fc

void __thiscall FUN_100172fc(void *this,uint param_1)

{
  FUN_10017350((void *)((int)this - *(int *)((int)this + -4)),param_1);
  return;
}



// Function: FUN_10017304 at 10017304

void __thiscall FUN_10017304(void *this,uint param_1)

{
  FUN_100173c0((void *)((int)this - *(int *)((int)this + -4)),param_1);
  return;
}



// Function: FUN_1001730c at 1001730c

void __thiscall FUN_1001730c(void *this,uint param_1)

{
  std::basic_iostream<char,struct_std::char_traits<char>_>::_scalar_deleting_destructor_
            ((basic_iostream<char,struct_std::char_traits<char>_> *)
             ((int)this - *(int *)((int)this + -4)),param_1);
  return;
}



// Function: FUN_10017320 at 10017320

undefined4 * __thiscall FUN_10017320(void *this,uint param_1)

{
  FUN_10016920((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_10017350 at 10017350

int __thiscall FUN_10017350(void *this,uint param_1)

{
  FUN_10017240((int)this + -0x34);
  if ((param_1 & 1) != 0) {
    operator_delete((void *)((int)this + -0x34));
  }
  return (int)this + -0x34;
}



// Function: FUN_10017390 at 10017390

undefined4 * __thiscall FUN_10017390(void *this,uint param_1)

{
  FUN_10016a60((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_100173c0 at 100173c0

int __thiscall FUN_100173c0(void *this,uint param_1)

{
  FUN_10017270((int)this + -0x34);
  if ((param_1 & 1) != 0) {
    operator_delete((void *)((int)this + -0x34));
  }
  return (int)this + -0x34;
}



// Function: FUN_10017400 at 10017400

undefined4 * __thiscall FUN_10017400(void *this,uint param_1)

{
  FUN_10016bb0((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FID_conflict:`scalar_deleting_destructor' at 10017430

/* Library Function - Multiple Matches With Different Base Names
    public: virtual void * __thiscall std::basic_ostream<char,struct std::char_traits<char>
   >::`scalar deleting destructor'(unsigned int)
    public: virtual void * __thiscall std::basic_ostream<unsigned short,struct
   std::char_traits<unsigned short> >::`scalar deleting destructor'(unsigned int)
    public: virtual void * __thiscall std::basic_ostream<wchar_t,struct std::char_traits<wchar_t>
   >::`scalar deleting destructor'(unsigned int)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug */

int __thiscall FID_conflict__scalar_deleting_destructor_(void *this,uint param_1)

{
  FID_conflict__vbase_destructor_((int)this + -4);
  if ((param_1 & 1) != 0) {
    operator_delete((void *)((int)this + -4));
  }
  return (int)this + -4;
}



// Function: FUN_10017470 at 10017470

undefined4 * __thiscall FUN_10017470(void *this,uint param_1)

{
  FUN_10016e10((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_100174a0 at 100174a0

undefined4 * __thiscall FUN_100174a0(void *this,uint param_1)

{
  FUN_10016e70((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: `scalar_deleting_destructor' at 100174d0

/* Library Function - Single Match
    public: virtual void * __thiscall std::basic_iostream<char,struct std::char_traits<char>
   >::`scalar deleting destructor'(unsigned int)
   
   Library: Visual Studio 2003 Debug */

void * __thiscall
std::basic_iostream<char,struct_std::char_traits<char>_>::_scalar_deleting_destructor_
          (basic_iostream<char,struct_std::char_traits<char>_> *this,uint param_1)

{
  FUN_100172d0((int)(this + -0xc));
  if ((param_1 & 1) != 0) {
    operator_delete(this + -0xc);
  }
  return this + -0xc;
}



// Function: FUN_10017510 at 10017510

undefined4 * __thiscall FUN_10017510(void *this,uint param_1)

{
  FUN_10016f80((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_10017540 at 10017540

undefined4 __thiscall FUN_10017540(void *this,undefined4 *param_1,undefined4 *param_2)

{
  void *pvVar1;
  undefined4 uVar2;
  
                    /* WARNING: Load size is inaccurate */
  pvVar1 = _recalloc(*this,*(int *)((int)this + 8) + 1,4);
  if (pvVar1 == (void *)0x0) {
    uVar2 = 0;
  }
  else {
    *(void **)this = pvVar1;
    pvVar1 = _recalloc(*(void **)((int)this + 4),*(int *)((int)this + 8) + 1,4);
    if (pvVar1 == (void *)0x0) {
      uVar2 = 0;
    }
    else {
      *(void **)((int)this + 4) = pvVar1;
      FUN_1001afd0(this,*(int *)((int)this + 8),param_1,param_2);
      *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1;
      uVar2 = 1;
    }
  }
  return uVar2;
}



// Function: FUN_100175e0 at 100175e0

undefined4 __thiscall FUN_100175e0(void *this,char *param_1,wchar_t *param_2)

{
  undefined4 uVar1;
  size_t sVar2;
  int iVar3;
  undefined4 local_2c;
  undefined4 local_28;
  uint local_24;
  uint local_20;
  int local_1c;
  void *local_18;
  void *local_14;
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c2e0;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if ((param_1 == (char *)0x0) || (param_2 == (wchar_t *)0x0)) {
    uVar1 = 0;
  }
  else {
    local_1c = 0;
    sVar2 = strlen(param_1);
    local_20 = sVar2 + 1;
    local_18 = (void *)0x0;
    local_18 = (void *)FUN_10028fd6(local_20);
    FUN_10015cf0(&local_2c);
    local_8 = 0;
    FUN_10019da0(&local_2c,local_18);
    sVar2 = FUN_10015140(param_2);
    local_24 = sVar2 * 2 + 2;
    local_14 = (void *)0x0;
    local_14 = (void *)FUN_10028fd6(-(uint)((int)((ulonglong)local_24 * 2 >> 0x20) != 0) |
                                    (uint)((ulonglong)local_24 * 2));
    FUN_10015d10(&local_28);
    local_8 = CONCAT31(local_8._1_3_,1);
    FUN_10019dc0(&local_28,local_14);
    if ((local_18 == (void *)0x0) || (local_14 == (void *)0x0)) {
      local_1c = -0x7ff8fff2;
    }
    else {
      FUN_1001ee20(local_18,local_20,param_1,local_20);
      FUN_1001ee20(local_14,local_24,param_2,local_24);
      iVar3 = FUN_10017540(this,&local_18,&local_14);
      if (iVar3 == 0) {
        local_1c = -0x7ff8fff2;
      }
    }
    if (-1 < local_1c) {
      detach(&local_2c);
      detach(&local_28);
    }
    local_8 = local_8 & 0xffffff00;
    FUN_10016900(&local_28);
    local_8 = 0xffffffff;
    uVar1 = 0x10017781;
    FUN_100168e0(&local_2c);
  }
  ExceptionList = local_10;
  return uVar1;
}



// Function: FUN_100177a0 at 100177a0

void __thiscall FUN_100177a0(void *this,LPCSTR param_1)

{
  LPSTR pCVar1;
  
  pCVar1 = CharNextA(param_1);
  FUN_10018550(this,param_1,(int)pCVar1 - (int)param_1);
  return;
}



// Function: FUN_100177d0 at 100177d0

void FUN_100177d0(int *param_1)

{
  undefined **ppuVar1;
  
  ppuVar1 = FUN_1001a960();
  (**(code **)(*param_1 + 0xc))(param_1,L"APPID",ppuVar1);
  return;
}



// Function: FUN_10017800 at 10017800

void FUN_10017800(int param_1)

{
  FUN_10012220((LONG *)(param_1 + 4));
  return;
}



// Function: FUN_10017820 at 10017820

void FUN_10017820(int param_1)

{
  FUN_100128f0((undefined4 *)(param_1 + 0x14));
  return;
}



// Function: FUN_10017832 at 10017832

void FUN_10017832(int param_1)

{
  FUN_10017820(param_1 + -4);
  return;
}



// Function: FUN_1001783c at 1001783c

void FUN_1001783c(int param_1)

{
  FUN_10017820(param_1 + -8);
  return;
}



// Function: FUN_10017846 at 10017846

void FUN_10017846(int param_1)

{
  FUN_10017820(param_1 + -0x10);
  return;
}



// Function: FUN_10017850 at 10017850

void FUN_10017850(int param_1)

{
  FUN_10017820(param_1 + -0xc);
  return;
}



// Function: FUN_10017860 at 10017860

void FUN_10017860(int param_1)

{
  FUN_10012200((LONG *)(param_1 + 0x14));
  return;
}



// Function: FUN_10017872 at 10017872

void FUN_10017872(int param_1)

{
  FUN_10017860(param_1 + -4);
  return;
}



// Function: FUN_1001787c at 1001787c

void FUN_1001787c(int param_1)

{
  FUN_10017860(param_1 + -8);
  return;
}



// Function: FUN_10017886 at 10017886

void FUN_10017886(int param_1)

{
  FUN_10017860(param_1 + -0x10);
  return;
}



// Function: FUN_10017890 at 10017890

void FUN_10017890(int param_1)

{
  FUN_10017860(param_1 + -0xc);
  return;
}



// Function: FUN_100178a0 at 100178a0

int FUN_100178a0(int param_1)

{
  int iVar1;
  
  iVar1 = FUN_10012200((LONG *)(param_1 + 4));
  if (iVar1 == 2) {
    (**(code **)(*DAT_100403a8 + 4))();
  }
  return iVar1;
}



// Function: FUN_100178e0 at 100178e0

int FUN_100178e0(int param_1)

{
  int iVar1;
  
  iVar1 = FUN_10012200((LONG *)(param_1 + 4));
  if (iVar1 == 2) {
    (**(code **)(*DAT_100403a8 + 4))();
  }
  return iVar1;
}



// Function: FUN_10017920 at 10017920

undefined4 FUN_10017920(void)

{
  return 1;
}



// Function: FUN_10017930 at 10017930

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_10017930(int param_1,wchar_t *param_2,wchar_t *param_3)

{
  char cVar1;
  size_t sVar2;
  long lVar3;
  uint local_4c;
  undefined4 local_48;
  UINT local_44;
  int local_40;
  undefined4 local_3c;
  undefined1 *local_38;
  undefined4 local_34;
  LPSTR local_30;
  LPSTR local_2c;
  char *local_28;
  char *local_24;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_20 [4];
  wchar_t *local_1c;
  ulong local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c308;
  local_10 = ExceptionList;
  local_4c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_14 = local_4c;
  if ((param_2 != (wchar_t *)0x0) && (param_3 != (wchar_t *)0x0)) {
    FUN_1001b180();
    local_44 = FUN_10012f50();
    FUN_1000d590((undefined4 *)local_20);
    local_8 = 0;
    local_1c = param_2;
    if (param_2 == (wchar_t *)0x0) {
      local_28 = (char *)0x0;
    }
    else {
      sVar2 = wcslen(param_2);
      local_18 = sVar2 + 1;
      lVar3 = ATL::AtlMultiply<int>((int *)&local_18,local_18,2);
      if (lVar3 < 0) {
        local_30 = (LPSTR)0x0;
      }
      else {
        if (((int)local_18 < 0x401) && (cVar1 = FUN_10012fe0(local_18), cVar1 != '\0')) {
          local_38 = (undefined1 *)&local_4c;
          local_2c = (LPSTR)&local_4c;
        }
        else {
          local_2c = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                            CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                      (local_20,local_18);
        }
        local_30 = FUN_10019d50(local_2c,local_1c,local_18,local_44);
      }
      local_28 = local_30;
    }
    local_24 = local_28;
    if (local_28 == (char *)0x0) {
      local_3c = 0x8007000e;
      local_8 = 0xffffffff;
      ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
      ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
    }
    else {
      local_40 = FUN_100175e0((void *)(param_1 + 4),local_28,param_3);
      FUN_1001dd80();
      if (local_40 == 0) {
        local_34 = 0x8007000e;
      }
      else {
        local_34 = 0;
      }
      local_48 = local_34;
      local_8 = 0xffffffff;
      ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
      ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
    }
  }
  ExceptionList = local_10;
  local_4c = 0x10017ac4;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10017ad0 at 10017ad0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void __thiscall FUN_10017ad0(void *this,wchar_t *param_1)

{
  char cVar1;
  long lVar2;
  size_t sVar3;
  uint local_48;
  undefined4 local_44;
  undefined1 *local_40;
  void *local_3c;
  undefined4 local_38;
  UINT local_34;
  char *local_30;
  LPSTR local_2c;
  LPSTR local_28;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_24 [4];
  char *local_20;
  wchar_t *local_1c;
  ulong local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c338;
  local_10 = ExceptionList;
  local_48 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_3c = this;
  local_14 = local_48;
  if (param_1 != (wchar_t *)0x0) {
    local_34 = FUN_10012f50();
    FUN_1000d590((undefined4 *)local_24);
    local_8 = 0;
    local_1c = param_1;
    if (param_1 == (wchar_t *)0x0) {
      local_30 = (char *)0x0;
    }
    else {
      sVar3 = wcslen(param_1);
      local_18 = sVar3 + 1;
      lVar2 = ATL::AtlMultiply<int>((int *)&local_18,local_18,2);
      if (lVar2 < 0) {
        local_28 = (LPSTR)0x0;
      }
      else {
        if (((int)local_18 < 0x401) && (cVar1 = FUN_10012fe0(local_18), cVar1 != '\0')) {
          local_40 = (undefined1 *)&local_48;
          local_2c = (LPSTR)&local_48;
        }
        else {
          local_2c = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                            CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                      (local_24,local_18);
        }
        local_28 = FUN_10019d50(local_2c,local_1c,local_18,local_34);
      }
      local_30 = local_28;
    }
    local_20 = local_30;
    if (local_30 == (char *)0x0) {
      local_38 = 0;
      local_8 = 0xffffffff;
      ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
      ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_24);
    }
    else {
      sVar3 = strlen(local_30);
      local_44 = FUN_10018550(local_3c,local_20,sVar3);
      local_8 = 0xffffffff;
      ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
      ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_24);
    }
  }
  ExceptionList = local_10;
  local_48 = 0x10017c32;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10017c40 at 10017c40

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */
/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void __thiscall FUN_10017c40(void *this,void *param_1,LPCSTR param_2,undefined1 *param_3)

{
  char cVar1;
  int iVar2;
  UINT UVar3;
  size_t sVar4;
  long lVar5;
  uint uStack_1298;
  undefined1 auStack_1274 [4];
  LPWSTR pWStack_1270;
  LPWSTR pWStack_1268;
  LPWSTR pWStack_1264;
  LPWSTR pWStack_1260;
  BYTE *pBStack_1258;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> aCStack_1254 [4];
  size_t sStack_1250;
  uint uStack_124c;
  uint local_1248;
  uint local_1244;
  ushort local_1240 [2];
  undefined4 *local_123c;
  ulong local_1234;
  ulong uStack_1230;
  int local_122c;
  undefined4 local_1220 [65];
  undefined4 auStack_111c [65];
  BYTE local_1018 [4096];
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c381;
  local_10 = ExceptionList;
  uStack_1298 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_1298;
  ExceptionList = &local_10;
  local_1240[0] = 0;
  local_1234 = 0;
  local_123c = (undefined4 *)this;
  local_18 = uStack_1298;
  local_122c = FUN_1001b250(this,local_1018);
  if (-1 < local_122c) {
    iVar2 = FUN_1001ebd0((LPCSTR)local_1018,local_1240);
    if (iVar2 == 0) {
      FUN_1001a940();
    }
    else {
      FUN_1001db70(local_123c);
      local_122c = FUN_1001b250(local_123c,local_1018);
      if (-1 < local_122c) {
        local_1244 = (uint)local_1240[0];
        if (local_1244 < 0x14) {
          if (local_1244 == 0x13) {
            UVar3 = FUN_10012f50();
            FUN_1000d590((undefined4 *)aCStack_1254);
            local_8 = 3;
            pBStack_1258 = local_1018;
            if (pBStack_1258 == (BYTE *)0x0) {
              pWStack_1264 = (LPWSTR)0x0;
            }
            else {
              sVar4 = strlen((char *)pBStack_1258);
              uStack_1230 = sVar4 + 1;
              lVar5 = ATL::AtlMultiply<int>((int *)&uStack_1230,uStack_1230,2);
              if (lVar5 < 0) {
                pWStack_1270 = (LPWSTR)0x0;
              }
              else {
                if (((int)uStack_1230 < 0x401) && (cVar1 = FUN_10012fe0(uStack_1230), cVar1 != '\0')
                   ) {
                  pWStack_1268 = (LPWSTR)&uStack_1298;
                  local_14 = (undefined1 *)&uStack_1298;
                }
                else {
                  pWStack_1268 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                         CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
                                         Allocate(aCStack_1254,uStack_1230);
                }
                pWStack_1270 = FUN_100107c0(pWStack_1268,(LPCSTR)pBStack_1258,uStack_1230 >> 1,UVar3
                                           );
              }
              pWStack_1264 = pWStack_1270;
            }
            pWStack_1260 = pWStack_1264;
            if (pWStack_1264 == (LPWSTR)0x0) {
              local_8 = 0xffffffff;
              ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
              ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(aCStack_1254);
              goto LAB_10018313;
            }
            Ordinal_277(pWStack_1264,0,0,auStack_1274);
            local_1234 = FUN_1001d930(param_1,param_2);
            local_8 = 0xffffffff;
            ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
            ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(aCStack_1254);
          }
          else if (local_1244 == 8) {
            local_1234 = FUN_1001da00(param_1,param_2,local_1018,1);
          }
          else if (local_1244 == 0x11) {
            sStack_1250 = strlen((char *)local_1018);
            if ((sStack_1250 & 1) == 0) {
              uStack_124c = (int)sStack_1250 / 2;
              FUN_10016320(auStack_111c);
              local_8 = 5;
              Allocate(auStack_111c,uStack_124c);
              FUN_10018192();
              return;
            }
            goto LAB_10018313;
          }
        }
        else if (local_1244 == 0x4008) {
          sVar4 = strlen((char *)local_1018);
          local_1248 = sVar4 + 2;
          FUN_100162e0(local_1220);
          local_8 = 1;
          Allocate(local_1220,local_1248);
          FUN_10017de2();
          return;
        }
        if (local_1234 == 0) {
          local_122c = FUN_1001b250(local_123c,param_3);
        }
        else {
          FUN_10018bc0(local_1234);
        }
      }
    }
  }
LAB_10018313:
  ExceptionList = local_10;
  __security_check_cookie(local_18 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: Catch@10017ddc at 10017ddc

undefined * Catch_10017ddc(void)

{
  return &DAT_10017deb;
}



// Function: FUN_10017de2 at 10017de2

/* WARNING: Unable to track spacebase fully for stack */

void FUN_10017de2(void)

{
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  LPSTR pCVar4;
  BOOL BVar5;
  BYTE *pBVar6;
  LSTATUS LVar7;
  uint unaff_EBP;
  
  *(undefined4 *)(unaff_EBP - 4) = 0;
  iVar2 = FUN_100171c0((undefined4 *)(unaff_EBP - 0x121c));
  if (iVar2 == 0) {
    *(undefined4 *)(unaff_EBP - 0x1230) = 0xe;
  }
  else {
    uVar3 = FUN_100171c0((undefined4 *)(unaff_EBP - 0x121c));
    *(undefined4 *)(unaff_EBP - 0x1220) = uVar3;
    *(uint *)(unaff_EBP - 0x1224) = unaff_EBP - 0x1014;
    *(undefined4 *)(unaff_EBP - 0x1244) = 0;
    while (**(char **)(unaff_EBP - 0x1224) != '\0') {
      pCVar4 = CharNextA(*(LPCSTR *)(unaff_EBP - 0x1224));
      *(LPSTR *)(unaff_EBP - 0x1258) = pCVar4;
      if ((**(char **)(unaff_EBP - 0x1224) == '\\') && (**(char **)(unaff_EBP - 0x1258) == '0')) {
        **(undefined1 **)(unaff_EBP - 0x1220) = 0;
        *(int *)(unaff_EBP - 0x1220) = *(int *)(unaff_EBP - 0x1220) + 1;
        pCVar4 = CharNextA(*(LPCSTR *)(unaff_EBP - 0x1258));
        *(LPSTR *)(unaff_EBP - 0x1224) = pCVar4;
      }
      else {
        **(undefined1 **)(unaff_EBP - 0x1220) = **(undefined1 **)(unaff_EBP - 0x1224);
        BVar5 = IsDBCSLeadByte(**(BYTE **)(unaff_EBP - 0x1224));
        if (BVar5 != 0) {
          *(int *)(unaff_EBP - 0x1220) = *(int *)(unaff_EBP - 0x1220) + 1;
          *(int *)(unaff_EBP - 0x1224) = *(int *)(unaff_EBP - 0x1224) + 1;
          if (**(char **)(unaff_EBP - 0x1224) == '\0') break;
          **(undefined1 **)(unaff_EBP - 0x1220) = **(undefined1 **)(unaff_EBP - 0x1224);
        }
        *(int *)(unaff_EBP - 0x1220) = *(int *)(unaff_EBP - 0x1220) + 1;
        *(int *)(unaff_EBP - 0x1224) = *(int *)(unaff_EBP - 0x1224) + 1;
      }
      *(int *)(unaff_EBP - 0x1244) = *(int *)(unaff_EBP - 0x1244) + 1;
    }
    **(undefined1 **)(unaff_EBP - 0x1220) = 0;
    *(int *)(unaff_EBP - 0x1220) = *(int *)(unaff_EBP - 0x1220) + 1;
    **(undefined1 **)(unaff_EBP - 0x1220) = 0;
    pBVar6 = (BYTE *)FUN_100171c0((undefined4 *)(unaff_EBP - 0x121c));
    LVar7 = FUN_1001d960(*(void **)(unaff_EBP + 8),*(LPCSTR *)(unaff_EBP + 0xc),pBVar6);
    *(LSTATUS *)(unaff_EBP - 0x1230) = LVar7;
  }
  *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
  ~CTempBuffer<>((int *)(unaff_EBP - 0x121c));
  if (*(int *)(unaff_EBP - 0x1230) == 0) {
    uVar3 = FUN_1001b250(*(void **)(unaff_EBP - 0x1238),*(undefined1 **)(unaff_EBP + 0x10));
    *(undefined4 *)(unaff_EBP - 0x1228) = uVar3;
  }
  else {
    *(undefined4 *)(unaff_EBP - 0x1280) = 0x204;
    FUN_10018bc0(*(ulong *)(unaff_EBP - 0x1230));
  }
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uVar1 = *(uint *)(unaff_EBP - 0x14);
  *(undefined4 *)(unaff_EBP - 0x1288) = 0x10018331;
  __security_check_cookie(uVar1 ^ unaff_EBP);
  return;
}



// Function: Catch@1001818c at 1001818c

undefined * Catch_1001818c(void)

{
  return &DAT_1001819b;
}



// Function: FUN_10018192 at 10018192

/* WARNING: Unable to track spacebase fully for stack */

void FUN_10018192(void)

{
  int iVar1;
  void *_Dst;
  uint uVar2;
  BYTE *lpData;
  HKEY hKey;
  LSTATUS LVar3;
  undefined4 uVar4;
  uint unaff_EBP;
  LPCSTR lpValueName;
  DWORD Reserved;
  DWORD dwType;
  size_t _Size;
  DWORD cbData;
  
  *(undefined4 *)(unaff_EBP - 4) = 4;
  iVar1 = FUN_100171e0((undefined4 *)(unaff_EBP - 0x1118));
  if (iVar1 == 0) {
    *(undefined4 *)(unaff_EBP - 0x1278) = 0x80004005;
    *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
    ~CTempBuffer<>((int *)(unaff_EBP - 0x1118));
  }
  else {
    _Size = *(size_t *)(unaff_EBP - 0x1248);
    iVar1 = 0;
    _Dst = (void *)FUN_100171e0((undefined4 *)(unaff_EBP - 0x1118));
    memset(_Dst,iVar1,_Size);
    *(undefined4 *)(unaff_EBP - 0x1234) = 0;
    while (*(int *)(unaff_EBP - 0x1234) < *(int *)(unaff_EBP - 0x124c)) {
      iVar1 = FUN_100171e0((undefined4 *)(unaff_EBP - 0x1118));
      *(int *)(unaff_EBP - 0x1268) = iVar1 + *(int *)(unaff_EBP - 0x1234) / 2;
      uVar2 = FUN_10019e60(*(char *)((unaff_EBP - 0x1014) + *(int *)(unaff_EBP - 0x1234)));
      **(byte **)(unaff_EBP - 0x1268) =
           **(byte **)(unaff_EBP - 0x1268) |
           (byte)((uVar2 & 0xff) <<
                 (('\x01' - ((byte)*(undefined4 *)(unaff_EBP - 0x1234) & 1)) * '\x04' & 0x1f));
      *(int *)(unaff_EBP - 0x1234) = *(int *)(unaff_EBP - 0x1234) + 1;
    }
    cbData = *(DWORD *)(unaff_EBP - 0x1248);
    lpData = (BYTE *)FUN_100171e0((undefined4 *)(unaff_EBP - 0x1118));
    dwType = 3;
    Reserved = 0;
    lpValueName = *(LPCSTR *)(unaff_EBP + 0xc);
    hKey = (HKEY)FUN_100171f0(*(undefined4 **)(unaff_EBP + 8));
    LVar3 = RegSetValueExA(hKey,lpValueName,Reserved,dwType,lpData,cbData);
    *(LSTATUS *)(unaff_EBP - 0x1230) = LVar3;
    *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
    ~CTempBuffer<>((int *)(unaff_EBP - 0x1118));
    if (*(int *)(unaff_EBP - 0x1230) == 0) {
      uVar4 = FUN_1001b250(*(void **)(unaff_EBP - 0x1238),*(undefined1 **)(unaff_EBP + 0x10));
      *(undefined4 *)(unaff_EBP - 0x1228) = uVar4;
    }
    else {
      *(undefined4 *)(unaff_EBP - 0x1280) = 0x204;
      FUN_10018bc0(*(ulong *)(unaff_EBP - 0x1230));
    }
  }
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uVar2 = *(uint *)(unaff_EBP - 0x14);
  *(undefined4 *)(unaff_EBP - 0x1288) = 0x10018331;
  __security_check_cookie(uVar2 ^ unaff_EBP);
  return;
}



// Function: Allocate at 10018340

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall ATL::CTempBuffer<char,128,class ATL::CCRTAllocator>::Allocate(unsigned
   int)
    public: unsigned char * __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::Allocate(unsigned int)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void __thiscall Allocate(void *this,uint param_1)

{
  uint uVar1;
  
  uVar1 = ATL::AtlMultiplyThrow<unsigned_int>(param_1,1);
  FUN_100183d0(this,uVar1);
  return;
}



// Function: Allocate at 10018370

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall ATL::CTempBuffer<char,128,class ATL::CCRTAllocator>::Allocate(unsigned
   int)
    public: unsigned char * __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::Allocate(unsigned int)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void __thiscall Allocate(void *this,uint param_1)

{
  uint uVar1;
  
  uVar1 = ATL::AtlMultiplyThrow<unsigned_int>(param_1,1);
  FUN_10018410(this,uVar1);
  return;
}



// Function: Allocate at 100183a0

/* Library Function - Multiple Matches With Same Base Name
    public: char * __thiscall ATL::CTempBuffer<char,128,class ATL::CCRTAllocator>::Allocate(unsigned
   int)
    public: unsigned char * __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::Allocate(unsigned int)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void __thiscall Allocate(void *this,uint param_1)

{
  uint uVar1;
  
  uVar1 = ATL::AtlMultiplyThrow<unsigned_int>(param_1,1);
  FUN_10018450(this,uVar1);
  return;
}



// Function: FUN_100183d0 at 100183d0

undefined4 __thiscall FUN_100183d0(void *this,uint param_1)

{
  if (param_1 < 0x101) {
    *(int *)this = (int)this + 4;
  }
  else {
    AllocateHeap(this,param_1);
  }
                    /* WARNING: Load size is inaccurate */
  return *this;
}



// Function: FUN_10018410 at 10018410

undefined4 __thiscall FUN_10018410(void *this,uint param_1)

{
  if (param_1 < 0x401) {
    *(int *)this = (int)this + 4;
  }
  else {
    AllocateHeap(this,param_1);
  }
                    /* WARNING: Load size is inaccurate */
  return *this;
}



// Function: FUN_10018450 at 10018450

undefined4 __thiscall FUN_10018450(void *this,uint param_1)

{
  if (param_1 < 0x101) {
    *(int *)this = (int)this + 4;
  }
  else {
    AllocateHeap(this,param_1);
  }
                    /* WARNING: Load size is inaccurate */
  return *this;
}



// Function: AllocateHeap at 10018490

/* Library Function - Multiple Matches With Same Base Name
    private: void __thiscall ATL::CTempBuffer<char,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<wchar_t,10,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<wchar_t,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __thiscall AllocateHeap(void *this,size_t param_1)

{
  int iVar1;
  
  iVar1 = FUN_100107a0(param_1);
  if (iVar1 == 0) {
    FUN_10010aa0(0x8007000e);
  }
  *(int *)this = iVar1;
  return;
}



// Function: AllocateHeap at 100184d0

/* Library Function - Multiple Matches With Same Base Name
    private: void __thiscall ATL::CTempBuffer<char,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<wchar_t,10,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<wchar_t,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __thiscall AllocateHeap(void *this,size_t param_1)

{
  int iVar1;
  
  iVar1 = FUN_100107a0(param_1);
  if (iVar1 == 0) {
    FUN_10010aa0(0x8007000e);
  }
  *(int *)this = iVar1;
  return;
}



// Function: AllocateHeap at 10018510

/* Library Function - Multiple Matches With Same Base Name
    private: void __thiscall ATL::CTempBuffer<char,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<wchar_t,10,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
    private: void __thiscall ATL::CTempBuffer<wchar_t,128,class
   ATL::CCRTAllocator>::AllocateHeap(unsigned int)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __thiscall AllocateHeap(void *this,size_t param_1)

{
  int iVar1;
  
  iVar1 = FUN_100107a0(param_1);
  if (iVar1 == 0) {
    FUN_10010aa0(0x8007000e);
  }
  *(int *)this = iVar1;
  return;
}



// Function: FUN_10018550 at 10018550

undefined4 __thiscall FUN_10018550(void *this,void *param_1,rsize_t param_2)

{
  int iVar1;
  undefined4 uVar2;
  LPVOID pvVar3;
  
                    /* WARNING: Load size is inaccurate */
  iVar1 = *this + 1 + param_2;
                    /* WARNING: Load size is inaccurate */
  if ((*this < iVar1) && ((int)param_2 < iVar1)) {
    if (*(int *)((int)this + 4) <= iVar1) {
      while (*(int *)((int)this + 4) <= iVar1) {
        if (0x3fffffff < *(int *)((int)this + 4)) {
          return 0;
        }
        *(int *)((int)this + 4) = *(int *)((int)this + 4) << 1;
      }
      pvVar3 = FUN_10018720(*(LPVOID *)((int)this + 8),*(uint *)((int)this + 4),1);
      if (pvVar3 == (LPVOID)0x0) {
        return 0;
      }
      *(LPVOID *)((int)this + 8) = pvVar3;
    }
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
    if (((*this < 0) || (*(int *)((int)this + 4) <= *this)) ||
       (*(int *)((int)this + 4) < *(int *)((int)this + 4) - *this)) {
      uVar2 = 0;
    }
    else {
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
      FUN_1001ee20((void *)(*(int *)((int)this + 8) + *this),*(int *)((int)this + 4) - *this,param_1
                   ,param_2);
                    /* WARNING: Load size is inaccurate */
      *(rsize_t *)this = *this + param_2;
                    /* WARNING: Load size is inaccurate */
      *(undefined1 *)(*(int *)((int)this + 8) + *this) = 0;
      uVar2 = 1;
    }
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}



// Function: AtlCallTermFunc at 10018670

/* Library Function - Single Match
    void __stdcall ATL::AtlCallTermFunc(struct ATL::_ATL_MODULE70 *)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void ATL::AtlCallTermFunc(_ATL_MODULE70 *param_1)

{
  undefined4 *puVar1;
  undefined4 *local_8;
  
  if (param_1 == (_ATL_MODULE70 *)0x0) {
    _AtlRaiseException(0xc0000005,1);
  }
  local_8 = *(undefined4 **)(param_1 + 8);
  while (local_8 != (undefined4 *)0x0) {
    (*(code *)*local_8)(local_8[1]);
    puVar1 = (undefined4 *)local_8[2];
    operator_delete(local_8);
    local_8 = puVar1;
  }
  *(undefined4 *)(param_1 + 8) = 0;
  return;
}



// Function: AtlCoTaskMemCAlloc at 100186e0

/* Library Function - Single Match
    void * __cdecl ATL::AtlCoTaskMemCAlloc(unsigned long,unsigned long)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void * __cdecl ATL::AtlCoTaskMemCAlloc(ulong param_1,ulong param_2)

{
  HRESULT HVar1;
  void *pvVar2;
  SIZE_T local_8;
  
  local_8 = 0;
  HVar1 = AtlMultiply<>(&local_8,param_1,param_2);
  if (HVar1 < 0) {
    pvVar2 = (void *)0x0;
  }
  else {
    pvVar2 = CoTaskMemAlloc(local_8);
  }
  return pvVar2;
}



// Function: FUN_10018720 at 10018720

LPVOID __cdecl FUN_10018720(LPVOID param_1,uint param_2,uint param_3)

{
  HRESULT HVar1;
  LPVOID pvVar2;
  SIZE_T local_8;
  
  local_8 = 0;
  HVar1 = AtlMultiply<>(&local_8,param_2,param_3);
  if (HVar1 < 0) {
    pvVar2 = (LPVOID)0x0;
  }
  else {
    pvVar2 = CoTaskMemRealloc(param_1,local_8);
  }
  return pvVar2;
}



// Function: FUN_10018760 at 10018760

int FUN_10018760(int *param_1,int *param_2,undefined4 param_3,int *param_4)

{
  uint uVar1;
  int iVar2;
  PVOID pvVar3;
  CComCritSecLock<class_ATL::CComCriticalSection> local_30 [8];
  PVOID local_28;
  undefined4 *local_24;
  int *local_20;
  undefined4 *local_1c;
  int *local_18;
  int local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c3b8;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  if (param_4 == (int *)0x0) {
    local_14 = -0x7fffbffd;
  }
  else {
    *param_4 = 0;
    if (param_1 == (int *)0x0) {
      local_14 = -0x7ff8ffa9;
    }
    else if (*param_1 == 0) {
      local_14 = -0x7fff0001;
    }
    else {
      local_14 = 0;
      for (local_18 = (int *)param_1[2]; local_18 < (int *)param_1[3]; local_18 = local_18 + 1) {
        if (((*local_18 != 0) && (local_1c = (undefined4 *)*local_18, local_1c[2] != 0)) &&
           (iVar2 = FUN_100022c0(param_2,(int *)*local_1c), iVar2 != 0)) {
          local_20 = (int *)local_1c[4];
          if (*local_20 == 0) {
            ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
            CComCritSecLock<class_ATL::CComCriticalSection>
                      (local_30,(CComCriticalSection *)(param_1 + 4),false);
            local_8 = 0;
            local_14 = FUN_10012860((undefined4 *)local_30);
            if (local_14 < 0) {
              local_8 = 0xffffffff;
              ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
              ~CComCritSecLock<class_ATL::CComCriticalSection>(local_30);
              break;
            }
            if ((*local_20 == 0) &&
               (local_14 = (*(code *)local_1c[2])(local_1c[3],&DAT_1002f4c4,&local_28,uVar1),
               -1 < local_14)) {
              pvVar3 = EncodePointer(local_28);
              *local_20 = (int)pvVar3;
            }
            local_8 = 0xffffffff;
            ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
            ~CComCritSecLock<class_ATL::CComCriticalSection>(local_30);
          }
          if (*local_20 != 0) {
            local_24 = (undefined4 *)DecodePointer((PVOID)*local_20);
            local_14 = (**(code **)*local_24)(local_24,param_3,param_4);
          }
          break;
        }
      }
      if ((*param_4 == 0) && (local_14 == 0)) {
        local_14 = -0x7ffbfeef;
      }
    }
  }
  ExceptionList = local_10;
  return local_14;
}



// Function: FUN_10018920 at 10018920

int FUN_10018920(int param_1,int param_2,void *param_3)

{
  undefined4 *puVar1;
  bool bVar2;
  undefined3 extraout_var;
  int *piVar3;
  int iVar4;
  int *local_c;
  int local_8;
  
  if (param_1 == 0) {
    local_8 = -0x7ff8ffa9;
  }
  else {
    local_8 = 0;
    for (local_c = *(int **)(param_1 + 8); local_c < *(int **)(param_1 + 0xc); local_c = local_c + 1
        ) {
      if ((*local_c != 0) &&
         ((puVar1 = (undefined4 *)*local_c, param_3 == (void *)0x0 ||
          (bVar2 = FUN_1001ef60(param_3,(void *)*puVar1), CONCAT31(extraout_var,bVar2) != 0)))) {
        local_8 = (*(code *)puVar1[1])(1);
        if (local_8 < 0) break;
        iVar4 = 1;
        piVar3 = (int *)(*(code *)puVar1[6])();
        local_8 = FUN_10019280((GUID *)*puVar1,piVar3,iVar4);
        if (local_8 < 0) break;
      }
    }
    if ((-1 < local_8) && (param_2 != 0)) {
      local_8 = FUN_100198b0(*(HMODULE *)(param_1 + 4),(wchar_t *)0x0);
    }
  }
  return local_8;
}



// Function: FUN_100189f0 at 100189f0

int FUN_100189f0(int param_1,int param_2,void *param_3)

{
  undefined4 *puVar1;
  bool bVar2;
  undefined3 extraout_var;
  int *piVar3;
  int iVar4;
  int *local_c;
  int local_8;
  
  if (param_1 == 0) {
    local_8 = -0x7ff8ffa9;
  }
  else {
    local_8 = 0;
    for (local_c = *(int **)(param_1 + 8); local_c < *(int **)(param_1 + 0xc); local_c = local_c + 1
        ) {
      if ((*local_c != 0) &&
         ((puVar1 = (undefined4 *)*local_c, param_3 == (void *)0x0 ||
          (bVar2 = FUN_1001ef60(param_3,(void *)*puVar1), CONCAT31(extraout_var,bVar2) != 0)))) {
        iVar4 = 0;
        piVar3 = (int *)(*(code *)puVar1[6])();
        local_8 = FUN_10019280((GUID *)*puVar1,piVar3,iVar4);
        if ((local_8 < 0) || (local_8 = (*(code *)puVar1[1])(0), local_8 < 0)) break;
      }
    }
    if ((-1 < local_8) && (param_2 != 0)) {
      local_8 = FUN_10019bb0(*(HMODULE *)(param_1 + 4),(wchar_t *)0x0);
    }
  }
  return local_8;
}



// Function: AtlCrtErrorCheck at 10018ac0

/* Library Function - Single Match
    int __cdecl ATL::AtlCrtErrorCheck(int)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug, Visual
   Studio 2012 Debug */

int __cdecl ATL::AtlCrtErrorCheck(int param_1)

{
  switch(param_1) {
  case 0:
  case 0x50:
    break;
  default:
    FUN_10010aa0(0x80004005);
    break;
  case 0xc:
    FUN_10010aa0(0x8007000e);
    break;
  case 0x16:
  case 0x22:
    FUN_10010aa0(0x80070057);
  }
  return param_1;
}



// Function: FUN_10018b70 at 10018b70

undefined4 FUN_10018b70(undefined1 *param_1)

{
  undefined4 uVar1;
  
  if (param_1 == (undefined1 *)0x0) {
    uVar1 = 0x80004003;
  }
  else {
    *param_1 = DAT_100403cc;
    uVar1 = 0;
  }
  return uVar1;
}



// Function: FUN_10018ba0 at 10018ba0

void FUN_10018ba0(void)

{
  DWORD x;
  
  x = GetLastError();
  _HRESULT_FROM_WIN32(x);
  return;
}



// Function: FUN_10018bc0 at 10018bc0

void __cdecl FUN_10018bc0(ulong param_1)

{
  _HRESULT_FROM_WIN32(param_1);
  return;
}



// Function: FUN_10018be0 at 10018be0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_10018be0(HMODULE param_1,wchar_t *param_2,int *param_3,undefined4 *param_4)

{
  char cVar1;
  size_t sVar2;
  long lVar3;
  int iVar4;
  uint local_1b4;
  HRESULT local_1b0;
  undefined4 local_1ac;
  undefined4 local_1a8;
  undefined1 *local_1a4;
  int local_1a0;
  undefined4 local_19c;
  undefined4 local_198;
  undefined4 local_194;
  undefined1 *local_190;
  undefined4 local_18c;
  undefined4 local_188;
  undefined1 *local_184;
  LPSTR local_180;
  LPSTR local_17c;
  size_t local_178;
  LPWSTR local_174;
  LPWSTR local_170;
  LPWSTR local_16c;
  LPWSTR local_168;
  char *local_164;
  LPWSTR local_160;
  LPWSTR local_15c;
  uint local_158;
  char *local_154;
  wchar_t *local_150;
  UINT local_14c;
  LPCSTR local_148;
  int local_144;
  LPWSTR local_140;
  DWORD local_13c;
  char *local_138;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_134 [4];
  ulong local_130;
  CHAR local_12c [272];
  char local_1c [8];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c3eb;
  local_10 = ExceptionList;
  local_1b4 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_14 = local_1b4;
  if ((param_3 != (int *)0x0) && (param_4 != (undefined4 *)0x0)) {
    *param_3 = 0;
    *param_4 = 0;
    local_14c = FUN_10012f50();
    FUN_1000d590((undefined4 *)local_134);
    local_8 = 0;
    local_13c = GetModuleFileNameA(param_1,local_12c,0x104);
    if (local_13c == 0) {
      local_1a8 = FUN_10018ba0();
      local_8 = 0xffffffff;
      local_18c = local_1a8;
      ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
      ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_134);
    }
    else if (local_13c == 0x104) {
      local_1b0 = _HRESULT_FROM_WIN32(0x7a);
      local_8 = 0xffffffff;
      ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
      ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_134);
    }
    else {
      local_148 = (LPCSTR)0x0;
      local_148 = FUN_10015a60(local_12c);
      if (param_2 != (wchar_t *)0x0) {
        local_150 = param_2;
        if (param_2 == (wchar_t *)0x0) {
          local_164 = (char *)0x0;
        }
        else {
          sVar2 = wcslen(param_2);
          local_130 = sVar2 + 1;
          lVar3 = ATL::AtlMultiply<int>((int *)&local_130,local_130,2);
          if (lVar3 < 0) {
            local_180 = (LPSTR)0x0;
          }
          else {
            if (((int)local_130 < 0x401) && (cVar1 = FUN_10012fe0(local_130), cVar1 != '\0')) {
              local_184 = (undefined1 *)&local_1b4;
              local_17c = (LPSTR)&local_1b4;
            }
            else {
              local_17c = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                 CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                           (local_134,local_130);
            }
            local_180 = FUN_10019d50(local_17c,local_150,local_130,local_14c);
          }
          local_164 = local_180;
        }
        local_154 = local_164;
        if (local_164 == (char *)0x0) {
          local_1ac = 0x8007000e;
          local_8 = 0xffffffff;
          ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
          ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_134);
          goto LAB_1001925c;
        }
        local_178 = strlen(local_164);
        local_158 = local_13c + local_178;
        if (((local_158 < local_13c) || (local_158 < local_178)) || (0x10d < local_158)) {
          local_194 = 0x80004005;
          local_8 = 0xffffffff;
          ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
          ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_134);
          goto LAB_1001925c;
        }
        FUN_1001eed0(local_12c + local_13c,0x10e - local_13c,local_154);
      }
      local_138 = local_12c;
      if (local_138 == (char *)0x0) {
        local_15c = (LPWSTR)0x0;
      }
      else {
        sVar2 = strlen(local_138);
        local_130 = sVar2 + 1;
        lVar3 = ATL::AtlMultiply<int>((int *)&local_130,local_130,2);
        if (lVar3 < 0) {
          local_16c = (LPWSTR)0x0;
        }
        else {
          if (((int)local_130 < 0x401) && (cVar1 = FUN_10012fe0(local_130), cVar1 != '\0')) {
            local_1a4 = (undefined1 *)&local_1b4;
            local_174 = (LPWSTR)&local_1b4;
          }
          else {
            local_174 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                          (local_134,local_130);
          }
          local_16c = FUN_100107c0(local_174,local_138,local_130 >> 1,local_14c);
        }
        local_15c = local_16c;
      }
      local_140 = local_15c;
      if (local_15c == (LPWSTR)0x0) {
        local_19c = 0x8007000e;
        local_8 = 0xffffffff;
        ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
        ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_134);
      }
      else {
        local_144 = Ordinal_161();
        if (local_144 < 0) {
          builtin_strncpy(local_1c,".tlb",5);
          if ((char *)0x104 < local_148 + (5 - (int)local_12c)) {
            local_188 = 0x80004005;
            local_8 = 0xffffffff;
            ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
            ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_134);
            goto LAB_1001925c;
          }
          FUN_1001eed0(local_148,0x10e - ((int)local_148 - (int)local_12c),local_1c);
          local_138 = local_12c;
          if (local_138 == (char *)0x0) {
            local_170 = (LPWSTR)0x0;
          }
          else {
            sVar2 = strlen(local_138);
            local_130 = sVar2 + 1;
            lVar3 = ATL::AtlMultiply<int>((int *)&local_130,local_130,2);
            if (lVar3 < 0) {
              local_168 = (LPWSTR)0x0;
            }
            else {
              if (((int)local_130 < 0x401) && (cVar1 = FUN_10012fe0(local_130), cVar1 != '\0')) {
                local_190 = &stack0xfffffe44;
                local_160 = (LPWSTR)&stack0xfffffe44;
              }
              else {
                local_160 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                    CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                              (local_134,local_130);
              }
              local_168 = FUN_100107c0(local_160,local_138,local_130 >> 1,local_14c);
            }
            local_170 = local_168;
          }
          local_140 = local_170;
          if (local_170 == (LPWSTR)0x0) {
            local_198 = 0x8007000e;
            local_8 = 0xffffffff;
            ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
            ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_134);
            goto LAB_1001925c;
          }
          local_144 = Ordinal_161(local_170,param_4);
        }
        if (-1 < local_144) {
          iVar4 = Ordinal_2(local_140);
          *param_3 = iVar4;
          if (*param_3 == 0) {
            local_144 = -0x7ff8fff2;
            (**(code **)(*(int *)*param_4 + 8))(*param_4);
            *param_4 = 0;
          }
        }
        local_1a0 = local_144;
        local_8 = 0xffffffff;
        ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
        ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_134);
      }
    }
  }
LAB_1001925c:
  ExceptionList = local_10;
  local_1b4 = 0x10019277;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10019280 at 10019280

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_10019280(GUID *param_1,int *param_2,int param_3)

{
  undefined4 *puVar1;
  char cVar2;
  int iVar3;
  LPVOID *ppv;
  size_t sVar4;
  long lVar5;
  HKEY pHVar6;
  LPSTR pCVar7;
  LPDWORD pDVar8;
  LPDWORD pDVar9;
  DWORD *pDVar10;
  LPDWORD pDVar11;
  LPDWORD pDVar12;
  LPDWORD pDVar13;
  LPDWORD pDVar14;
  LPDWORD pDVar15;
  char *pcVar16;
  LPDWORD pDVar17;
  REGSAM RVar18;
  PFILETIME p_Var19;
  uint local_19c;
  undefined1 *local_198;
  undefined4 local_194;
  undefined4 local_190;
  undefined4 local_18c;
  undefined4 local_188;
  UINT local_184;
  CRegKey local_180 [12];
  int local_174;
  CRegKey local_170 [12];
  int *local_164;
  int *local_160;
  int *local_15c;
  LPSTR local_158;
  int *local_154;
  LPSTR local_150;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_14c [4];
  LPSTR local_148;
  wchar_t *local_144;
  LPSTR local_140;
  DWORD local_13c;
  int *local_138;
  HRESULT local_134;
  ulong local_130;
  long local_12c;
  int local_128;
  undefined4 local_124;
  undefined4 local_120;
  undefined4 local_11c;
  undefined4 local_118;
  OLECHAR local_114 [64];
  char local_94 [128];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c44c;
  local_10 = ExceptionList;
  local_19c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_14 = local_19c;
  FUN_10016140(&local_128);
  local_8 = 0;
  if (param_2 == (int *)0x0) {
    local_190 = 0;
    local_8 = 0xffffffff;
    FID_conflict__bad_alloc(&local_128);
  }
  else {
    iVar3 = FUN_100022c0((int *)param_1,(int *)&DAT_1003499c);
    if (iVar3 == 0) {
      ppv = (LPVOID *)FUN_10017220(&local_128);
      local_134 = CoCreateInstance((IID *)&DAT_100356ec,(LPUNKNOWN)0x0,1,(IID *)&DAT_1002fb78,ppv);
      if (local_134 < 0) {
        local_188 = 0;
        local_8 = 0xffffffff;
        FID_conflict__bad_alloc(&local_128);
      }
      else {
        local_134 = 0;
        for (local_138 = param_2; *local_138 != 0; local_138 = local_138 + 2) {
          puVar1 = (undefined4 *)local_138[1];
          local_124 = *puVar1;
          local_120 = puVar1[1];
          local_11c = puVar1[2];
          local_118 = puVar1[3];
          if (param_3 == 0) {
            if (*local_138 == 1) {
              local_160 = (int *)FUN_10017200(&local_128);
              (**(code **)(*local_160 + 0x18))(local_160,param_1,1,&local_124);
            }
            else {
              local_15c = (int *)FUN_10017200(&local_128);
              (**(code **)(*local_15c + 0x20))(local_15c,param_1,1,&local_124);
            }
          }
          else {
            if (*local_138 == 1) {
              local_154 = (int *)FUN_10017200(&local_128);
              local_134 = (**(code **)(*local_154 + 0x14))(local_154,param_1,1,&local_124);
            }
            else {
              local_164 = (int *)FUN_10017200(&local_128);
              local_134 = (**(code **)(*local_164 + 0x1c))(local_164,param_1,1,&local_124);
            }
            if (local_134 < 0) {
              local_174 = local_134;
              local_8 = 0xffffffff;
              FID_conflict__bad_alloc(&local_128);
              goto LAB_1001988e;
            }
          }
        }
        if (param_3 == 0) {
          StringFromGUID2(param_1,local_114,0x40);
          local_184 = FUN_10012f50();
          FUN_1000d590((undefined4 *)local_14c);
          local_8._0_1_ = 1;
          local_144 = local_114;
          if (local_144 == (wchar_t *)0x0) {
            local_158 = (LPSTR)0x0;
          }
          else {
            sVar4 = wcslen(local_144);
            local_130 = sVar4 + 1;
            lVar5 = ATL::AtlMultiply<int>((int *)&local_130,local_130,2);
            if (lVar5 < 0) {
              local_148 = (LPSTR)0x0;
            }
            else {
              if (((int)local_130 < 0x401) && (cVar2 = FUN_10012fe0(local_130), cVar2 != '\0')) {
                local_198 = (undefined1 *)&local_19c;
                local_150 = (LPSTR)&local_19c;
              }
              else {
                local_150 = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                   CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                             (local_14c,local_130);
              }
              local_148 = FUN_10019d50(local_150,local_144,local_130,local_184);
            }
            local_158 = local_148;
          }
          local_140 = local_158;
          if (local_158 != (LPSTR)0x0) {
            FUN_1001eed0(local_94,0x80,"CLSID\\");
            FUN_1001eea0(local_94,0x80,local_140);
            FUN_1001eea0(local_94,0x80,"\\Required Categories");
            ATL::CRegKey::CRegKey(local_180,(HKEY__ *)0x80000000);
            local_8._0_1_ = 2;
            ATL::CRegKey::CRegKey(local_170,(CAtlTransactionManager *)0x0);
            local_8 = CONCAT31(local_8._1_3_,3);
            local_13c = 0;
            RVar18 = 0x20019;
            pcVar16 = local_94;
            pHVar6 = (HKEY)FUN_100171f0((undefined4 *)local_180);
            local_12c = FUN_1001b470(local_170,pHVar6,pcVar16,RVar18);
            if (local_12c == 0) {
              p_Var19 = (PFILETIME)0x0;
              pDVar17 = (LPDWORD)0x0;
              pDVar15 = (LPDWORD)0x0;
              pDVar14 = (LPDWORD)0x0;
              pDVar13 = (LPDWORD)0x0;
              pDVar12 = (LPDWORD)0x0;
              pDVar11 = (LPDWORD)0x0;
              pDVar10 = &local_13c;
              pDVar9 = (LPDWORD)0x0;
              pDVar8 = (LPDWORD)0x0;
              pCVar7 = (LPSTR)0x0;
              pHVar6 = (HKEY)FUN_100171f0((undefined4 *)local_170);
              local_12c = RegQueryInfoKeyA(pHVar6,pCVar7,pDVar8,pDVar9,pDVar10,pDVar11,pDVar12,
                                           pDVar13,pDVar14,pDVar15,pDVar17,p_Var19);
              ATL::CRegKey::Close(local_170);
              if ((local_12c == 0) && (local_13c == 0)) {
                FUN_1001a550(local_180,local_94);
              }
            }
            FUN_1001eed0(local_94,0x80,"CLSID\\");
            FUN_1001eea0(local_94,0x80,local_140);
            FUN_1001eea0(local_94,0x80,"\\Implemented Categories");
            RVar18 = 0x20019;
            pcVar16 = local_94;
            pHVar6 = (HKEY)FUN_100171f0((undefined4 *)local_180);
            local_12c = FUN_1001b470(local_170,pHVar6,pcVar16,RVar18);
            if (local_12c == 0) {
              p_Var19 = (PFILETIME)0x0;
              pDVar17 = (LPDWORD)0x0;
              pDVar15 = (LPDWORD)0x0;
              pDVar14 = (LPDWORD)0x0;
              pDVar13 = (LPDWORD)0x0;
              pDVar12 = (LPDWORD)0x0;
              pDVar11 = (LPDWORD)0x0;
              pDVar10 = &local_13c;
              pDVar9 = (LPDWORD)0x0;
              pDVar8 = (LPDWORD)0x0;
              pCVar7 = (LPSTR)0x0;
              pHVar6 = (HKEY)FUN_100171f0((undefined4 *)local_170);
              local_12c = RegQueryInfoKeyA(pHVar6,pCVar7,pDVar8,pDVar9,pDVar10,pDVar11,pDVar12,
                                           pDVar13,pDVar14,pDVar15,pDVar17,p_Var19);
              ATL::CRegKey::Close(local_170);
              if ((local_12c == 0) && (local_13c == 0)) {
                FUN_1001a550(local_180,local_94);
              }
            }
            local_8._0_1_ = 2;
            FUN_10016f60(local_170);
            local_8._0_1_ = 1;
            FUN_10016f60(local_180);
          }
          local_8 = (uint)local_8._1_3_ << 8;
          ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
          ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_14c);
        }
        local_194 = 0;
        local_8 = 0xffffffff;
        FID_conflict__bad_alloc(&local_128);
      }
    }
    else {
      local_18c = 0;
      local_8 = 0xffffffff;
      FID_conflict__bad_alloc(&local_128);
    }
  }
LAB_1001988e:
  ExceptionList = local_10;
  local_19c = 0x100198a9;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100198b0 at 100198b0

/* WARNING: Removing unreachable block (ram,0x100199f7) */

void FUN_100198b0(HMODULE param_1,wchar_t *param_2)

{
  bool bVar1;
  undefined4 *puVar2;
  int *piVar3;
  undefined4 uVar4;
  rsize_t rVar5;
  int iVar6;
  HMODULE hModule;
  undefined4 uVar7;
  wchar_t *local_23c;
  FARPROC local_234;
  undefined4 local_230;
  int local_22c;
  wchar_t *local_228;
  int local_224;
  char local_21d;
  wchar_t local_21c [259];
  undefined2 uStack_16;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c4a1;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_1000e3d0(&local_230);
  local_8 = 0;
  FUN_10016190(&local_22c);
  local_8._0_1_ = 1;
  puVar2 = (undefined4 *)FUN_10017230(&local_22c);
  piVar3 = (int *)FUN_100101f0(&local_230);
  local_224 = FUN_10018be0(param_1,param_2,piVar3,puVar2);
  if (-1 < local_224) {
    local_23c = (wchar_t *)0x0;
    FUN_1000e3d0(&local_228);
    local_8 = CONCAT31(local_8._1_3_,2);
    piVar3 = (int *)FUN_10017210(&local_22c);
    uVar4 = FUN_100101f0(&local_228);
    local_224 = (**(code **)(*piVar3 + 0x24))(piVar3,0xffffffff,0,0,0,uVar4);
    if ((-1 < local_224) && (bVar1 = FUN_10017170((int *)&local_228), bVar1)) {
      rVar5 = FUN_1001b140(&local_228);
      FUN_1001ef30(local_21c,0x104,local_228,rVar5);
      uStack_16 = 0;
      iVar6 = FUN_10015ad0(local_21c);
      if (0x207 < (uint)(iVar6 * 2)) {
        ___report_rangecheckfailure();
      }
      local_21c[iVar6] = L'\0';
      local_23c = local_21c;
    }
    local_234 = (FARPROC)0x0;
    local_21d = '\0';
    local_224 = FUN_10018b70(&local_21d);
    if (local_224 < 0) {
      local_8._0_1_ = 1;
      FUN_10002040(&local_228);
      local_8 = (uint)local_8._1_3_ << 8;
      FID_conflict__bad_alloc(&local_22c);
      local_8 = 0xffffffff;
      FUN_10002040(&local_230);
      goto LAB_10019b8a;
    }
    if ((local_21d == '\x01') &&
       (hModule = GetModuleHandleW(L"OLEAUT32.DLL"), hModule != (HMODULE)0x0)) {
      local_234 = GetProcAddress(hModule,"RegisterTypeLibForUser");
    }
    if (local_234 == (FARPROC)0x0) {
      local_234 = Ordinal_163_exref;
    }
    uVar4 = FUN_1000fcd0(&local_230);
    uVar7 = FUN_100171b0(&local_22c);
    local_224 = (*local_234)(uVar7,uVar4,local_23c);
    local_8._0_1_ = 1;
    FUN_10002040(&local_228);
  }
  local_8 = (uint)local_8._1_3_ << 8;
  FID_conflict__bad_alloc(&local_22c);
  local_8 = 0xffffffff;
  FUN_10002040(&local_230);
LAB_10019b8a:
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10019bb0 at 10019bb0

int FUN_10019bb0(HMODULE param_1,wchar_t *param_2)

{
  undefined4 *puVar1;
  int *piVar2;
  int iVar3;
  HMODULE hModule;
  undefined4 local_28;
  FARPROC local_24;
  int local_20;
  int local_1c;
  int local_18;
  char local_11;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c4e0;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_1000e3d0(&local_28);
  local_8 = 0;
  FUN_10016190(&local_20);
  local_8._0_1_ = 1;
  puVar1 = (undefined4 *)FUN_10017230(&local_20);
  piVar2 = (int *)FUN_100101f0(&local_28);
  local_18 = FUN_10018be0(param_1,param_2,piVar2,puVar1);
  if (-1 < local_18) {
    piVar2 = (int *)FUN_10017210(&local_20);
    local_18 = (**(code **)(*piVar2 + 0x1c))(piVar2,&local_1c);
    if (-1 < local_18) {
      local_24 = (FARPROC)0x0;
      local_11 = '\0';
      iVar3 = FUN_10018b70(&local_11);
      local_18 = iVar3;
      if (iVar3 < 0) {
        local_8 = (uint)local_8._1_3_ << 8;
        FID_conflict__bad_alloc(&local_20);
        local_8 = 0xffffffff;
        FUN_10002040(&local_28);
        ExceptionList = local_10;
        return iVar3;
      }
      if ((local_11 == '\x01') &&
         (hModule = GetModuleHandleW(L"OLEAUT32.DLL"), hModule != (HMODULE)0x0)) {
        local_24 = GetProcAddress(hModule,"UnRegisterTypeLibForUser");
      }
      if (local_24 == (FARPROC)0x0) {
        local_24 = Ordinal_186_exref;
      }
      local_18 = (*local_24)(local_1c,(uint)*(ushort *)(local_1c + 0x18),
                             (uint)*(ushort *)(local_1c + 0x1a),*(undefined4 *)(local_1c + 0x10),
                             *(undefined4 *)(local_1c + 0x14));
      piVar2 = (int *)FUN_10017210(&local_20);
      (**(code **)(*piVar2 + 0x30))(piVar2,local_1c);
    }
  }
  iVar3 = local_18;
  local_8 = (uint)local_8._1_3_ << 8;
  FID_conflict__bad_alloc(&local_20);
  local_8 = 0xffffffff;
  FUN_10002040(&local_28);
  ExceptionList = local_10;
  return iVar3;
}



// Function: FUN_10019d50 at 10019d50

LPSTR FUN_10019d50(LPSTR param_1,LPCWSTR param_2,int param_3,UINT param_4)

{
  int iVar1;
  
  if ((param_1 == (LPSTR)0x0) || (param_2 == (LPCWSTR)0x0)) {
    param_1 = (LPSTR)0x0;
  }
  else {
    *param_1 = '\0';
    iVar1 = WideCharToMultiByte(param_4,0,param_2,-1,param_1,param_3,(LPCSTR)0x0,(LPBOOL)0x0);
    if (iVar1 == 0) {
      param_1 = (LPSTR)0x0;
    }
  }
  return param_1;
}



// Function: FUN_10019da0 at 10019da0

void __thiscall FUN_10019da0(void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  return;
}



// Function: FUN_10019dc0 at 10019dc0

void __thiscall FUN_10019dc0(void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  return;
}



// Function: FUN_10019de0 at 10019de0

void __thiscall FUN_10019de0(void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 0;
  return;
}



// Function: FUN_10019e10 at 10019e10

undefined4 FUN_10019e10(LPCSTR param_1)

{
  int iVar1;
  int local_8;
  
  local_8 = 0;
  while( true ) {
    if (0xb < local_8) {
      return 1;
    }
    iVar1 = lstrcmpiA(param_1,(&PTR_s_AppID_100305a8)[local_8]);
    if (iVar1 == 0) break;
    local_8 = local_8 + 1;
  }
  return 0;
}



// Function: FUN_10019e60 at 10019e60

uint __cdecl FUN_10019e60(char param_1)

{
  uint uVar1;
  
  switch(param_1) {
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
    uVar1 = (int)param_1 - 0x30;
    break;
  default:
    uVar1 = 0;
    break;
  case 'A':
  case 'B':
  case 'C':
  case 'D':
  case 'E':
  case 'F':
    uVar1 = (int)param_1 - 0x37;
    break;
  case 'a':
  case 'b':
  case 'c':
  case 'd':
  case 'e':
  case 'f':
    uVar1 = (int)param_1 - 0x57;
  }
  return uVar1;
}



// Function: FUN_10019f00 at 10019f00

undefined4 __fastcall FUN_10019f00(int *param_1)

{
  int iVar1;
  undefined4 *puVar2;
  undefined4 local_8;
  
  local_8 = 0;
  while( true ) {
    iVar1 = FUN_1001acc0((int)param_1);
    if (iVar1 <= local_8) break;
    puVar2 = (undefined4 *)FUN_1001ab80(param_1,local_8);
    operator_delete__((void *)*puVar2);
    puVar2 = (undefined4 *)FUN_1001ade0(param_1,local_8);
    operator_delete__((void *)*puVar2);
    local_8 = local_8 + 1;
  }
  FUN_1001d0f0(param_1);
  return 0;
}



// Function: FUN_10019f80 at 10019f80

undefined4 FUN_10019f80(int param_1)

{
  undefined4 uVar1;
  
  FUN_1001b180();
  uVar1 = FUN_10019f00((int *)(param_1 + 4));
  FUN_1001dd80();
  return uVar1;
}



// Function: Close at 10019fc0

/* Library Function - Single Match
    public: long __thiscall ATL::CRegKey::Close(void)
   
   Libraries: Visual Studio 2008 Debug, Visual Studio 2010 Debug */

long __thiscall ATL::CRegKey::Close(CRegKey *this)

{
  LSTATUS local_c;
  
  local_c = 0;
  if (*(int *)this != 0) {
    local_c = RegCloseKey(*(HKEY *)this);
    *(undefined4 *)this = 0;
  }
  *(undefined4 *)(this + 4) = 0;
  return local_c;
}



// Function: FUN_1001a010 at 1001a010

long __thiscall
FUN_1001a010(void *this,HKEY param_1,LPCSTR param_2,LPSTR param_3,DWORD param_4,REGSAM param_5,
            LPSECURITY_ATTRIBUTES param_6,DWORD *param_7)

{
  DWORD local_18;
  int local_14;
  long local_10;
  HKEY local_c;
  CRegKey *local_8;
  
  local_c = (HKEY)0x0;
  local_8 = (CRegKey *)this;
  if (*(int *)((int)this + 8) == 0) {
    local_14 = RegCreateKeyExA(param_1,param_2,0,param_3,param_4,param_5,param_6,&local_c,&local_18)
    ;
  }
  else {
    local_14 = FUN_1001bbf0(*(void **)((int)this + 8),param_1,param_2,0,param_3,param_4,param_5,
                            param_6,&local_c,&local_18);
  }
  local_10 = local_14;
  if (param_7 != (DWORD *)0x0) {
    *param_7 = local_18;
  }
  if (local_14 == 0) {
    local_10 = ATL::CRegKey::Close(local_8);
    *(HKEY *)local_8 = local_c;
  }
  return local_10;
}



// Function: FUN_1001a0c0 at 1001a0c0

undefined4 FUN_1001a0c0(int param_1,int param_2,int *param_3,undefined4 *param_4)

{
  undefined4 uVar1;
  int iVar2;
  
  if (param_4 == (undefined4 *)0x0) {
    uVar1 = 0x80004003;
  }
  else {
    *param_4 = 0;
    iVar2 = FUN_10026df0(param_1 + 0x24 + *(int *)(*(int *)(param_1 + 0x24) + 4));
    if (iVar2 == 0) {
      uVar1 = 0x80040112;
    }
    else if ((param_2 == 0) || (iVar2 = FUN_10012190(param_3), iVar2 != 0)) {
      uVar1 = (**(code **)(param_1 + 0x2c))(param_2,param_3,param_4);
    }
    else {
      uVar1 = 0x80040110;
    }
  }
  return uVar1;
}



// Function: FUN_1001a140 at 1001a140

undefined4 FUN_1001a140(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  void *this;
  undefined4 uVar1;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002c512;
  local_10 = ExceptionList;
  if (param_3 != (undefined4 *)0x0) {
    ExceptionList = &local_10;
    *param_3 = 0;
    local_8 = 0;
    this = (void *)FUN_10028fa8(0xc4);
    local_8._0_1_ = 1;
    if (this != (void *)0x0) {
      FUN_10015d30(this,param_1);
    }
    local_8 = (uint)local_8._1_3_ << 8;
    uVar1 = FUN_1001a1e9();
    return uVar1;
  }
  return 0x80004003;
}



// Function: Catch@1001a1e3 at 1001a1e3

undefined * Catch_1001a1e3(void)

{
  return &DAT_1001a1f2;
}



// Function: FUN_1001a1e9 at 1001a1e9

undefined4 FUN_1001a1e9(void)

{
  int iVar1;
  undefined4 uVar2;
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  if (*(int *)(unaff_EBP + -0x14) != 0) {
    FUN_10012c60();
    FUN_10012260();
    iVar1 = FUN_1001ece0(*(int *)(unaff_EBP + -0x14));
    *(int *)(unaff_EBP + -0x18) = iVar1;
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar2 = FUN_1001a7a0(*(int *)(unaff_EBP + -0x14));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
    }
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar2 = FUN_10012f40();
      *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
    }
    FUN_10012290();
    if (*(int *)(unaff_EBP + -0x18) == 0) {
      uVar2 = (**(code **)**(undefined4 **)(unaff_EBP + -0x14))
                        (*(undefined4 *)(unaff_EBP + -0x14),*(undefined4 *)(unaff_EBP + 0xc),
                         *(undefined4 *)(unaff_EBP + 0x10));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar2;
    }
    if (*(int *)(unaff_EBP + -0x18) != 0) {
      *(undefined4 *)(unaff_EBP + -0x2c) = *(undefined4 *)(unaff_EBP + -0x14);
      *(undefined4 *)(unaff_EBP + -0x1c) = *(undefined4 *)(unaff_EBP + -0x2c);
      if (*(int *)(unaff_EBP + -0x1c) == 0) {
        *(undefined4 *)(unaff_EBP + -0x30) = 0;
      }
      else {
        uVar2 = (**(code **)(**(int **)(unaff_EBP + -0x1c) + 0xc))(1);
        *(undefined4 *)(unaff_EBP + -0x30) = uVar2;
      }
    }
  }
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x18);
}



// Function: FUN_1001a2c0 at 1001a2c0

undefined4 FUN_1001a2c0(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002c542;
  local_10 = ExceptionList;
  if (param_3 != (undefined4 *)0x0) {
    ExceptionList = &local_10;
    *param_3 = 0;
    local_8 = 0;
    puVar1 = (undefined4 *)FUN_10028fa8(0xb8);
    local_8._0_1_ = 1;
    if (puVar1 != (undefined4 *)0x0) {
      FUN_10015f50(puVar1);
    }
    local_8 = (uint)local_8._1_3_ << 8;
    uVar2 = FUN_1001a369();
    return uVar2;
  }
  return 0x80004003;
}



// Function: Catch@1001a363 at 1001a363

undefined * Catch_1001a363(void)

{
  return &DAT_1001a372;
}



// Function: FUN_1001a369 at 1001a369

undefined4 FUN_1001a369(void)

{
  undefined4 uVar1;
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  if (*(int *)(unaff_EBP + -0x14) != 0) {
    FUN_10012c60();
    FUN_1001af90(*(int *)(unaff_EBP + -0x14));
    uVar1 = FUN_10012fa0(*(int *)(unaff_EBP + -0x14) + 0x14);
    *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar1 = (**(code **)(**(int **)(unaff_EBP + -0x14) + 0x10))
                        (*(undefined4 *)(unaff_EBP + -0x14));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    if (-1 < *(int *)(unaff_EBP + -0x18)) {
      uVar1 = FUN_10012f40();
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    FUN_1001afb0(*(int *)(unaff_EBP + -0x14));
    if (*(int *)(unaff_EBP + -0x18) == 0) {
      uVar1 = (**(code **)**(undefined4 **)(unaff_EBP + -0x14))
                        (*(undefined4 *)(unaff_EBP + -0x14),*(undefined4 *)(unaff_EBP + 0xc),
                         *(undefined4 *)(unaff_EBP + 0x10));
      *(undefined4 *)(unaff_EBP + -0x18) = uVar1;
    }
    if (*(int *)(unaff_EBP + -0x18) != 0) {
      *(undefined4 *)(unaff_EBP + -0x2c) = *(undefined4 *)(unaff_EBP + -0x14);
      *(undefined4 *)(unaff_EBP + -0x1c) = *(undefined4 *)(unaff_EBP + -0x2c);
      if (*(int *)(unaff_EBP + -0x1c) == 0) {
        *(undefined4 *)(unaff_EBP + -0x30) = 0;
      }
      else {
        uVar1 = (**(code **)(**(int **)(unaff_EBP + -0x1c) + 0x14))(1);
        *(undefined4 *)(unaff_EBP + -0x30) = uVar1;
      }
    }
  }
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + -0x18);
}



// Function: FUN_1001a450 at 1001a450

undefined4 FUN_1001a450(int param_1,int param_2,int *param_3,undefined4 *param_4)

{
  int iVar1;
  undefined4 local_8;
  
  local_8 = 0x80004003;
  if (param_4 != (undefined4 *)0x0) {
    *param_4 = 0;
    if ((param_2 == 0) || (iVar1 = FUN_10012190(param_3), iVar1 != 0)) {
      local_8 = (**(code **)(param_1 + 0x24))(param_2,param_3,param_4);
    }
    else {
      local_8 = 0x80040110;
    }
  }
  return local_8;
}



// Function: FUN_1001a4b0 at 1001a4b0

undefined4
FUN_1001a4b0(int param_1,int param_2,undefined4 param_3,int *param_4,short *param_5,
            undefined4 *param_6)

{
  undefined4 uVar1;
  int iVar2;
  
  if (param_6 == (undefined4 *)0x0) {
    uVar1 = 0x80004003;
  }
  else {
    *param_6 = 0;
    if (((param_5 == (short *)0x0) ||
        (iVar2 = FUN_100271d0((void *)(param_1 + 0x24 + *(int *)(*(int *)(param_1 + 0x24) + 4)),
                              param_5), iVar2 != 0)) &&
       ((param_5 != (short *)0x0 ||
        (iVar2 = FUN_10026df0(param_1 + 0x24 + *(int *)(*(int *)(param_1 + 0x24) + 4)), iVar2 != 0))
       )) {
      if ((param_2 == 0) || (iVar2 = FUN_10012190(param_4), iVar2 != 0)) {
        uVar1 = (**(code **)(param_1 + 0x2c))(param_2,param_4,param_6);
      }
      else {
        uVar1 = 0x80040110;
      }
    }
    else {
      uVar1 = 0x80040112;
    }
  }
  return uVar1;
}



// Function: FUN_1001a550 at 1001a550

void __thiscall FUN_1001a550(void *this,LPCSTR param_1)

{
  if (*(int *)((int)this + 8) == 0) {
                    /* WARNING: Load size is inaccurate */
    RegDeleteKeyA(*this,param_1);
  }
  else {
                    /* WARNING: Load size is inaccurate */
    FUN_1001bcb0(*(void **)((int)this + 8),*this,param_1);
  }
  return;
}



// Function: FUN_1001a5a0 at 1001a5a0

void __thiscall FUN_1001a5a0(void *this,LPCSTR param_1)

{
                    /* WARNING: Load size is inaccurate */
  RegDeleteValueA(*this,param_1);
  return;
}



// Function: detach at 1001a5d0

/* Library Function - Multiple Matches With Same Base Name
    public: char const * __thiscall __crt_unique_heap_ptr<char const ,struct
   __crt_internal_free_policy>::detach(void)
    public: wchar_t const * __thiscall __crt_unique_heap_ptr<wchar_t const ,struct
   __crt_internal_free_policy>::detach(void)
    public: char * __thiscall __crt_unique_heap_ptr<char,struct
   __crt_internal_free_policy>::detach(void)
    public: char * __thiscall __crt_unique_heap_ptr<char,struct
   __crt_public_free_policy>::detach(void)
     31 names - too many to list
   
   Libraries: Visual Studio 2015 Debug, Visual Studio 2017 Debug, Visual Studio 2019 Debug */

undefined4 __fastcall detach(undefined4 *param_1)

{
  undefined4 uVar1;
  
  uVar1 = *param_1;
  *param_1 = 0;
  return uVar1;
}



// Function: detach at 1001a600

/* Library Function - Multiple Matches With Same Base Name
    public: char const * __thiscall __crt_unique_heap_ptr<char const ,struct
   __crt_internal_free_policy>::detach(void)
    public: wchar_t const * __thiscall __crt_unique_heap_ptr<wchar_t const ,struct
   __crt_internal_free_policy>::detach(void)
    public: char * __thiscall __crt_unique_heap_ptr<char,struct
   __crt_internal_free_policy>::detach(void)
    public: char * __thiscall __crt_unique_heap_ptr<char,struct
   __crt_public_free_policy>::detach(void)
     31 names - too many to list
   
   Libraries: Visual Studio 2015 Debug, Visual Studio 2017 Debug, Visual Studio 2019 Debug */

undefined4 __fastcall detach(undefined4 *param_1)

{
  undefined4 uVar1;
  
  uVar1 = *param_1;
  *param_1 = 0;
  return uVar1;
}



// Function: FUN_1001a630 at 1001a630

undefined4 __fastcall FUN_1001a630(undefined4 *param_1)

{
  undefined4 uVar1;
  
  uVar1 = param_1[2];
  param_1[2] = 0;
  *param_1 = 0;
  param_1[1] = 0;
  return uVar1;
}



// Function: FUN_1001a670 at 1001a670

undefined4 __fastcall FUN_1001a670(undefined4 *param_1)

{
  undefined4 uVar1;
  
  uVar1 = *param_1;
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  return uVar1;
}



// Function: FUN_1001a6b0 at 1001a6b0

undefined4 __fastcall FUN_1001a6b0(undefined4 *param_1)

{
  LPSTR pCVar1;
  
  if ((*(char *)*param_1 == '\'') && (pCVar1 = CharNextA((LPCSTR)*param_1), *pCVar1 != '\'')) {
    return 1;
  }
  return 0;
}



// Function: FUN_1001a700 at 1001a700

void __cdecl FUN_1001a700(short *param_1,int param_2,short *param_3)

{
  short *psVar1;
  uint local_8;
  
  if (param_2 != 0) {
    local_8 = 0;
    for (; (local_8 < param_2 - 1U && (*param_3 != 0)); param_3 = param_3 + 1) {
      *param_1 = *param_3;
      psVar1 = param_1 + 1;
      if ((*param_3 == 0x27) && (local_8 = local_8 + 1, local_8 < param_2 - 1U)) {
        *psVar1 = *param_3;
        psVar1 = param_1 + 2;
      }
      param_1 = psVar1;
      local_8 = local_8 + 1;
    }
    *param_1 = 0;
  }
  return;
}



// Function: FUN_1001a7a0 at 1001a7a0

void __fastcall FUN_1001a7a0(int param_1)

{
  FUN_10011710();
  (**(code **)(*(int *)(param_1 + 0xc) + 0x10))(param_1 + 0xc);
  return;
}



// Function: FUN_1001a7d0 at 1001a7d0

void FUN_1001a7d0(void)

{
  FUN_10012150();
  return;
}



// Function: FUN_1001a7f0 at 1001a7f0

void FUN_1001a7f0(void)

{
  FUN_10011750();
  FUN_10011750();
  return;
}



// Function: FUN_1001a820 at 1001a820

int __thiscall FUN_1001a820(void *this,undefined4 *param_1)

{
  bool bVar1;
  int local_8;
  
  local_8 = 0;
  while( true ) {
    if (*(int *)((int)this + 8) <= local_8) {
      return -1;
    }
                    /* WARNING: Load size is inaccurate */
    bVar1 = FUN_1001b0c0(*(LPCSTR *)(*this + local_8 * 4),(LPCSTR)*param_1);
    if (bVar1) break;
    local_8 = local_8 + 1;
  }
  return local_8;
}



// Function: Free at 1001a880

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall ATL::CAutoVectorPtr<char>::Free(void)
    public: void __thiscall ATL::CAutoVectorPtr<int>::Free(void)
    public: void __thiscall ATL::CAutoVectorPtr<unsigned long>::Free(void)
    public: void __thiscall ATL::CAutoVectorPtr<void *>::Free(void)
     6 names - too many to list
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __fastcall Free(undefined4 *param_1)

{
  operator_delete__((void *)*param_1);
  *param_1 = 0;
  return;
}



// Function: Free at 1001a8b0

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall ATL::CAutoVectorPtr<char>::Free(void)
    public: void __thiscall ATL::CAutoVectorPtr<int>::Free(void)
    public: void __thiscall ATL::CAutoVectorPtr<unsigned long>::Free(void)
    public: void __thiscall ATL::CAutoVectorPtr<void *>::Free(void)
     6 names - too many to list
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __fastcall Free(undefined4 *param_1)

{
  operator_delete__((void *)*param_1);
  *param_1 = 0;
  return;
}



// Function: FreeHeap at 1001a8e0

/* Library Function - Multiple Matches With Same Base Name
    private: void __thiscall ATL::CTempBuffer<char,128,class ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<wchar_t,10,class ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<wchar_t,128,class ATL::CCRTAllocator>::FreeHeap(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __fastcall FreeHeap(undefined4 *param_1)

{
  FUN_10011760((void *)*param_1);
  return;
}



// Function: FreeHeap at 1001a900

/* Library Function - Multiple Matches With Same Base Name
    private: void __thiscall ATL::CTempBuffer<char,128,class ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<wchar_t,10,class ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<wchar_t,128,class ATL::CCRTAllocator>::FreeHeap(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __fastcall FreeHeap(undefined4 *param_1)

{
  FUN_10011760((void *)*param_1);
  return;
}



// Function: FreeHeap at 1001a920

/* Library Function - Multiple Matches With Same Base Name
    private: void __thiscall ATL::CTempBuffer<char,128,class ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<unsigned char,128,class
   ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<wchar_t,10,class ATL::CCRTAllocator>::FreeHeap(void)
    private: void __thiscall ATL::CTempBuffer<wchar_t,128,class ATL::CCRTAllocator>::FreeHeap(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

void __fastcall FreeHeap(undefined4 *param_1)

{
  FUN_10011760((void *)*param_1);
  return;
}



// Function: FUN_1001a940 at 1001a940

undefined4 FUN_1001a940(void)

{
  return 0x80020009;
}



// Function: FUN_1001a960 at 1001a960

undefined ** FUN_1001a960(void)

{
  return &PTR_10033e4c;
}



// Function: FUN_1001a970 at 1001a970

int __thiscall FUN_1001a970(void *this,int *param_1,undefined4 param_2,int *param_3)

{
  uint uVar1;
  int iVar2;
  CComCritSecLock<class_ATL::CComCriticalSection> local_24 [8];
  void *local_1c;
  int local_18;
  int *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c5c8;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  *param_3 = 0;
  local_18 = 0;
  local_1c = this;
  if (*(int *)((int)this + 0x2c) != 0) {
    for (local_14 = *(int **)((int)this + 0x2c); *local_14 != 0; local_14 = local_14 + 9) {
      if ((local_14[2] != 0) && (iVar2 = FUN_100022c0(param_1,(int *)*local_14), iVar2 != 0)) {
        if (local_14[4] == 0) {
          ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
          CComCritSecLock<class_ATL::CComCriticalSection>
                    (local_24,(CComCriticalSection *)&DAT_10040568,false);
          local_8 = 0;
          local_18 = FUN_10012860((undefined4 *)local_24);
          if (local_18 < 0) {
            local_8 = 0xffffffff;
            ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
            ~CComCritSecLock<class_ATL::CComCriticalSection>(local_24);
            break;
          }
          if (local_14[4] == 0) {
            local_18 = (*(code *)local_14[2])(local_14[3],&DAT_1002f4c4,local_14 + 4,uVar1);
          }
          local_8 = 0xffffffff;
          ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
          ~CComCritSecLock<class_ATL::CComCriticalSection>(local_24);
        }
        if (local_14[4] != 0) {
          local_18 = (*(code *)**(undefined4 **)local_14[4])(local_14[4],param_2,param_3);
        }
        break;
      }
    }
  }
  if ((*param_3 == 0) && (local_18 == 0)) {
    local_18 = FUN_10018760((int *)&DAT_10040558,param_1,param_2,param_3);
  }
  ExceptionList = local_10;
  return local_18;
}



// Function: FUN_1001aae0 at 1001aae0

int __thiscall FUN_1001aae0(void *this,undefined4 *param_1)

{
  int local_c;
  
  if (param_1 == (undefined4 *)0x0) {
    local_c = -0x7fffbffd;
  }
  else {
    local_c = 0;
    if (*(int *)((int)this + 0x28) == 0) {
      local_c = CoCreateInstance((IID *)&DAT_10034bdc,(LPUNKNOWN)0x0,1,(IID *)&DAT_1002f500,
                                 (LPVOID *)((int)this + 0x28));
    }
    if (-1 < local_c) {
      *param_1 = *(undefined4 *)((int)this + 0x28);
      (**(code **)(**(int **)((int)this + 0x28) + 4))(*(undefined4 *)((int)this + 0x28));
    }
  }
  return local_c;
}



// Function: FUN_1001ab56 at 1001ab56

void FUN_1001ab56(int param_1,undefined4 param_2,undefined4 *param_3,int param_4,undefined4 param_5,
                 uint *param_6)

{
  FUN_1000bb60(param_1 + -4,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Function: FUN_1001ab60 at 1001ab60

void FUN_1001ab60(int param_1,undefined4 param_2,undefined4 *param_3,int param_4,undefined4 param_5,
                 uint *param_6)

{
  FUN_1000bb60(param_1 + -8,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Function: FUN_1001ab6a at 1001ab6a

void FUN_1001ab6a(int param_1,undefined4 param_2,undefined4 *param_3,int param_4,undefined4 param_5,
                 uint *param_6)

{
  FUN_1000bb60(param_1 + -0xc,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Function: FUN_1001ab80 at 1001ab80

int __thiscall FUN_1001ab80(void *this,int param_1)

{
  if ((param_1 < 0) || (*(int *)((int)this + 8) <= param_1)) {
    ATL::_AtlRaiseException(0xc000008c,1);
  }
                    /* WARNING: Load size is inaccurate */
  return *this + param_1 * 4;
}



// Function: FUN_1001abc0 at 1001abc0

undefined4 FUN_1001abc0(int param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  int local_8;
  
  if (param_2 == (undefined4 *)0x0) {
    uVar1 = 0x80004003;
  }
  else {
    *param_2 = 0xc;
    uVar1 = FUN_10026df0(param_1 + 0x24 + *(int *)(*(int *)(param_1 + 0x24) + 4));
    param_2[2] = uVar1;
    local_8 = 0;
    uVar1 = FUN_10026d70((void *)(param_1 + 0x24 + *(int *)(*(int *)(param_1 + 0x24) + 4)),0,
                         &local_8);
    param_2[1] = uVar1;
    Ordinal_6(local_8);
    uVar1 = 0;
  }
  return uVar1;
}



// Function: FUN_1001ac30 at 1001ac30

undefined4 __fastcall FUN_1001ac30(int param_1)

{
  return *(undefined4 *)(param_1 + 8);
}



// Function: FUN_1001ac41 at 1001ac41

void FUN_1001ac41(void)

{
  FUN_1001ac80();
  return;
}



// Function: FUN_1001ac5a at 1001ac5a

void FUN_1001ac5a(void)

{
  FUN_1001ac80();
  return;
}



// Function: FUN_1001ac80 at 1001ac80

undefined * FUN_1001ac80(void)

{
  return &DAT_100339a0;
}



// Function: FUN_1001ac8c at 1001ac8c

void FUN_1001ac8c(void)

{
  FUN_1001acb0();
  return;
}



// Function: FUN_1001ac9f at 1001ac9f

void FUN_1001ac9f(void)

{
  FUN_1001acb0();
  return;
}



// Function: FUN_1001acb0 at 1001acb0

char * FUN_1001acb0(void)

{
  return "SubFileComponent";
}



// Function: FUN_1001acc0 at 1001acc0

undefined4 __fastcall FUN_1001acc0(int param_1)

{
  return *(undefined4 *)(param_1 + 8);
}



// Function: FUN_1001ace0 at 1001ace0

void FUN_1001ace0(undefined4 param_1,int param_2,undefined4 param_3,undefined4 *param_4)

{
  FUN_10012070(&PTR_DAT_1003f564,param_2,param_3,param_4);
  return;
}



// Function: FUN_1001ad00 at 1001ad00

void FUN_1001ad00(undefined4 param_1,int param_2,undefined4 param_3,undefined4 *param_4)

{
  FUN_10012070(&PTR_DAT_1003f12c,param_2,param_3,param_4);
  return;
}



// Function: FUN_1001ad20 at 1001ad20

void FUN_1001ad20(undefined4 param_1,int param_2,undefined4 param_3,undefined4 *param_4)

{
  FUN_10012070(&PTR_DAT_1003f110,param_2,param_3,param_4);
  return;
}



// Function: FUN_1001ad40 at 1001ad40

void FUN_1001ad40(undefined4 param_1,int param_2,undefined4 param_3,undefined4 *param_4)

{
  FUN_10012070(&PTR_DAT_1003f148,param_2,param_3,param_4);
  return;
}



// Function: GetTypeInfoCount at 1001ad60

/* Library Function - Single Match
    public: virtual long __stdcall CWnd::XAccessible::GetTypeInfoCount(unsigned int *)
   
   Library: Visual Studio */

long CWnd::XAccessible::GetTypeInfoCount(uint *param_1)

{
  long lVar1;
  undefined4 *in_stack_00000008;
  
  if (in_stack_00000008 == (undefined4 *)0x0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    *in_stack_00000008 = 1;
    lVar1 = 0;
  }
  return lVar1;
}



// Function: GetTypeInfoCount at 1001ad80

/* Library Function - Single Match
    public: virtual long __stdcall CWnd::XAccessible::GetTypeInfoCount(unsigned int *)
   
   Library: Visual Studio */

long CWnd::XAccessible::GetTypeInfoCount(uint *param_1)

{
  long lVar1;
  undefined4 *in_stack_00000008;
  
  if (in_stack_00000008 == (undefined4 *)0x0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    *in_stack_00000008 = 1;
    lVar1 = 0;
  }
  return lVar1;
}



// Function: GetTypeInfoCount at 1001ada0

/* Library Function - Single Match
    public: virtual long __stdcall CWnd::XAccessible::GetTypeInfoCount(unsigned int *)
   
   Library: Visual Studio */

long CWnd::XAccessible::GetTypeInfoCount(uint *param_1)

{
  long lVar1;
  undefined4 *in_stack_00000008;
  
  if (in_stack_00000008 == (undefined4 *)0x0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    *in_stack_00000008 = 1;
    lVar1 = 0;
  }
  return lVar1;
}



// Function: GetTypeInfoCount at 1001adc0

/* Library Function - Single Match
    public: virtual long __stdcall CWnd::XAccessible::GetTypeInfoCount(unsigned int *)
   
   Library: Visual Studio */

long CWnd::XAccessible::GetTypeInfoCount(uint *param_1)

{
  long lVar1;
  undefined4 *in_stack_00000008;
  
  if (in_stack_00000008 == (undefined4 *)0x0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    *in_stack_00000008 = 1;
    lVar1 = 0;
  }
  return lVar1;
}



// Function: FUN_1001ade0 at 1001ade0

int __thiscall FUN_1001ade0(void *this,int param_1)

{
  if ((param_1 < 0) || (*(int *)((int)this + 8) <= param_1)) {
    ATL::_AtlRaiseException(0xc000008c,1);
  }
  return *(int *)((int)this + 4) + param_1 * 4;
}



// Function: FUN_1001ae20 at 1001ae20

undefined4 __cdecl FUN_1001ae20(LPCSTR param_1)

{
  int iVar1;
  uint local_8;
  
  local_8 = 0;
  while( true ) {
    if (0xd < local_8) {
      return 0;
    }
    iVar1 = lstrcmpiA(param_1,(&PTR_DAT_10033a70)[local_8 * 2]);
    if (iVar1 == 0) break;
    local_8 = local_8 + 1;
  }
  return *(undefined4 *)(&DAT_10033a74 + local_8 * 8);
}



// Function: FUN_1001ae70 at 1001ae70

bool FUN_1001ae70(HKEY param_1)

{
  LSTATUS LVar1;
  DWORD local_8;
  
  local_8 = 0;
  LVar1 = RegQueryInfoKeyW(param_1,(LPWSTR)0x0,(LPDWORD)0x0,(LPDWORD)0x0,&local_8,(LPDWORD)0x0,
                           (LPDWORD)0x0,(LPDWORD)0x0,(LPDWORD)0x0,(LPDWORD)0x0,(LPDWORD)0x0,
                           (PFILETIME)0x0);
  return LVar1 == 0 && local_8 != 0;
}



// Function: FUN_1001aed0 at 1001aed0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 __thiscall FUN_1001aed0(void *this,int param_1,undefined4 param_2,undefined4 *param_3)

{
  int *local_c;
  int *local_8;
  
  if (param_3 != (undefined4 *)0x0) {
    _DAT_100403ac = *param_3;
    _DAT_100403b0 = param_3[1];
    _DAT_100403b4 = param_3[2];
    _DAT_100403b8 = param_3[3];
  }
  if ((param_1 != -1) && (*(int *)((int)this + 0x2c) = param_1, *(int *)((int)this + 0x2c) != 0)) {
    for (local_c = *(int **)((int)this + 0x2c); *local_c != 0; local_c = local_c + 9) {
      (*(code *)local_c[8])(1);
    }
  }
  for (local_8 = DAT_10040560; local_8 < DAT_10040564; local_8 = local_8 + 1) {
    if (*local_8 != 0) {
      (**(code **)(*local_8 + 0x1c))(1);
    }
  }
  return 0;
}



// Function: FUN_1001af80 at 1001af80

void FUN_1001af80(void)

{
  return;
}



// Function: FUN_1001af90 at 1001af90

void __fastcall FUN_1001af90(int param_1)

{
  FUN_10012200((LONG *)(param_1 + 0x14));
  return;
}



// Function: FUN_1001afb0 at 1001afb0

void __fastcall FUN_1001afb0(int param_1)

{
  FUN_100122d0((LONG *)(param_1 + 0x14));
  return;
}



// Function: FUN_1001afd0 at 1001afd0

void __thiscall FUN_1001afd0(void *this,int param_1,undefined4 *param_2,undefined4 *param_3)

{
  void *pvVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c623;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
                    /* WARNING: Load size is inaccurate */
  pvVar1 = (void *)FUN_10015b90(4,*this + param_1 * 4);
  local_8 = 0;
  if (pvVar1 != (void *)0x0) {
    FUN_10016340(pvVar1,param_2);
  }
  local_8 = 0xffffffff;
  pvVar1 = (void *)FUN_10015ba0(4,*(int *)((int)this + 4) + param_1 * 4);
  local_8 = 1;
  if (pvVar1 != (void *)0x0) {
    FUN_10016360(pvVar1,param_3);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_1001b0a0 at 1001b0a0

void FUN_1001b0a0(int param_1,uint param_2,undefined4 param_3,undefined4 param_4,undefined2 param_5,
                 undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)

{
  FUN_1000bc70(param_1 + -4,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  return;
}



// Function: FUN_1001b0aa at 1001b0aa

void FUN_1001b0aa(int param_1,uint param_2,undefined4 param_3,undefined4 param_4,undefined2 param_5,
                 undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)

{
  FUN_1000bc70(param_1 + -8,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  return;
}



// Function: FUN_1001b0b4 at 1001b0b4

void FUN_1001b0b4(int param_1,uint param_2,undefined4 param_3,undefined4 param_4,undefined2 param_5,
                 undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)

{
  FUN_1000bc70(param_1 + -0xc,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  return;
}



// Function: FUN_1001b0c0 at 1001b0c0

bool __cdecl FUN_1001b0c0(LPCSTR param_1,LPCSTR param_2)

{
  int iVar1;
  
  iVar1 = lstrcmpiA(param_1,param_2);
  return iVar1 == 0;
}



// Function: FUN_1001b0e0 at 1001b0e0

undefined4 FUN_1001b0e0(undefined1 param_1)

{
  undefined4 uVar1;
  
  switch(param_1) {
  case 9:
  case 10:
  case 0xd:
  case 0x20:
    uVar1 = 1;
    break;
  default:
    uVar1 = 0;
  }
  return uVar1;
}



// Function: FUN_1001b140 at 1001b140

void __fastcall FUN_1001b140(undefined4 *param_1)

{
  Ordinal_7(*param_1);
  return;
}



// Function: FUN_1001b160 at 1001b160

void __fastcall FUN_1001b160(int param_1)

{
  FUN_100120d0((LONG *)(param_1 + 8));
  return;
}



// Function: FUN_1001b180 at 1001b180

undefined4 FUN_1001b180(void)

{
  return 0;
}



// Function: FUN_1001b190 at 1001b190

undefined4 FUN_1001b190(undefined4 param_1,int param_2)

{
  if (param_2 == 0) {
    (**(code **)(*DAT_100403a8 + 8))();
  }
  else {
    (**(code **)(*DAT_100403a8 + 4))();
  }
  return 0;
}



// Function: FUN_1001b1d0 at 1001b1d0

undefined4 FUN_1001b1d0(undefined4 param_1,int param_2)

{
  if (param_2 == 0) {
    (**(code **)(*DAT_100403a8 + 8))();
  }
  else {
    (**(code **)(*DAT_100403a8 + 4))();
  }
  return 0;
}



// Function: FUN_1001b210 at 1001b210

undefined4 __thiscall FUN_1001b210(void *this,undefined4 *param_1)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  
  iVar1 = FUN_1001a820(this,param_1);
  if (iVar1 == -1) {
    uVar2 = 0;
  }
  else {
    puVar3 = (undefined4 *)FUN_1001ade0(this,iVar1);
    uVar2 = *puVar3;
  }
  return uVar2;
}



// Function: FUN_1001b250 at 1001b250

undefined4 __thiscall FUN_1001b250(void *this,undefined1 *param_1)

{
  undefined1 *puVar1;
  undefined4 uVar2;
  LPSTR pCVar3;
  int iVar4;
  int local_18;
  int local_14;
  undefined1 *local_10;
  undefined1 *local_c;
  
  puVar1 = param_1;
  FUN_1001db70((undefined4 *)this);
                    /* WARNING: Load size is inaccurate */
  if (**this == '\0') {
    uVar2 = FUN_1001a940();
  }
  else {
                    /* WARNING: Load size is inaccurate */
    if (**this == '\'') {
                    /* WARNING: Load size is inaccurate */
      pCVar3 = CharNextA(*this);
      *(LPSTR *)this = pCVar3;
                    /* WARNING: Load size is inaccurate */
      while ((**this != '\0' && (iVar4 = FUN_1001a6b0((undefined4 *)this), iVar4 == 0))) {
                    /* WARNING: Load size is inaccurate */
        if (**this == '\'') {
                    /* WARNING: Load size is inaccurate */
          pCVar3 = CharNextA(*this);
          *(LPSTR *)this = pCVar3;
        }
                    /* WARNING: Load size is inaccurate */
        local_c = *this;
                    /* WARNING: Load size is inaccurate */
        pCVar3 = CharNextA(*this);
        *(LPSTR *)this = pCVar3;
                    /* WARNING: Load size is inaccurate */
        iVar4 = *this - (int)local_c;
        if (puVar1 + 0x1000 <= param_1 + iVar4 + 1) {
          uVar2 = FUN_1001a940();
          return uVar2;
        }
        for (local_14 = 0; local_14 < iVar4; local_14 = local_14 + 1) {
          *param_1 = *local_c;
          param_1 = param_1 + 1;
          local_c = local_c + 1;
        }
      }
                    /* WARNING: Load size is inaccurate */
      if (**this == '\0') {
        uVar2 = FUN_1001a940();
        return uVar2;
      }
      *param_1 = 0;
                    /* WARNING: Load size is inaccurate */
      pCVar3 = CharNextA(*this);
      *(LPSTR *)this = pCVar3;
    }
    else {
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
      while ((**this != '\0' && (iVar4 = FUN_1001b0e0(**this), iVar4 == 0))) {
                    /* WARNING: Load size is inaccurate */
        local_10 = *this;
                    /* WARNING: Load size is inaccurate */
        pCVar3 = CharNextA(*this);
        *(LPSTR *)this = pCVar3;
                    /* WARNING: Load size is inaccurate */
        iVar4 = *this - (int)local_10;
        if (puVar1 + 0x1000 <= param_1 + iVar4 + 1) {
          uVar2 = FUN_1001a940();
          return uVar2;
        }
        for (local_18 = 0; local_18 < iVar4; local_18 = local_18 + 1) {
          *param_1 = *local_10;
          param_1 = param_1 + 1;
          local_10 = local_10 + 1;
        }
      }
      *param_1 = 0;
    }
    uVar2 = 0;
  }
  return uVar2;
}



// Function: FUN_1001b470 at 1001b470

long __thiscall FUN_1001b470(void *this,HKEY param_1,LPCSTR param_2,REGSAM param_3)

{
  int local_14;
  long local_10;
  HKEY local_c;
  CRegKey *local_8;
  
  local_c = (HKEY)0x0;
  local_8 = (CRegKey *)this;
  if (*(int *)((int)this + 8) == 0) {
    local_14 = RegOpenKeyExA(param_1,param_2,0,param_3,&local_c);
  }
  else {
    local_14 = FUN_1001bd40(*(void **)((int)this + 8),param_1,param_2,0,param_3,&local_c);
  }
  local_10 = local_14;
  if (local_14 == 0) {
    local_10 = ATL::CRegKey::Close(local_8);
    *(HKEY *)local_8 = local_c;
  }
  return local_10;
}



// Function: FUN_1001b500 at 1001b500

void __thiscall FUN_1001b500(void *this,char *param_1,undefined4 *param_2)

{
  size_t sVar1;
  LPSTR pCVar2;
  int iVar3;
  wchar_t *pwVar4;
  undefined4 uVar5;
  undefined4 local_5c [2];
  int local_54;
  char *local_50;
  LPCSTR local_4c;
  int local_48;
  char local_41;
  int local_40;
  char local_3a;
  char local_39;
  int *local_38;
  undefined1 local_34 [32];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c648;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_38 = (int *)this;
  if ((param_1 != (char *)0x0) && (param_2 != (undefined4 *)0x0)) {
    *param_2 = 0;
    sVar1 = strlen(param_1);
    FUN_10016670(local_5c,sVar1 << 1);
    local_8 = 0;
    if (local_54 == 0) {
      local_8 = 0xffffffff;
      FUN_10016f40((int)local_5c);
    }
    else {
      *local_38 = (int)param_1;
      local_40 = 0;
      local_41 = '\0';
      local_40 = FUN_10018b70(&local_41);
      if (local_40 < 0) {
        local_8 = 0xffffffff;
        FUN_10016f40((int)local_5c);
      }
      else {
        local_48 = 0;
        local_3a = '\0';
        local_39 = '\0';
        while (*(char *)*local_38 != '\0') {
          if (local_41 == '\x01') {
            if (local_48 == 0) {
              local_50 = (char *)0x0;
              local_50 = _tcschr((char *)*local_38,0x10033ae0);
              if ((local_50 != (char *)0x0) && (local_50 == (char *)*local_38)) {
                pCVar2 = CharNextA((LPCSTR)*local_38);
                *local_38 = (int)pCVar2;
                pCVar2 = CharNextA((LPCSTR)*local_38);
                *local_38 = (int)pCVar2;
                pCVar2 = CharNextA((LPCSTR)*local_38);
                *local_38 = (int)pCVar2;
                pCVar2 = CharNextA((LPCSTR)*local_38);
                *local_38 = (int)pCVar2;
                iVar3 = FUN_10017ad0(local_5c,L"HKCU\r\n{\tSoftware\r\n\t{\r\n\t\tClasses");
                if (iVar3 == 0) {
                  local_40 = -0x7ff8fff2;
                  break;
                }
                local_3a = '\x01';
              }
            }
            if (*(char *)*local_38 == '\'') {
              if (local_39 == '\0') {
                local_39 = '\x01';
              }
              else {
                iVar3 = FUN_1001a6b0(local_38);
                if (iVar3 == 0) {
                  pCVar2 = CharNextA((LPCSTR)*local_38);
                  *local_38 = (int)pCVar2;
                  iVar3 = FUN_100177a0(local_5c,(LPCSTR)*local_38);
                  if (iVar3 == 0) {
                    local_40 = -0x7ff8fff2;
                    break;
                  }
                }
                else {
                  local_39 = '\0';
                }
              }
            }
            if ((local_39 == '\0') && (*(char *)*local_38 == '{')) {
              local_48 = local_48 + 1;
            }
            if ((((local_39 == '\0') && (*(char *)*local_38 == '}')) &&
                (local_48 = local_48 + -1, local_48 == 0)) && (local_3a == '\x01')) {
              iVar3 = FUN_10017ad0(local_5c,L"\r\n\t}\r\n}\r\n");
              if (iVar3 == 0) {
                local_40 = -0x7ff8fff2;
                break;
              }
              local_3a = '\0';
            }
          }
          if (*(char *)*local_38 == '%') {
            pCVar2 = CharNextA((LPCSTR)*local_38);
            *local_38 = (int)pCVar2;
            if (*(char *)*local_38 == '%') {
              iVar3 = FUN_100177a0(local_5c,(LPCSTR)*local_38);
              if (iVar3 == 0) {
                local_40 = -0x7ff8fff2;
                break;
              }
            }
            else {
              local_4c = FUN_1001dbb0((LPSTR)*local_38,'%');
              if (local_4c == (LPCSTR)0x0) {
                local_40 = FUN_1001a940();
                break;
              }
              if (0x1f < (int)local_4c - *local_38) {
                local_40 = -0x7fffbffb;
                break;
              }
              ATL::Checked::memmove_s(local_34,0x20,(void *)*local_38,(int)local_4c - *local_38);
              pwVar4 = (wchar_t *)FUN_1001dc00(local_38[1]);
              if (pwVar4 == (wchar_t *)0x0) {
                local_40 = FUN_1001a940();
                break;
              }
              iVar3 = FUN_10017ad0(local_5c,pwVar4);
              if (iVar3 == 0) {
                local_40 = -0x7ff8fff2;
                break;
              }
              while ((LPCSTR)*local_38 != local_4c) {
                pCVar2 = CharNextA((LPCSTR)*local_38);
                *local_38 = (int)pCVar2;
              }
            }
          }
          else {
            iVar3 = FUN_100177a0(local_5c,(LPCSTR)*local_38);
            if (iVar3 == 0) {
              local_40 = -0x7ff8fff2;
              break;
            }
          }
          pCVar2 = CharNextA((LPCSTR)*local_38);
          *local_38 = (int)pCVar2;
        }
        if (-1 < local_40) {
          uVar5 = FUN_1001a630(local_5c);
          *param_2 = uVar5;
        }
        local_8 = 0xffffffff;
        FUN_10016f40((int)local_5c);
      }
    }
  }
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001b910 at 1001b910

long FUN_1001b910(int *param_1,_GUID *param_2,void **param_3)

{
  int iVar1;
  long local_8;
  
  if (param_3 == (void **)0x0) {
    local_8 = -0x7fffbffd;
  }
  else {
    *param_3 = (void *)0x0;
    local_8 = 0;
    iVar1 = FUN_10012190((int *)param_2);
    if (iVar1 == 0) {
      local_8 = ATL::CAccessibleProxy::_InternalQueryInterface
                          ((CAccessibleProxy *)(param_1 + 3),param_2,param_3);
    }
    else {
      *param_3 = param_1;
      (**(code **)(*param_1 + 4))(param_1);
    }
  }
  return local_8;
}



// Function: FUN_1001b980 at 1001b980

void FUN_1001b980(int param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_10012910((void *)(param_1 + 0x14),param_2,param_3);
  return;
}



// Function: FUN_1001b99a at 1001b99a

void FUN_1001b99a(int param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_1001b980(param_1 + -4,param_2,param_3);
  return;
}



// Function: FUN_1001b9a4 at 1001b9a4

void FUN_1001b9a4(int param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_1001b980(param_1 + -8,param_2,param_3);
  return;
}



// Function: FUN_1001b9ae at 1001b9ae

void FUN_1001b9ae(int param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_1001b980(param_1 + -0x10,param_2,param_3);
  return;
}



// Function: FUN_1001b9b8 at 1001b9b8

void FUN_1001b9b8(int param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_1001b980(param_1 + -0xc,param_2,param_3);
  return;
}



// Function: QueryInterface at 1001b9d0

/* Library Function - Single Match
    public: virtual long __stdcall CMFCComObject<class ATL::CAccessibleProxy>::QueryInterface(struct
   _GUID const &,void * *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

long CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface(_GUID *param_1,void **param_2)

{
  long lVar1;
  void **in_stack_0000000c;
  
  lVar1 = ATL::CAccessibleProxy::_InternalQueryInterface
                    ((CAccessibleProxy *)param_1,(_GUID *)param_2,in_stack_0000000c);
  return lVar1;
}



// Function: FUN_1001b9e7 at 1001b9e7

void FUN_1001b9e7(int param_1,void **param_2)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface((_GUID *)(param_1 + -4),param_2);
  return;
}



// Function: FUN_1001b9f1 at 1001b9f1

void FUN_1001b9f1(int param_1,void **param_2)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface((_GUID *)(param_1 + -8),param_2);
  return;
}



// Function: FUN_1001b9fb at 1001b9fb

void FUN_1001b9fb(int param_1,void **param_2)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface((_GUID *)(param_1 + -0x10),param_2);
  return;
}



// Function: FUN_1001ba05 at 1001ba05

void FUN_1001ba05(int param_1,void **param_2)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface((_GUID *)(param_1 + -0xc),param_2);
  return;
}



// Function: QueryInterface at 1001ba10

/* Library Function - Single Match
    public: virtual long __stdcall CMFCComObject<class ATL::CAccessibleProxy>::QueryInterface(struct
   _GUID const &,void * *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

long CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface(_GUID *param_1,void **param_2)

{
  long lVar1;
  void **in_stack_0000000c;
  
  lVar1 = ATL::CAccessibleProxy::_InternalQueryInterface
                    ((CAccessibleProxy *)param_1,(_GUID *)param_2,in_stack_0000000c);
  return lVar1;
}



// Function: QueryInterface at 1001ba30

/* Library Function - Single Match
    public: virtual long __stdcall CMFCComObject<class ATL::CAccessibleProxy>::QueryInterface(struct
   _GUID const &,void * *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

long CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface(_GUID *param_1,void **param_2)

{
  long lVar1;
  void **in_stack_0000000c;
  
  lVar1 = ATL::CAccessibleProxy::_InternalQueryInterface
                    ((CAccessibleProxy *)param_1,(_GUID *)param_2,in_stack_0000000c);
  return lVar1;
}



// Function: FUN_1001ba50 at 1001ba50

undefined4 FUN_1001ba50(void)

{
  return 0x80004001;
}



// Function: FUN_1001ba60 at 1001ba60

void FUN_1001ba60(LPCSTR param_1)

{
  LSTATUS LVar1;
  _FILETIME local_140;
  undefined4 local_138;
  long local_134;
  int local_130;
  HKEY local_12c [3];
  DWORD local_120;
  undefined4 *local_11c;
  long local_118;
  CHAR local_114 [256];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c67b;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  ATL::CRegKey::CRegKey((CRegKey *)local_12c,(CAtlTransactionManager *)0x0);
  local_8 = 0;
  local_118 = FUN_1001b470(local_12c,(HKEY)*local_11c,param_1,local_11c[1] | 0x2001f);
  if (local_118 == 0) {
    do {
      local_120 = 0x100;
      LVar1 = RegEnumKeyExA(local_12c[0],0,local_114,&local_120,(LPDWORD)0x0,(LPSTR)0x0,(LPDWORD)0x0
                            ,&local_140);
      if (LVar1 != 0) {
        ATL::CRegKey::Close((CRegKey *)local_12c);
        local_138 = FUN_1001a550(local_11c,param_1);
        local_8 = 0xffffffff;
        FUN_10016f60((CRegKey *)local_12c);
        goto LAB_1001bbcb;
      }
      local_118 = FUN_1001ba60(local_114);
    } while (local_118 == 0);
    local_8 = 0xffffffff;
    local_130 = local_118;
    FUN_10016f60((CRegKey *)local_12c);
  }
  else {
    local_8 = 0xffffffff;
    local_134 = local_118;
    FUN_10016f60((CRegKey *)local_12c);
  }
LAB_1001bbcb:
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001bbf0 at 1001bbf0

LSTATUS __thiscall
FUN_1001bbf0(void *this,HKEY param_1,LPCSTR param_2,DWORD param_3,LPSTR param_4,DWORD param_5,
            REGSAM param_6,LPSECURITY_ATTRIBUTES param_7,PHKEY param_8,LPDWORD param_9)

{
  HMODULE hModule;
  FARPROC pFVar1;
  int iVar2;
  LSTATUS LVar3;
  
                    /* WARNING: Load size is inaccurate */
  if (*this == 0) {
    if (*(int *)((int)this + 4) != 0) {
      LVar3 = RegCreateKeyExA(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,
                              param_9);
      return LVar3;
    }
  }
  else {
    hModule = GetModuleHandleA("Advapi32.dll");
    if (hModule == (HMODULE)0x0) {
      return 1;
    }
    pFVar1 = GetProcAddress(hModule,"RegCreateKeyTransactedA");
    if (pFVar1 != (FARPROC)0x0) {
                    /* WARNING: Load size is inaccurate */
      iVar2 = (*pFVar1)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,
                        *this,0);
      return iVar2;
    }
  }
  return 1;
}



// Function: FUN_1001bcb0 at 1001bcb0

LSTATUS __thiscall FUN_1001bcb0(void *this,HKEY param_1,LPCSTR param_2)

{
  HMODULE hModule;
  FARPROC pFVar1;
  int iVar2;
  LSTATUS LVar3;
  
                    /* WARNING: Load size is inaccurate */
  if (*this == 0) {
    if (*(int *)((int)this + 4) != 0) {
      LVar3 = RegDeleteKeyA(param_1,param_2);
      return LVar3;
    }
  }
  else {
    hModule = GetModuleHandleA("Advapi32.dll");
    if (hModule == (HMODULE)0x0) {
      return 1;
    }
    pFVar1 = GetProcAddress(hModule,"RegDeleteKeyTransactedA");
    if (pFVar1 != (FARPROC)0x0) {
                    /* WARNING: Load size is inaccurate */
      iVar2 = (*pFVar1)(param_1,param_2,0,0,*this,0);
      return iVar2;
    }
  }
  return 1;
}



// Function: FUN_1001bd40 at 1001bd40

LSTATUS __thiscall
FUN_1001bd40(void *this,HKEY param_1,LPCSTR param_2,DWORD param_3,REGSAM param_4,PHKEY param_5)

{
  HMODULE hModule;
  FARPROC pFVar1;
  int iVar2;
  LSTATUS LVar3;
  
                    /* WARNING: Load size is inaccurate */
  if (*this == 0) {
    if (*(int *)((int)this + 4) != 0) {
      LVar3 = RegOpenKeyExA(param_1,param_2,param_3,param_4,param_5);
      return LVar3;
    }
  }
  else {
    hModule = GetModuleHandleA("Advapi32.dll");
    if (hModule == (HMODULE)0x0) {
      return 1;
    }
    pFVar1 = GetProcAddress(hModule,"RegOpenKeyTransactedA");
    if (pFVar1 != (FARPROC)0x0) {
                    /* WARNING: Load size is inaccurate */
      iVar2 = (*pFVar1)(param_1,param_2,param_3,param_4,param_5,*this,0);
      return iVar2;
    }
  }
  return 1;
}



// Function: FUN_1001bde0 at 1001bde0

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __thiscall FUN_1001bde0(void *this,char *param_1,int param_2)

{
  undefined4 uVar1;
  LPVOID local_1018;
  HKEY local_1014;
  undefined4 *local_1010;
  int local_100c;
  char local_1008 [4096];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_100c = 0;
  local_1018 = (LPVOID)0x0;
  local_1010 = (undefined4 *)this;
  local_100c = FUN_1001b500(this,param_1,&local_1018);
  if (-1 < local_100c) {
    *local_1010 = local_1018;
    while( true ) {
      if ((*(char *)*local_1010 == '\0') ||
         (local_100c = FUN_1001b250(local_1010,local_1008), local_100c < 0)) goto LAB_1001bfc8;
      local_1014 = (HKEY)FUN_1001ae20(local_1008);
      if (local_1014 == (HKEY)0x0) break;
      local_100c = FUN_1001b250(local_1010,local_1008);
      if (local_100c < 0) goto LAB_1001bfc8;
      if (local_1008[0] != '{') {
        local_100c = FUN_1001a940();
        goto LAB_1001bfc8;
      }
      if (param_2 == 0) {
        local_100c = FUN_1001c4e0(local_1008,local_1014,0,0);
        if (local_100c < 0) goto LAB_1001bfc8;
      }
      else {
        uVar1 = *local_1010;
        local_100c = FUN_1001c4e0(local_1008,local_1014,param_2,0);
        if (local_100c < 0) {
          *local_1010 = uVar1;
          FUN_1001c4e0(local_1008,local_1014,0,0);
          goto LAB_1001bfc8;
        }
      }
      FUN_1001db70(local_1010);
    }
    local_100c = FUN_1001a940();
LAB_1001bfc8:
    CoTaskMemFree(local_1018);
  }
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001bff0 at 1001bff0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_1001bff0(wchar_t *param_1,LPCSTR param_2,LPCSTR param_3)

{
  char cVar1;
  size_t sVar2;
  long lVar3;
  uint uStack_47c;
  undefined1 local_46c [8];
  undefined4 local_464;
  undefined1 *local_460;
  undefined4 local_45c;
  undefined4 uStack_458;
  HGLOBAL local_454;
  UINT local_450;
  LPCSTR local_44c;
  LPSTR local_448;
  HGLOBAL local_444;
  LPSTR local_440;
  LPCSTR local_43c;
  HRSRC local_438;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_434 [4];
  wchar_t *local_430;
  undefined4 local_42c;
  DWORD local_428;
  ulong local_424;
  HMODULE local_420;
  int local_41c [257];
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c6c6;
  local_10 = ExceptionList;
  uStack_47c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_47c;
  ExceptionList = &local_10;
  local_18 = uStack_47c;
  local_450 = FUN_10012f50();
  FUN_1000d590((undefined4 *)local_434);
  local_8 = 0;
  FUN_100167a0(local_46c,local_464);
  FUN_10016300(local_41c);
  local_8._0_1_ = 1;
  local_430 = param_1;
  if (param_1 == (wchar_t *)0x0) {
    local_44c = (LPCSTR)0x0;
    goto LAB_1001c15a;
  }
  sVar2 = wcslen(param_1);
  local_424 = sVar2 + 1;
  lVar3 = ATL::AtlMultiply<int>((int *)&local_424,local_424,2);
  if (lVar3 < 0) {
    local_440 = (LPSTR)0x0;
  }
  else {
    if ((int)local_424 < 0x401) {
      cVar1 = FUN_10012fe0(local_424);
      if (cVar1 == '\0') goto LAB_1001c10f;
      local_460 = (undefined1 *)&uStack_47c;
      local_448 = (LPSTR)&uStack_47c;
      local_14 = (undefined1 *)&uStack_47c;
    }
    else {
LAB_1001c10f:
      local_448 = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                         CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                   (local_434,local_424);
    }
    local_440 = FUN_10019d50(local_448,local_430,local_424,local_450);
  }
  local_44c = local_440;
LAB_1001c15a:
  local_43c = local_44c;
  if (local_44c == (LPCSTR)0x0) {
    local_45c = 0x8007000e;
    local_8 = (uint)local_8._1_3_ << 8;
    ~CTempBuffer<>(local_41c);
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_434);
  }
  else {
    local_420 = LoadLibraryExA(local_44c,(HANDLE)0x0,0x60);
    if (local_420 == (HMODULE)0x0) {
      local_420 = LoadLibraryExA(local_43c,(HANDLE)0x0,2);
    }
    if (local_420 == (HMODULE)0x0) {
      local_42c = FUN_10018ba0();
    }
    else {
      local_438 = FindResourceA(local_420,param_2,param_3);
      if (local_438 == (HRSRC)0x0) {
        local_42c = FUN_10018ba0();
      }
      else {
        local_444 = LoadResource(local_420,local_438);
        if (local_444 == (HGLOBAL)0x0) {
          local_42c = FUN_10018ba0();
        }
        else {
          local_428 = SizeofResource(local_420,local_438);
          local_454 = local_444;
          if (local_428 <= local_428 + 1) {
            local_8 = CONCAT31(local_8._1_3_,2);
            Allocate(local_41c,local_428 + 1);
            FUN_1001c2c3();
            return;
          }
          local_42c = 0x8007000e;
        }
      }
    }
    if (local_420 != (HMODULE)0x0) {
      FreeLibrary(local_420);
    }
    uStack_458 = local_42c;
    local_8 = (uint)local_8._1_3_ << 8;
    ~CTempBuffer<>(local_41c);
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_434);
  }
  ExceptionList = local_10;
  __security_check_cookie(local_18 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: Catch@1001c2bd at 1001c2bd

undefined * Catch_1001c2bd(void)

{
  return &DAT_1001c2cc;
}



// Function: FUN_1001c2c3 at 1001c2c3

/* WARNING: Unable to track spacebase fully for stack */

void FUN_1001c2c3(void)

{
  uint uVar1;
  int iVar2;
  void *pvVar3;
  char *pcVar4;
  undefined4 uVar5;
  uint unaff_EBP;
  rsize_t rVar6;
  void *pvVar7;
  rsize_t rVar8;
  
  *(undefined4 *)(unaff_EBP - 4) = 1;
  iVar2 = FUN_100171d0((undefined4 *)(unaff_EBP - 0x418));
  if (iVar2 == 0) {
    *(undefined4 *)(unaff_EBP - 0x428) = 0x8007000e;
  }
  else {
    rVar8 = *(rsize_t *)(unaff_EBP - 0x424);
    pvVar7 = *(void **)(unaff_EBP - 0x450);
    rVar6 = *(rsize_t *)(unaff_EBP - 0x424);
    pvVar3 = (void *)FUN_100171d0((undefined4 *)(unaff_EBP - 0x418));
    FUN_1001ee20(pvVar3,rVar6,pvVar7,rVar8);
    iVar2 = FUN_100171d0((undefined4 *)(unaff_EBP - 0x418));
    *(undefined1 *)(iVar2 + *(int *)(unaff_EBP - 0x424)) = 0;
    iVar2 = *(int *)(unaff_EBP + 0x14);
    pcVar4 = (char *)FUN_100171d0((undefined4 *)(unaff_EBP - 0x418));
    uVar5 = FUN_1001bde0((void *)(unaff_EBP - 0x468),pcVar4,iVar2);
    *(undefined4 *)(unaff_EBP - 0x428) = uVar5;
  }
  if (*(int *)(unaff_EBP - 0x41c) != 0) {
    FreeLibrary(*(HMODULE *)(unaff_EBP - 0x41c));
  }
  *(undefined4 *)(unaff_EBP - 0x454) = *(undefined4 *)(unaff_EBP - 0x428);
  *(undefined1 *)(unaff_EBP - 4) = 0;
  ~CTempBuffer<>((int *)(unaff_EBP - 0x418));
  *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP - 0x430));
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uVar1 = *(uint *)(unaff_EBP - 0x14);
  *(undefined4 *)(unaff_EBP - 0x46c) = 0x1001c3b4;
  __security_check_cookie(uVar1 ^ unaff_EBP);
  return;
}



// Function: FUN_1001c3c0 at 1001c3c0

int FUN_1001c3c0(int param_1,void *param_2)

{
  int local_8;
  
  local_8 = FUN_1001c410(&DAT_10040558,param_1,param_2);
  if ((-1 < local_8) && (DAT_100403c4 != (code *)0x0)) {
    local_8 = (*DAT_100403c4)(DAT_10040524);
  }
  return local_8;
}



// Function: FUN_1001c410 at 1001c410

void __thiscall FUN_1001c410(void *this,int param_1,void *param_2)

{
  FUN_10018920((int)this,param_1,param_2);
  return;
}



// Function: FUN_1001c430 at 1001c430

int __thiscall FUN_1001c430(void *this,int param_1,void *param_2)

{
  bool bVar1;
  undefined3 extraout_var;
  int *piVar2;
  int iVar3;
  int local_c;
  int *local_8;
  
  local_c = 0;
  local_8 = *(int **)((int)this + 0x2c);
  if (local_8 != (int *)0x0) {
    for (; *local_8 != 0; local_8 = local_8 + 9) {
      if ((param_2 == (void *)0x0) ||
         (bVar1 = FUN_1001ef60(param_2,(void *)*local_8), CONCAT31(extraout_var,bVar1) != 0)) {
        local_c = (*(code *)local_8[1])(1);
        if (local_c < 0) break;
        iVar3 = 1;
        piVar2 = (int *)(*(code *)local_8[7])();
        local_c = FUN_10019280((GUID *)*local_8,piVar2,iVar3);
        if (local_c < 0) break;
      }
    }
  }
  if (-1 < local_c) {
    local_c = FUN_1001c3c0(param_1,param_2);
  }
  return local_c;
}



// Function: FUN_1001c4e0 at 1001c4e0

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void FUN_1001c4e0(LPCSTR param_1,HKEY param_2,int param_3,int param_4)

{
  bool bVar1;
  int iVar2;
  LPCSTR pCVar3;
  HKEY pHVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  size_t sVar5;
  CRegKey local_1184 [12];
  int local_1178;
  CRegKey local_1174 [12];
  int local_1168;
  CRegKey local_1164 [12];
  int local_1158;
  undefined4 local_1154;
  undefined4 local_1150;
  undefined4 local_114c;
  uint local_1148;
  CRegKey local_1144 [12];
  uint local_1138;
  int local_1134;
  HKEY local_1130 [3];
  void *local_1124;
  ulong local_1120;
  int local_111c;
  CHAR local_1118 [4096];
  CHAR local_118 [260];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c727;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  ATL::CRegKey::CRegKey((CRegKey *)local_1130,(CAtlTransactionManager *)0x0);
  local_8 = 0;
  local_1134 = 1;
  local_1158 = param_4;
  local_111c = 0;
  local_111c = FUN_1001b250(local_1124,param_1);
  if (-1 < local_111c) {
LAB_1001c58d:
    if (*param_1 == '}') goto LAB_1001ce84;
    local_1134 = 1;
    iVar2 = lstrcmpiA(param_1,"Delete");
    local_1138 = (uint)(iVar2 == 0);
    local_1148 = local_1138;
    iVar2 = lstrcmpiA(param_1,"ForceRemove");
    if ((iVar2 == 0) || (local_1148 != 0)) {
      local_111c = FUN_1001b250(local_1124,param_1);
      if (local_111c < 0) goto LAB_1001ce84;
      if (param_3 == 0) goto LAB_1001c75d;
      ATL::CRegKey::CRegKey(local_1144,(CAtlTransactionManager *)0x0);
      local_8._0_1_ = 1;
      pCVar3 = FUN_1001dbb0(param_1,'\\');
      if (pCVar3 == (LPCSTR)0x0) {
        iVar2 = FUN_10019e10(param_1);
        if (iVar2 != 0) {
          FUN_10019de0(local_1144,param_2);
          FUN_1001ba60(param_1);
          FUN_1001a670((undefined4 *)local_1144);
        }
        if (local_1148 == 0) {
          local_8 = (uint)local_8._1_3_ << 8;
          FUN_10016f60(local_1144);
          goto LAB_1001c75d;
        }
        local_111c = FUN_1001b250(local_1124,param_1);
        if (local_111c < 0) {
          local_8 = (uint)local_8._1_3_ << 8;
          FUN_10016f60(local_1144);
        }
        else {
          local_111c = FUN_1001dab0(local_1124,param_1);
          if (-1 < local_111c) {
            local_8 = (uint)local_8._1_3_ << 8;
            FUN_10016f60(local_1144);
            goto LAB_1001ce10;
          }
          local_8 = (uint)local_8._1_3_ << 8;
          FUN_10016f60(local_1144);
        }
        goto LAB_1001ce84;
      }
      local_1150 = FUN_1001a940();
      local_8 = (uint)local_8._1_3_ << 8;
      FUN_10016f60(local_1144);
      local_8 = 0xffffffff;
      FUN_10016f60((CRegKey *)local_1130);
      goto LAB_1001cea8;
    }
LAB_1001c75d:
    iVar2 = lstrcmpiA(param_1,"NoRemove");
    if (iVar2 == 0) {
      local_1134 = 0;
      local_111c = FUN_1001b250(local_1124,param_1);
      if (local_111c < 0) goto LAB_1001ce84;
    }
    iVar2 = lstrcmpiA(param_1,"Val");
    if (iVar2 == 0) {
      local_111c = FUN_1001b250(local_1124,local_1118);
      if ((local_111c < 0) || (local_111c = FUN_1001b250(local_1124,param_1), local_111c < 0))
      goto LAB_1001ce84;
      if (*param_1 != '=') {
        local_1154 = FUN_1001a940();
        local_8 = 0xffffffff;
        FUN_10016f60((CRegKey *)local_1130);
        goto LAB_1001cea8;
      }
      if (param_3 != 0) {
        ATL::CRegKey::CRegKey(local_1164,(CAtlTransactionManager *)0x0);
        local_8._0_1_ = 2;
        FUN_10019de0(local_1164,param_2);
        local_111c = FUN_10017c40(local_1124,local_1164,local_1118,param_1);
        FUN_1001a670((undefined4 *)local_1164);
        if (-1 < local_111c) {
          local_8 = (uint)local_8._1_3_ << 8;
          FUN_10016f60(local_1164);
          goto LAB_1001ce10;
        }
        local_8 = (uint)local_8._1_3_ << 8;
        FUN_10016f60(local_1164);
        local_8 = 0xffffffff;
        FUN_10016f60((CRegKey *)local_1130);
        goto LAB_1001cea8;
      }
      if ((param_4 == 0) && (local_1134 != 0)) {
        ATL::CRegKey::CRegKey(local_1174,(CAtlTransactionManager *)0x0);
        local_8._0_1_ = 3;
        local_1120 = FUN_1001b470(local_1174,param_2,(LPCSTR)0x0,0x20006);
        if (local_1120 != 0) {
          local_111c = FUN_10018bc0(local_1120);
          local_8 = (uint)local_8._1_3_ << 8;
          FUN_10016f60(local_1174);
          goto LAB_1001ce84;
        }
        local_1120 = FUN_1001a5a0(local_1174,local_1118);
        if ((local_1120 != 0) && (local_1120 != 2)) {
          local_111c = FUN_10018bc0(local_1120);
          local_8 = (uint)local_8._1_3_ << 8;
          FUN_10016f60(local_1174);
          goto LAB_1001ce84;
        }
        local_8 = (uint)local_8._1_3_ << 8;
        FUN_10016f60(local_1174);
      }
      local_111c = FUN_1001dab0(local_1124,param_1);
joined_r0x1001c9e7:
      if (local_111c < 0) goto LAB_1001ce84;
      goto LAB_1001c58d;
    }
    pCVar3 = FUN_1001dbb0(param_1,'\\');
    if (pCVar3 != (LPCSTR)0x0) {
      FUN_1001a940();
      local_8 = 0xffffffff;
      FUN_10016f60((CRegKey *)local_1130);
      goto LAB_1001cea8;
    }
    if (param_3 == 0) {
      if (param_4 == 0) {
        local_1120 = FUN_1001b470(local_1130,param_2,param_1,0x20019);
      }
      else {
        local_1120 = 2;
      }
      if (local_1120 != 0) {
        param_4 = 1;
      }
      ATL::Checked::memmove_s(local_118,0x104,param_1,0xffffffff);
      local_111c = FUN_1001b250(local_1124,param_1);
      if (((local_111c < 0) || (local_111c = FUN_1001dab0(local_1124,param_1), local_111c < 0)) ||
         (((*param_1 == '{' && (sVar5 = strlen(param_1), sVar5 == 1)) &&
          (((local_111c = FUN_1001c4e0(param_1,local_1130[0],0,param_4), local_111c < 0 &&
            (param_4 == 0)) || (local_111c = FUN_1001b250(local_1124,param_1), local_111c < 0))))))
      goto LAB_1001ce84;
      param_4 = local_1158;
      if (local_1120 == 2) goto LAB_1001c58d;
      if (local_1120 != 0) {
        if (local_1158 == 0) goto LAB_1001cc98;
        goto LAB_1001c58d;
      }
      if (local_1158 != 0) {
        pHVar4 = (HKEY)FUN_100171f0(local_1130);
        bVar1 = FUN_1001ae70(pHVar4);
        if (CONCAT31(extraout_var,bVar1) != 0) {
          iVar2 = FUN_10019e10(local_118);
          if ((iVar2 != 0) && (local_1134 != 0)) {
            FUN_1001ba60(local_118);
          }
          goto LAB_1001c58d;
        }
      }
      pHVar4 = (HKEY)FUN_100171f0(local_1130);
      bVar1 = FUN_1001ae70(pHVar4);
      local_1168 = CONCAT31(extraout_var_00,bVar1);
      local_1120 = ATL::CRegKey::Close((CRegKey *)local_1130);
      if (local_1120 != 0) {
        FUN_10018bc0(local_1120);
        local_8 = 0xffffffff;
        FUN_10016f60((CRegKey *)local_1130);
        goto LAB_1001cea8;
      }
      if ((local_1134 != 0) && (local_1168 == 0)) {
        ATL::CRegKey::CRegKey(local_1184,(CAtlTransactionManager *)0x0);
        local_8._0_1_ = 4;
        FUN_10019de0(local_1184,param_2);
        local_1120 = FUN_1001a550(local_1184,local_118);
        FUN_1001a670((undefined4 *)local_1184);
        if (local_1120 == 0) {
          local_8 = (uint)local_8._1_3_ << 8;
          FUN_10016f60(local_1184);
          goto LAB_1001ce10;
        }
        local_111c = FUN_10018bc0(local_1120);
        local_8 = (uint)local_8._1_3_ << 8;
        FUN_10016f60(local_1184);
        goto LAB_1001ce84;
      }
    }
    else {
      local_1120 = FUN_1001b470(local_1130,param_2,param_1,0x2001f);
      if (((local_1120 != 0) &&
          (local_1120 = FUN_1001b470(local_1130,param_2,param_1,0x20019), local_1120 != 0)) &&
         (local_1120 = FUN_1001a010(local_1130,param_2,param_1,(LPSTR)0x0,0,0x2001f,
                                    (LPSECURITY_ATTRIBUTES)0x0,(DWORD *)0x0), local_1120 != 0)) {
        local_114c = FUN_10018bc0(local_1120);
        local_8 = 0xffffffff;
        FUN_10016f60((CRegKey *)local_1130);
        goto LAB_1001cea8;
      }
      local_111c = FUN_1001b250(local_1124,param_1);
      if ((local_111c < 0) ||
         ((*param_1 == '=' &&
          (local_111c = FUN_10017c40(local_1124,local_1130,(LPCSTR)0x0,param_1), local_111c < 0))))
      goto LAB_1001ce84;
    }
LAB_1001ce10:
    if (((param_3 != 0) && (*param_1 == '{')) && (sVar5 = strlen(param_1), sVar5 == 1)) {
      local_111c = FUN_1001c4e0(param_1,local_1130[0],param_3,0);
      if (-1 < local_111c) {
        local_111c = FUN_1001b250(local_1124,param_1);
        goto joined_r0x1001c9e7;
      }
      goto LAB_1001ce84;
    }
    goto LAB_1001c58d;
  }
  local_8 = 0xffffffff;
  local_1178 = local_111c;
  FUN_10016f60((CRegKey *)local_1130);
LAB_1001cea8:
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
LAB_1001cc98:
  local_111c = FUN_10018bc0(local_1120);
LAB_1001ce84:
  local_8 = 0xffffffff;
  FUN_10016f60((CRegKey *)local_1130);
  goto LAB_1001cea8;
}



// Function: Release at 1001ced0

/* Library Function - Single Match
    public: virtual unsigned long __stdcall CMFCComObject<class
   ATL::CAccessibleProxy>::Release(void)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

ulong CMFCComObject<class_ATL::CAccessibleProxy>::Release(void)

{
  ulong uVar1;
  int *in_stack_00000004;
  
  uVar1 = FUN_100122f0(in_stack_00000004 + 1);
  if ((uVar1 == 0) && (in_stack_00000004 != (int *)0x0)) {
    (**(code **)(*in_stack_00000004 + 0xc))(1);
  }
  return uVar1;
}



// Function: FUN_1001cf20 at 1001cf20

void FUN_1001cf20(int param_1)

{
  FUN_10012940((undefined4 *)(param_1 + 0x14));
  return;
}



// Function: FUN_1001cf32 at 1001cf32

void FUN_1001cf32(int param_1)

{
  FUN_1001cf20(param_1 + -4);
  return;
}



// Function: FUN_1001cf3c at 1001cf3c

void FUN_1001cf3c(int param_1)

{
  FUN_1001cf20(param_1 + -8);
  return;
}



// Function: FUN_1001cf46 at 1001cf46

void FUN_1001cf46(int param_1)

{
  FUN_1001cf20(param_1 + -0x10);
  return;
}



// Function: FUN_1001cf50 at 1001cf50

void FUN_1001cf50(int param_1)

{
  FUN_1001cf20(param_1 + -0xc);
  return;
}



// Function: Release at 1001cf60

/* Library Function - Single Match
    public: virtual unsigned long __stdcall CMFCComObject<class
   ATL::CAccessibleProxy>::Release(void)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

ulong CMFCComObject<class_ATL::CAccessibleProxy>::Release(void)

{
  ulong uVar1;
  int *in_stack_00000004;
  
  uVar1 = FUN_100122d0(in_stack_00000004 + 5);
  if ((uVar1 == 0) && (in_stack_00000004 != (int *)0x0)) {
    (**(code **)(*in_stack_00000004 + 0x14))(1);
  }
  return uVar1;
}



// Function: FUN_1001cfb0 at 1001cfb0

void FUN_1001cfb0(void)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::Release();
  return;
}



// Function: FUN_1001cfba at 1001cfba

void FUN_1001cfba(void)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::Release();
  return;
}



// Function: FUN_1001cfc4 at 1001cfc4

void FUN_1001cfc4(void)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::Release();
  return;
}



// Function: FUN_1001cfce at 1001cfce

void FUN_1001cfce(void)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::Release();
  return;
}



// Function: FUN_1001cfe0 at 1001cfe0

int FUN_1001cfe0(int param_1)

{
  int iVar1;
  
  iVar1 = FUN_100122d0((LONG *)(param_1 + 4));
  if (iVar1 == 0) {
    if (param_1 != 0) {
      (*(code *)**(undefined4 **)(param_1 + 0x24 + *(int *)(*(int *)(param_1 + 0x24) + 4)))(1);
    }
  }
  else if (iVar1 == 1) {
    (**(code **)(*DAT_100403a8 + 8))();
  }
  return iVar1;
}



// Function: FUN_1001d070 at 1001d070

int FUN_1001d070(int *param_1)

{
  int iVar1;
  
  iVar1 = FUN_100122d0(param_1 + 1);
  if (iVar1 == 0) {
    if (param_1 != (int *)0x0) {
      (**(code **)(*param_1 + 0x14))(1);
    }
  }
  else if (iVar1 == 1) {
    (**(code **)(*DAT_100403a8 + 8))();
  }
  return iVar1;
}



// Function: FUN_1001d0e0 at 1001d0e0

undefined4 FUN_1001d0e0(void)

{
  return 0;
}



// Function: FUN_1001d0f0 at 1001d0f0

void __fastcall FUN_1001d0f0(int *param_1)

{
  int local_c;
  
  if (*param_1 != 0) {
    for (local_c = 0; local_c < param_1[2]; local_c = local_c + 1) {
    }
    free((void *)*param_1);
    *param_1 = 0;
  }
  if (param_1[1] != 0) {
    free((void *)param_1[1]);
    param_1[1] = 0;
  }
  param_1[2] = 0;
  return;
}



// Function: FUN_1001d170 at 1001d170

undefined4 FUN_1001d170(int param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  undefined4 local_8;
  
  if (param_3 == (int *)0x0) {
    local_8 = 0x80004003;
  }
  else {
    *param_3 = 0;
    iVar1 = FUN_10026df0(param_1 + 0x24 + *(int *)(*(int *)(param_1 + 0x24) + 4));
    if (iVar1 == 0) {
      local_8 = 0x80040112;
    }
    else {
      iVar1 = FUN_10026d70((void *)(param_1 + 0x24 + *(int *)(*(int *)(param_1 + 0x24) + 4)),param_2
                           ,param_3);
      if (iVar1 == 0) {
        local_8 = 0x80004005;
      }
      else {
        local_8 = 0;
      }
    }
  }
  return local_8;
}



// Function: FUN_1001d1f0 at 1001d1f0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_1001d1f0(undefined4 param_1,wchar_t *param_2,ushort param_3,wchar_t *param_4)

{
  char cVar1;
  size_t sVar2;
  long lVar3;
  uint local_44;
  undefined4 local_40;
  UINT local_3c;
  undefined4 local_38;
  undefined1 *local_34;
  LPCSTR local_30;
  LPSTR local_2c;
  LPSTR local_28;
  LPCSTR local_24;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_20 [4];
  wchar_t *local_1c;
  ulong local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c758;
  local_10 = ExceptionList;
  local_44 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_14 = local_44;
  local_3c = FUN_10012f50();
  FUN_1000d590((undefined4 *)local_20);
  local_8 = 0;
  local_1c = param_4;
  if (param_4 == (wchar_t *)0x0) {
    local_24 = (LPCSTR)0x0;
    goto LAB_1001d2d5;
  }
  sVar2 = wcslen(param_4);
  local_18 = sVar2 + 1;
  lVar3 = ATL::AtlMultiply<int>((int *)&local_18,local_18,2);
  if (lVar3 < 0) {
    local_2c = (LPSTR)0x0;
  }
  else {
    if ((int)local_18 < 0x401) {
      cVar1 = FUN_10012fe0(local_18);
      if (cVar1 == '\0') goto LAB_1001d2a8;
      local_34 = (undefined1 *)&local_44;
      local_28 = (LPSTR)&local_44;
    }
    else {
LAB_1001d2a8:
      local_28 = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                        CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                  (local_20,local_18);
    }
    local_2c = FUN_10019d50(local_28,local_1c,local_18,local_3c);
  }
  local_24 = local_2c;
LAB_1001d2d5:
  local_30 = local_24;
  if (local_24 == (LPCSTR)0x0) {
    local_38 = 0x8007000e;
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
  }
  else {
    local_40 = FUN_1001bff0(param_2,(LPCSTR)(uint)param_3,local_24);
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
  }
  ExceptionList = local_10;
  local_44 = 0x1001d340;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001d350 at 1001d350

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_1001d350(undefined4 param_1,wchar_t *param_2,wchar_t *param_3,wchar_t *param_4)

{
  char cVar1;
  size_t sVar2;
  long lVar3;
  uint local_5c;
  undefined4 local_58;
  undefined1 *local_54;
  undefined4 local_50;
  undefined1 *local_4c;
  undefined4 local_48;
  LPSTR local_44;
  LPSTR local_40;
  LPSTR local_3c;
  LPCSTR local_38;
  UINT local_34;
  LPSTR local_30;
  LPSTR local_2c;
  LPCSTR local_28;
  LPSTR local_24;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_20 [4];
  wchar_t *local_1c;
  ulong local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c788;
  local_10 = ExceptionList;
  local_5c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_14 = local_5c;
  local_34 = FUN_10012f50();
  FUN_1000d590((undefined4 *)local_20);
  local_8 = 0;
  if ((param_3 == (wchar_t *)0x0) || (param_4 == (wchar_t *)0x0)) {
    local_48 = 0x80070057;
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
    goto LAB_1001d563;
  }
  local_1c = param_3;
  if (param_3 == (wchar_t *)0x0) {
    local_3c = (LPSTR)0x0;
  }
  else {
    sVar2 = wcslen(param_3);
    local_18 = sVar2 + 1;
    lVar3 = ATL::AtlMultiply<int>((int *)&local_18,local_18,2);
    if (lVar3 < 0) {
      local_2c = (LPSTR)0x0;
    }
    else {
      if ((int)local_18 < 0x401) {
        cVar1 = FUN_10012fe0(local_18);
        if (cVar1 == '\0') goto LAB_1001d432;
        local_54 = (undefined1 *)&local_5c;
        local_40 = (LPSTR)&local_5c;
      }
      else {
LAB_1001d432:
        local_40 = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                          CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                    (local_20,local_18);
      }
      local_2c = FUN_10019d50(local_40,local_1c,local_18,local_34);
    }
    local_3c = local_2c;
  }
  local_30 = local_3c;
  local_1c = param_4;
  if (param_4 == (wchar_t *)0x0) {
    local_38 = (LPCSTR)0x0;
  }
  else {
    sVar2 = wcslen(param_4);
    local_18 = sVar2 + 1;
    lVar3 = ATL::AtlMultiply<int>((int *)&local_18,local_18,2);
    if (lVar3 < 0) {
      local_24 = (LPSTR)0x0;
    }
    else {
      if ((int)local_18 < 0x401) {
        cVar1 = FUN_10012fe0(local_18);
        if (cVar1 == '\0') goto LAB_1001d4de;
        local_4c = (undefined1 *)&local_5c;
        local_44 = (LPSTR)&local_5c;
      }
      else {
LAB_1001d4de:
        local_44 = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                          CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                    (local_20,local_18);
      }
      local_24 = FUN_10019d50(local_44,local_1c,local_18,local_34);
    }
    local_38 = local_24;
  }
  local_28 = local_38;
  if ((local_30 == (LPCSTR)0x0) || (local_38 == (LPCSTR)0x0)) {
    local_50 = 0x8007000e;
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
  }
  else {
    local_58 = FUN_1001bff0(param_2,local_30,local_38);
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
  }
LAB_1001d563:
  ExceptionList = local_10;
  local_5c = 0x1001d57b;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001d590 at 1001d590

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_1001d590(undefined4 param_1,wchar_t *param_2,ushort param_3,wchar_t *param_4)

{
  char cVar1;
  size_t sVar2;
  long lVar3;
  uint local_44;
  undefined4 local_40;
  UINT local_3c;
  undefined4 local_38;
  undefined1 *local_34;
  LPCSTR local_30;
  LPSTR local_2c;
  LPSTR local_28;
  LPCSTR local_24;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_20 [4];
  wchar_t *local_1c;
  ulong local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c7b8;
  local_10 = ExceptionList;
  local_44 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_14 = local_44;
  local_3c = FUN_10012f50();
  FUN_1000d590((undefined4 *)local_20);
  local_8 = 0;
  local_1c = param_4;
  if (param_4 == (wchar_t *)0x0) {
    local_24 = (LPCSTR)0x0;
    goto LAB_1001d675;
  }
  sVar2 = wcslen(param_4);
  local_18 = sVar2 + 1;
  lVar3 = ATL::AtlMultiply<int>((int *)&local_18,local_18,2);
  if (lVar3 < 0) {
    local_2c = (LPSTR)0x0;
  }
  else {
    if ((int)local_18 < 0x401) {
      cVar1 = FUN_10012fe0(local_18);
      if (cVar1 == '\0') goto LAB_1001d648;
      local_34 = (undefined1 *)&local_44;
      local_28 = (LPSTR)&local_44;
    }
    else {
LAB_1001d648:
      local_28 = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                        CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                  (local_20,local_18);
    }
    local_2c = FUN_10019d50(local_28,local_1c,local_18,local_3c);
  }
  local_24 = local_2c;
LAB_1001d675:
  local_30 = local_24;
  if (local_24 == (LPCSTR)0x0) {
    local_38 = 0x8007000e;
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
  }
  else {
    local_40 = FUN_1001bff0(param_2,(LPCSTR)(uint)param_3,local_24);
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
  }
  ExceptionList = local_10;
  local_44 = 0x1001d6e0;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001d6f0 at 1001d6f0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_1001d6f0(undefined4 param_1,wchar_t *param_2,wchar_t *param_3,wchar_t *param_4)

{
  char cVar1;
  size_t sVar2;
  long lVar3;
  uint local_5c;
  undefined4 local_58;
  undefined1 *local_54;
  undefined4 local_50;
  undefined1 *local_4c;
  undefined4 local_48;
  LPSTR local_44;
  LPSTR local_40;
  LPSTR local_3c;
  LPCSTR local_38;
  UINT local_34;
  LPSTR local_30;
  LPSTR local_2c;
  LPCSTR local_28;
  LPSTR local_24;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_20 [4];
  wchar_t *local_1c;
  ulong local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c7e8;
  local_10 = ExceptionList;
  local_5c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_14 = local_5c;
  local_34 = FUN_10012f50();
  FUN_1000d590((undefined4 *)local_20);
  local_8 = 0;
  if ((param_3 == (wchar_t *)0x0) || (param_4 == (wchar_t *)0x0)) {
    local_48 = 0x80070057;
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
    goto LAB_1001d903;
  }
  local_1c = param_3;
  if (param_3 == (wchar_t *)0x0) {
    local_3c = (LPSTR)0x0;
  }
  else {
    sVar2 = wcslen(param_3);
    local_18 = sVar2 + 1;
    lVar3 = ATL::AtlMultiply<int>((int *)&local_18,local_18,2);
    if (lVar3 < 0) {
      local_2c = (LPSTR)0x0;
    }
    else {
      if ((int)local_18 < 0x401) {
        cVar1 = FUN_10012fe0(local_18);
        if (cVar1 == '\0') goto LAB_1001d7d2;
        local_54 = (undefined1 *)&local_5c;
        local_40 = (LPSTR)&local_5c;
      }
      else {
LAB_1001d7d2:
        local_40 = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                          CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                    (local_20,local_18);
      }
      local_2c = FUN_10019d50(local_40,local_1c,local_18,local_34);
    }
    local_3c = local_2c;
  }
  local_30 = local_3c;
  local_1c = param_4;
  if (param_4 == (wchar_t *)0x0) {
    local_38 = (LPCSTR)0x0;
  }
  else {
    sVar2 = wcslen(param_4);
    local_18 = sVar2 + 1;
    lVar3 = ATL::AtlMultiply<int>((int *)&local_18,local_18,2);
    if (lVar3 < 0) {
      local_24 = (LPSTR)0x0;
    }
    else {
      if ((int)local_18 < 0x401) {
        cVar1 = FUN_10012fe0(local_18);
        if (cVar1 == '\0') goto LAB_1001d87e;
        local_4c = (undefined1 *)&local_5c;
        local_44 = (LPSTR)&local_5c;
      }
      else {
LAB_1001d87e:
        local_44 = (LPSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                          CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                    (local_20,local_18);
      }
      local_24 = FUN_10019d50(local_44,local_1c,local_18,local_34);
    }
    local_38 = local_24;
  }
  local_28 = local_38;
  if ((local_30 == (LPCSTR)0x0) || (local_38 == (LPCSTR)0x0)) {
    local_50 = 0x8007000e;
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
  }
  else {
    local_58 = FUN_1001bff0(param_2,local_30,local_38);
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_20);
  }
LAB_1001d903:
  ExceptionList = local_10;
  local_5c = 0x1001d91b;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001d930 at 1001d930

void __thiscall FUN_1001d930(void *this,LPCSTR param_1)

{
                    /* WARNING: Load size is inaccurate */
  RegSetValueExA(*this,param_1,0,4,&stack0x00000008,4);
  return;
}



// Function: FUN_1001d960 at 1001d960

LSTATUS __thiscall FUN_1001d960(void *this,LPCSTR param_1,BYTE *param_2)

{
  LSTATUS LVar1;
  size_t sVar2;
  int iVar3;
  DWORD local_10;
  BYTE *local_8;
  
  if (param_2 == (BYTE *)0x0) {
    LVar1 = 0xd;
  }
  else {
    local_10 = 0;
    local_8 = param_2;
    do {
      sVar2 = strlen((char *)local_8);
      iVar3 = sVar2 + 1;
      local_8 = local_8 + iVar3;
      local_10 = local_10 + iVar3;
    } while (iVar3 != 1);
                    /* WARNING: Load size is inaccurate */
    LVar1 = RegSetValueExA(*this,param_1,0,7,param_2,local_10);
  }
  return LVar1;
}



// Function: FUN_1001da00 at 1001da00

LSTATUS __thiscall FUN_1001da00(void *this,LPCSTR param_1,BYTE *param_2,DWORD param_3)

{
  LSTATUS LVar1;
  size_t sVar2;
  
  if (param_2 == (BYTE *)0x0) {
    LVar1 = 0xd;
  }
  else {
    sVar2 = strlen((char *)param_2);
                    /* WARNING: Load size is inaccurate */
    LVar1 = RegSetValueExA(*this,param_1,0,param_3,param_2,sVar2 + 1);
  }
  return LVar1;
}



// Function: FUN_1001da70 at 1001da70

void __thiscall FUN_1001da70(void *this,undefined4 param_1)

{
  *(undefined4 *)((int)this + 0x2c) = param_1;
  return;
}



// Function: FUN_1001da90 at 1001da90

void __thiscall FUN_1001da90(void *this,undefined4 param_1)

{
  *(undefined4 *)((int)this + 0x24) = param_1;
  return;
}



// Function: FUN_1001dab0 at 1001dab0

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __thiscall FUN_1001dab0(void *this,char *param_1)

{
  int iVar1;
  undefined1 local_1008 [4096];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  if ((*param_1 == '=') && (iVar1 = FUN_1001b250(this,param_1), -1 < iVar1)) {
    FUN_1001db70((undefined4 *)this);
    iVar1 = FUN_1001b250(this,local_1008);
    if (-1 < iVar1) {
      FUN_1001b250(this,param_1);
    }
  }
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001db70 at 1001db70

void __fastcall FUN_1001db70(undefined4 *param_1)

{
  int iVar1;
  LPSTR pCVar2;
  
  while( true ) {
    iVar1 = FUN_1001b0e0(*(undefined1 *)*param_1);
    if (iVar1 == 0) break;
    pCVar2 = CharNextA((LPCSTR)*param_1);
    *param_1 = pCVar2;
  }
  return;
}



// Function: FUN_1001dbb0 at 1001dbb0

LPCSTR __cdecl FUN_1001dbb0(LPSTR param_1,char param_2)

{
  LPSTR pCVar1;
  LPCSTR local_8;
  
  local_8 = (LPCSTR)0x0;
  if (param_1 == (LPSTR)0x0) {
    pCVar1 = (LPCSTR)0x0;
  }
  else {
    for (; (pCVar1 = local_8, *param_1 != '\0' && (pCVar1 = param_1, *param_1 != param_2));
        param_1 = CharNextA(param_1)) {
    }
  }
  return pCVar1;
}



// Function: FUN_1001dc00 at 1001dc00

undefined4 __fastcall FUN_1001dc00(int param_1)

{
  undefined4 uVar1;
  
  FUN_1001b180();
  uVar1 = FUN_1001b210((void *)(param_1 + 4),(undefined4 *)&stack0x00000004);
  FUN_1001dd80();
  return uVar1;
}



// Function: FUN_1001dc40 at 1001dc40

void __fastcall FUN_1001dc40(int param_1)

{
  undefined4 local_c;
  
  if (*(int *)(param_1 + 4) != 0) {
    if (*(int *)(param_1 + 0xc) != 0) {
      if (param_1 == 0) {
        local_c = (_ATL_MODULE70 *)0x0;
      }
      else {
        local_c = (_ATL_MODULE70 *)(param_1 + 4);
      }
      ATL::AtlCallTermFunc(local_c);
      *(undefined4 *)(param_1 + 0xc) = 0;
    }
    if (*(int *)(param_1 + 0x28) != 0) {
      (**(code **)(**(int **)(param_1 + 0x28) + 8))(*(undefined4 *)(param_1 + 0x28));
    }
    FUN_10002280((LPCRITICAL_SECTION)(param_1 + 0x10));
    *(undefined4 *)(param_1 + 4) = 0;
  }
  return;
}



// Function: FUN_1001dcc0 at 1001dcc0

void __fastcall FUN_1001dcc0(int param_1)

{
  int *local_c;
  int *local_8;
  
  if (*(int *)(param_1 + 0x2c) != 0) {
    for (local_8 = *(int **)(param_1 + 0x2c); *local_8 != 0; local_8 = local_8 + 9) {
      if (local_8[4] != 0) {
        (**(code **)(*(int *)local_8[4] + 8))(local_8[4]);
      }
      local_8[4] = 0;
      (*(code *)local_8[8])(0);
    }
  }
  for (local_c = DAT_10040560; local_c < DAT_10040564; local_c = local_c + 1) {
    if (*local_c != 0) {
      (**(code **)(*local_c + 0x1c))(0);
    }
  }
  FUN_1001dc40(param_1);
  return;
}



// Function: FUN_1001dd60 at 1001dd60

void __fastcall FUN_1001dd60(int param_1)

{
  FUN_10011600((LONG *)(param_1 + 8));
  return;
}



// Function: FUN_1001dd80 at 1001dd80

undefined4 FUN_1001dd80(void)

{
  return 0;
}



// Function: FUN_1001dd90 at 1001dd90

int __thiscall FUN_1001dd90(void *this,int param_1,void *param_2)

{
  int local_8;
  
  local_8 = 0;
  if (DAT_100403c8 != (code *)0x0) {
    local_8 = (*DAT_100403c8)(this);
  }
  if (-1 < local_8) {
    local_8 = FUN_1001dde0(&DAT_10040558,param_1,param_2);
  }
  return local_8;
}



// Function: FUN_1001dde0 at 1001dde0

void __thiscall FUN_1001dde0(void *this,int param_1,void *param_2)

{
  FUN_100189f0((int)this,param_1,param_2);
  return;
}



// Function: FUN_1001de00 at 1001de00

int __thiscall FUN_1001de00(void *this,int param_1,void *param_2)

{
  bool bVar1;
  undefined3 extraout_var;
  int *piVar2;
  int iVar3;
  int local_c;
  int *local_8;
  
  local_c = 0;
  local_8 = *(int **)((int)this + 0x2c);
  if (local_8 != (int *)0x0) {
    for (; *local_8 != 0; local_8 = local_8 + 9) {
      if ((param_2 == (void *)0x0) ||
         (bVar1 = FUN_1001ef60(param_2,(void *)*local_8), CONCAT31(extraout_var,bVar1) != 0)) {
        iVar3 = 0;
        piVar2 = (int *)(*(code *)local_8[7])();
        local_c = FUN_10019280((GUID *)*local_8,piVar2,iVar3);
        if ((local_c < 0) || (local_c = (*(code *)local_8[1])(0), local_c < 0)) break;
      }
    }
  }
  if (-1 < local_c) {
    local_c = FUN_1001dd90(this,param_1,param_2);
  }
  return local_c;
}



// Function: FUN_1001deb0 at 1001deb0

undefined4 FUN_1001deb0(void)

{
  return 0x80004005;
}



// Function: FUN_1001dec0 at 1001dec0

undefined4 FUN_1001dec0(void)

{
  return 0x80004005;
}



// Function: FUN_1001ded0 at 1001ded0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_1001ded0(int *param_1,ushort param_2,int param_3,int *param_4)

{
  char cVar1;
  bool bVar2;
  UINT UVar3;
  DWORD DVar4;
  long lVar5;
  HMODULE pHVar6;
  size_t sVar7;
  LPWSTR local_990;
  LPWSTR local_988;
  LPWSTR local_980;
  int local_974;
  undefined4 local_970 [5];
  HMODULE local_95c;
  char *local_958;
  LPWSTR local_954;
  int local_950;
  ulong local_94c;
  int local_948;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_944 [4];
  wchar_t local_940 [520];
  wchar_t local_530;
  undefined2 local_52e [523];
  CHAR local_118 [260];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c826;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_10016730(local_970);
  local_8 = 0;
  local_948 = FUN_1001a7d0();
  if (local_948 < 0) {
    local_8 = 0xffffffff;
    FUN_10016f80(local_970);
  }
  else {
    if (param_4 != (int *)0x0) {
      for (; *param_4 != 0; param_4 = param_4 + 2) {
        FUN_10017930((int)local_970,(wchar_t *)*param_4,(wchar_t *)param_4[1]);
      }
    }
    local_948 = (**(code **)(*param_1 + 0x14))();
    if (local_948 < 0) {
      local_8 = 0xffffffff;
      FUN_10016f80(local_970);
    }
    else {
      UVar3 = FUN_10012f50();
      FUN_1000d590((undefined4 *)local_944);
      local_8._0_1_ = 1;
      local_95c = (HMODULE)FUN_10011aa0(0x10040520);
      DVar4 = GetModuleFileNameA(local_95c,local_118,0x104);
      if (DVar4 == 0) {
        FUN_10018ba0();
        local_8 = (uint)local_8._1_3_ << 8;
        ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
        ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_944);
        local_8 = 0xffffffff;
        FUN_10016f80(local_970);
      }
      else if (DVar4 == 0x104) {
        _HRESULT_FROM_WIN32(0x7a);
        local_8 = (uint)local_8._1_3_ << 8;
        ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
        ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_944);
        local_8 = 0xffffffff;
        FUN_10016f80(local_970);
      }
      else {
        local_954 = (LPWSTR)0x0;
        local_958 = local_118;
        if (local_958 == (char *)0x0) {
          local_990 = (LPWSTR)0x0;
        }
        else {
          sVar7 = strlen(local_958);
          local_94c = sVar7 + 1;
          lVar5 = ATL::AtlMultiply<int>((int *)&local_94c,local_94c,2);
          if (lVar5 < 0) {
            local_988 = (LPWSTR)0x0;
          }
          else {
            if (((int)local_94c < 0x401) && (cVar1 = FUN_10012fe0(local_94c), cVar1 != '\0')) {
              local_980 = (LPWSTR)&stack0xfffff63c;
            }
            else {
              local_980 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                            (local_944,local_94c);
            }
            local_988 = FUN_100107c0(local_980,local_958,local_94c >> 1,UVar3);
          }
          local_990 = local_988;
        }
        local_954 = local_990;
        if (local_990 == (LPWSTR)0x0) {
          local_8 = (uint)local_8._1_3_ << 8;
          ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
          ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_944);
          local_8 = 0xffffffff;
          FUN_10016f80(local_970);
        }
        else {
          FUN_1001a700(local_940,0x208,local_990);
          if ((local_95c == (HMODULE)0x0) ||
             (pHVar6 = GetModuleHandleA((LPCSTR)0x0), local_95c == pHVar6)) {
            local_530 = L'\"';
            bVar2 = FUN_1001ee50(local_52e,0x20b,local_940);
            if (!bVar2) {
              local_8 = (uint)local_8._1_3_ << 8;
              ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
              ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_944);
              local_8 = 0xffffffff;
              FUN_10016f80(local_970);
              goto LAB_1001e466;
            }
            sVar7 = FUN_10015140(&local_530);
            local_52e[sVar7 - 1] = 0x22;
            if (0x417 < sVar7 * 2 + 2) {
              ___report_rangecheckfailure();
            }
            local_52e[sVar7] = 0;
            local_950 = FUN_10017930((int)local_970,L"Module",&local_530);
          }
          else {
            local_950 = FUN_10017930((int)local_970,L"Module",local_940);
          }
          if (local_950 < 0) {
            local_8 = (uint)local_8._1_3_ << 8;
            ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
            ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_944);
            local_8 = 0xffffffff;
            FUN_10016f80(local_970);
          }
          else {
            local_950 = FUN_10017930((int)local_970,L"Module_Raw",local_940);
            if (local_950 < 0) {
              local_8 = (uint)local_8._1_3_ << 8;
              ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
              ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_944);
              local_8 = 0xffffffff;
              FUN_10016f80(local_970);
            }
            else {
              if (param_3 == 0) {
                local_974 = FUN_1001d590(local_970,local_954,param_2,L"REGISTRY");
              }
              else {
                local_974 = FUN_1001d1f0(local_970,local_954,param_2,L"REGISTRY");
              }
              local_948 = local_974;
              local_8 = (uint)local_8._1_3_ << 8;
              ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
              ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_944);
              local_8 = 0xffffffff;
              FUN_10016f80(local_970);
            }
          }
        }
      }
    }
  }
LAB_1001e466:
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001e490 at 1001e490

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_1001e490(int *param_1,char *param_2,int param_3,int *param_4)

{
  bool bVar1;
  char cVar2;
  UINT UVar3;
  DWORD DVar4;
  HMODULE pHVar5;
  size_t sVar6;
  long lVar7;
  LPWSTR local_9a4;
  LPWSTR local_99c;
  LPWSTR local_998;
  LPWSTR local_994;
  LPWSTR local_988;
  int local_984;
  wchar_t *local_978;
  undefined4 local_974 [5];
  HMODULE local_960;
  wchar_t *local_95c;
  LPWSTR local_958;
  int local_954;
  char *local_950;
  int local_94c;
  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> local_948 [4];
  ulong local_944;
  wchar_t local_940 [520];
  wchar_t local_530;
  undefined2 local_52e [523];
  CHAR local_118 [260];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002c866;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  FUN_10016730(local_974);
  local_8 = 0;
  local_94c = FUN_1001a7d0();
  if (local_94c < 0) {
    local_8 = 0xffffffff;
    FUN_10016f80(local_974);
  }
  else {
    if (param_4 != (int *)0x0) {
      for (; *param_4 != 0; param_4 = param_4 + 2) {
        FUN_10017930((int)local_974,(wchar_t *)*param_4,(wchar_t *)param_4[1]);
      }
    }
    local_94c = (**(code **)(*param_1 + 0x14))();
    if (local_94c < 0) {
      local_8 = 0xffffffff;
      FUN_10016f80(local_974);
    }
    else {
      UVar3 = FUN_10012f50();
      FUN_1000d590((undefined4 *)local_948);
      local_8._0_1_ = 1;
      local_960 = (HMODULE)FUN_10011aa0(0x10040520);
      DVar4 = GetModuleFileNameA(local_960,local_118,0x104);
      if (DVar4 == 0) {
        FUN_10018ba0();
        local_8 = (uint)local_8._1_3_ << 8;
        ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
        ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_948);
        local_8 = 0xffffffff;
        FUN_10016f80(local_974);
      }
      else if (DVar4 == 0x104) {
        _HRESULT_FROM_WIN32(0x7a);
        local_8 = (uint)local_8._1_3_ << 8;
        ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
        ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_948);
        local_8 = 0xffffffff;
        FUN_10016f80(local_974);
      }
      else {
        local_958 = (LPWSTR)0x0;
        local_950 = local_118;
        if (local_950 == (char *)0x0) {
          local_9a4 = (LPWSTR)0x0;
        }
        else {
          sVar6 = strlen(local_950);
          local_944 = sVar6 + 1;
          lVar7 = ATL::AtlMultiply<int>((int *)&local_944,local_944,2);
          if (lVar7 < 0) {
            local_99c = (LPWSTR)0x0;
          }
          else {
            if (((int)local_944 < 0x401) && (cVar2 = FUN_10012fe0(local_944), cVar2 != '\0')) {
              local_994 = (LPWSTR)&stack0xfffff624;
            }
            else {
              local_994 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                  CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                            (local_948,local_944);
            }
            local_99c = FUN_100107c0(local_994,local_950,local_944 >> 1,UVar3);
          }
          local_9a4 = local_99c;
        }
        local_958 = local_9a4;
        if (local_9a4 == (LPWSTR)0x0) {
          local_8 = (uint)local_8._1_3_ << 8;
          ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
          ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_948);
          local_8 = 0xffffffff;
          FUN_10016f80(local_974);
        }
        else {
          FUN_1001a700(local_940,0x208,local_9a4);
          if ((local_960 == (HMODULE)0x0) ||
             (pHVar5 = GetModuleHandleA((LPCSTR)0x0), local_960 == pHVar5)) {
            local_530 = L'\"';
            bVar1 = FUN_1001ee50(local_52e,0x20b,local_940);
            if (!bVar1) {
              local_8 = (uint)local_8._1_3_ << 8;
              ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
              ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_948);
              local_8 = 0xffffffff;
              FUN_10016f80(local_974);
              goto LAB_1001eb69;
            }
            sVar6 = FUN_10015140(&local_530);
            local_52e[sVar6 - 1] = 0x22;
            if (0x417 < sVar6 * 2 + 2) {
              ___report_rangecheckfailure();
            }
            local_52e[sVar6] = 0;
            local_954 = FUN_10017930((int)local_974,L"Module",&local_530);
          }
          else {
            local_954 = FUN_10017930((int)local_974,L"Module",local_940);
          }
          if (local_954 < 0) {
            local_8 = (uint)local_8._1_3_ << 8;
            ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
            ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_948);
            local_8 = 0xffffffff;
            FUN_10016f80(local_974);
          }
          else {
            local_954 = FUN_10017930((int)local_974,L"Module_Raw",local_940);
            if (local_954 < 0) {
              local_8 = (uint)local_8._1_3_ << 8;
              ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
              ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_948);
              local_8 = 0xffffffff;
              FUN_10016f80(local_974);
            }
            else {
              local_950 = param_2;
              if (param_2 == (char *)0x0) {
                local_978 = (wchar_t *)0x0;
              }
              else {
                sVar6 = strlen(param_2);
                local_944 = sVar6 + 1;
                lVar7 = ATL::AtlMultiply<int>((int *)&local_944,local_944,2);
                if (lVar7 < 0) {
                  local_998 = (LPWSTR)0x0;
                }
                else {
                  if (((int)local_944 < 0x401) && (cVar2 = FUN_10012fe0(local_944), cVar2 != '\0'))
                  {
                    local_988 = (LPWSTR)&stack0xfffff624;
                  }
                  else {
                    local_988 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                                        CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
                                        Allocate(local_948,local_944);
                  }
                  local_998 = FUN_100107c0(local_988,local_950,local_944 >> 1,UVar3);
                }
                local_978 = local_998;
              }
              local_95c = local_978;
              if (local_978 == (wchar_t *)0x0) {
                local_8 = (uint)local_8._1_3_ << 8;
                ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
                ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_948);
                local_8 = 0xffffffff;
                FUN_10016f80(local_974);
              }
              else {
                if (param_3 == 0) {
                  local_984 = FUN_1001d6f0(local_974,local_958,local_978,L"REGISTRY");
                }
                else {
                  local_984 = FUN_1001d350(local_974,local_958,local_978,L"REGISTRY");
                }
                local_94c = local_984;
                local_8 = (uint)local_8._1_3_ << 8;
                ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
                ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>(local_948);
                local_8 = 0xffffffff;
                FUN_10016f80(local_974);
              }
            }
          }
        }
      }
    }
  }
LAB_1001eb69:
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_1001eb90 at 1001eb90

void FUN_1001eb90(int *param_1,ushort param_2,int param_3,int *param_4)

{
  FUN_1001ded0(param_1,param_2,param_3,param_4);
  return;
}



// Function: FUN_1001ebb0 at 1001ebb0

void FUN_1001ebb0(int *param_1,char *param_2,int param_3,int *param_4)

{
  FUN_1001e490(param_1,param_2,param_3,param_4);
  return;
}



// Function: FUN_1001ebd0 at 1001ebd0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 __cdecl FUN_1001ebd0(LPCSTR param_1,undefined2 *param_2)

{
  int iVar1;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c89e;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if ((DAT_100404d4 & 1) == 0) {
    DAT_100404d4 = DAT_100404d4 | 1;
    _DAT_100404b4 = &DAT_1002fa08;
    _DAT_100404b8 = 8;
    _DAT_100404bc = &DAT_1002fa0c;
    _DAT_100404c0 = 0x4008;
    _DAT_100404c4 = &DAT_1002fa10;
    _DAT_100404c8 = 0x13;
    _DAT_100404cc = &DAT_1002fa14;
    _DAT_100404d0 = 0x11;
  }
  local_8 = 0xffffffff;
  local_14 = 0;
  while( true ) {
    if (3 < local_14) {
      ExceptionList = local_10;
      return 0;
    }
    iVar1 = lstrcmpiA(param_1,*(LPCSTR *)(&DAT_100404b4 + local_14 * 8));
    if (iVar1 == 0) break;
    local_14 = local_14 + 1;
  }
  *param_2 = *(undefined2 *)(&DAT_100404b8 + local_14 * 8);
  ExceptionList = local_10;
  return 1;
}



// Function: FUN_1001ece0 at 1001ece0

int __fastcall FUN_1001ece0(int param_1)

{
  undefined4 local_8;
  
  local_8 = FUN_10012fa0(param_1 + 0x20);
  if (-1 < local_8) {
    local_8 = FUN_10012fc0();
  }
  return local_8;
}



// Function: _AtlRaiseException at 1001ed20

/* Library Function - Single Match
    void __cdecl ATL::_AtlRaiseException(unsigned long,unsigned long)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug */

void __cdecl ATL::_AtlRaiseException(ulong param_1,ulong param_2)

{
  RaiseException(param_1,param_2,0,(ULONG_PTR *)0x0);
  return;
}



// Function: _GetEntries at 1001ed40

/* Library Function - Single Match
    public: static struct ATL::_ATL_INTMAP_ENTRY const * __stdcall
   ATL::CAccessibleProxy::_GetEntries(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

_ATL_INTMAP_ENTRY * ATL::CAccessibleProxy::_GetEntries(void)

{
  return (_ATL_INTMAP_ENTRY *)&PTR_DAT_1003408c;
}



// Function: _GetEntries at 1001ed50

/* Library Function - Single Match
    public: static struct ATL::_ATL_INTMAP_ENTRY const * __stdcall
   ATL::CAccessibleProxy::_GetEntries(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

_ATL_INTMAP_ENTRY * ATL::CAccessibleProxy::_GetEntries(void)

{
  return (_ATL_INTMAP_ENTRY *)&PTR_DAT_10033cd4;
}



// Function: _GetEntries at 1001ed60

/* Library Function - Single Match
    public: static struct ATL::_ATL_INTMAP_ENTRY const * __stdcall
   ATL::CAccessibleProxy::_GetEntries(void)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

_ATL_INTMAP_ENTRY * ATL::CAccessibleProxy::_GetEntries(void)

{
  return (_ATL_INTMAP_ENTRY *)&PTR_DAT_10033cf0;
}



// Function: _InternalQueryInterface at 1001ed70

/* Library Function - Single Match
    public: long __thiscall ATL::CAccessibleProxy::_InternalQueryInterface(struct _GUID const &,void
   * *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

long __thiscall
ATL::CAccessibleProxy::_InternalQueryInterface(CAccessibleProxy *this,_GUID *param_1,void **param_2)

{
  _ATL_INTMAP_ENTRY *p_Var1;
  int iVar2;
  
  p_Var1 = _GetEntries();
  iVar2 = FUN_100122a0((int)this,(int *)p_Var1,(int *)param_1,param_2);
  return iVar2;
}



// Function: _InternalQueryInterface at 1001eda0

/* Library Function - Single Match
    public: long __thiscall ATL::CAccessibleProxy::_InternalQueryInterface(struct _GUID const &,void
   * *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

long __thiscall
ATL::CAccessibleProxy::_InternalQueryInterface(CAccessibleProxy *this,_GUID *param_1,void **param_2)

{
  _ATL_INTMAP_ENTRY *p_Var1;
  int iVar2;
  
  p_Var1 = _GetEntries();
  iVar2 = FUN_100122a0((int)this,(int *)p_Var1,(int *)param_1,param_2);
  return iVar2;
}



// Function: _InternalQueryInterface at 1001edd0

/* Library Function - Single Match
    public: long __thiscall ATL::CAccessibleProxy::_InternalQueryInterface(struct _GUID const &,void
   * *)
   
   Libraries: Visual Studio 2003 Debug, Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual
   Studio 2010 Debug */

long __thiscall
ATL::CAccessibleProxy::_InternalQueryInterface(CAccessibleProxy *this,_GUID *param_1,void **param_2)

{
  _ATL_INTMAP_ENTRY *p_Var1;
  int iVar2;
  
  p_Var1 = _GetEntries();
  iVar2 = FUN_100122a0((int)this,(int *)p_Var1,(int *)param_1,param_2);
  return iVar2;
}



// Function: _tcschr at 1001ee00

/* Library Function - Single Match
    char * __cdecl _tcschr(char *,unsigned int)
   
   Library: Visual Studio 2005 Debug */

char * __cdecl _tcschr(char *param_1,uint param_2)

{
  char *pcVar1;
  
  pcVar1 = (char *)__tcschr((uchar *)param_1,(uchar *)param_2);
  return pcVar1;
}



// Function: FUN_1001ee20 at 1001ee20

void __cdecl FUN_1001ee20(void *param_1,rsize_t param_2,void *param_3,rsize_t param_4)

{
  errno_t eVar1;
  
  eVar1 = memcpy_s(param_1,param_2,param_3,param_4);
  ATL::AtlCrtErrorCheck(eVar1);
  return;
}



// Function: FUN_1001ee50 at 1001ee50

bool __cdecl FUN_1001ee50(void *param_1,int param_2,wchar_t *param_3)

{
  size_t sVar1;
  errno_t eVar2;
  
  sVar1 = FUN_10015140(param_3);
  eVar2 = memcpy_s(param_1,param_2 << 1,param_3,sVar1 * 2 + 2);
  return eVar2 == 0;
}



// Function: FUN_1001eea0 at 1001eea0

void __cdecl FUN_1001eea0(char *param_1,rsize_t param_2,char *param_3)

{
  errno_t eVar1;
  
  eVar1 = strcat_s(param_1,param_2,param_3);
  ATL::AtlCrtErrorCheck(eVar1);
  return;
}



// Function: FUN_1001eed0 at 1001eed0

void __cdecl FUN_1001eed0(char *param_1,rsize_t param_2,char *param_3)

{
  errno_t eVar1;
  
  eVar1 = strcpy_s(param_1,param_2,param_3);
  ATL::AtlCrtErrorCheck(eVar1);
  return;
}



// Function: memmove_s at 1001ef00

/* Library Function - Single Match
    void __cdecl ATL::Checked::memmove_s(void *,unsigned int,void const *,unsigned int)
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2008 Debug, Visual Studio 2010 Debug, Visual
   Studio 2012 Debug */

void __cdecl ATL::Checked::memmove_s(void *param_1,uint param_2,void *param_3,uint param_4)

{
  int iVar1;
  
  iVar1 = FUN_1001efa0((uchar *)param_1,param_2,(uchar *)param_3,param_4);
  AtlCrtErrorCheck(iVar1);
  return;
}



// Function: FUN_1001ef30 at 1001ef30

void __cdecl FUN_1001ef30(wchar_t *param_1,rsize_t param_2,wchar_t *param_3,rsize_t param_4)

{
  errno_t eVar1;
  
  eVar1 = wcsncpy_s(param_1,param_2,param_3,param_4);
  ATL::AtlCrtErrorCheck(eVar1);
  return;
}



// Function: FUN_1001ef60 at 1001ef60

bool __cdecl FUN_1001ef60(void *param_1,void *param_2)

{
  int iVar1;
  
  iVar1 = memcmp(param_1,param_2,0x10);
  return iVar1 == 0;
}



// Function: FUN_1001efa0 at 1001efa0

void __cdecl FUN_1001efa0(uchar *param_1,size_t param_2,uchar *param_3,size_t param_4)

{
  _mbsnbcpy_s(param_1,param_2,param_3,param_4);
  return;
}



// Function: __tcschr at 1001efc0

/* Library Function - Single Match
    __tcschr
   
   Library: Visual Studio 2005 Debug */

void __cdecl __tcschr(uchar *param_1,uchar *param_2)

{
  _mbsstr(param_1,param_2);
  return;
}



// Function: FUN_1001efe0 at 1001efe0

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __cdecl
FUN_1001efe0(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1,
            undefined4 *param_2,undefined4 *param_3)

{
  uint uVar1;
  bool bVar2;
  uint uVar3;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar4;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c8d9;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>)0x0;
  local_8 = 0;
  uVar3 = param_2[4] + param_3[4];
  uVar1 = *(uint *)(param_1 + 0x10);
  if (((uVar1 <= uVar3) && (*(uint *)(param_1 + 0x14) != uVar3)) &&
     (bVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
              _Grow(param_1,uVar3,true), bVar2)) {
    *(uint *)(param_1 + 0x10) = uVar1;
    pbVar4 = param_1;
    if (0xf < *(uint *)(param_1 + 0x14)) {
      pbVar4 = *(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> **)
                param_1;
    }
    pbVar4[uVar1] =
         (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>)0x0;
  }
  FUN_1001f5a0(param_1,param_2,0,0xffffffff);
  FUN_1001f5a0(param_1,param_3,0,0xffffffff);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1001f0a0 at 1001f0a0

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __cdecl
FUN_1001f0a0(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1,
            undefined4 *param_2,int *param_3)

{
  uint uVar1;
  bool bVar2;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar3;
  int iVar4;
  uint uVar5;
  int *piVar6;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c919;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>)0x0;
  local_8 = 0;
  if ((char)*param_3 == '\0') {
    iVar4 = 0;
  }
  else {
    piVar6 = param_3;
    do {
      iVar4 = *piVar6;
      piVar6 = (int *)((int)piVar6 + 1);
    } while ((char)iVar4 != '\0');
    iVar4 = (int)piVar6 - ((int)param_3 + 1);
  }
  uVar1 = *(uint *)(param_1 + 0x10);
  uVar5 = iVar4 + param_2[4];
  if (((uVar1 <= uVar5) && (*(uint *)(param_1 + 0x14) != uVar5)) &&
     (bVar2 = std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
              _Grow(param_1,uVar5,true), bVar2)) {
    *(uint *)(param_1 + 0x10) = uVar1;
    pbVar3 = param_1;
    if (0xf < *(uint *)(param_1 + 0x14)) {
      pbVar3 = *(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> **)
                param_1;
    }
    pbVar3[uVar1] =
         (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>)0x0;
  }
  FUN_1001f5a0(param_1,param_2,0,0xffffffff);
  if ((char)*param_3 == '\0') {
    uVar5 = 0;
  }
  else {
    piVar6 = param_3;
    do {
      iVar4 = *piVar6;
      piVar6 = (int *)((int)piVar6 + 1);
    } while ((char)iVar4 != '\0');
    uVar5 = (int)piVar6 - ((int)param_3 + 1);
  }
  FUN_1001f6d0(param_1,param_3,uVar5);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_1001f190 at 1001f190

void __thiscall
FUN_1001f190(void *this,
            basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
            *param_1,basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                     *param_2)

{
  int iVar1;
  void *pvVar2;
  
  pvVar2 = this;
  if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
    pvVar2 = *this;
  }
  iVar1 = *(int *)((int)this + 0x10) + (int)pvVar2;
  if (*(uint *)((int)this + 0x14) < 0x10) {
    FUN_10020170(this,(int *)this,iVar1,param_1,param_2);
    return;
  }
                    /* WARNING: Load size is inaccurate */
  FUN_10020170(this,*this,iVar1,param_1,param_2);
  return;
}



// Function: FUN_1001f1d0 at 1001f1d0

undefined4 * __thiscall FUN_1001f1d0(void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  return (undefined4 *)this;
}



// Function: FUN_1001f1e0 at 1001f1e0

undefined4 * __thiscall FUN_1001f1e0(void *this,undefined4 param_1)

{
  *(undefined4 *)this = param_1;
  return (undefined4 *)this;
}



// Function: FUN_1001f1f0 at 1001f1f0

undefined4 * __thiscall FUN_1001f1f0(void *this,int *param_1,int param_2)

{
  int *piVar1;
  uint uVar2;
  void *pvVar3;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c94b;
  local_10 = ExceptionList;
  uVar2 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  *(undefined ***)this = CStreamReader::vftable;
  *(undefined4 *)((int)this + 4) = 0;
  local_8 = 0;
  piVar1 = *(int **)((int)this + 4);
  if (piVar1 != param_1) {
    *(int **)((int)this + 4) = param_1;
    if (param_1 != (int *)0x0) {
      (**(code **)(*param_1 + 4))(param_1,uVar2);
    }
    if (piVar1 != (int *)0x0) {
      (**(code **)(*piVar1 + 8))(piVar1);
    }
  }
  pvVar3 = operator_new__(param_2 + 1);
  *(void **)((int)this + 8) = pvVar3;
  *(undefined1 *)((int)pvVar3 + param_2) = 0;
  *(int *)((int)this + 0x14) = param_2;
  *(undefined2 *)((int)this + 0x10) = 0x100;
  *(undefined4 *)((int)this + 0xc) = 0;
  *(undefined1 *)((int)this + 0x12) = 0;
  *(undefined4 *)((int)this + 0x18) = 0;
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_1001f2a0 at 1001f2a0

undefined4 * __thiscall FUN_1001f2a0(void *this,undefined4 *param_1)

{
  if ((undefined4 *)this != param_1) {
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      operator_delete(*this);
    }
    *(undefined4 *)((int)this + 0x14) = 0xf;
    *(undefined4 *)((int)this + 0x10) = 0;
    *(undefined1 *)this = 0;
    FID_conflict__Assign_rv(this,param_1);
  }
  return (undefined4 *)this;
}



// Function: FUN_1001f2e0 at 1001f2e0

bool __thiscall FUN_1001f2e0(void *this,int *param_1)

{
                    /* WARNING: Load size is inaccurate */
  return *this == *param_1;
}



// Function: FUN_1001f330 at 1001f330

int __thiscall FUN_1001f330(void *this,int *param_1)

{
                    /* WARNING: Load size is inaccurate */
  return *this - *param_1;
}



// Function: FUN_1001f340 at 1001f340

int __thiscall FUN_1001f340(void *this,int *param_1)

{
                    /* WARNING: Load size is inaccurate */
  return *this - *param_1;
}



// Function: FUN_1001f350 at 1001f350

void __thiscall FUN_1001f350(void *this,undefined4 *param_1)

{
  FUN_1001f5a0(this,param_1,0,0xffffffff);
  return;
}



// Function: FUN_1001f370 at 1001f370

void __thiscall FUN_1001f370(void *this,int *param_1)

{
  int iVar1;
  int *piVar2;
  
  if ((char)*param_1 == '\0') {
    FUN_1001f6d0(this,param_1,0);
    return;
  }
  piVar2 = param_1;
  do {
    iVar1 = *piVar2;
    piVar2 = (int *)((int)piVar2 + 1);
  } while ((char)iVar1 != '\0');
  FUN_1001f6d0(this,param_1,(int)piVar2 - ((int)param_1 + 1));
  return;
}



// Function: FUN_1001f3b0 at 1001f3b0

undefined4 __thiscall FUN_1001f3b0(void *this,undefined4 *param_1)

{
  uchar *puVar1;
  
  puVar1 = _mbsstr(*(uchar **)((int)this + 0xc),"\n");
  if (puVar1 == (uchar *)0x0) {
    puVar1 = _mbsstr(*(uchar **)((int)this + 0xc),"\r");
    if (puVar1 == (uchar *)0x0) {
      return 0;
    }
  }
  for (; (puVar1[-1] == '\r' || (puVar1[-1] == '\n')); puVar1 = puVar1 + -1) {
  }
  *puVar1 = '\0';
  *param_1 = *(undefined4 *)((int)this + 0xc);
  *(uchar **)((int)this + 0xc) = puVar1 + 1;
  return CONCAT31((int3)((uint)puVar1 >> 8),1);
}



// Function: FUN_1001f420 at 1001f420

undefined4 __fastcall FUN_1001f420(int *param_1)

{
  char *pcVar1;
  char cVar2;
  
  while( true ) {
    cVar2 = (**(code **)(*param_1 + 0xc))();
    pcVar1 = (char *)param_1[3];
    if (((*pcVar1 != '\n') && (*pcVar1 != '\r')) || (cVar2 == '\0')) break;
    param_1[3] = (int)(pcVar1 + 1);
  }
  return CONCAT31((int3)((uint)pcVar1 >> 8),1);
}



// Function: FUN_1001f450 at 1001f450

undefined1 __thiscall FUN_1001f450(void *this,int *param_1)

{
  int *piVar1;
  code *pcVar2;
  undefined1 uVar3;
  int iVar4;
  int local_c;
  int local_8;
  
  uVar3 = 0;
  if (*(int *)((int)this + 4) != 0) {
    *param_1 = 0;
    param_1[1] = 0;
    piVar1 = *(int **)((int)this + 4);
    if (piVar1 == (int *)0x0) {
      _com_issue_error(-0x7fffbffd);
      pcVar2 = (code *)swi(3);
      uVar3 = (*pcVar2)();
      return uVar3;
    }
    iVar4 = (**(code **)(*piVar1 + 0x14))(piVar1,*param_1,param_1[1],1,&local_c);
    if (-1 < iVar4) {
      param_1[1] = local_8;
      if (*(int *)((int)this + 0xc) != 0) {
        *param_1 = ((*(int *)((int)this + 0xc) - *(int *)((int)this + 0x18)) -
                   *(int *)((int)this + 8)) + local_c;
        return 1;
      }
      *param_1 = local_c;
      uVar3 = 1;
    }
  }
  return uVar3;
}



// Function: FUN_1001f4e0 at 1001f4e0

undefined4 __thiscall FUN_1001f4e0(void *this,undefined4 *param_1,undefined4 param_2)

{
  int *piVar1;
  uint in_EAX;
  uint uVar2;
  int local_c;
  undefined4 local_8;
  
  piVar1 = *(int **)((int)this + 4);
  if (piVar1 == (int *)0x0) {
    return in_EAX & 0xffffff00;
  }
  uVar2 = (**(code **)(*piVar1 + 0x14))(piVar1,*param_1,param_1[1],param_2,&local_c);
  if (-1 < (int)uVar2) {
    param_1[1] = local_8;
    *param_1 = local_c;
    if (*(int *)((int)this + 0xc) != 0) {
      local_c = *(int *)((int)this + 0x18) + *(int *)((int)this + 8);
      *(int *)((int)this + 0xc) = local_c;
    }
    return CONCAT31((int3)((uint)local_c >> 8),1);
  }
  return uVar2 & 0xffffff00;
}



// Function: FUN_1001f560 at 1001f560

int __cdecl FUN_1001f560(int param_1,int param_2)

{
  if (param_1 == 0) {
    return param_1;
  }
  return param_1 - param_2;
}



// Function: FUN_1001f580 at 1001f580

void __thiscall FUN_1001f580(void *this,undefined4 *param_1)

{
  FUN_1001f5a0(this,param_1,0,0xffffffff);
  return;
}



// Function: FUN_1001f5a0 at 1001f5a0

int * __thiscall FUN_1001f5a0(void *this,undefined4 *param_1,uint param_2,uint param_3)

{
  uint extraout_EAX;
  uint uVar1;
  undefined4 *extraout_ECX;
  undefined4 *extraout_ECX_00;
  undefined4 *extraout_ECX_01;
  undefined4 *puVar2;
  uint extraout_EDX;
  uint uVar3;
  int extraout_EDX_00;
  int iVar4;
  void *pvVar5;
  
  uVar1 = param_1[4];
  puVar2 = param_1;
  uVar3 = param_2;
  if (uVar1 < param_2) {
    std::_Xout_of_range("invalid string position");
    uVar1 = extraout_EAX;
    puVar2 = extraout_ECX;
    uVar3 = extraout_EDX;
  }
  iVar4 = *(int *)((int)this + 0x10);
  if (uVar1 - uVar3 < param_3) {
    param_3 = uVar1 - uVar3;
  }
  if (-iVar4 - 1U <= param_3) {
    std::_Xlength_error("string too long");
    puVar2 = extraout_ECX_00;
    iVar4 = extraout_EDX_00;
  }
  if (param_3 != 0) {
    uVar1 = iVar4 + param_3;
    if (uVar1 == 0xffffffff) {
      std::_Xlength_error("string too long");
      puVar2 = extraout_ECX_01;
    }
    if (*(uint *)((int)this + 0x14) < uVar1) {
      FUN_10013170(this,uVar1);
      puVar2 = param_1;
      if (uVar1 == 0) {
        return (int *)this;
      }
    }
    else if (uVar1 == 0) {
      *(undefined4 *)((int)this + 0x10) = 0;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
        **this = 0;
        return (int *)this;
      }
      *(undefined1 *)this = 0;
      return (int *)this;
    }
    if (0xf < (uint)puVar2[5]) {
      puVar2 = (undefined4 *)*puVar2;
    }
    pvVar5 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      pvVar5 = *this;
    }
    if (param_3 != 0) {
      memcpy((void *)(*(int *)((int)this + 0x10) + (int)pvVar5),(void *)(param_2 + (int)puVar2),
             param_3);
    }
    *(uint *)((int)this + 0x10) = uVar1;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      *(undefined1 *)(*this + uVar1) = 0;
      return (int *)this;
    }
    *(undefined1 *)((int)this + uVar1) = 0;
  }
  return (int *)this;
}



// Function: FUN_1001f690 at 1001f690

void __thiscall FUN_1001f690(void *this,int *param_1)

{
  int iVar1;
  int *piVar2;
  
  if ((char)*param_1 == '\0') {
    FUN_1001f6d0(this,param_1,0);
    return;
  }
  piVar2 = param_1;
  do {
    iVar1 = *piVar2;
    piVar2 = (int *)((int)piVar2 + 1);
  } while ((char)iVar1 != '\0');
  FUN_1001f6d0(this,param_1,(int)piVar2 - ((int)param_1 + 1));
  return;
}



// Function: FUN_1001f6d0 at 1001f6d0

int * __thiscall FUN_1001f6d0(void *this,int *param_1,uint param_2)

{
  uint uVar1;
  int *piVar2;
  size_t extraout_ECX;
  size_t extraout_ECX_00;
  uint uVar3;
  int extraout_EDX;
  int iVar4;
  void *pvVar5;
  
  if (param_1 != (int *)0x0) {
    uVar3 = *(uint *)((int)this + 0x14);
    piVar2 = (int *)this;
    if (0xf < uVar3) {
                    /* WARNING: Load size is inaccurate */
      piVar2 = *this;
    }
    if (piVar2 <= param_1) {
      pvVar5 = this;
      if (0xf < uVar3) {
                    /* WARNING: Load size is inaccurate */
        pvVar5 = *this;
      }
      if (param_1 < (int *)(*(int *)((int)this + 0x10) + (int)pvVar5)) {
        if (0xf < uVar3) {
                    /* WARNING: Load size is inaccurate */
          piVar2 = FUN_1001f5a0(this,(undefined4 *)this,(int)param_1 - *this,param_2);
          return piVar2;
        }
        piVar2 = FUN_1001f5a0(this,(undefined4 *)this,(int)param_1 - (int)this,param_2);
        return piVar2;
      }
    }
  }
  iVar4 = *(int *)((int)this + 0x10);
  uVar3 = param_2;
  if (-iVar4 - 1U <= param_2) {
    std::_Xlength_error("string too long");
    uVar3 = extraout_ECX;
    iVar4 = extraout_EDX;
  }
  if (uVar3 != 0) {
    uVar1 = iVar4 + uVar3;
    if (uVar1 == 0xffffffff) {
      std::_Xlength_error("string too long");
      uVar3 = extraout_ECX_00;
    }
    if (*(uint *)((int)this + 0x14) < uVar1) {
      FUN_10013170(this,uVar1);
      uVar3 = param_2;
      if (uVar1 == 0) {
        return (int *)this;
      }
    }
    else if (uVar1 == 0) {
      *(undefined4 *)((int)this + 0x10) = 0;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
        **this = 0;
        return (int *)this;
      }
      *(undefined1 *)this = 0;
      return (int *)this;
    }
    pvVar5 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      pvVar5 = *this;
    }
    if (uVar3 != 0) {
      memcpy((void *)(*(int *)((int)this + 0x10) + (int)pvVar5),param_1,uVar3);
    }
    *(uint *)((int)this + 0x10) = uVar1;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      *(undefined1 *)(*this + uVar1) = 0;
      return (int *)this;
    }
    *(undefined1 *)((int)this + uVar1) = 0;
  }
  return (int *)this;
}



// Function: FUN_1001f7f0 at 1001f7f0

void __thiscall FUN_1001f7f0(void *this,undefined4 *param_1)

{
  if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
    this = *this;
  }
  *param_1 = this;
  return;
}



// Function: FUN_1001f820 at 1001f820

void __thiscall FUN_1001f820(void *this,int *param_1)

{
  if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
    *param_1 = *(int *)((int)this + 0x10) + *this;
    return;
  }
  *param_1 = *(int *)((int)this + 0x10) + (int)this;
  return;
}



// Function: FUN_1001f850 at 1001f850

uint __fastcall FUN_1001f850(int param_1)

{
  uint *puVar1;
  char *pcVar2;
  int *piVar3;
  code *pcVar4;
  char *pcVar5;
  uint uVar6;
  undefined1 uVar7;
  bool bVar8;
  
  pcVar5 = (char *)(*(int *)(param_1 + 0x18) + *(int *)(param_1 + 8));
  pcVar2 = *(char **)(param_1 + 0xc);
  puVar1 = (uint *)(param_1 + 0x18);
  uVar7 = 0;
  bVar8 = pcVar2 == pcVar5;
  uVar6 = CONCAT31((int3)((uint)pcVar5 >> 8),bVar8);
  *(bool *)(param_1 + 0x11) = bVar8;
  if ((pcVar2 == (char *)0x0) || (bVar8)) {
    if (*(char *)(param_1 + 0x12) == '\0') {
      piVar3 = *(int **)(param_1 + 4);
      if (piVar3 == (int *)0x0) {
        _com_issue_error(-0x7fffbffd);
        pcVar4 = (code *)swi(3);
        uVar6 = (*pcVar4)();
        return uVar6;
      }
      uVar6 = (**(code **)(*piVar3 + 0xc))
                        (piVar3,*(undefined4 *)(param_1 + 8),*(undefined4 *)(param_1 + 0x14),puVar1)
      ;
      if ((int)uVar6 < 0) {
        return uVar6 & 0xffffff00;
      }
      *(int *)(param_1 + 0xc) = *(int *)(param_1 + 8);
      *(undefined1 *)(*(int *)(param_1 + 8) + *puVar1) = 0;
      uVar6 = *puVar1;
      uVar7 = 1;
      *(undefined1 *)(param_1 + 0x11) = 0;
      if (uVar6 < *(uint *)(param_1 + 0x14)) {
        *(undefined1 *)(param_1 + 0x12) = 1;
        return CONCAT31((int3)(uVar6 >> 8),1);
      }
      goto LAB_1001f8c5;
    }
LAB_1001f8be:
    if (*pcVar2 == '\0') goto LAB_1001f8c5;
  }
  else if (*(char *)(param_1 + 0x12) != '\0') goto LAB_1001f8be;
  uVar7 = 1;
LAB_1001f8c5:
  return CONCAT31((int3)(uVar6 >> 8),uVar7);
}



// Function: FUN_1001f8e0 at 1001f8e0

void __thiscall FUN_1001f8e0(void *this,int *param_1)

{
  int iVar1;
  char cVar2;
  char *pcVar3;
  int *piVar4;
  char ****ppppcVar5;
  uint uStack_64;
  char *local_50;
  int local_4c;
  char ***local_48 [5];
  uint local_34;
  char ***local_30 [4];
  int local_20;
  uint local_1c;
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002caa0;
  local_10 = ExceptionList;
  uStack_64 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_64;
  ExceptionList = &local_10;
  local_50 = (char *)0x0;
  local_8 = 0;
                    /* WARNING: Load size is inaccurate */
  local_18 = uStack_64;
  cVar2 = (**(code **)(*this + 0xc))();
  if (cVar2 == '\0') {
    local_4c = 1;
  }
  else {
                    /* WARNING: Load size is inaccurate */
    cVar2 = (**(code **)(*this + 0x10))(&local_50);
    if (cVar2 == '\0') {
      basic_string<>(local_30,*(char **)((int)this + 0xc));
      local_8._0_1_ = 1;
      *(int *)((int)this + 0xc) = *(int *)((int)this + 0x18) + *(int *)((int)this + 8);
                    /* WARNING: Load size is inaccurate */
      local_4c = (**(code **)(*this + 4))(param_1);
      if (local_4c != 1) {
        piVar4 = param_1;
        do {
          iVar1 = *piVar4;
          piVar4 = (int *)((int)piVar4 + 1);
        } while ((char)iVar1 != '\0');
        if (piVar4 != (int *)((int)param_1 + 1)) {
          FUN_1001f0a0((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                        *)local_48,local_30,param_1);
          local_8 = CONCAT31(local_8._1_3_,2);
          ppppcVar5 = local_48;
          if (0xf < local_34) {
            ppppcVar5 = (char ****)local_48[0];
          }
          do {
            cVar2 = *(char *)ppppcVar5;
            *(char *)param_1 = cVar2;
            param_1 = (int *)((int)param_1 + 1);
            ppppcVar5 = (char ****)((int)ppppcVar5 + 1);
          } while (cVar2 != '\0');
          local_4c = 0;
          local_8._0_1_ = 1;
          ~basic_string<>(local_48);
          local_8 = (uint)local_8._1_3_ << 8;
          ~basic_string<>(local_30);
          goto LAB_1001fa2f;
        }
      }
      if (local_20 == 0) {
        local_4c = 1;
        local_8 = (uint)local_8._1_3_ << 8;
        ~basic_string<>(local_30);
      }
      else {
        ppppcVar5 = local_30;
        if (0xf < local_1c) {
          ppppcVar5 = (char ****)local_30[0];
        }
        do {
          cVar2 = *(char *)ppppcVar5;
          *(char *)param_1 = cVar2;
          param_1 = (int *)((int)param_1 + 1);
          ppppcVar5 = (char ****)((int)ppppcVar5 + 1);
        } while (cVar2 != '\0');
        local_4c = 0;
        local_8 = (uint)local_8._1_3_ << 8;
        ~basic_string<>(local_30);
      }
    }
    else {
      pcVar3 = local_50;
      do {
        cVar2 = *pcVar3;
        pcVar3[(int)param_1 - (int)local_50] = cVar2;
        pcVar3 = pcVar3 + 1;
      } while (cVar2 != '\0');
    }
  }
LAB_1001fa2f:
                    /* WARNING: Load size is inaccurate */
  (**(code **)(*this + 0x14))();
  local_8 = 0xffffffff;
  FUN_1001fa58();
  return;
}



// Function: Catch@1001fa41 at 1001fa41

undefined * Catch_1001fa41(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -0x48) = 0x80004005;
  return &DAT_1001fa4e;
}



// Function: FUN_1001fa58 at 1001fa58

void FUN_1001fa58(void)

{
  uint unaff_EBP;
  undefined4 uStack0000000c;
  
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uStack0000000c = 0x1001fa70;
  __security_check_cookie(*(uint *)(unaff_EBP - 0x14) ^ unaff_EBP);
  return;
}



// Function: FUN_1001fa80 at 1001fa80

void __thiscall
FUN_1001fa80(void *this,
            basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1)

{
  char cVar1;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar2;
  uint uStack_78;
  char *local_68;
  int local_64;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_60 [24];
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> local_48 [16];
  int local_38;
  undefined1 local_30 [16];
  int local_20;
  undefined4 local_1c;
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002cae8;
  local_10 = ExceptionList;
  uStack_78 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_78;
  ExceptionList = &local_10;
  local_68 = (char *)0x0;
  local_8 = 0;
                    /* WARNING: Load size is inaccurate */
  local_18 = uStack_78;
  cVar1 = (**(code **)(*this + 0xc))();
  if (cVar1 == '\0') {
    local_64 = 1;
  }
  else {
                    /* WARNING: Load size is inaccurate */
    cVar1 = (**(code **)(*this + 0x10))(&local_68);
    if (cVar1 == '\0') {
      basic_string<>(local_48,*(char **)((int)this + 0xc));
      local_8._1_3_ = (uint3)((uint)local_8 >> 8);
      *(int *)((int)this + 0xc) = *(int *)((int)this + 0x18) + *(int *)((int)this + 8);
      local_1c = 0xf;
      local_20 = 0;
      local_30[0] = 0;
      local_8._0_1_ = 2;
                    /* WARNING: Load size is inaccurate */
      local_64 = (**(code **)(*this + 8))(local_30);
      if ((local_64 == 1) || (local_20 == 0)) {
        if (local_38 == 0) {
          local_64 = 1;
        }
        else {
          if (param_1 != local_48) {
            std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
            assign(param_1,local_48,0,0xffffffff);
          }
          local_64 = 0;
        }
      }
      else {
        pbVar2 = FUN_1001efe0(local_60,(undefined4 *)local_48,(undefined4 *)local_30);
        local_8._0_1_ = 3;
        FUN_1001f2a0(param_1,(undefined4 *)pbVar2);
        local_8._0_1_ = 2;
        ~basic_string<>(local_60);
        local_64 = 0;
      }
      local_8._0_1_ = 1;
      ~basic_string<>(local_30);
      local_8 = (uint)local_8._1_3_ << 8;
      ~basic_string<>(local_48);
    }
    else {
      std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::operator=
                (param_1,local_68);
    }
  }
                    /* WARNING: Load size is inaccurate */
  (**(code **)(*this + 0x14))();
  local_8 = 0xffffffff;
  FUN_1001fbdf();
  return;
}



// Function: Catch@1001fbc8 at 1001fbc8

undefined * Catch_1001fbc8(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -0x60) = 0x80004005;
  return &DAT_1001fbd5;
}



// Function: FUN_1001fbdf at 1001fbdf

void FUN_1001fbdf(void)

{
  uint unaff_EBP;
  undefined4 uStack0000000c;
  
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uStack0000000c = 0x1001fbf7;
  __security_check_cookie(*(uint *)(unaff_EBP - 0x14) ^ unaff_EBP);
  return;
}



// Function: FUN_1001fc00 at 1001fc00

int * __thiscall
FUN_1001fc00(void *this,int *param_1,int *param_2,int *param_3,uint param_4,uint param_5)

{
  code *pcVar1;
  int *piVar2;
  int *piVar3;
  uint uVar4;
  int *piVar5;
  undefined1 *puVar6;
  void *pvVar7;
  void *pvVar8;
  int *piVar9;
  int *extraout_ECX;
  int *piVar10;
  int *extraout_EDX;
  int *extraout_EDX_00;
  int *_Size;
  void *local_8;
  
  piVar2 = param_1;
  piVar9 = *(int **)((int)this + 0x10);
  if ((piVar9 < param_1) || ((uint)param_3[4] < param_4)) {
    std::_Xout_of_range("invalid string position");
    pcVar1 = (code *)swi(3);
    piVar9 = (int *)(*pcVar1)();
    return piVar9;
  }
  piVar10 = (int *)((int)piVar9 - (int)param_1);
  _Size = param_2;
  if (piVar10 < param_2) {
    _Size = piVar10;
  }
  piVar3 = (int *)(param_3[4] - param_4);
  if (piVar3 < param_5) {
    param_5 = (uint)piVar3;
  }
  uVar4 = (int)piVar9 - (int)_Size;
  if (-param_5 - 1 <= uVar4) {
    std::_Xlength_error("string too long");
    piVar9 = extraout_ECX;
    piVar10 = extraout_EDX;
  }
  piVar10 = (int *)((int)piVar10 - (int)_Size);
  piVar5 = (int *)(uVar4 + param_5);
  piVar3 = piVar10;
  if (piVar9 < piVar5) {
    if (piVar5 == (int *)0xffffffff) {
      std::_Xlength_error("string too long");
      piVar3 = extraout_EDX_00;
    }
    if (*(int **)((int)this + 0x14) < piVar5) {
      FUN_10013170(this,(uint)piVar5);
      piVar3 = piVar10;
    }
    else if (piVar5 == (int *)0x0) {
      *(undefined4 *)((int)this + 0x10) = 0;
      puVar6 = (undefined1 *)this;
      if ((int *)0xf < *(int **)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
        puVar6 = *this;
      }
      *puVar6 = 0;
    }
  }
  if ((int *)this == param_3) {
    param_2 = (int *)this;
    if (_Size < param_5) {
      if (param_1 < param_4) {
        param_3 = (int *)this;
        if (param_4 < (uint)((int)param_1 + (int)_Size)) {
          pvVar8 = this;
          if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
            param_3 = *this;
                    /* WARNING: Load size is inaccurate */
            pvVar8 = *this;
          }
          if (_Size != (int *)0x0) {
            memmove((void *)((int)pvVar8 + (int)param_1),(void *)((int)param_3 + param_4),
                    (size_t)_Size);
          }
          pvVar8 = this;
          param_3 = (int *)this;
          if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
            param_3 = *this;
                    /* WARNING: Load size is inaccurate */
            pvVar8 = *this;
          }
          if (piVar10 != (int *)0x0) {
            memmove((void *)((int)pvVar8 + (int)param_1 + param_5),
                    (void *)((int)param_3 + (int)param_1 + (int)_Size),(size_t)piVar10);
          }
          pvVar8 = this;
          param_3 = (int *)this;
          if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
            param_3 = *this;
                    /* WARNING: Load size is inaccurate */
            pvVar8 = *this;
          }
          piVar10 = (int *)(param_5 - (int)_Size);
          if (piVar10 == (int *)0x0) goto LAB_1001ff4b;
          pvVar7 = (void *)((int)param_3 + param_4 + param_5);
          pvVar8 = (void *)((int)param_1 + (int)pvVar8 + (int)_Size);
        }
        else {
          param_1 = (int *)this;
          if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
            param_1 = *this;
                    /* WARNING: Load size is inaccurate */
            param_3 = *this;
          }
          if (piVar3 != (int *)0x0) {
            memmove((void *)((int)param_3 + (int)piVar2 + param_5),
                    (void *)((int)param_1 + (int)piVar2 + (int)_Size),(size_t)piVar3);
          }
          pvVar8 = this;
          pvVar7 = this;
          if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
            pvVar8 = *this;
            pvVar7 = *this;
          }
          if ((int *)param_5 == (int *)0x0) goto LAB_1001ff4b;
          pvVar7 = (void *)((int)pvVar7 + (param_4 - (int)_Size) + param_5);
          pvVar8 = (void *)((int)pvVar8 + (int)piVar2);
          piVar10 = (int *)param_5;
        }
      }
      else {
        param_1 = (int *)this;
        if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
          param_1 = *this;
                    /* WARNING: Load size is inaccurate */
          param_2 = *this;
        }
        if (piVar3 != (int *)0x0) {
          memmove((void *)((int)param_2 + (int)piVar2 + param_5),
                  (void *)((int)param_1 + (int)piVar2 + (int)_Size),(size_t)piVar3);
        }
        pvVar8 = this;
        pvVar7 = this;
        if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
                    /* WARNING: Load size is inaccurate */
          pvVar8 = *this;
          pvVar7 = *this;
        }
        if ((int *)param_5 == (int *)0x0) goto LAB_1001ff4b;
        pvVar7 = (void *)(param_4 + (int)pvVar7);
        pvVar8 = (void *)((int)pvVar8 + (int)piVar2);
        piVar10 = (int *)param_5;
      }
    }
    else {
      pvVar8 = this;
      param_1 = (int *)this;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
        param_1 = *this;
                    /* WARNING: Load size is inaccurate */
        pvVar8 = *this;
      }
      if ((int *)param_5 != (int *)0x0) {
        memmove((void *)((int)pvVar8 + (int)piVar2),(void *)((int)param_1 + param_4),param_5);
      }
      pvVar8 = this;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
        param_2 = *this;
                    /* WARNING: Load size is inaccurate */
        pvVar8 = *this;
      }
      if (piVar10 == (int *)0x0) goto LAB_1001ff4b;
      pvVar7 = (void *)((int)param_2 + (int)piVar2 + (int)_Size);
      pvVar8 = (void *)((int)pvVar8 + (int)piVar2 + param_5);
    }
    memmove(pvVar8,pvVar7,(size_t)piVar10);
  }
  else {
    pvVar8 = this;
    local_8 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      local_8 = *this;
                    /* WARNING: Load size is inaccurate */
      pvVar8 = *this;
    }
    if (piVar3 != (int *)0x0) {
      memmove((void *)((int)pvVar8 + (int)param_1 + param_5),
              (void *)((int)local_8 + (int)param_1 + (int)_Size),(size_t)piVar3);
    }
    if (0xf < (uint)param_3[5]) {
      param_3 = (int *)*param_3;
    }
    pvVar8 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      pvVar8 = *this;
    }
    if ((int *)param_5 != (int *)0x0) {
      memcpy((void *)((int)pvVar8 + (int)param_1),(void *)((int)param_3 + param_4),param_5);
    }
  }
LAB_1001ff4b:
  *(int **)((int)this + 0x10) = piVar5;
  if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
    *(undefined1 *)(*this + (int)piVar5) = 0;
    return (int *)this;
  }
  *(undefined1 *)((int)this + (int)piVar5) = 0;
  return (int *)this;
}



// Function: FUN_1001ffa0 at 1001ffa0

basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> * __thiscall
FUN_1001ffa0(void *this,int *param_1,
            basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
            *param_2,basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                     *param_3,int *param_4)

{
  uint uVar1;
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *pbVar2;
  int *extraout_EAX;
  int *piVar3;
  void *pvVar4;
  int *extraout_ECX;
  int *piVar5;
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
  *extraout_EDX;
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
  *extraout_EDX_00;
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *_Size;
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *pbVar6;
  size_t _Size_00;
  void *local_8;
  
  if (param_3 !=
      (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *)0x0)
  {
    uVar1 = *(uint *)((int)this + 0x14);
    pbVar2 = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
              *)this;
    if (0xf < uVar1) {
                    /* WARNING: Load size is inaccurate */
      pbVar2 = *this;
    }
    if (pbVar2 <= param_3) {
      pvVar4 = this;
      if (0xf < uVar1) {
                    /* WARNING: Load size is inaccurate */
        pvVar4 = *this;
      }
      if (param_3 < (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                     *)(*(int *)((int)this + 0x10) + (int)pvVar4)) {
        pvVar4 = this;
        if (0xf < uVar1) {
                    /* WARNING: Load size is inaccurate */
          pvVar4 = *this;
        }
        pbVar2 = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                  *)FUN_1001fc00(this,param_1,(int *)param_2,(int *)this,(int)param_3 - (int)pvVar4,
                                 (uint)param_4);
        return pbVar2;
      }
    }
  }
  piVar5 = *(int **)((int)this + 0x10);
  piVar3 = param_1;
  if (piVar5 < param_1) {
    std::_Xout_of_range("invalid string position");
    piVar3 = extraout_EAX;
    piVar5 = extraout_ECX;
  }
  pbVar6 = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *
           )((int)piVar5 - (int)piVar3);
  pbVar2 = param_2;
  if (pbVar6 < param_2) {
    pbVar2 = pbVar6;
  }
  _Size = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *)
          param_4;
  if (-(int)param_4 - 1U <= (uint)((int)piVar5 - (int)pbVar2)) {
    std::_Xlength_error("string too long");
    _Size = extraout_EDX;
  }
  _Size_00 = (int)pbVar6 - (int)pbVar2;
  if (_Size < pbVar2) {
    param_2 = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
               *)this;
    local_8 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      param_2 = *this;
                    /* WARNING: Load size is inaccurate */
      local_8 = *this;
    }
    if (_Size_00 != 0) {
      memmove(_Size + (int)local_8 + (int)param_1,param_2 + (int)param_1 + (int)pbVar2,_Size_00);
      _Size = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
               *)param_4;
    }
  }
  if ((_Size != (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                 *)0x0) ||
     (pbVar2 != (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                 *)0x0)) {
    pbVar6 = _Size + (*(int *)((int)this + 0x10) - (int)pbVar2);
    if (pbVar6 == (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                   *)0xffffffff) {
      std::_Xlength_error("string too long");
      _Size = extraout_EDX_00;
    }
    if (*(basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> **)
         ((int)this + 0x14) < pbVar6) {
      FUN_10013170(this,(uint)pbVar6);
      _Size = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
               *)param_4;
      if (pbVar6 == (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                     *)0x0) {
        return (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                *)this;
      }
    }
    else if (pbVar6 == (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                        *)0x0) {
      *(undefined4 *)((int)this + 0x10) = 0;
      if (*(basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
            **)((int)this + 0x14) <
          (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *)
          0x10) {
        *(undefined1 *)this = 0;
        return (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                *)this;
      }
                    /* WARNING: Load size is inaccurate */
      **this = 0;
      return (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
              *)this;
    }
    if (pbVar2 < _Size) {
      param_2 = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                 *)this;
      local_8 = this;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
        param_2 = *this;
                    /* WARNING: Load size is inaccurate */
        local_8 = *this;
      }
      if (_Size_00 != 0) {
        memmove(_Size + (int)local_8 + (int)param_1,param_2 + (int)param_1 + (int)pbVar2,_Size_00);
        _Size = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                 *)param_4;
      }
    }
    pvVar4 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      pvVar4 = *this;
    }
    if (_Size != (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                  *)0x0) {
      memcpy((void *)((int)pvVar4 + (int)param_1),param_3,(size_t)_Size);
    }
    std::basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>::
    _Eos((basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *)
         this,(uint)pbVar6);
  }
  return (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *)
         this;
}



// Function: FUN_10020170 at 10020170

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
FUN_10020170(void *this,int *param_1,int param_2,
            basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
            *param_3,basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                     *param_4)

{
  uint uVar1;
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *pbVar2;
  void *pvVar3;
  
  if (param_3 != param_4) {
    pvVar3 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      pvVar3 = *this;
    }
    if (param_2 == 0) {
      pbVar2 = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                *)0x0;
    }
    else {
      pbVar2 = (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                *)(param_2 - (int)param_1);
    }
    if (param_1 != (int *)0x0) {
      param_1 = (int *)((int)param_1 - (int)pvVar3);
    }
    FUN_1001ffa0(this,param_1,pbVar2,param_3,(int *)(param_4 + -(int)param_3));
    return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this;
  }
  pvVar3 = this;
  if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
    pvVar3 = *this;
  }
  if (param_2 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = param_2 - (int)param_1;
  }
  if (param_1 != (int *)0x0) {
    std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase
              ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this,
               (int)param_1 - (int)pvVar3,uVar1);
    return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this;
  }
  std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase
            ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this,0,
             uVar1);
  return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this;
}



// Function: reserve at 10020200

/* Library Function - Single Match
    public: void __thiscall std::basic_string<char,struct std::char_traits<char>,class
   std::allocator<char> >::reserve(unsigned int)
   
   Library: Visual Studio 2010 Release */

void __thiscall
std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::reserve
          (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,
          uint param_1)

{
  uint uVar1;
  bool bVar2;
  
  uVar1 = *(uint *)(this + 0x10);
  if ((uVar1 <= param_1) && (*(uint *)(this + 0x14) != param_1)) {
    bVar2 = _Grow(this,param_1,true);
    if (bVar2) {
      *(uint *)(this + 0x10) = uVar1;
      if (0xf < *(uint *)(this + 0x14)) {
        this = *(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> **)
                this;
      }
      this[uVar1] = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>)
                    0x0;
    }
  }
  return;
}



// Function: FUN_10020240 at 10020240

void FUN_10020240(int *param_1,char *param_2)

{
  char cVar1;
  int *piVar2;
  basic_ostream<char,struct_std::char_traits<char>_> *this;
  uint uVar3;
  int iVar4;
  uint uVar5;
  char *pcVar6;
  uint uVar7;
  uint extraout_ECX;
  uint extraout_ECX_00;
  uint extraout_ECX_01;
  bool bVar8;
  bool bVar9;
  __int64 _Var10;
  int local_28;
  int iStack_24;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cb28;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  bVar8 = false;
  if (*param_2 == '\0') {
    uVar5 = 0;
  }
  else {
    pcVar6 = param_2;
    do {
      cVar1 = *pcVar6;
      pcVar6 = pcVar6 + 1;
    } while (cVar1 != '\0');
    uVar5 = (int)pcVar6 - (int)(param_2 + 1);
  }
  iVar4 = *(int *)(*param_1 + 4);
  uVar7 = *(uint *)(iVar4 + 0x20 + (int)param_1);
  iStack_24 = *(int *)(iVar4 + 0x24 + (int)param_1);
  if ((iStack_24 < 0) ||
     ((iStack_24 < 1 && (((uVar7 == 0 || (iStack_24 < 0)) || ((iStack_24 < 1 && (uVar7 <= uVar5)))))
      ))) {
    iStack_24 = 0;
    local_28 = 0;
  }
  else {
    local_28 = uVar7 - uVar5;
    iStack_24 = iStack_24 - (uint)(uVar7 < uVar5);
  }
  piVar2 = *(int **)(iVar4 + 0x38 + (int)param_1);
  if (piVar2 != (int *)0x0) {
    (**(code **)(*piVar2 + 4))();
  }
  local_8 = 0;
  if ((*(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0) &&
     (this = *(basic_ostream<char,struct_std::char_traits<char>_> **)
              (*(int *)(*param_1 + 4) + 0x3c + (int)param_1),
     this != (basic_ostream<char,struct_std::char_traits<char>_> *)0x0)) {
    std::basic_ostream<char,struct_std::char_traits<char>_>::flush(this);
  }
  bVar9 = *(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0;
  uVar7 = (uint)bVar9;
  local_8 = 1;
  if (!bVar9) {
    FUN_1002042f(uVar7,param_1);
    return;
  }
  local_8 = 2;
  if ((*(uint *)(*(int *)(*param_1 + 4) + 0x14 + (int)param_1) & 0x1c0) != 0x40) {
    while( true ) {
      if ((iStack_24 < 0) || ((iStack_24 < 1 && (local_28 == 0)))) goto LAB_10020369;
      iVar4 = std::basic_streambuf<char,struct_std::char_traits<char>_>::sputc
                        (*(basic_streambuf<char,struct_std::char_traits<char>_> **)
                          (*(int *)(*param_1 + 4) + 0x38 + (int)param_1),
                         *(char *)(*(int *)(*param_1 + 4) + 0x40 + (int)param_1));
      uVar7 = extraout_ECX;
      if (iVar4 == -1) break;
      bVar9 = local_28 != 0;
      local_28 = local_28 + -1;
      iStack_24 = iStack_24 + -1 + (uint)bVar9;
    }
    bVar8 = true;
LAB_10020369:
    if (bVar8) goto LAB_100203ea;
  }
  _Var10 = std::basic_streambuf<char,struct_std::char_traits<char>_>::sputn
                     (*(basic_streambuf<char,struct_std::char_traits<char>_> **)
                       (*(int *)(*param_1 + 4) + 0x38 + (int)param_1),param_2,
                      (ulonglong)uVar3 << 0x20);
  uVar7 = extraout_ECX_00;
  if (((uint)_Var10 == uVar5) && ((int)((ulonglong)_Var10 >> 0x20) == 0)) {
    while ((-1 < iStack_24 &&
           (((0 < iStack_24 || (local_28 != 0)) &&
            (iVar4 = std::basic_streambuf<char,struct_std::char_traits<char>_>::sputc
                               (*(basic_streambuf<char,struct_std::char_traits<char>_> **)
                                 ((int)param_1 + *(int *)(*param_1 + 4) + 0x38),
                                *(char *)((int)param_1 + *(int *)(*param_1 + 4) + 0x40)),
            uVar7 = extraout_ECX_01, iVar4 != -1))))) {
      bVar8 = local_28 != 0;
      local_28 = local_28 + -1;
      iStack_24 = iStack_24 + -1 + (uint)bVar8;
    }
  }
LAB_100203ea:
  iVar4 = *(int *)(*param_1 + 4);
  *(undefined4 *)(iVar4 + 0x20 + (int)param_1) = 0;
  *(undefined4 *)(iVar4 + 0x24 + (int)param_1) = 0;
  local_8 = 1;
  FUN_1002042f(uVar7,param_1);
  return;
}



// Function: Catch@10020408 at 10020408

undefined * Catch_10020408(void)

{
  int unaff_EBP;
  
  std::basic_ios<char,struct_std::char_traits<char>_>::setstate
            ((basic_ios<char,struct_std::char_traits<char>_> *)
             (*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8)),4,true);
  return &DAT_10020422;
}



// Function: FUN_1002042f at 1002042f

undefined4 __fastcall FUN_1002042f(undefined4 param_1,int *param_2)

{
  basic_ostream<char,struct_std::char_traits<char>_> *this;
  bool bVar1;
  int unaff_EBX;
  int unaff_EBP;
  
  std::basic_ios<char,struct_std::char_traits<char>_>::setstate
            ((basic_ios<char,struct_std::char_traits<char>_> *)
             (*(int *)(*param_2 + 4) + (int)param_2),unaff_EBX,false);
  *(undefined4 *)(unaff_EBP + -4) = 4;
  bVar1 = std::uncaught_exception();
  this = *(basic_ostream<char,struct_std::char_traits<char>_> **)(unaff_EBP + -0x2c);
  if (!bVar1) {
    std::basic_ostream<char,struct_std::char_traits<char>_>::_Osfx(this);
  }
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  if (*(int **)(this + *(int *)(*(int *)this + 4) + 0x38) != (int *)0x0) {
    (**(code **)(**(int **)(this + *(int *)(*(int *)this + 4) + 0x38) + 8))();
  }
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return *(undefined4 *)(unaff_EBP + 8);
}



// Function: FUN_10020490 at 10020490

undefined4 FUN_10020490(undefined1 *param_1,FILE *param_2)

{
  int iVar1;
  
  iVar1 = fgetc(param_2);
  if (iVar1 == -1) {
    return 0;
  }
  *param_1 = (char)iVar1;
  return 1;
}



// Function: FUN_100204c0 at 100204c0

bool __cdecl FUN_100204c0(char param_1,FILE *param_2)

{
  int iVar1;
  
  iVar1 = fputc((int)param_1,param_2);
  return iVar1 != -1;
}



// Function: FUN_100204e0 at 100204e0

bool __cdecl FUN_100204e0(byte *param_1,FILE *param_2)

{
  int iVar1;
  
  iVar1 = ungetc((uint)*param_1,param_2);
  return iVar1 != -1;
}



// Function: FUN_10020500 at 10020500

facet * __cdecl FUN_10020500(locale *param_1)

{
  int iVar1;
  uint uVar2;
  _Locimp *p_Var3;
  facet *pfVar4;
  bad_cast local_24 [12];
  _Lockit local_18 [4];
  facet *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cb59;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  std::_Lockit::_Lockit(local_18,0);
  local_8 = 0;
  local_14 = DAT_10040514;
  uVar2 = std::locale::id::operator_unsigned_int((id *)id_exref);
  iVar1 = *(int *)param_1;
  if (uVar2 < *(uint *)(iVar1 + 0xc)) {
    pfVar4 = *(facet **)(*(int *)(iVar1 + 8) + uVar2 * 4);
    if (pfVar4 != (facet *)0x0) goto LAB_100205d2;
  }
  else {
    pfVar4 = (facet *)0x0;
  }
  if (*(char *)(iVar1 + 0x14) == '\0') {
LAB_1002057f:
    if (pfVar4 != (facet *)0x0) goto LAB_100205d2;
  }
  else {
    p_Var3 = std::locale::_Getgloballocale();
    if (uVar2 < *(uint *)(p_Var3 + 0xc)) {
      pfVar4 = *(facet **)(*(int *)(p_Var3 + 8) + uVar2 * 4);
      goto LAB_1002057f;
    }
  }
  pfVar4 = local_14;
  if (local_14 == (facet *)0x0) {
    uVar2 = std::codecvt<char,char,int>::_Getcat(&local_14,param_1);
    pfVar4 = local_14;
    if (uVar2 == 0xffffffff) {
      std::bad_cast::bad_cast(local_24,"bad cast");
                    /* WARNING: Subroutine does not return */
      _CxxThrowException(local_24,(ThrowInfo *)&DAT_1003bdb0);
    }
    DAT_10040514 = local_14;
    (**(code **)(*(int *)local_14 + 4))();
    Facet_Register(pfVar4);
  }
LAB_100205d2:
  local_8 = 0xffffffff;
  std::_Lockit::~_Lockit(local_18);
  ExceptionList = local_10;
  return pfVar4;
}



// Function: FUN_10020600 at 10020600

basic_streambuf<char,struct_std::char_traits<char>_> * __thiscall
FUN_10020600(void *this,int param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cb89;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  basic_streambuf<char,struct_std::char_traits<char>_>
            ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
  local_8 = 0;
  *(undefined ***)this = std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  *(undefined1 *)((int)this + 0x4c) = 0;
  *(undefined1 *)((int)this + 0x45) = 0;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
            ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
  if (param_1 != 0) {
    *(int *)((int)this + 0xc) = param_1 + 8;
    *(int *)((int)this + 0x10) = param_1 + 8;
    *(int *)((int)this + 0x1c) = param_1;
    *(int *)((int)this + 0x20) = param_1;
    *(int *)((int)this + 0x2c) = param_1 + 4;
    *(int *)((int)this + 0x30) = param_1 + 4;
  }
  *(int *)((int)this + 0x50) = param_1;
  *(undefined4 *)((int)this + 0x48) = DAT_10040510;
  *(undefined4 *)((int)this + 0x40) = 0;
  ExceptionList = local_10;
  return (basic_streambuf<char,struct_std::char_traits<char>_> *)this;
}



// Function: FUN_100206a0 at 100206a0

basic_iostream<char,struct_std::char_traits<char>_> * __thiscall
FUN_100206a0(void *this,int param_1)

{
  basic_streambuf<char,struct_std::char_traits<char>_> *this_00;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cbf6;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (param_1 != 0) {
    *(undefined ***)this = &PTR_10034108;
    *(undefined **)((int)this + 0x10) = &DAT_10034110;
    *(undefined4 *)((int)this + 0x78) = _vftable__exref;
    *(undefined4 *)((int)this + 0x78) = _vftable__exref;
    local_8 = 1;
  }
  this_00 = (basic_streambuf<char,struct_std::char_traits<char>_> *)((int)this + 0x18);
  std::basic_iostream<char,struct_std::char_traits<char>_>::
  basic_iostream<char,struct_std::char_traits<char>_>
            ((basic_iostream<char,struct_std::char_traits<char>_> *)this,this_00);
  local_8 = 2;
                    /* WARNING: Load size is inaccurate */
  *(undefined ***)((int)this + *(int *)(*this + 4)) =
       std::basic_fstream<char,struct_std::char_traits<char>_>::vftable;
                    /* WARNING: Load size is inaccurate */
  *(int *)(*(int *)(*this + 4) + -4 + (int)this) = *(int *)(*this + 4) + -0x78;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  basic_streambuf<char,struct_std::char_traits<char>_>(this_00);
  local_8 = CONCAT31(local_8._1_3_,3);
  *(undefined ***)this_00 = std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  *(undefined1 *)((int)this + 100) = 0;
  *(undefined1 *)((int)this + 0x5d) = 0;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init(this_00);
  *(undefined4 *)((int)this + 0x68) = 0;
  *(undefined4 *)((int)this + 0x60) = DAT_10040510;
  *(undefined4 *)((int)this + 0x58) = 0;
  ExceptionList = local_10;
  return (basic_iostream<char,struct_std::char_traits<char>_> *)this;
}



// Function: FUN_100207a0 at 100207a0

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
FUN_100207a0(void *this,
            basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1,
            uint param_2,uint param_3)

{
  *(undefined4 *)((int)this + 0x14) = 0xf;
  *(undefined4 *)((int)this + 0x10) = 0;
  *(undefined1 *)this = 0;
  std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
            ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this,
             param_1,param_2,param_3);
  return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)this;
}



// Function: FUN_100207d0 at 100207d0

undefined1 * __thiscall FUN_100207d0(void *this,uint param_1,char param_2)

{
  *(undefined4 *)((int)this + 0x14) = 0xf;
  *(undefined4 *)((int)this + 0x10) = 0;
  *(undefined1 *)this = 0;
  FUN_10021350(this,param_1,param_2);
  return (undefined1 *)this;
}



// Function: FUN_10020800 at 10020800

undefined4 * __thiscall
FUN_10020800(void *this,undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  *(undefined4 *)((int)this + 8) = param_2;
  *(undefined4 *)((int)this + 0xc) = param_3;
  *(undefined4 *)((int)this + 0x10) = param_1;
  *(undefined4 *)this = 0;
  *(undefined4 *)((int)this + 4) = 0;
  return (undefined4 *)this;
}



// Function: FUN_10020830 at 10020830

undefined4 * __thiscall FUN_10020830(void *this,undefined4 param_1,undefined4 param_2)

{
  *(undefined4 *)this = param_1;
  *(undefined4 *)((int)this + 4) = param_2;
  *(undefined4 *)((int)this + 8) = 0;
  *(undefined4 *)((int)this + 0xc) = 0;
  *(undefined4 *)((int)this + 0x10) = 0;
  return (undefined4 *)this;
}



// Function: Sentry_base at 10020860

/* Library Function - Multiple Matches With Same Base Name
    public: __thiscall std::basic_ostream<char,struct std::char_traits<char>
   >::_Sentry_base::_Sentry_base(class std::basic_ostream<char,struct std::char_traits<char> > &)
    public: __thiscall std::basic_ostream<unsigned short,struct std::char_traits<unsigned short>
   >::_Sentry_base::_Sentry_base(class std::basic_ostream<unsigned short,struct
   std::char_traits<unsigned short> > &)
    public: __thiscall std::basic_ostream<wchar_t,struct std::char_traits<wchar_t>
   >::_Sentry_base::_Sentry_base(class std::basic_ostream<wchar_t,struct std::char_traits<wchar_t> >
   &)
   
   Library: Visual Studio 2012 Release */

undefined4 * __thiscall Sentry_base(void *this,int *param_1)

{
  int *piVar1;
  
  *(int **)this = param_1;
  piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))();
  }
  return (undefined4 *)this;
}



// Function: FUN_10020890 at 10020890

undefined4 * __thiscall FUN_10020890(void *this,int *param_1)

{
  int *piVar1;
  basic_ostream<char,struct_std::char_traits<char>_> *this_00;
  uint uVar2;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cc28;
  local_10 = ExceptionList;
  uVar2 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  *(int **)this = param_1;
  piVar1 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))(uVar2);
  }
  local_8 = 0;
  if ((*(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0) &&
     (this_00 = *(basic_ostream<char,struct_std::char_traits<char>_> **)
                 (*(int *)(*param_1 + 4) + 0x3c + (int)param_1),
     this_00 != (basic_ostream<char,struct_std::char_traits<char>_> *)0x0)) {
    std::basic_ostream<char,struct_std::char_traits<char>_>::flush(this_00);
  }
  *(bool *)((int)this + 4) = *(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0;
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_10020920 at 10020920

void __fastcall FUN_10020920(basic_streambuf<char,struct_std::char_traits<char>_> *param_1)

{
  undefined4 uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002cc59;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined ***)param_1 = std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  local_8 = 0;
  if ((*(int *)(param_1 + 0x50) != 0) &&
     ((basic_streambuf<char,struct_std::char_traits<char>_> *)**(int **)(param_1 + 0xc) ==
      param_1 + 0x44)) {
    uVar1 = *(undefined4 *)(param_1 + 0x3c);
    **(int **)(param_1 + 0xc) = *(int *)(param_1 + 0x38);
    **(undefined4 **)(param_1 + 0x1c) = uVar1;
    **(undefined4 **)(param_1 + 0x2c) = 0;
  }
  if (param_1[0x4c] != (basic_streambuf<char,struct_std::char_traits<char>_>)0x0) {
    FUN_10021430(param_1);
  }
  local_8 = 0xffffffff;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  ~basic_streambuf<char,struct_std::char_traits<char>_>(param_1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_100209b0 at 100209b0

void __fastcall FUN_100209b0(int param_1)

{
  basic_streambuf<char,struct_std::char_traits<char>_> *this;
  int iVar1;
  undefined4 uVar2;
  uint3 uVar3;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002cca0;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined ***)(*(int *)(*(int *)(param_1 + -0x78) + 4) + -0x78 + param_1) =
       std::basic_fstream<char,struct_std::char_traits<char>_>::vftable;
  iVar1 = *(int *)(*(int *)(param_1 + -0x78) + 4);
  *(int *)(iVar1 + -0x7c + param_1) = iVar1 + -0x78;
  this = (basic_streambuf<char,struct_std::char_traits<char>_> *)(param_1 + -0x60);
  *(undefined ***)this = std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  local_8._1_3_ = 0;
  uVar3 = local_8._1_3_;
  local_8._0_1_ = 2;
  local_8._1_3_ = 0;
  if ((*(int *)(param_1 + -0x10) != 0) && (**(int **)(param_1 + -0x54) == param_1 + -0x1c)) {
    uVar2 = *(undefined4 *)(param_1 + -0x24);
    **(int **)(param_1 + -0x54) = *(int *)(param_1 + -0x28);
    **(undefined4 **)(param_1 + -0x44) = uVar2;
    **(undefined4 **)(param_1 + -0x34) = 0;
  }
  if (*(char *)(param_1 + -0x14) != '\0') {
    FUN_10021430(this);
    uVar3 = local_8._1_3_;
  }
  local_8._1_3_ = uVar3;
  local_8 = (uint)local_8._1_3_ << 8;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  ~basic_streambuf<char,struct_std::char_traits<char>_>(this);
  local_8 = 0xffffffff;
  std::basic_iostream<char,struct_std::char_traits<char>_>::
  ~basic_iostream<char,struct_std::char_traits<char>_>
            ((basic_iostream<char,struct_std::char_traits<char>_> *)(param_1 + -0x58));
  ExceptionList = local_10;
  return;
}



// Function: FUN_10020a70 at 10020a70

void __fastcall FUN_10020a70(int *param_1)

{
  int *piVar1;
  
  piVar1 = *(int **)(*(int *)(*(int *)*param_1 + 4) + 0x38 + *param_1);
  if (piVar1 != (int *)0x0) {
                    /* WARNING: Could not recover jumptable at 0x10020a81. Too many branches */
                    /* WARNING: Treating indirect jump as call */
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}



// Function: FUN_10020a90 at 10020a90

void __fastcall FUN_10020a90(int *param_1)

{
  undefined4 *puVar1;
  
  if ((int *)*param_1 != (int *)0x0) {
    puVar1 = (undefined4 *)(**(code **)(*(int *)*param_1 + 8))();
    if (puVar1 != (undefined4 *)0x0) {
      (**(code **)*puVar1)(1);
    }
  }
  return;
}



// Function: FUN_10020ab0 at 10020ab0

void __fastcall FUN_10020ab0(int *param_1)

{
  int *piVar1;
  bool bVar2;
  uint uVar3;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002ccc8;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  bVar2 = std::uncaught_exception();
  if (!bVar2) {
    std::basic_ostream<char,struct_std::char_traits<char>_>::_Osfx
              ((basic_ostream<char,struct_std::char_traits<char>_> *)*param_1);
  }
  local_8 = 0xffffffff;
  piVar1 = *(int **)(*(int *)(*(int *)*param_1 + 4) + 0x38 + *param_1);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(uVar3);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10020b20 at 10020b20

uint __thiscall FUN_10020b20(void *this,int param_1)

{
  code *pcVar1;
  uint uVar2;
  
  if (param_1 == 0) {
                    /* WARNING: Load size is inaccurate */
    return (uint)(*this == 0);
  }
  _com_issue_error(-0x7fffbffd);
  pcVar1 = (code *)swi(3);
  uVar2 = (*pcVar1)();
  return uVar2;
}



// Function: FUN_10020b60 at 10020b60

undefined8 __thiscall FUN_10020b60(void *this,uint *param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = *(uint *)((int)this + 8) - param_1[2];
  uVar2 = uVar1 - *param_1;
                    /* WARNING: Load size is inaccurate */
  return CONCAT44(((((*(int *)((int)this + 0xc) - param_1[3]) -
                    (uint)(*(uint *)((int)this + 8) < param_1[2])) - param_1[1]) -
                  (uint)(uVar1 < *param_1)) + *(int *)((int)this + 4) + (uint)CARRY4(uVar2,*this),
                  uVar2 + *this);
}



// Function: FUN_10020b90 at 10020b90

uint * __thiscall FUN_10020b90(void *this,uint param_1,int param_2)

{
  uint uVar1;
  
                    /* WARNING: Load size is inaccurate */
  uVar1 = *this;
  *(uint *)this = *this + param_1;
  *(int *)((int)this + 4) = *(int *)((int)this + 4) + param_2 + (uint)CARRY4(uVar1,param_1);
  return (uint *)this;
}



// Function: FUN_10020bb0 at 10020bb0

void __fastcall FUN_10020bb0(int param_1)

{
  ios_base *piVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002ccf9;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  piVar1 = (ios_base *)(param_1 + 0x78);
  FUN_100209b0((int)piVar1);
  *(code **)piVar1 = _vftable__exref;
  local_8 = 0xffffffff;
  *(code **)piVar1 = _vftable__exref;
  std::ios_base::_Ios_base_dtor(piVar1);
  ExceptionList = local_10;
  return;
}



// Function: FUN_10020c10 at 10020c10

void __thiscall FUN_10020c10(void *this,byte param_1)

{
  FUN_10020cc0((void *)((int)this - *(int *)((int)this + -4)),param_1);
  return;
}



// Function: FUN_10020c20 at 10020c20

basic_streambuf<char,struct_std::char_traits<char>_> * __thiscall
FUN_10020c20(void *this,byte param_1)

{
  undefined4 uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002cd29;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined ***)this = std::basic_filebuf<char,struct_std::char_traits<char>_>::vftable;
  local_8 = 0;
  if ((*(int *)((int)this + 0x50) != 0) && (**(int **)((int)this + 0xc) == (int)this + 0x44)) {
    uVar1 = *(undefined4 *)((int)this + 0x3c);
    **(int **)((int)this + 0xc) = *(int *)((int)this + 0x38);
    **(undefined4 **)((int)this + 0x1c) = uVar1;
    **(undefined4 **)((int)this + 0x2c) = 0;
  }
  if (*(char *)((int)this + 0x4c) != '\0') {
    FUN_10021430((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
  }
  local_8 = 0xffffffff;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  ~basic_streambuf<char,struct_std::char_traits<char>_>
            ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  ExceptionList = local_10;
  return (basic_streambuf<char,struct_std::char_traits<char>_> *)this;
}



// Function: FUN_10020cc0 at 10020cc0

ios_base * __thiscall FUN_10020cc0(void *this,byte param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cd59;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100209b0((int)this);
  *(code **)this = _vftable__exref;
  local_8 = 0xffffffff;
  *(code **)this = _vftable__exref;
  std::ios_base::_Ios_base_dtor((ios_base *)this);
  if ((param_1 & 1) != 0) {
    operator_delete((ios_base *)((int)this + -0x78));
  }
  ExceptionList = local_10;
  return (ios_base *)((int)this + -0x78);
}



// Function: FUN_10020d40 at 10020d40

uint __cdecl
FUN_10020d40(char *param_1,short param_2,short param_3,short *param_4,ushort *param_5,byte *param_6)

{
  char cVar1;
  byte *pbVar2;
  char *pcVar3;
  uint uVar4;
  char *pcVar5;
  byte *pbVar6;
  int iVar7;
  ushort local_8 [2];
  
  pcVar3 = FUN_10023d80(param_1);
  if ((param_2 == 5) || (param_2 == 4)) {
    pcVar5 = param_1;
    do {
      cVar1 = *pcVar5;
      pcVar3 = (char *)CONCAT31((int3)((uint)pcVar3 >> 8),cVar1);
      pcVar5 = pcVar5 + 1;
    } while (cVar1 != '\0');
    if (((int)pcVar5 - (int)(param_1 + 1) == 0x13) &&
       (pcVar3 = (char *)sscanf(param_1 + 3,"%4hx",local_8), 0 < (int)pcVar3)) {
      *param_4 = local_8[0] * 0x100 + (local_8[0] >> 8);
      goto LAB_10020de3;
    }
  }
  else {
    pcVar5 = param_1;
    do {
      cVar1 = *pcVar5;
      pcVar3 = (char *)CONCAT31((int3)((uint)pcVar3 >> 8),cVar1);
      pcVar5 = pcVar5 + 1;
    } while (cVar1 != '\0');
    if (((int)pcVar5 - (int)(param_1 + 1) == 4) &&
       (pcVar3 = (char *)sscanf(param_1,"%4hx",param_4), 0 < (int)pcVar3)) {
LAB_10020de3:
      uVar4 = 0;
      *param_5 = 0;
      if ((param_2 == 5) || (param_2 == 4)) {
        pcVar3 = param_1 + 7;
        iVar7 = (int)param_6 - (int)pcVar3;
        do {
          cVar1 = *pcVar3;
          pcVar3[iVar7] = cVar1;
          pcVar3 = pcVar3 + 1;
          pbVar2 = param_6;
        } while (cVar1 != '\0');
        do {
          pbVar6 = pbVar2;
          pbVar2 = pbVar6 + 1;
        } while (*pbVar6 != 0);
        pbVar6[-2] = 0;
        uVar4 = FUN_10023760((uint)*param_5,param_6,0,param_3);
        *param_5 = (ushort)uVar4;
      }
      return CONCAT31((int3)(uVar4 >> 8),1);
    }
  }
  return (uint)pcVar3 & 0xffffff00;
}



// Function: FUN_10020e40 at 10020e40

uint __cdecl FUN_10020e40(char *param_1,undefined4 param_2,ushort *param_3)

{
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  byte local_8 [4];
  
  pcVar2 = FUN_10023d80(param_1);
  pcVar3 = param_1;
  do {
    cVar1 = *pcVar3;
    pcVar2 = (char *)CONCAT31((int3)((uint)pcVar2 >> 8),cVar1);
    pcVar3 = pcVar3 + 1;
  } while (cVar1 != '\0');
  if ((int)pcVar3 - (int)(param_1 + 1) == 8) {
    pcVar2 = (char *)sscanf(param_1,"*E%4hx%2hx",param_2,local_8);
    if (1 < (int)pcVar2) {
      *param_3 = (ushort)local_8[0];
      return CONCAT31((int3)((uint)param_3 >> 8),1);
    }
  }
  return (uint)pcVar2 & 0xffffff00;
}



// Function: FUN_10020ea0 at 10020ea0

void __cdecl FUN_10020ea0(char *param_1)

{
  char cVar1;
  
  cVar1 = *param_1;
  while (cVar1 != '\0') {
    cVar1 = *param_1;
    if (*param_1 == '\n') {
      cVar1 = '\0';
    }
    if (cVar1 == '\r') {
      cVar1 = '\0';
    }
    *param_1 = cVar1;
    cVar1 = param_1[1];
    param_1 = param_1 + 1;
  }
  return;
}



// Function: FUN_10020ee0 at 10020ee0

/* WARNING: Removing unreachable block (ram,0x10020f0c) */

uint __cdecl FUN_10020ee0(short param_1,ushort param_2,ushort param_3,short param_4)

{
  undefined4 in_EAX;
  uint uVar1;
  uint uVar2;
  
  if ((param_1 == 1) || (param_1 == 5)) {
    uVar1 = CONCAT22((short)((uint)in_EAX >> 0x10),param_2);
    if (param_2 != param_3) {
      return uVar1 & 0xffffff00;
    }
  }
  else {
    uVar2 = (uint)(param_2 >> 8) + (param_2 & 0xff);
    uVar1 = uVar2 & 0xff;
    if ((short)uVar1 != 0) {
      uVar1 = (uint)(byte)-(char)uVar2;
    }
    if ((param_2 != param_3) || (param_4 != (short)uVar1)) {
      return 0;
    }
  }
  return CONCAT31((int3)(uVar1 >> 8),1);
}



// Function: FUN_10020f47 at 10020f47

void __fastcall FUN_10020f47(int param_1)

{
                    /* WARNING: Could not recover jumptable at 0x10020f4d. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_istream<char,struct_std::char_traits<char>_>::_Add_vtordisp1
            ((basic_istream<char,struct_std::char_traits<char>_> *)
             ((param_1 - *(int *)(param_1 + -4)) + -0x60));
  return;
}



// Function: FUN_10020f53 at 10020f53

void __fastcall FUN_10020f53(int param_1)

{
                    /* WARNING: Could not recover jumptable at 0x10020f59. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_ostream<char,struct_std::char_traits<char>_>::_Add_vtordisp2
            ((basic_ostream<char,struct_std::char_traits<char>_> *)
             ((param_1 - *(int *)(param_1 + -4)) + -0x60));
  return;
}



// Function: FUN_10020f60 at 10020f60

void __thiscall FUN_10020f60(void *this,int param_1,size_t param_2,char param_3)

{
  if (param_2 == 1) {
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      this = *this;
    }
    *(char *)((int)this + param_1) = param_3;
    return;
  }
  if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
    this = *this;
  }
  memset((void *)(param_1 + (int)this),(int)param_3,param_2);
  return;
}



// Function: FUN_10020fb0 at 10020fb0

/* WARNING: Removing unreachable block (ram,0x10021028) */

void __fastcall FUN_10020fb0(int *param_1)

{
  int iVar1;
  ulonglong *puVar2;
  size_t sVar3;
  ulonglong *puVar4;
  ulonglong *puVar5;
  size_t _Count;
  char *local_34;
  int *local_30;
  ulonglong local_2c;
  undefined1 local_24;
  int local_1c;
  uint local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cea8;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_30 = param_1;
  if (((param_1[0x10] == 0) || (*(char *)((int)param_1 + 0x45) == '\0')) ||
     (iVar1 = (**(code **)(*param_1 + 0xc))(0xffffffff,local_14), iVar1 == -1)) {
LAB_10021120:
    ExceptionList = local_10;
    __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
    return;
  }
  local_18 = 0xf;
  local_2c = 0;
  local_1c = 8;
  local_24 = 0;
  local_8 = 0;
  do {
    puVar2 = (ulonglong *)local_2c;
    do {
      puVar5 = &local_2c;
      if (0xf < local_18) {
        puVar5 = puVar2;
      }
      puVar4 = &local_2c;
      if (0xf < local_18) {
        puVar4 = puVar2;
      }
      iVar1 = std::codecvt<char,char,int>::unshift
                        ((codecvt<char,char,int> *)param_1[0x10],param_1 + 0x12,(char *)puVar4,
                         (char *)((int)puVar5 + local_1c),&local_34);
      if (iVar1 != 0) {
        if (iVar1 == 1) goto LAB_1002108e;
LAB_100210f0:
        local_8 = 0xffffffff;
        if (0xf < local_18) {
          operator_delete((ulonglong *)local_2c);
        }
        local_18 = 0xf;
        local_1c = 0;
        local_2c = local_2c & 0xffffffffffffff00;
        goto LAB_10021120;
      }
      *(undefined1 *)((int)param_1 + 0x45) = 0;
LAB_1002108e:
      puVar2 = &local_2c;
      if (0xf < local_18) {
        puVar2 = (ulonglong *)local_2c;
      }
      _Count = (int)local_34 - (int)puVar2;
      if (_Count != 0) {
        puVar2 = &local_2c;
        if (0xf < local_18) {
          puVar2 = (ulonglong *)local_2c;
        }
        sVar3 = fwrite(puVar2,1,_Count,(FILE *)local_30[0x14]);
        if (_Count != sVar3) goto LAB_100210f0;
      }
      param_1 = local_30;
      if (*(char *)((int)local_30 + 0x45) == '\0') goto LAB_100210f0;
      puVar2 = (ulonglong *)local_2c;
    } while (_Count != 0);
    FUN_100212a0(&local_2c,8,'\0');
  } while( true );
}



// Function: FUN_10021140 at 10021140

int __thiscall FUN_10021140(void *this,uint param_1)

{
  int iVar1;
  _Locimp *p_Var2;
  int iVar3;
  
                    /* WARNING: Load size is inaccurate */
  iVar1 = *this;
  if (param_1 < *(uint *)(iVar1 + 0xc)) {
    iVar3 = *(int *)(*(int *)(iVar1 + 8) + param_1 * 4);
    if (iVar3 != 0) {
      return iVar3;
    }
  }
  else {
    iVar3 = 0;
  }
  if (*(char *)(iVar1 + 0x14) != '\0') {
    p_Var2 = std::locale::_Getgloballocale();
    if (param_1 < *(uint *)(p_Var2 + 0xc)) {
      return *(int *)(*(int *)(p_Var2 + 8) + param_1 * 4);
    }
    iVar3 = 0;
  }
  return iVar3;
}



// Function: FUN_10021180 at 10021180

void __thiscall FUN_10021180(void *this,int param_1,int param_2)

{
  *(bool *)((int)this + 0x4c) = param_2 == 1;
  *(undefined1 *)((int)this + 0x45) = 0;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
            ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
  if (param_1 != 0) {
    *(int *)((int)this + 0xc) = param_1 + 8;
    *(int *)((int)this + 0x10) = param_1 + 8;
    *(int *)((int)this + 0x1c) = param_1;
    *(int *)((int)this + 0x20) = param_1;
    *(int *)((int)this + 0x2c) = param_1 + 4;
    *(int *)((int)this + 0x30) = param_1 + 4;
  }
  *(int *)((int)this + 0x50) = param_1;
  *(undefined4 *)((int)this + 0x48) = DAT_10040510;
  *(undefined4 *)((int)this + 0x40) = 0;
  return;
}



// Function: FUN_100211d0 at 100211d0

void __thiscall FUN_100211d0(void *this,codecvt_base *param_1)

{
  bool bVar1;
  
  bVar1 = std::codecvt_base::always_noconv(param_1);
  if (bVar1) {
    *(undefined4 *)((int)this + 0x40) = 0;
    return;
  }
  *(codecvt_base **)((int)this + 0x40) = param_1;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
            ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
  return;
}



// Function: FUN_10021210 at 10021210

void __fastcall FUN_10021210(int param_1)

{
  if (*(FILE **)(param_1 + 0x50) != (FILE *)0x0) {
    _lock_file(*(FILE **)(param_1 + 0x50));
  }
  return;
}



// Function: _Reset_back at 10021220

/* Library Function - Single Match
    private: void __thiscall std::basic_filebuf<char,struct std::char_traits<char>
   >::_Reset_back(void)
   
   Library: Visual Studio 2012 Release */

void __thiscall
std::basic_filebuf<char,struct_std::char_traits<char>_>::_Reset_back
          (basic_filebuf<char,struct_std::char_traits<char>_> *this)

{
  undefined4 uVar1;
  
  if ((basic_filebuf<char,struct_std::char_traits<char>_> *)**(int **)(this + 0xc) == this + 0x44) {
    uVar1 = *(undefined4 *)(this + 0x3c);
    **(int **)(this + 0xc) = *(int *)(this + 0x38);
    **(undefined4 **)(this + 0x1c) = uVar1;
    **(undefined4 **)(this + 0x2c) = 0;
  }
  return;
}



// Function: _Set_back at 10021250

/* Library Function - Single Match
    private: void __thiscall std::basic_filebuf<char,struct std::char_traits<char>
   >::_Set_back(void)
   
   Library: Visual Studio 2012 Release */

void __thiscall
std::basic_filebuf<char,struct_std::char_traits<char>_>::_Set_back
          (basic_filebuf<char,struct_std::char_traits<char>_> *this)

{
  basic_filebuf<char,struct_std::char_traits<char>_> *pbVar1;
  basic_filebuf<char,struct_std::char_traits<char>_> *pbVar2;
  
  pbVar1 = this + 0x44;
  pbVar2 = (basic_filebuf<char,struct_std::char_traits<char>_> *)**(int **)(this + 0xc);
  if (pbVar2 != pbVar1) {
    *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x38) = pbVar2;
    *(int *)(this + 0x3c) = **(int **)(this + 0x2c) + **(int **)(this + 0x1c);
  }
  **(int **)(this + 0xc) = (int)pbVar1;
  **(int **)(this + 0x1c) = (int)pbVar1;
  **(undefined4 **)(this + 0x2c) = this + (0x45 - (int)pbVar1);
  return;
}



// Function: FUN_10021290 at 10021290

void __fastcall FUN_10021290(int param_1)

{
  if (*(FILE **)(param_1 + 0x50) != (FILE *)0x0) {
    _unlock_file(*(FILE **)(param_1 + 0x50));
  }
  return;
}



// Function: FUN_100212a0 at 100212a0

int * __thiscall FUN_100212a0(void *this,uint param_1,char param_2)

{
  uint uVar1;
  int extraout_ECX;
  int iVar2;
  
  iVar2 = *(int *)((int)this + 0x10);
  if (-iVar2 - 1U <= param_1) {
    std::_Xlength_error("string too long");
    iVar2 = extraout_ECX;
  }
  if (param_1 != 0) {
    uVar1 = iVar2 + param_1;
    if (uVar1 == 0xffffffff) {
      std::_Xlength_error("string too long");
    }
    if (*(uint *)((int)this + 0x14) < uVar1) {
      FUN_10013170(this,uVar1);
      if (uVar1 == 0) {
        return (int *)this;
      }
    }
    else if (uVar1 == 0) {
      *(undefined4 *)((int)this + 0x10) = 0;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
        **this = 0;
        return (int *)this;
      }
      *(undefined1 *)this = 0;
      return (int *)this;
    }
    FUN_10020f60(this,*(int *)((int)this + 0x10),param_1,param_2);
    *(uint *)((int)this + 0x10) = uVar1;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      *(undefined1 *)(*this + uVar1) = 0;
      return (int *)this;
    }
    *(undefined1 *)((int)this + uVar1) = 0;
  }
  return (int *)this;
}



// Function: FUN_10021350 at 10021350

int * __thiscall FUN_10021350(void *this,uint param_1,char param_2)

{
  void *extraout_ECX;
  void *pvVar1;
  
  pvVar1 = this;
  if (param_1 == 0xffffffff) {
    std::_Xlength_error("string too long");
    std::_Xlength_error("string too long");
    pvVar1 = extraout_ECX;
  }
  if (*(uint *)((int)this + 0x14) < param_1) {
    FUN_10013170(pvVar1,param_1);
    if (param_1 == 0) {
      return (int *)this;
    }
  }
  else if (param_1 == 0) {
    *(undefined4 *)((int)this + 0x10) = 0;
    if (*(uint *)((int)this + 0x14) < 0x10) {
      *(undefined1 *)this = 0;
      return (int *)this;
    }
                    /* WARNING: Load size is inaccurate */
    **this = 0;
    return (int *)this;
  }
  if (param_1 == 1) {
    if (*(uint *)((int)this + 0x14) < 0x10) {
      *(char *)this = param_2;
    }
    else {
                    /* WARNING: Load size is inaccurate */
      **this = param_2;
    }
  }
  else {
    pvVar1 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      pvVar1 = *this;
    }
    memset(pvVar1,(int)param_2,param_1);
  }
  *(uint *)((int)this + 0x10) = param_1;
  if (*(uint *)((int)this + 0x14) < 0x10) {
    *(undefined1 *)((int)this + param_1) = 0;
    return (int *)this;
  }
                    /* WARNING: Load size is inaccurate */
  *(undefined1 *)(*this + param_1) = 0;
  return (int *)this;
}



// Function: FUN_10021410 at 10021410

void __cdecl FUN_10021410(void *param_1,size_t param_2,char param_3)

{
  memset(param_1,(int)param_3,param_2);
  return;
}



// Function: FUN_10021430 at 10021430

basic_streambuf<char,struct_std::char_traits<char>_> * __fastcall
FUN_10021430(basic_streambuf<char,struct_std::char_traits<char>_> *param_1)

{
  char cVar1;
  int iVar2;
  basic_streambuf<char,struct_std::char_traits<char>_> *pbVar3;
  
  if (*(int *)(param_1 + 0x50) == 0) {
    pbVar3 = (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;
  }
  else {
    cVar1 = FUN_10020fb0((int *)param_1);
    pbVar3 = param_1;
    if (cVar1 == '\0') {
      pbVar3 = (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;
    }
    iVar2 = fclose(*(FILE **)(param_1 + 0x50));
    if (iVar2 != 0) {
      pbVar3 = (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;
    }
  }
  param_1[0x4c] = (basic_streambuf<char,struct_std::char_traits<char>_>)0x0;
  param_1[0x45] = (basic_streambuf<char,struct_std::char_traits<char>_>)0x0;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init(param_1);
  *(undefined4 *)(param_1 + 0x50) = 0;
  *(undefined4 *)(param_1 + 0x48) = DAT_10040510;
  *(undefined4 *)(param_1 + 0x40) = 0;
  return pbVar3;
}



// Function: FUN_10021490 at 10021490

uint __cdecl FUN_10021490(byte *param_1,byte *param_2,uint param_3)

{
  uint uVar1;
  bool bVar2;
  
  if (param_3 == 0) {
    return 0;
  }
  uVar1 = param_3 - 4;
  if (3 < param_3) {
    do {
      if (*(int *)param_1 != *(int *)param_2) goto LAB_100214c6;
      param_1 = param_1 + 4;
      param_2 = param_2 + 4;
      bVar2 = 3 < uVar1;
      uVar1 = uVar1 - 4;
    } while (bVar2);
  }
  if (uVar1 != 0xfffffffc) {
LAB_100214c6:
    bVar2 = *param_1 < *param_2;
    if ((*param_1 != *param_2) ||
       ((uVar1 != 0xfffffffd &&
        ((bVar2 = param_1[1] < param_2[1], param_1[1] != param_2[1] ||
         ((uVar1 != 0xfffffffe &&
          ((bVar2 = param_1[2] < param_2[2], param_1[2] != param_2[2] ||
           ((uVar1 != 0xffffffff && (bVar2 = param_1[3] < param_2[3], param_1[3] != param_2[3]))))))
         )))))) {
      return -(uint)bVar2 | 1;
    }
  }
  return 0;
}



// Function: FUN_10021500 at 10021500

undefined1 __cdecl FUN_10021500(char *param_1,short param_2,short param_3,short param_4)

{
  undefined1 uVar1;
  basic_streambuf<char,struct_std::char_traits<char>_> *pbVar2;
  int iVar3;
  int local_d0 [3];
  int aiStack_c4 [3];
  undefined1 local_b8 [96];
  code *local_58 [18];
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cee4;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100206a0(local_d0,1);
  local_8 = 0;
  if (param_2 == 1) {
    iVar3 = 1;
  }
  else {
    iVar3 = 3;
  }
  pbVar2 = FUN_10022b30(local_b8,param_1,iVar3,(int *)0x40);
  if (pbVar2 == (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0) {
    std::basic_ios<char,struct_std::char_traits<char>_>::setstate
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               ((int)local_d0 + *(int *)(local_d0[0] + 4)),2,false);
  }
  else {
    std::basic_ios<char,struct_std::char_traits<char>_>::clear
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               ((int)local_d0 + *(int *)(local_d0[0] + 4)),0,false);
  }
  if (*(int *)((int)aiStack_c4 + *(int *)(local_d0[0] + 4)) == 0) {
    uVar1 = FUN_10021720((basic_istream<char,struct_std::char_traits<char>_> *)local_d0,param_2,
                         param_3,param_4);
  }
  else {
    uVar1 = 0;
  }
  local_8 = 0xffffffff;
  FUN_100209b0((int)local_58);
  local_8 = 0xffffffff;
  local_58[0] = _vftable__exref;
  std::ios_base::_Ios_base_dtor((ios_base *)local_58);
  ExceptionList = local_10;
  return uVar1;
}



// Function: FUN_10021610 at 10021610

undefined1 __cdecl FUN_10021610(ushort *param_1,short param_2,short param_3,short param_4)

{
  undefined1 uVar1;
  basic_streambuf<char,struct_std::char_traits<char>_> *pbVar2;
  int iVar3;
  int local_d0 [3];
  int aiStack_c4 [3];
  undefined1 local_b8 [96];
  code *local_58 [18];
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cf24;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100206a0(local_d0,1);
  local_8 = 0;
  if (param_2 == 1) {
    iVar3 = 1;
  }
  else {
    iVar3 = 3;
  }
  pbVar2 = FUN_10022c40(local_b8,param_1,iVar3,(int *)0x40);
  if (pbVar2 == (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0) {
    std::basic_ios<char,struct_std::char_traits<char>_>::setstate
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               ((int)local_d0 + *(int *)(local_d0[0] + 4)),2,false);
  }
  else {
    std::basic_ios<char,struct_std::char_traits<char>_>::clear
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               ((int)local_d0 + *(int *)(local_d0[0] + 4)),0,false);
  }
  if (*(int *)((int)aiStack_c4 + *(int *)(local_d0[0] + 4)) == 0) {
    uVar1 = FUN_10021720((basic_istream<char,struct_std::char_traits<char>_> *)local_d0,param_2,
                         param_3,param_4);
  }
  else {
    uVar1 = 0;
  }
  local_8 = 0xffffffff;
  FUN_100209b0((int)local_58);
  local_8 = 0xffffffff;
  local_58[0] = _vftable__exref;
  std::ios_base::_Ios_base_dtor((ios_base *)local_58);
  ExceptionList = local_10;
  return uVar1;
}



// Function: FUN_10021720 at 10021720

void __cdecl
FUN_10021720(basic_istream<char,struct_std::char_traits<char>_> *param_1,short param_2,short param_3
            ,short param_4)

{
  byte bVar1;
  uint uVar2;
  int *piVar3;
  byte *pbVar4;
  int iVar5;
  basic_istream<char,struct_std::char_traits<char>_> *pbVar6;
  uint uVar7;
  byte *pbVar8;
  basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *pbVar9;
  char ******_Src;
  byte ******ppppppbVar10;
  int iVar11;
  basic_istream<char,struct_std::char_traits<char>_> *this;
  int iVar12;
  char cVar13;
  short sVar14;
  basic_ostream<char,struct_std::char_traits<char>_> local_dc [4];
  undefined4 uStack_d8;
  basic_ostream<char,struct_std::char_traits<char>_> local_d4 [72];
  byte *local_8c;
  int local_88;
  int local_84;
  int local_80;
  int local_7c;
  uint local_78;
  uint local_74;
  uint local_70;
  basic_istream<char,struct_std::char_traits<char>_> *local_6c;
  char local_65;
  void *local_64 [4];
  undefined4 local_54;
  uint local_50;
  char *****local_4c [4];
  undefined4 local_3c;
  uint local_38;
  byte *****local_34 [4];
  int local_24;
  uint local_20;
  int local_1c [2];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cf74;
  local_10 = ExceptionList;
  uVar2 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_6c = param_1;
  local_14 = uVar2;
  std::basic_istream<char,struct_std::char_traits<char>_>::seekg(param_1,0,2);
  piVar3 = (int *)std::basic_istream<char,struct_std::char_traits<char>_>::tellg(param_1);
  iVar11 = *piVar3 + piVar3[2] + 1;
  iVar12 = 0;
  local_80 = 0;
  local_78 = 0;
  local_74 = 0;
  local_70 = 0;
  local_7c = 0;
  pbVar4 = (byte *)operator_new__(iVar11 + 1);
  local_65 = '\x01';
  local_8c = pbVar4;
  iVar5 = FUN_10022930(local_6c,(char *)pbVar4,iVar11);
  local_84 = (iVar5 != 1) + 1;
  std::basic_istream<char,struct_std::char_traits<char>_>::seekg(local_6c,0,0);
  this = local_6c;
  if (param_3 == 0x2d) {
    local_88 = iVar11 >> 0x1f;
    sVar14 = (short)(iVar11 >> 0x1f);
    local_1c[0] = iVar11;
    pbVar6 = std::basic_istream<char,struct_std::char_traits<char>_>::getline
                       (local_6c,(char *)pbVar4,CONCAT44(uVar2,CONCAT22(sVar14,sVar14)));
    pbVar6 = pbVar6 + *(int *)(*(int *)pbVar6 + 4);
    if (((byte)pbVar6[0xc] & 6) != 0) {
      pbVar6 = (basic_istream<char,struct_std::char_traits<char>_> *)0x0;
    }
    while (pbVar6 != (basic_istream<char,struct_std::char_traits<char>_> *)0x0) {
      if (local_65 != '\0') {
        local_20 = 0xf;
        local_24 = 0;
        local_34[0] = (byte *****)((uint)local_34[0] & 0xffffff00);
        if (*pbVar4 == 0) {
          uVar7 = 0;
        }
        else {
          pbVar8 = pbVar4;
          do {
            bVar1 = *pbVar8;
            pbVar8 = pbVar8 + 1;
          } while (bVar1 != 0);
          uVar7 = (int)pbVar8 - (int)(pbVar4 + 1);
        }
        std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
                  ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
                   local_34,(char *)pbVar4,uVar7);
        local_8 = 0;
        uVar7 = FUN_10022860(local_34,(byte *)"crc=\"",0,5);
        this = local_6c;
        if (uVar7 == 0xffffffff) {
          iVar12 = iVar12 + local_24 + local_84;
          cVar13 = (char)(iVar12 >> 0x1f);
          local_7c = iVar12;
          std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
                    ((basic_ostream<char,struct_std::char_traits<char>_> *)(local_6c + 0x10),
                     CONCAT26((short)(iVar12 >> 0x1f),CONCAT15(cVar13,CONCAT14(cVar13,iVar12))),0);
        }
        else {
          piVar3 = (int *)(uVar7 + 5);
          uVar7 = FUN_10022860(local_34,&DAT_10034144,(uint)piVar3,1);
          if (uVar7 - (int)piVar3 != 4) {
            local_8 = 0xffffffff;
            if (0xf < local_20) {
              operator_delete(local_34[0]);
            }
            local_20 = 0xf;
            local_24 = 0;
            local_34[0] = (byte *****)((uint)local_34[0] & 0xffffff00);
            this = local_6c;
            break;
          }
          local_80 = (int)piVar3 + iVar12;
          local_65 = '\0';
          local_38 = 0xf;
          local_3c = 0;
          local_4c[0] = (char *****)((uint)local_4c[0] & 0xffffff00);
          local_8._0_1_ = 1;
          pbVar9 = FUN_10023360(local_34,(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                                          *)local_64,(uint)piVar3,4);
          local_8._0_1_ = 2;
          if ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
              local_4c != pbVar9) {
            if (0xf < local_38) {
              operator_delete(local_4c[0]);
            }
            local_38 = 0xf;
            local_3c = 0;
            local_4c[0] = (char *****)((uint)local_4c[0] & 0xffffff00);
            FID_conflict__Assign_rv(local_4c,(undefined4 *)pbVar9);
          }
          local_8._0_1_ = 1;
          if (0xf < local_50) {
            operator_delete(local_64[0]);
          }
          _Src = local_4c;
          if (0xf < local_38) {
            _Src = (char ******)local_4c[0];
          }
          local_50 = 0xf;
          local_54 = 0;
          local_64[0] = (void *)((uint)local_64[0] & 0xffffff00);
          local_78 = 0;
          sscanf((char *)_Src,"%x",0x48,(short)&local_78);
          local_74 = local_78 & 0xffff;
          FUN_1001ffa0(local_34,piVar3,
                       (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                        *)0x4,(basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                               *)&DAT_1003414c,(int *)0x4);
          ppppppbVar10 = local_34;
          pbVar8 = pbVar4;
          if (0xf < local_20) {
            ppppppbVar10 = (byte ******)local_34[0];
          }
          do {
            bVar1 = *(byte *)ppppppbVar10;
            *pbVar8 = bVar1;
            ppppppbVar10 = (byte ******)((int)ppppppbVar10 + 1);
            pbVar8 = pbVar8 + 1;
          } while (bVar1 != 0);
          local_8 = (uint)local_8._1_3_ << 8;
          if (0xf < local_38) {
            operator_delete(local_4c[0]);
          }
          local_38 = 0xf;
          local_3c = 0;
          local_4c[0] = (char *****)((uint)local_4c[0] & 0xffffff00);
          this = local_6c;
          iVar12 = local_7c;
        }
        local_8 = 0xffffffff;
        if (0xf < local_20) {
          operator_delete(local_34[0]);
        }
        local_20 = 0xf;
        local_24 = 0;
        local_34[0] = (byte *****)((uint)local_34[0] & 0xffffff00);
      }
      local_70 = FUN_10023760(local_70,pbVar4,0,param_4);
      local_70 = local_70 & 0xffff;
      pbVar6 = std::basic_istream<char,struct_std::char_traits<char>_>::getline
                         (this,(char *)pbVar4,CONCAT44(uVar2,local_88));
      pbVar6 = pbVar6 + *(int *)(*(int *)pbVar6 + 4);
      if (((byte)pbVar6[0xc] & 6) != 0) {
        pbVar6 = (basic_istream<char,struct_std::char_traits<char>_> *)0x0;
      }
    }
  }
  if (local_65 == '\0') {
    sVar14 = (short)local_70;
    if (((param_2 != 1) && (param_2 == 0)) && ((short)local_74 != sVar14)) {
      std::basic_ostream<char,struct_std::char_traits<char>_>::
      basic_ostream<char,struct_std::char_traits<char>_>
                (local_dc,*(basic_streambuf<char,struct_std::char_traits<char>_> **)
                           (this + *(int *)(*(int *)this + 4) + 0x38),false);
      local_8 = 3;
      cVar13 = (char)(local_80 >> 0x1f);
      std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
                (local_dc,CONCAT26((short)(local_80 >> 0x1f),
                                   CONCAT15(cVar13,CONCAT14(cVar13,local_80))),0);
      sprintf((char *)local_1c,"%4.4X",0x18,sVar14);
      FUN_10020240((int *)local_dc,(char *)local_1c);
      local_8 = 0xffffffff;
      std::basic_ostream<char,struct_std::char_traits<char>_>::
      ~basic_ostream<char,struct_std::char_traits<char>_>(local_d4);
      std::basic_ios<char,struct_std::char_traits<char>_>::
      ~basic_ios<char,struct_std::char_traits<char>_>
                ((basic_ios<char,struct_std::char_traits<char>_> *)local_d4);
    }
  }
  FUN_100227d0(&local_8c);
  ExceptionList = local_10;
  uStack_d8 = 0x10021b69;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10021b70 at 10021b70

uint __cdecl FUN_10021b70(char *param_1,short param_2,short param_3)

{
  basic_streambuf<char,struct_std::char_traits<char>_> *pbVar1;
  uint uVar2;
  undefined4 extraout_EAX;
  int iVar3;
  int local_d0 [6];
  undefined1 local_b8 [96];
  code *local_58 [18];
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cfb4;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100206a0(local_d0,1);
  local_8 = 0;
  if (((param_2 == 1) || (param_2 == 5)) || (param_2 == 3)) {
    iVar3 = 1;
  }
  else {
    iVar3 = 0x23;
  }
  pbVar1 = FUN_10022b30(local_b8,param_1,iVar3,(int *)0x40);
  if (pbVar1 == (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0) {
    std::basic_ios<char,struct_std::char_traits<char>_>::setstate
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               ((int)local_d0 + *(int *)(local_d0[0] + 4)),2,false);
  }
  else {
    std::basic_ios<char,struct_std::char_traits<char>_>::clear
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               ((int)local_d0 + *(int *)(local_d0[0] + 4)),0,false);
  }
  uVar2 = FUN_10021d70((basic_istream<char,struct_std::char_traits<char>_> *)local_d0,param_2,
                       param_3);
  local_8 = 0xffffffff;
  FUN_100209b0((int)local_58);
  local_8 = 0xffffffff;
  local_58[0] = _vftable__exref;
  std::ios_base::_Ios_base_dtor((ios_base *)local_58);
  ExceptionList = local_10;
  return CONCAT31((int3)((uint)extraout_EAX >> 8),(char)uVar2);
}



// Function: FUN_10021c70 at 10021c70

uint __cdecl FUN_10021c70(ushort *param_1,short param_2,short param_3)

{
  basic_streambuf<char,struct_std::char_traits<char>_> *pbVar1;
  uint uVar2;
  undefined4 extraout_EAX;
  int iVar3;
  int local_d0 [6];
  undefined1 local_b8 [96];
  code *local_58 [18];
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002cff4;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  FUN_100206a0(local_d0,1);
  local_8 = 0;
  if (((param_2 == 1) || (param_2 == 5)) || (param_2 == 3)) {
    iVar3 = 1;
  }
  else {
    iVar3 = 0x23;
  }
  pbVar1 = FUN_10022c40(local_b8,param_1,iVar3,(int *)0x40);
  if (pbVar1 == (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0) {
    std::basic_ios<char,struct_std::char_traits<char>_>::setstate
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               ((int)local_d0 + *(int *)(local_d0[0] + 4)),2,false);
  }
  else {
    std::basic_ios<char,struct_std::char_traits<char>_>::clear
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               ((int)local_d0 + *(int *)(local_d0[0] + 4)),0,false);
  }
  uVar2 = FUN_10021d70((basic_istream<char,struct_std::char_traits<char>_> *)local_d0,param_2,
                       param_3);
  local_8 = 0xffffffff;
  FUN_100209b0((int)local_58);
  local_8 = 0xffffffff;
  local_58[0] = _vftable__exref;
  std::ios_base::_Ios_base_dtor((ios_base *)local_58);
  ExceptionList = local_10;
  return CONCAT31((int3)((uint)extraout_EAX >> 8),(char)uVar2);
}



// Function: FUN_10021d70 at 10021d70

/* WARNING: Removing unreachable block (ram,0x10022175) */

uint __cdecl
FUN_10021d70(basic_istream<char,struct_std::char_traits<char>_> *param_1,short param_2,short param_3
            )

{
  byte bVar1;
  bool bVar2;
  uint uVar3;
  int *piVar4;
  byte *pbVar5;
  undefined8 *puVar6;
  basic_istream<char,struct_std::char_traits<char>_> *pbVar7;
  undefined4 uVar8;
  int iVar9;
  byte *pbVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  ushort uVar14;
  undefined2 uVar15;
  short sVar16;
  char cVar17;
  short sVar18;
  basic_ostream<char,struct_std::char_traits<char>_> local_9c [8];
  code *local_94 [18];
  undefined8 local_4c;
  undefined8 local_44;
  undefined8 local_3c;
  int local_34;
  undefined4 local_30;
  uint local_2c;
  undefined4 local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  byte *local_18;
  byte *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d062;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  std::basic_istream<char,struct_std::char_traits<char>_>::seekg(param_1,0,2);
  piVar4 = (int *)std::basic_istream<char,struct_std::char_traits<char>_>::tellg(param_1);
  uVar11 = *piVar4 + piVar4[2] + 1;
  local_1c = uVar11;
  std::basic_istream<char,struct_std::char_traits<char>_>::seekg(param_1,0,0);
  uVar11 = uVar11 + 1;
  local_14 = (byte *)operator_new__(uVar11);
  pbVar5 = (byte *)operator_new__(uVar11);
  local_28 = 0;
  local_34 = 0;
  local_20 = 0;
  local_30 = 0;
  local_24 = 0;
  local_4c = 0;
  local_44 = 0;
  local_18 = pbVar5;
  if (((byte)param_1[*(int *)(*(int *)param_1 + 4) + 0xc] & 6) != 0) {
LAB_10022053:
    FUN_100227d0(&local_18);
    uVar11 = FUN_100227d0(&local_14);
    ExceptionList = local_10;
    return uVar11 & 0xffffff00;
  }
  if ((((param_2 == 0) || (param_2 == 1)) || (param_2 == 4)) || (param_2 == 5)) {
    sVar16 = (short)((int)local_1c >> 0x1f);
    local_20 = local_1c;
    local_1c = (int)local_1c >> 0x1f;
    pbVar7 = std::basic_istream<char,struct_std::char_traits<char>_>::getline
                       (param_1,(char *)pbVar5,CONCAT44(uVar3,CONCAT22(sVar16,sVar16)));
    pbVar7 = pbVar7 + *(int *)(*(int *)pbVar7 + 4);
    if (((byte)pbVar7[0xc] & 6) != 0) {
      pbVar7 = (basic_istream<char,struct_std::char_traits<char>_> *)0x0;
    }
    if ((pbVar7 == (basic_istream<char,struct_std::char_traits<char>_> *)0x0) ||
       (uVar8 = FUN_10020d40((char *)pbVar5,param_2,param_3,(short *)&local_28,(ushort *)&local_24,
                             local_14), (char)uVar8 == '\0')) goto LAB_10022053;
    pbVar7 = std::basic_istream<char,struct_std::char_traits<char>_>::getline
                       (param_1,(char *)pbVar5,CONCAT44(uVar3,local_1c));
    pbVar7 = pbVar7 + *(int *)(*(int *)pbVar7 + 4);
    uVar11 = local_24;
    if (((byte)pbVar7[0xc] & 6) != 0) {
      pbVar7 = (basic_istream<char,struct_std::char_traits<char>_> *)0x0;
    }
    while (pbVar7 != (basic_istream<char,struct_std::char_traits<char>_> *)0x0) {
      uVar11 = FUN_10023760(uVar11,pbVar5,0,param_3);
      uVar11 = uVar11 & 0xffff;
      pbVar7 = std::basic_istream<char,struct_std::char_traits<char>_>::getline
                         (param_1,(char *)pbVar5,CONCAT44(uVar3,local_1c));
      pbVar7 = pbVar7 + *(int *)(*(int *)pbVar7 + 4);
      if (((byte)pbVar7[0xc] & 6) != 0) {
        pbVar7 = (basic_istream<char,struct_std::char_traits<char>_> *)0x0;
      }
    }
  }
  else {
    uVar11 = 0;
    puVar6 = (undefined8 *)std::basic_istream<char,struct_std::char_traits<char>_>::tellg(param_1);
    local_4c = *puVar6;
    local_44 = puVar6[1];
    local_3c = puVar6[2];
    local_2c = (int)local_1c >> 0x1f;
    while( true ) {
      pbVar7 = std::basic_istream<char,struct_std::char_traits<char>_>::getline
                         (param_1,(char *)pbVar5,CONCAT44(uVar3,local_2c));
      pbVar7 = pbVar7 + *(int *)(*(int *)pbVar7 + 4);
      if (((byte)pbVar7[0xc] & 6) != 0) {
        pbVar7 = (basic_istream<char,struct_std::char_traits<char>_> *)0x0;
      }
      if (pbVar7 == (basic_istream<char,struct_std::char_traits<char>_> *)0x0) goto LAB_1002203a;
      if ((*pbVar5 == 0x2a) && (pbVar5[1] == 0x45)) break;
      if (param_2 == 2) {
        piVar4 = (int *)std::basic_istream<char,struct_std::char_traits<char>_>::tellg(param_1);
        local_24 = piVar4[2] + *piVar4;
        local_34 = local_34 + 1;
        FUN_10020ea0((char *)pbVar5);
        pbVar10 = pbVar5;
        do {
          bVar1 = *pbVar10;
          pbVar10 = pbVar10 + 1;
        } while (bVar1 != 0);
        if ((uint)((int)pbVar10 - (int)(pbVar5 + 1)) < 3) goto LAB_10022053;
        if (((*pbVar5 != 0x2a) || ((pbVar5[1] != 0x48 && (pbVar5[1] != 0x47)))) && (*pbVar5 != 0x42)
           ) {
          pbVar10 = pbVar5;
          do {
            bVar1 = *pbVar10;
            pbVar10 = pbVar10 + 1;
          } while (bVar1 != 0);
          pbVar5[(int)(pbVar10 + (-2 - (int)(pbVar5 + 1)))] = 0;
          bVar2 = FUN_100237d0((char *)pbVar5,0);
          if (!bVar2) goto LAB_10022053;
        }
        std::basic_ostream<char,struct_std::char_traits<char>_>::
        basic_ostream<char,struct_std::char_traits<char>_>
                  (local_9c,*(basic_streambuf<char,struct_std::char_traits<char>_> **)
                             (param_1 + *(int *)(*(int *)param_1 + 4) + 0x38),false);
        local_8 = 0;
        if (local_34 == 1) {
          cVar17 = '\0';
          sVar18 = 0;
          uVar15 = 0;
          sVar16 = 0;
        }
        else {
          cVar17 = (char)((int)local_20 >> 0x1f);
          sVar16 = (short)(local_20 >> 0x10);
          sVar18 = sVar16 >> 0xf;
          uVar15 = (undefined2)local_20;
        }
        std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
                  (local_9c,CONCAT26(sVar18,CONCAT15(cVar17,CONCAT14(cVar17,CONCAT22(sVar16,uVar15))
                                                    )),0);
        FUN_10020240((int *)local_9c,(char *)pbVar5);
        local_20 = local_24;
        local_8 = 0xffffffff;
        std::basic_ostream<char,struct_std::char_traits<char>_>::
        ~basic_ostream<char,struct_std::char_traits<char>_>
                  ((basic_ostream<char,struct_std::char_traits<char>_> *)local_94);
        local_8 = 0xffffffff;
        local_94[0] = _vftable__exref;
        std::ios_base::_Ios_base_dtor((ios_base *)local_94);
        uVar3 = (int)local_24 >> 0x1f;
        std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
                  ((basic_ostream<char,struct_std::char_traits<char>_> *)(param_1 + 0x10),
                   (longlong)(int)local_24,0);
      }
      uVar11 = FUN_10023760(uVar11,pbVar5,0,param_3);
      uVar11 = uVar11 & 0xffff;
    }
    puVar6 = (undefined8 *)std::basic_istream<char,struct_std::char_traits<char>_>::tellg(param_1);
    local_4c = *puVar6;
    local_44 = puVar6[1];
    local_3c = puVar6[2];
LAB_1002203a:
    uVar8 = FUN_10020e40((char *)pbVar5,&local_28,(ushort *)&local_30);
    if ((char)uVar8 == '\0') goto LAB_10022053;
  }
  uVar14 = (ushort)uVar11;
  if (((param_2 == 1) || (param_2 == 3)) || (param_2 == 5)) {
    FUN_100227d0(&local_18);
    FUN_100227d0(&local_14);
    uVar11 = FUN_10020ee0(param_2,uVar14,(ushort)local_28,(short)local_30);
    ExceptionList = local_10;
    return uVar11;
  }
  if ((param_2 == 0) || (param_2 == 4)) {
    if (uVar14 == (ushort)local_28) goto LAB_10022355;
    std::basic_ostream<char,struct_std::char_traits<char>_>::
    basic_ostream<char,struct_std::char_traits<char>_>
              (local_9c,*(basic_streambuf<char,struct_std::char_traits<char>_> **)
                         (param_1 + *(int *)(*(int *)param_1 + 4) + 0x38),false);
    local_8 = 2;
    std::basic_ostream<char,struct_std::char_traits<char>_>::seekp(local_9c,0,0);
    if (param_2 == 0) {
      sprintf((char *)pbVar5,"%4.4X",0x18,uVar14);
      FUN_10020240((int *)local_9c,(char *)pbVar5);
    }
    else {
      sprintf((char *)pbVar5,":04%4.4hX%s",(char)(uVar14 >> 8),(short)local_14);
      FUN_100237d0((char *)pbVar5,0);
      FUN_10020240((int *)local_9c,(char *)pbVar5);
    }
    local_8 = 0xffffffff;
    std::basic_ostream<char,struct_std::char_traits<char>_>::
    ~basic_ostream<char,struct_std::char_traits<char>_>
              ((basic_ostream<char,struct_std::char_traits<char>_> *)local_94);
  }
  else {
    local_20 = uVar11 & 0xffff;
    local_1c = (local_20 >> 8) + (uVar11 & 0xff);
    cVar17 = (char)local_1c;
    local_1c = local_1c & 0xff;
    if (cVar17 != '\0') {
      local_1c = (uint)(byte)-cVar17;
    }
    if ((uVar14 == (ushort)local_28) && ((ushort)local_1c == (ushort)local_30)) goto LAB_10022355;
    std::basic_ostream<char,struct_std::char_traits<char>_>::
    basic_ostream<char,struct_std::char_traits<char>_>
              (local_9c,*(basic_streambuf<char,struct_std::char_traits<char>_> **)
                         (param_1 + *(int *)(*(int *)param_1 + 4) + 0x38),false);
    local_8 = 4;
    uVar11 = (uint)local_4c;
    iVar13 = local_4c._4_4_;
    local_2c = (uint)local_44 - 10;
    iVar12 = local_44._4_4_ - (uint)((uint)local_44 < 10);
    iVar9 = iVar12 + local_4c._4_4_ + (uint)CARRY4(local_2c,(uint)local_4c);
    std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
              ((basic_ostream<char,struct_std::char_traits<char>_> *)(param_1 + 0x10),
               CONCAT26((short)((uint)iVar9 >> 0x10),
                        CONCAT15((char)((uint)iVar9 >> 8),
                                 CONCAT14((char)iVar9,local_2c + (uint)local_4c))),0);
    iVar9 = std::basic_istream<char,struct_std::char_traits<char>_>::get(param_1);
    uVar3 = uVar11 + (iVar9 == 10);
    iVar13 = iVar12 + iVar13 + (uint)CARRY4(uVar11,(uint)(iVar9 == 10)) +
             (uint)CARRY4(local_2c,uVar3);
    std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
              (local_9c,CONCAT26((short)((uint)iVar13 >> 0x10),
                                 CONCAT15((char)((uint)iVar13 >> 8),
                                          CONCAT14((char)iVar13,local_2c + uVar3))),0);
    pbVar5 = local_18;
    sprintf((char *)local_18,"*E%4.4X%2.2X",(char)local_20,(short)local_1c);
    FUN_10020240((int *)local_9c,(char *)pbVar5);
    local_8 = 0xffffffff;
    std::basic_ostream<char,struct_std::char_traits<char>_>::
    ~basic_ostream<char,struct_std::char_traits<char>_>
              ((basic_ostream<char,struct_std::char_traits<char>_> *)local_94);
  }
  local_8 = 0xffffffff;
  local_94[0] = _vftable__exref;
  std::ios_base::_Ios_base_dtor((ios_base *)local_94);
LAB_10022355:
  FUN_100227d0(&local_18);
  uVar8 = FUN_100227d0(&local_14);
  ExceptionList = local_10;
  return CONCAT31((int3)((uint)uVar8 >> 8),1);
}



// Function: FUN_100223c0 at 100223c0

/* WARNING: Removing unreachable block (ram,0x100225d8) */

undefined1 __cdecl FUN_100223c0(int *param_1,uint param_2,short param_3)

{
  byte bVar1;
  char cVar2;
  uint uVar3;
  int *extraout_EAX;
  int *extraout_EAX_00;
  int *extraout_EAX_01;
  byte *pbVar4;
  byte *_Dest;
  int iVar5;
  undefined4 uVar6;
  int *extraout_EAX_02;
  int *extraout_EAX_03;
  int *extraout_EAX_04;
  int *piVar7;
  int *extraout_EAX_05;
  uint uVar8;
  int extraout_EDX;
  undefined1 uVar9;
  short sVar10;
  ushort uVar11;
  undefined **local_54;
  int *local_50;
  void *local_4c;
  int local_38 [2];
  int local_30;
  undefined4 local_2c;
  undefined4 local_28;
  uint local_24;
  undefined4 local_20;
  byte *local_1c;
  byte *local_18;
  char local_11;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002d098;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_1 == (int *)0x0) {
    uVar9 = 0;
    goto LAB_100227a6;
  }
  piVar7 = param_1;
  if (param_1 == (int *)0x0) {
    _com_issue_error(-0x7fffbffd);
    piVar7 = extraout_EAX;
  }
  (**(code **)(*piVar7 + 0x14))(piVar7,0,0,2,local_38,uVar3);
  piVar7 = param_1;
  if (param_1 == (int *)0x0) {
    _com_issue_error(-0x7fffbffd);
    piVar7 = extraout_EAX_00;
  }
  (**(code **)(*piVar7 + 0x14))(piVar7,0,0,0,local_38);
  piVar7 = param_1;
  if (param_1 == (int *)0x0) {
    _com_issue_error(-0x7fffbffd);
    piVar7 = extraout_EAX_01;
  }
  FUN_1001f1f0(&local_54,piVar7,local_38[0] + 1);
  local_8 = CONCAT31(local_8._1_3_,1);
  pbVar4 = (byte *)operator_new__(local_38[0] + 2U);
  local_18 = pbVar4;
  _Dest = (byte *)operator_new__(local_38[0] + 2U);
  local_20 = 0;
  local_24 = 0;
  local_28 = 0;
  local_2c = 0;
  local_30 = 0;
  sVar10 = (short)param_2;
  local_1c = _Dest;
  if ((((sVar10 == 0) || (sVar10 == 1)) || (sVar10 == 4)) || (sVar10 == 5)) {
    iVar5 = FUN_1001f8e0(&local_54,(int *)_Dest);
    if ((iVar5 != 0) ||
       (uVar6 = FUN_10020d40((char *)_Dest,sVar10,param_3,(short *)&local_20,(ushort *)&local_24,
                             pbVar4), (char)uVar6 == '\0')) goto LAB_1002253f;
    iVar5 = FUN_1001f8e0(&local_54,(int *)_Dest);
    uVar3 = local_24;
    while (iVar5 == 0) {
      uVar3 = FUN_10023760(uVar3,_Dest,0,param_3);
      uVar3 = uVar3 & 0xffff;
      iVar5 = FUN_1001f8e0(&local_54,(int *)_Dest);
    }
LAB_1002258f:
    if (((sVar10 == 1) || (sVar10 == 3)) || (sVar10 == 5)) {
      FUN_100227d0(&local_1c);
      FUN_100227d0(&local_18);
      uVar3 = FUN_10020ee0(sVar10,(ushort)uVar3,(ushort)local_20,(short)local_28);
      uVar9 = (undefined1)uVar3;
    }
    else {
      if (sVar10 == 0) goto LAB_100226a5;
      if (sVar10 == 4) goto LAB_100226a5;
      local_24 = uVar3 & 0xffff;
      uVar8 = (local_24 >> 8) + (uVar3 & 0xff);
      cVar2 = (char)uVar8;
      param_2 = uVar8 & 0xff;
      if (cVar2 != '\0') {
        param_2 = (uint)(byte)-cVar2;
      }
      if (((ushort)uVar3 != (ushort)local_20) || ((ushort)param_2 != (ushort)local_28)) {
        piVar7 = param_1;
        if (param_1 == (int *)0x0) {
          _com_issue_error(-0x7fffbffd);
          piVar7 = extraout_EAX_02;
        }
        (**(code **)(*piVar7 + 0x14))(piVar7,0,0,0,0);
        piVar7 = param_1;
        if (param_1 == (int *)0x0) {
          _com_issue_error(-0x7fffbffd);
          piVar7 = extraout_EAX_03;
        }
        (**(code **)(*piVar7 + 0xc))(piVar7,&local_11,1,0);
        local_30 = local_30 + (uint)(local_11 == '\n');
        iVar5 = local_30 + -10;
        piVar7 = param_1;
        if (param_1 == (int *)0x0) {
          _com_issue_error(-0x7fffbffd);
          piVar7 = extraout_EAX_04;
          iVar5 = extraout_EDX;
        }
        (**(code **)(*piVar7 + 0x14))(piVar7,iVar5,0,0,0);
        sprintf((char *)_Dest,"*E%4.4X%2.2X",local_24,param_2);
        pbVar4 = _Dest;
        do {
          bVar1 = *pbVar4;
          pbVar4 = pbVar4 + 1;
        } while (bVar1 != 0);
        while (param_1 == (int *)0x0) {
          _com_issue_error(-0x7fffbffd);
LAB_100226a5:
          if ((ushort)uVar3 == (ushort)local_20) goto LAB_1002273e;
          piVar7 = param_1;
          if (param_1 == (int *)0x0) {
            _com_issue_error(-0x7fffbffd);
            piVar7 = extraout_EAX_05;
          }
          (**(code **)(*piVar7 + 0x14))(piVar7,0,0,0,0);
          if ((short)param_2 == 0) {
            sprintf((char *)_Dest,"%4.4X",uVar3 & 0xffff);
            pbVar4 = _Dest;
            do {
              bVar1 = *pbVar4;
              pbVar4 = pbVar4 + 1;
            } while (bVar1 != 0);
          }
          else {
            iVar5 = uVar3 << 8;
            uVar11 = (ushort)uVar3 >> 8;
            uVar3 = (uint)uVar11;
            sprintf((char *)_Dest,":04%4.4hX%s",(uint)(ushort)((short)iVar5 + uVar11),local_18);
            FUN_100237d0((char *)_Dest,0);
            pbVar4 = _Dest;
            do {
              bVar1 = *pbVar4;
              pbVar4 = pbVar4 + 1;
            } while (bVar1 != 0);
          }
        }
        (**(code **)(*param_1 + 0x10))(param_1,_Dest,(int)pbVar4 - (int)(_Dest + 1),0);
      }
LAB_1002273e:
      FUN_100227d0(&local_1c);
      FUN_100227d0(&local_18);
      uVar9 = 1;
    }
  }
  else {
    uVar3 = 0;
    while( true ) {
      FUN_1001f450(&local_54,&local_30);
      iVar5 = FUN_1001f8e0(&local_54,(int *)_Dest);
      if (iVar5 != 0) break;
      if ((*_Dest == 0x2a) && (_Dest[1] == 0x45)) {
        FUN_1001f450(&local_54,&local_30);
        break;
      }
      uVar3 = FUN_10023760(uVar3,_Dest,0,param_3);
      uVar3 = uVar3 & 0xffff;
    }
    uVar6 = FUN_10020e40((char *)_Dest,&local_20,(ushort *)&local_28);
    if ((char)uVar6 != '\0') goto LAB_1002258f;
LAB_1002253f:
    FUN_100227d0(&local_1c);
    FUN_100227d0(&local_18);
    uVar9 = 0;
  }
  local_8._1_3_ = (uint3)((uint)local_8 >> 8);
  local_54 = CStreamReader::vftable;
  local_8._0_1_ = 2;
  operator_delete__(local_4c);
  local_8 = (uint)local_8._1_3_ << 8;
  if (local_50 != (int *)0x0) {
    (**(code **)(*local_50 + 8))(local_50);
  }
LAB_100227a6:
  local_8 = 0xffffffff;
  if (param_1 != (int *)0x0) {
    (**(code **)(*param_1 + 8))(param_1);
  }
  ExceptionList = local_10;
  return uVar9;
}



// Function: FUN_100227d0 at 100227d0

void __cdecl FUN_100227d0(undefined4 *param_1)

{
  if ((void *)*param_1 != (void *)0x0) {
    operator_delete__((void *)*param_1);
    *param_1 = 0;
  }
  return;
}



// Function: FUN_10022800 at 10022800

bool __cdecl FUN_10022800(int *param_1,int *param_2)

{
  return *param_1 == *param_2;
}



// Function: FUN_10022820 at 10022820

void __thiscall FUN_10022820(void *this,byte *param_1,uint param_2)

{
  byte bVar1;
  byte *pbVar2;
  
  if (*param_1 == 0) {
    FUN_10022860(this,param_1,param_2,0);
    return;
  }
  pbVar2 = param_1;
  do {
    bVar1 = *pbVar2;
    pbVar2 = pbVar2 + 1;
  } while (bVar1 != 0);
  FUN_10022860(this,param_1,param_2,(int)pbVar2 - (int)(param_1 + 1));
  return;
}



// Function: FUN_10022860 at 10022860

uint __thiscall FUN_10022860(void *this,byte *param_1,uint param_2,uint param_3)

{
  void *pvVar1;
  byte *pbVar2;
  byte *_Buf;
  uint uVar3;
  byte *_MaxCount;
  
  if ((param_3 == 0) && (param_2 <= *(uint *)((int)this + 0x10))) {
    return param_2;
  }
  if ((param_2 < *(uint *)((int)this + 0x10)) &&
     (uVar3 = *(uint *)((int)this + 0x10) - param_2, param_3 <= uVar3)) {
    _MaxCount = (byte *)(uVar3 + (1 - param_3));
    pvVar1 = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
      pvVar1 = *this;
    }
    _Buf = (byte *)(param_2 + (int)pvVar1);
    while ((_MaxCount != (byte *)0x0 &&
           (pbVar2 = (byte *)memchr(_Buf,(int)(char)*param_1,(size_t)_MaxCount),
           pbVar2 != (byte *)0x0))) {
      uVar3 = FUN_10021490(pbVar2,param_1,param_3);
      if (uVar3 == 0) {
        if (0xf < *(uint *)((int)this + 0x14)) {
                    /* WARNING: Load size is inaccurate */
          this = *this;
        }
        return (int)pbVar2 - (int)this;
      }
      _MaxCount = _Buf + (int)(_MaxCount + (-1 - (int)pbVar2));
      _Buf = pbVar2 + 1;
    }
  }
  return 0xffffffff;
}



// Function: FUN_10022900 at 10022900

void __cdecl FUN_10022900(void *param_1,size_t param_2,char *param_3)

{
  if (param_2 == 0) {
    return;
  }
  memchr(param_1,(int)*param_3,param_2);
  return;
}



// Function: FUN_10022930 at 10022930

void __cdecl
FUN_10022930(basic_istream<char,struct_std::char_traits<char>_> *param_1,char *param_2,int param_3)

{
  char cVar1;
  bool bVar2;
  uint uVar3;
  int *piVar4;
  basic_istream<char,struct_std::char_traits<char>_> *pbVar5;
  int iVar6;
  char *pcVar7;
  void *local_2c [4];
  int local_1c;
  uint local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d0c8;
  local_10 = ExceptionList;
  uVar3 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  bVar2 = false;
  local_14 = uVar3;
  if ((param_2 == (char *)0x0) || (param_3 == 0)) {
    std::basic_istream<char,struct_std::char_traits<char>_>::seekg(param_1,0,2);
    piVar4 = (int *)std::basic_istream<char,struct_std::char_traits<char>_>::tellg(param_1);
    param_3 = *piVar4 + 1 + piVar4[2];
    param_2 = (char *)operator_new__(param_3 + 1);
    bVar2 = true;
  }
  std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
            ((basic_ostream<char,struct_std::char_traits<char>_> *)(param_1 + 0x10),0,0);
  pbVar5 = std::basic_istream<char,struct_std::char_traits<char>_>::getline
                     (param_1,param_2,CONCAT44(uVar3,param_3 >> 0x1f));
  pbVar5 = pbVar5 + *(int *)(*(int *)pbVar5 + 4);
  if (((byte)pbVar5[0xc] & 6) != 0) {
    pbVar5 = (basic_istream<char,struct_std::char_traits<char>_> *)0x0;
  }
  if (pbVar5 != (basic_istream<char,struct_std::char_traits<char>_> *)0x0) {
    local_18 = 0xf;
    local_1c = 0;
    local_2c[0] = (void *)((uint)local_2c[0] & 0xffffff00);
    if (*param_2 == '\0') {
      uVar3 = 0;
    }
    else {
      pcVar7 = param_2;
      do {
        cVar1 = *pcVar7;
        pcVar7 = pcVar7 + 1;
      } while (cVar1 != '\0');
      uVar3 = (int)pcVar7 - (int)(param_2 + 1);
    }
    std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
              ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
               local_2c,param_2,uVar3);
    local_8 = 0;
    std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
              ((basic_ostream<char,struct_std::char_traits<char>_> *)(param_1 + 0x10),
               (ulonglong)(local_1c + 1),0);
    iVar6 = std::basic_istream<char,struct_std::char_traits<char>_>::get(param_1);
    if (iVar6 != 10) {
      std::basic_istream<char,struct_std::char_traits<char>_>::get(param_1);
    }
    std::basic_ostream<char,struct_std::char_traits<char>_>::seekp
              ((basic_ostream<char,struct_std::char_traits<char>_> *)(param_1 + 0x10),0,0);
    local_8 = 0xffffffff;
    if (0xf < local_18) {
      operator_delete(local_2c[0]);
    }
    local_18 = 0xf;
    local_1c = 0;
    local_2c[0] = (void *)((uint)local_2c[0] & 0xffffff00);
  }
  if (bVar2) {
    operator_delete__(param_2);
  }
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10022ac0 at 10022ac0

undefined4 FUN_10022ac0(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_10022ad0 at 10022ad0

void __thiscall FUN_10022ad0(void *this,locale *param_1)

{
  bool bVar1;
  facet *this_00;
  
  this_00 = FUN_10020500(param_1);
  bVar1 = std::codecvt_base::always_noconv((codecvt_base *)this_00);
  if (bVar1) {
    *(undefined4 *)((int)this + 0x40) = 0;
    return;
  }
  *(facet **)((int)this + 0x40) = this_00;
  std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
            ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
  return;
}



// Function: FUN_10022b10 at 10022b10

int __cdecl FUN_10022b10(int *param_1)

{
  int iVar1;
  
  iVar1 = 0;
  if (*param_1 != -1) {
    iVar1 = *param_1;
  }
  return iVar1;
}



// Function: FUN_10022b30 at 10022b30

basic_streambuf<char,struct_std::char_traits<char>_> * __thiscall
FUN_10022b30(void *this,char *param_1,int param_2,int *param_3)

{
  bool bVar1;
  _iobuf *p_Var2;
  locale *plVar3;
  facet *this_00;
  undefined4 *puVar4;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d0f8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (*(int *)((int)this + 0x50) == 0) {
    p_Var2 = std::_Fiopen(param_1,param_2,(int)param_3);
    if (p_Var2 != (_iobuf *)0x0) {
      *(undefined1 *)((int)this + 0x4c) = 1;
      *(undefined1 *)((int)this + 0x45) = 0;
      std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
                ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
      *(char ***)((int)this + 0xc) = &p_Var2->_base;
      *(char ***)((int)this + 0x10) = &p_Var2->_base;
      *(int **)((int)this + 0x2c) = &p_Var2->_cnt;
      *(int **)((int)this + 0x30) = &p_Var2->_cnt;
      *(_iobuf **)((int)this + 0x1c) = p_Var2;
      *(_iobuf **)((int)this + 0x20) = p_Var2;
      *(_iobuf **)((int)this + 0x50) = p_Var2;
      *(undefined4 *)((int)this + 0x48) = DAT_10040510;
      *(undefined4 *)((int)this + 0x40) = 0;
      plVar3 = (locale *)
               std::basic_streambuf<char,struct_std::char_traits<char>_>::getloc
                         ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
      local_8 = 0;
      this_00 = FUN_10020500(plVar3);
      bVar1 = std::codecvt_base::always_noconv((codecvt_base *)this_00);
      if (bVar1) {
        *(undefined4 *)((int)this + 0x40) = 0;
      }
      else {
        *(facet **)((int)this + 0x40) = this_00;
        std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
                  ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
      }
      local_8 = 0xffffffff;
      if (param_3 != (int *)0x0) {
        puVar4 = (undefined4 *)(**(code **)(*param_3 + 8))();
        if (puVar4 != (undefined4 *)0x0) {
          (**(code **)*puVar4)(1);
        }
      }
      ExceptionList = local_10;
      return (basic_streambuf<char,struct_std::char_traits<char>_> *)this;
    }
  }
  ExceptionList = local_10;
  return (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;
}



// Function: FUN_10022c40 at 10022c40

basic_streambuf<char,struct_std::char_traits<char>_> * __thiscall
FUN_10022c40(void *this,ushort *param_1,int param_2,int *param_3)

{
  bool bVar1;
  _iobuf *p_Var2;
  locale *plVar3;
  facet *this_00;
  undefined4 *puVar4;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d128;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if (*(int *)((int)this + 0x50) == 0) {
    p_Var2 = std::_Fiopen(param_1,param_2,(int)param_3);
    if (p_Var2 != (_iobuf *)0x0) {
      *(undefined1 *)((int)this + 0x4c) = 1;
      *(undefined1 *)((int)this + 0x45) = 0;
      std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
                ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
      *(char ***)((int)this + 0xc) = &p_Var2->_base;
      *(char ***)((int)this + 0x10) = &p_Var2->_base;
      *(int **)((int)this + 0x2c) = &p_Var2->_cnt;
      *(int **)((int)this + 0x30) = &p_Var2->_cnt;
      *(_iobuf **)((int)this + 0x1c) = p_Var2;
      *(_iobuf **)((int)this + 0x20) = p_Var2;
      *(_iobuf **)((int)this + 0x50) = p_Var2;
      *(undefined4 *)((int)this + 0x48) = DAT_10040510;
      *(undefined4 *)((int)this + 0x40) = 0;
      plVar3 = (locale *)
               std::basic_streambuf<char,struct_std::char_traits<char>_>::getloc
                         ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
      local_8 = 0;
      this_00 = FUN_10020500(plVar3);
      bVar1 = std::codecvt_base::always_noconv((codecvt_base *)this_00);
      if (bVar1) {
        *(undefined4 *)((int)this + 0x40) = 0;
      }
      else {
        *(facet **)((int)this + 0x40) = this_00;
        std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
                  ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
      }
      local_8 = 0xffffffff;
      if (param_3 != (int *)0x0) {
        puVar4 = (undefined4 *)(**(code **)(*param_3 + 8))();
        if (puVar4 != (undefined4 *)0x0) {
          (**(code **)*puVar4)(1);
        }
      }
      ExceptionList = local_10;
      return (basic_streambuf<char,struct_std::char_traits<char>_> *)this;
    }
  }
  ExceptionList = local_10;
  return (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;
}



// Function: FUN_10022d50 at 10022d50

void __thiscall FUN_10022d50(void *this,char *param_1,int param_2,int *param_3)

{
  basic_streambuf<char,struct_std::char_traits<char>_> *pbVar1;
  
  pbVar1 = FUN_10022b30((void *)((int)this + 0x18),param_1,param_2,param_3);
                    /* WARNING: Load size is inaccurate */
  if (pbVar1 == (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0) {
    std::basic_ios<char,struct_std::char_traits<char>_>::setstate
              ((basic_ios<char,struct_std::char_traits<char>_> *)(*(int *)(*this + 4) + (int)this),2
               ,false);
    return;
  }
  std::basic_ios<char,struct_std::char_traits<char>_>::clear
            ((basic_ios<char,struct_std::char_traits<char>_> *)(*(int *)(*this + 4) + (int)this),0,
             false);
  return;
}



// Function: FUN_10022d90 at 10022d90

void __thiscall FUN_10022d90(void *this,ushort *param_1,int param_2,int *param_3)

{
  basic_streambuf<char,struct_std::char_traits<char>_> *pbVar1;
  
  pbVar1 = FUN_10022c40((void *)((int)this + 0x18),param_1,param_2,param_3);
                    /* WARNING: Load size is inaccurate */
  if (pbVar1 == (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0) {
    std::basic_ios<char,struct_std::char_traits<char>_>::setstate
              ((basic_ios<char,struct_std::char_traits<char>_> *)(*(int *)(*this + 4) + (int)this),2
               ,false);
    return;
  }
  std::basic_ios<char,struct_std::char_traits<char>_>::clear
            ((basic_ios<char,struct_std::char_traits<char>_> *)(*(int *)(*this + 4) + (int)this),0,
             false);
  return;
}



// Function: FUN_10022dd0 at 10022dd0

/* WARNING: Removing unreachable block (ram,0x10022e9f) */

void __thiscall FUN_10022dd0(void *this,int param_1)

{
  uint uVar1;
  char *pcVar2;
  int iVar3;
  ulonglong *puVar4;
  size_t sVar5;
  ulonglong *puVar6;
  ulonglong *puVar7;
  char cVar8;
  char *local_3c;
  char *local_38;
  size_t local_34;
  char local_30;
  char acStack_2f [3];
  ulonglong local_2c;
  undefined1 local_24;
  uint local_1c;
  uint local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d158;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  if (param_1 != -1) {
    uVar1 = **(uint **)((int)this + 0x20);
    cVar8 = (char)param_1;
    if ((uVar1 == 0) || (**(int **)((int)this + 0x30) + uVar1 <= uVar1)) {
      if (*(int *)((int)this + 0x50) != 0) {
        if (**(int **)((int)this + 0xc) == (int)this + 0x44) {
          std::basic_streambuf<char,struct_std::char_traits<char>_>::setg
                    ((basic_streambuf<char,struct_std::char_traits<char>_> *)this,
                     *(char **)((int)this + 0x38),*(char **)((int)this + 0x3c),
                     *(char **)((int)this + 0x3c));
        }
        if (*(int *)((int)this + 0x40) == 0) {
          fputc((int)cVar8,*(FILE **)((int)this + 0x50));
        }
        else {
          local_18 = 0xf;
          local_2c = 0;
          _local_30 = CONCAT31(acStack_2f,cVar8);
          local_1c = 8;
          local_24 = 0;
          local_8 = 0;
          while( true ) {
            puVar4 = (ulonglong *)local_2c;
            do {
              puVar7 = &local_2c;
              if (0xf < local_18) {
                puVar7 = puVar4;
              }
              puVar6 = &local_2c;
              if (0xf < local_18) {
                puVar6 = puVar4;
              }
              iVar3 = std::codecvt<char,char,int>::out
                                (*(codecvt<char,char,int> **)((int)this + 0x40),
                                 (int *)((int)this + 0x48),&local_30,acStack_2f,&local_38,
                                 (char *)puVar6,(char *)((int)puVar7 + local_1c),&local_3c);
              if (iVar3 < 0) goto LAB_10022fa1;
              if (1 < iVar3) {
                if (iVar3 == 3) {
                  FUN_100204c0((char)_local_30,*(FILE **)((int)this + 0x50));
                }
                goto LAB_10022fa1;
              }
              puVar4 = &local_2c;
              if (0xf < local_18) {
                puVar4 = (ulonglong *)local_2c;
              }
              local_34 = (int)local_3c - (int)puVar4;
              if (local_34 != 0) {
                puVar4 = &local_2c;
                if (0xf < local_18) {
                  puVar4 = (ulonglong *)local_2c;
                }
                sVar5 = fwrite(puVar4,1,local_34,*(FILE **)((int)this + 0x50));
                if (local_34 != sVar5) goto LAB_10022fa1;
              }
              *(undefined1 *)((int)this + 0x45) = 1;
              if (local_38 != &local_30) goto LAB_10022fa1;
              puVar4 = (ulonglong *)local_2c;
            } while (local_34 != 0);
            if (0x1f < local_1c) break;
            FUN_100212a0(&local_2c,8,'\0');
          }
LAB_10022fa1:
          local_8 = 0xffffffff;
          if (0xf < local_18) {
            operator_delete((ulonglong *)local_2c);
          }
          local_18 = 0xf;
          local_1c = 0;
          local_2c = local_2c & 0xffffffffffffff00;
        }
      }
    }
    else {
      pcVar2 = std::basic_streambuf<char,struct_std::char_traits<char>_>::_Pninc
                         ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
      *pcVar2 = cVar8;
    }
  }
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10022ff0 at 10022ff0

uint __thiscall FUN_10022ff0(void *this,uint param_1)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = **(uint **)((int)this + 0x1c);
  if (((uVar1 != 0) && (**(uint **)((int)this + 0xc) < uVar1)) &&
     ((param_1 == 0xffffffff || (*(byte *)(uVar1 - 1) == param_1)))) {
    **(int **)((int)this + 0x2c) = **(int **)((int)this + 0x2c) + 1;
    **(int **)((int)this + 0x1c) = **(int **)((int)this + 0x1c) + -1;
    uVar1 = 0;
    if (param_1 != 0xffffffff) {
      uVar1 = param_1;
    }
    return uVar1;
  }
  if ((*(FILE **)((int)this + 0x50) != (FILE *)0x0) && (param_1 != 0xffffffff)) {
    if ((*(int *)((int)this + 0x40) == 0) &&
       (iVar2 = ungetc(param_1 & 0xff,*(FILE **)((int)this + 0x50)), iVar2 != -1)) {
      return param_1;
    }
    if ((undefined1 *)**(int **)((int)this + 0x1c) != (undefined1 *)((int)this + 0x44)) {
      *(undefined1 *)((int)this + 0x44) = (char)param_1;
      std::basic_filebuf<char,struct_std::char_traits<char>_>::_Set_back
                ((basic_filebuf<char,struct_std::char_traits<char>_> *)this);
      return param_1;
    }
  }
  return 0xffffffff;
}



// Function: FUN_10023080 at 10023080

void __thiscall
FUN_10023080(void *this,int *param_1,
            basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
            *param_2,basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                     *param_3)

{
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> bVar1;
  basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_> *pbVar2;
  
  if (*param_3 ==
      (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>)0x0) {
    FUN_1001ffa0(this,param_1,param_2,param_3,(int *)0x0);
    return;
  }
  pbVar2 = param_3;
  do {
    bVar1 = *pbVar2;
    pbVar2 = pbVar2 + 1;
  } while (bVar1 != (basic_string<char,struct_std::char_traits<char>,class_std::_DebugHeapAllocator<char>_>
                     )0x0);
  FUN_1001ffa0(this,param_1,param_2,param_3,(int *)(pbVar2 + -(int)(param_3 + 1)));
  return;
}



// Function: FUN_100230d0 at 100230d0

void __thiscall FUN_100230d0(void *this,undefined4 *param_1,int param_2,int param_3,int param_4)

{
  undefined4 uVar1;
  code *pcVar2;
  char cVar3;
  int iVar4;
  int unaff_EDI;
  int iVar5;
  
  iVar4 = param_3;
  iVar5 = param_2;
  if (((**(int **)((int)this + 0x1c) == (int)this + 0x44) && (param_4 == 1)) &&
     (*(int *)((int)this + 0x40) == 0)) {
    iVar4 = param_3 + -1 + (uint)(param_2 != 0);
    iVar5 = param_2 + -1;
  }
  if ((((*(int *)((int)this + 0x50) != 0) && (cVar3 = FUN_10020fb0((int *)this), cVar3 != '\0')) &&
      (((iVar5 == 0 && iVar4 == 0 && (param_4 == 1)) ||
       (iVar4 = _fseeki64(*(FILE **)((int)this + 0x50),CONCAT44(param_4,iVar4),unaff_EDI),
       iVar4 == 0)))) &&
     (iVar4 = fgetpos(*(FILE **)((int)this + 0x50),(fpos_t *)&param_2), iVar4 == 0)) {
    if (**(int **)((int)this + 0xc) == (int)this + 0x44) {
      uVar1 = *(undefined4 *)((int)this + 0x3c);
      **(int **)((int)this + 0xc) = *(int *)((int)this + 0x38);
      **(undefined4 **)((int)this + 0x1c) = uVar1;
      **(undefined4 **)((int)this + 0x2c) = 0;
    }
    param_1[2] = param_2;
    param_1[3] = param_3;
    uVar1 = *(undefined4 *)((int)this + 0x48);
    *param_1 = 0;
    param_1[1] = 0;
    param_1[4] = uVar1;
    return;
  }
  pcVar2 = _BADOFF_exref;
  *param_1 = *(undefined4 *)_BADOFF_exref;
  param_1[1] = *(undefined4 *)(pcVar2 + 4);
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  return;
}



// Function: FUN_100231d0 at 100231d0

void __thiscall
FUN_100231d0(void *this,undefined4 *param_1,int param_2,int param_3,undefined4 param_4,
            undefined4 param_5,undefined4 param_6)

{
  undefined4 uVar1;
  code *pcVar2;
  char cVar3;
  int iVar4;
  int unaff_EDI;
  undefined4 local_c;
  undefined4 local_8;
  
  local_c = param_4;
  local_8 = param_5;
  if (*(int *)((int)this + 0x50) != 0) {
    cVar3 = FUN_10020fb0((int *)this);
    if (cVar3 != '\0') {
      iVar4 = fsetpos(*(FILE **)((int)this + 0x50),(fpos_t *)&local_c);
      if (iVar4 == 0) {
        if (param_2 != 0 || param_3 != 0) {
          iVar4 = _fseeki64(*(FILE **)((int)this + 0x50),CONCAT44(1,param_3),unaff_EDI);
          if (iVar4 != 0) goto LAB_1002327a;
        }
        iVar4 = fgetpos(*(FILE **)((int)this + 0x50),(fpos_t *)&local_c);
        if (iVar4 == 0) {
          *(undefined4 *)((int)this + 0x48) = param_6;
          std::basic_filebuf<char,struct_std::char_traits<char>_>::_Reset_back
                    ((basic_filebuf<char,struct_std::char_traits<char>_> *)this);
          param_1[2] = local_c;
          param_1[3] = local_8;
          uVar1 = *(undefined4 *)((int)this + 0x48);
          *param_1 = 0;
          param_1[1] = 0;
          param_1[4] = uVar1;
          return;
        }
      }
    }
  }
LAB_1002327a:
  pcVar2 = _BADOFF_exref;
  *param_1 = *(undefined4 *)_BADOFF_exref;
  param_1[1] = *(undefined4 *)(pcVar2 + 4);
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  return;
}



// Function: FUN_100232c0 at 100232c0

basic_streambuf<char,struct_std::char_traits<char>_> * __thiscall
FUN_100232c0(void *this,char *param_1,size_t param_2,int param_3)

{
  int iVar1;
  
  if (*(FILE **)((int)this + 0x50) != (FILE *)0x0) {
    if ((param_1 == (char *)0x0) && (param_2 == 0 && param_3 == 0)) {
      iVar1 = 4;
    }
    else {
      iVar1 = 0;
    }
    iVar1 = setvbuf(*(FILE **)((int)this + 0x50),param_1,iVar1,param_2);
    if (iVar1 == 0) {
      iVar1 = *(int *)((int)this + 0x50);
      *(undefined1 *)((int)this + 0x4c) = 1;
      *(undefined1 *)((int)this + 0x45) = 0;
      std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init
                ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);
      if (iVar1 != 0) {
        *(int *)((int)this + 0xc) = iVar1 + 8;
        *(int *)((int)this + 0x10) = iVar1 + 8;
        *(int *)((int)this + 0x1c) = iVar1;
        *(int *)((int)this + 0x20) = iVar1;
        *(int *)((int)this + 0x2c) = iVar1 + 4;
        *(int *)((int)this + 0x30) = iVar1 + 4;
      }
      *(int *)((int)this + 0x50) = iVar1;
      *(undefined4 *)((int)this + 0x48) = DAT_10040510;
      *(undefined4 *)((int)this + 0x40) = 0;
      return (basic_streambuf<char,struct_std::char_traits<char>_> *)this;
    }
  }
  return (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;
}



// Function: FUN_10023360 at 10023360

basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall
FUN_10023360(void *this,
            basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *param_1,
            uint param_2,uint param_3)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d199;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>)0x0;
  std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
            (param_1,(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *
                     )this,param_2,param_3);
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_100233d0 at 100233d0

undefined4 __fastcall FUN_100233d0(int *param_1)

{
  int iVar1;
  
  if (param_1[0x14] != 0) {
    iVar1 = (**(code **)(*param_1 + 0xc))(0xffffffff);
    if (iVar1 != -1) {
      iVar1 = fflush((FILE *)param_1[0x14]);
      if (iVar1 < 0) {
        return 0xffffffff;
      }
    }
  }
  return 0;
}



// Function: FUN_10023400 at 10023400

undefined1 __cdecl FUN_10023400(undefined1 *param_1)

{
  return *param_1;
}



// Function: FUN_10023410 at 10023410

undefined1 __cdecl FUN_10023410(undefined1 *param_1)

{
  return *param_1;
}



// Function: FUN_10023420 at 10023420

void __fastcall FUN_10023420(basic_streambuf<char,struct_std::char_traits<char>_> *param_1)

{
  uint uVar1;
  int iVar2;
  char ******ppppppcVar3;
  char ******ppppppcVar4;
  char *pcVar5;
  char *local_38;
  char *local_34;
  char local_2d;
  char *****local_2c [4];
  int local_1c;
  uint local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d1c8;
  local_10 = ExceptionList;
  local_14 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  uVar1 = **(uint **)(param_1 + 0x1c);
  if ((uVar1 == 0) || (**(int **)(param_1 + 0x2c) + uVar1 <= uVar1)) {
    if (*(int *)(param_1 + 0x50) != 0) {
      if ((basic_streambuf<char,struct_std::char_traits<char>_> *)**(int **)(param_1 + 0xc) ==
          param_1 + 0x44) {
        std::basic_streambuf<char,struct_std::char_traits<char>_>::setg
                  (param_1,*(char **)(param_1 + 0x38),*(char **)(param_1 + 0x3c),
                   *(char **)(param_1 + 0x3c));
      }
      if (*(int *)(param_1 + 0x40) != 0) {
        local_18 = 0xf;
        local_1c = 0;
        local_2c[0] = (char *****)((uint)local_2c[0] & 0xffffff00);
        local_8 = 0;
        iVar2 = fgetc(*(FILE **)(param_1 + 0x50));
        do {
          if (iVar2 == -1) goto LAB_100235a7;
          FUN_100212a0(local_2c,1,(char)iVar2);
          ppppppcVar3 = local_2c;
          if (0xf < local_18) {
            ppppppcVar3 = (char ******)local_2c[0];
          }
          ppppppcVar4 = local_2c;
          if (0xf < local_18) {
            ppppppcVar4 = (char ******)local_2c[0];
          }
          iVar2 = std::codecvt<char,char,int>::in
                            (*(codecvt<char,char,int> **)(param_1 + 0x40),(int *)(param_1 + 0x48),
                             (char *)ppppppcVar4,(char *)((int)ppppppcVar3 + local_1c),&local_34,
                             &local_2d,(char *)local_2c,&local_38);
          if (iVar2 < 0) goto LAB_100235a7;
          if (iVar2 < 2) {
            if (local_38 != &local_2d) {
              ppppppcVar3 = local_2c;
              if (0xf < local_18) {
                ppppppcVar3 = (char ******)local_2c[0];
              }
              for (pcVar5 = (char *)((int)ppppppcVar3 + (local_1c - (int)local_34)); 0 < (int)pcVar5
                  ; pcVar5 = pcVar5 + -1) {
                ungetc((int)local_34[(int)(pcVar5 + -1)],*(FILE **)(param_1 + 0x50));
              }
LAB_100235a7:
              local_8 = 0xffffffff;
              if (0xf < local_18) {
                operator_delete(local_2c[0]);
              }
              local_18 = 0xf;
              local_1c = 0;
              local_2c[0] = (char *****)((uint)local_2c[0] & 0xffffff00);
              goto LAB_100235d3;
            }
            ppppppcVar3 = local_2c;
            if (0xf < local_18) {
              ppppppcVar3 = (char ******)local_2c[0];
            }
            std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase
                      ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                        *)local_2c,0,(int)local_34 - (int)ppppppcVar3);
          }
          else {
            if (iVar2 != 3) goto LAB_100235a7;
            if (local_1c != 0) {
              ppppppcVar3 = local_2c;
              if (0xf < local_18) {
                ppppppcVar3 = (char ******)local_2c[0];
              }
              memcpy_s(&local_2d,1,ppppppcVar3,1);
              goto LAB_100235a7;
            }
          }
          iVar2 = fgetc(*(FILE **)(param_1 + 0x50));
        } while( true );
      }
      fgetc(*(FILE **)(param_1 + 0x50));
    }
  }
  else {
    std::basic_streambuf<char,struct_std::char_traits<char>_>::_Gninc(param_1);
  }
LAB_100235d3:
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10023630 at 10023630

uint __fastcall FUN_10023630(int *param_1)

{
  byte *pbVar1;
  uint uVar2;
  
  pbVar1 = *(byte **)param_1[7];
  if ((pbVar1 != (byte *)0x0) && (pbVar1 < pbVar1 + *(int *)param_1[0xb])) {
    return (uint)*pbVar1;
  }
  uVar2 = (**(code **)(*param_1 + 0x1c))();
  if (uVar2 == 0xffffffff) {
    return 0xffffffff;
  }
  (**(code **)(*param_1 + 0x10))(uVar2);
  return uVar2;
}



// Function: FUN_10023670 at 10023670

ushort * __cdecl FUN_10023670(short param_1)

{
  int *piVar1;
  undefined4 *puVar2;
  uint uVar3;
  uint uVar4;
  ushort *puVar5;
  ushort uVar6;
  
  piVar1 = (int *)PTR_PTR_10040360;
  if (PTR_PTR_10040360 != (undefined *)0x0) {
    do {
      if ((short)piVar1[1] == param_1) {
        return (ushort *)((int)piVar1 + 6);
      }
      piVar1 = (int *)*piVar1;
    } while (piVar1 != (int *)0x0);
  }
  puVar2 = (undefined4 *)operator_new(0x208);
  if (puVar2 == (undefined4 *)0x0) {
    return (ushort *)0x0;
  }
  *(short *)(puVar2 + 1) = param_1;
  uVar4 = 0;
  puVar5 = (ushort *)((int)puVar2 + 6);
  do {
    if ((&DAT_1003fe50)[uVar4] == '\0') {
      uVar6 = 0;
    }
    else {
      uVar6 = param_1 * 2;
    }
    uVar3 = uVar4 & 0xffff;
    uVar4 = uVar4 + 1;
    *puVar5 = (ushort)((uVar3 * 2 ^ uVar3) << 6) ^ uVar6;
    puVar5 = puVar5 + 1;
  } while ((int)uVar4 < 0x100);
  *puVar2 = PTR_PTR_10040360;
  PTR_PTR_10040360 = (undefined *)puVar2;
  return (ushort *)((int)puVar2 + 6);
}



// Function: FUN_10023710 at 10023710

void __cdecl FUN_10023710(undefined4 param_1,undefined4 param_2,ushort param_3,short param_4)

{
  ushort uVar1;
  
  FUN_10023670(param_4);
  for (uVar1 = 0; (param_3 == 0 || (uVar1 < param_3)); uVar1 = uVar1 + 1) {
  }
  return;
}



// Function: FUN_10023760 at 10023760

uint __cdecl FUN_10023760(uint param_1,byte *param_2,ushort param_3,short param_4)

{
  ushort *puVar1;
  byte bVar2;
  ushort uVar3;
  
  puVar1 = FUN_10023670(param_4);
  bVar2 = *param_2;
  uVar3 = 0;
  if (bVar2 == 0) {
    return CONCAT22((short)((uint)puVar1 >> 0x10),(undefined2)param_1);
  }
  do {
    if ((param_3 != 0) && (param_3 <= uVar3)) {
      return param_1;
    }
    if (0x1f < bVar2) {
      param_1 = (uint)((ushort)(param_1 >> 7) & 0x1fe ^ puVar1[(bVar2 ^ param_1) & 0xff]);
    }
    bVar2 = param_2[1];
    param_2 = param_2 + 1;
    uVar3 = uVar3 + 1;
  } while (bVar2 != 0);
  return param_1;
}



// Function: FUN_100237d0 at 100237d0

bool __cdecl FUN_100237d0(char *param_1,short param_2)

{
  bool bVar1;
  int iVar2;
  char cVar3;
  char *pcVar4;
  char local_c [4];
  undefined1 local_8 [2];
  byte bStack_6;
  
  pcVar4 = (char *)0x0;
  bVar1 = true;
  _local_8 = 0;
  if (param_1 != (char *)0x0) {
    FUN_10023d80(param_1);
    cVar3 = *param_1;
    if (cVar3 == '*') {
      pcVar4 = param_1 + 2;
    }
    else if ((cVar3 == '+') || (cVar3 == ':')) {
      pcVar4 = param_1 + 1;
    }
    else {
      bVar1 = false;
    }
    cVar3 = '\0';
    if (bVar1) {
      while (*pcVar4 != '\0') {
        iVar2 = isxdigit((int)*pcVar4);
        if (iVar2 == 0) {
LAB_10023867:
          pcVar4 = pcVar4 + 1;
        }
        else {
          if (local_8[0] != '\0') {
            local_8[1] = *pcVar4;
            sscanf(local_8,"%2x",local_c);
            cVar3 = cVar3 + local_c[0];
            _local_8 = (uint3)bStack_6 << 0x10;
            goto LAB_10023867;
          }
          _local_8 = CONCAT21(stack0xfffffff9,*pcVar4);
          pcVar4 = pcVar4 + 1;
        }
      }
    }
    if (local_8[0] == '\0') {
      if (bVar1 != false) {
        if (param_2 != 0) {
          if (param_2 != 1) {
            return false;
          }
          if (cVar3 != '\0') {
            return false;
          }
          return bVar1;
        }
        sprintf(local_8,"%2.2X",-cVar3);
        strncat(param_1,local_8,2);
      }
      return bVar1;
    }
  }
  return false;
}



// Function: FUN_100238d0 at 100238d0

undefined1 * __thiscall FUN_100238d0(void *this,LPCSTR param_1,LPCSTR param_2,LPCSTR param_3)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d32e;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)((int)this + 0x14) = 0xf;
  *(undefined4 *)((int)this + 0x10) = 0;
  *(undefined1 *)this = 0;
  *(undefined4 *)((int)this + 0x2c) = 0xf;
  *(undefined4 *)((int)this + 0x28) = 0;
  *(undefined1 *)((int)this + 0x18) = 0;
  *(undefined4 *)((int)this + 0x44) = 0xf;
  *(undefined4 *)((int)this + 0x40) = 0;
  *(undefined1 *)((int)this + 0x30) = 0;
  local_8 = 2;
  FUN_10023b50(this,param_1,param_2,param_3);
  ExceptionList = local_10;
  return (undefined1 *)this;
}



// Function: FUN_10023970 at 10023970

undefined1 * __thiscall FUN_10023970(void *this,HMODULE param_1,LPCSTR param_2,LPCSTR param_3)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d36e;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)((int)this + 0x14) = 0xf;
  *(undefined4 *)((int)this + 0x10) = 0;
  *(undefined1 *)this = 0;
  *(undefined4 *)((int)this + 0x2c) = 0xf;
  *(undefined4 *)((int)this + 0x28) = 0;
  *(undefined1 *)((int)this + 0x18) = 0;
  *(undefined4 *)((int)this + 0x44) = 0xf;
  *(undefined4 *)((int)this + 0x40) = 0;
  *(undefined1 *)((int)this + 0x30) = 0;
  local_8 = 2;
  FUN_10023d20(this,param_1,param_2,param_3);
  ExceptionList = local_10;
  return (undefined1 *)this;
}



// Function: FUN_10023a10 at 10023a10

undefined1 * __fastcall FUN_10023a10(undefined1 *param_1)

{
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  *(undefined4 *)(param_1 + 0x2c) = 0xf;
  *(undefined4 *)(param_1 + 0x28) = 0;
  param_1[0x18] = 0;
  *(undefined4 *)(param_1 + 0x44) = 0xf;
  *(undefined4 *)(param_1 + 0x40) = 0;
  param_1[0x30] = 0;
  return param_1;
}



// Function: FUN_10023a90 at 10023a90

void __fastcall FUN_10023a90(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002d3ee;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 1;
  if (0xf < (uint)param_1[0x11]) {
    operator_delete((void *)param_1[0xc]);
  }
  param_1[0x11] = 0xf;
  param_1[0x10] = 0;
  *(undefined1 *)(param_1 + 0xc) = 0;
  local_8 = local_8 & 0xffffff00;
  if (0xf < (uint)param_1[0xb]) {
    operator_delete((void *)param_1[6]);
  }
  param_1[0xb] = 0xf;
  param_1[10] = 0;
  *(undefined1 *)(param_1 + 6) = 0;
  local_8 = 0xffffffff;
  if (0xf < (uint)param_1[5]) {
    operator_delete((void *)*param_1);
  }
  param_1[5] = 0xf;
  param_1[4] = 0;
  *(undefined1 *)param_1 = 0;
  ExceptionList = local_10;
  return;
}



// Function: FUN_10023b50 at 10023b50

void __thiscall FUN_10023b50(void *this,LPCSTR param_1,LPCSTR param_2,LPCSTR param_3)

{
  char cVar1;
  LPCSTR lpString2;
  DWORD _Size;
  void *lpData;
  BOOL BVar2;
  uint uVar3;
  char *pcVar4;
  uint local_240;
  char *local_23c;
  DWORD local_238;
  LPCSTR local_234;
  LPCSTR local_230;
  LPCSTR local_22c;
  LPVOID local_228;
  CHAR local_224 [500];
  char local_30 [20];
  char local_1c [20];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_230 = param_2;
  local_22c = param_3;
  local_234 = param_1;
  _Size = GetFileVersionInfoSizeA(param_1,&local_238);
  if ((_Size != 0) && (lpData = malloc(_Size), lpData != (void *)0x0)) {
    GetFileVersionInfoA(local_234,local_238,_Size,lpData);
    VerQueryValueA(lpData,"\\",&local_228,&local_240);
    sprintf(local_1c,"%u.%u.%u.%u",(uint)*(ushort *)((int)local_228 + 0x12),
            (uint)*(ushort *)((int)local_228 + 0x10),(uint)*(ushort *)((int)local_228 + 0x16),
            (uint)*(ushort *)((int)local_228 + 0x14));
    sprintf(local_30,"%u.%u.%u.%u",(uint)*(ushort *)((int)local_228 + 10),
            (uint)*(ushort *)((int)local_228 + 8),(uint)*(ushort *)((int)local_228 + 0xe),
            (uint)*(ushort *)((int)local_228 + 0xc));
    if (local_1c[0] == '\0') {
      uVar3 = 0;
    }
    else {
      pcVar4 = local_1c;
      do {
        cVar1 = *pcVar4;
        pcVar4 = pcVar4 + 1;
      } while (cVar1 != '\0');
      uVar3 = (int)pcVar4 - (int)(local_1c + 1);
    }
    std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
              ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
               ((int)this + 0x30),local_1c,uVar3);
    if (local_30[0] == '\0') {
      uVar3 = 0;
    }
    else {
      pcVar4 = local_30;
      do {
        cVar1 = *pcVar4;
        pcVar4 = pcVar4 + 1;
      } while (cVar1 != '\0');
      uVar3 = (int)pcVar4 - (int)(local_30 + 1);
    }
    std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::assign
              ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
               ((int)this + 0x18),local_30,uVar3);
    lpString2 = local_230;
    if ((local_230 != (LPCSTR)0x0) || (local_22c != (LPCSTR)0x0)) {
      lstrcpyA(local_224,"\\StringFileInfo\\");
      lstrcatA(local_224,lpString2);
      lstrcatA(local_224,"\\");
      lstrcatA(local_224,local_22c);
      BVar2 = VerQueryValueA(lpData,local_224,&local_23c,&local_240);
      if (BVar2 != 0) {
        std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::operator=
                  ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)
                   this,local_23c);
      }
    }
    free(lpData);
  }
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10023d20 at 10023d20

void __thiscall FUN_10023d20(void *this,HMODULE param_1,LPCSTR param_2,LPCSTR param_3)

{
  CHAR local_10c [260];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  if (param_1 != (HMODULE)0x0) {
    GetModuleFileNameA(param_1,local_10c,0x104);
    FUN_10023b50(this,local_10c,param_2,param_3);
  }
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10023d80 at 10023d80

char * __cdecl FUN_10023d80(char *param_1)

{
  char cVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  
  pcVar3 = param_1;
  if (*param_1 == '\0') {
    return param_1;
  }
  do {
    pcVar4 = pcVar3;
    pcVar3 = pcVar4 + 1;
  } while (*pcVar4 != '\0');
  pcVar4 = pcVar4 + -1;
  iVar2 = _ismbcspace((int)*param_1);
  for (pcVar3 = param_1; (iVar2 != 0 && (*pcVar3 != '\0')); pcVar3 = pcVar3 + 1) {
    iVar2 = _ismbcspace((int)pcVar3[1]);
  }
  iVar2 = _ismbcspace((int)*pcVar4);
  for (; (iVar2 != 0 && (pcVar3 < pcVar4)); pcVar4 = pcVar4 + -1) {
    iVar2 = _ismbcspace((int)pcVar4[-1]);
  }
  pcVar4[1] = '\0';
  if (pcVar3 != param_1) {
    pcVar4 = pcVar3;
    do {
      cVar1 = *pcVar4;
      pcVar4 = pcVar4 + 1;
    } while (cVar1 != '\0');
    memmove(param_1,pcVar3,(size_t)(pcVar4 + (1 - (int)(pcVar3 + 1))));
  }
  return param_1;
}



// Function: FUN_10023e30 at 10023e30

undefined4 * __thiscall FUN_10023e30(void *this,int *param_1)

{
  int iVar1;
  int *piVar2;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d538;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(undefined4 *)this = 0;
  piVar2 = (int *)*param_1;
  if (piVar2 != (int *)0x0) {
    (**(code **)(*piVar2 + 4))(piVar2);
  }
  local_8 = 0xffffffff;
  iVar1 = FUN_10024010(this,piVar2);
  if ((iVar1 < 0) && (iVar1 != -0x7fffbffe)) {
    _com_issue_error(iVar1);
  }
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: FUN_10023eb0 at 10023eb0

int * __thiscall FUN_10023eb0(void *this,int *param_1)

{
  int *piVar1;
  
                    /* WARNING: Load size is inaccurate */
  piVar1 = *this;
  if (piVar1 != param_1) {
    *(int **)this = param_1;
    if (param_1 != (int *)0x0) {
      (**(code **)(*param_1 + 4))(param_1);
    }
    if (piVar1 != (int *)0x0) {
      (**(code **)(*piVar1 + 8))(piVar1);
    }
  }
  return (int *)this;
}



// Function: FUN_10023ee0 at 10023ee0

int * __thiscall FUN_10023ee0(void *this,int *param_1)

{
  int *piVar1;
  
                    /* WARNING: Load size is inaccurate */
  piVar1 = *this;
  if (piVar1 != param_1) {
    *(int **)this = param_1;
    if (param_1 != (int *)0x0) {
      (**(code **)(*param_1 + 4))(param_1);
    }
    if (piVar1 != (int *)0x0) {
      (**(code **)(*piVar1 + 8))(piVar1);
    }
  }
  return (int *)this;
}



// Function: FUN_10023f10 at 10023f10

void * __thiscall FUN_10023f10(void *this,int *param_1)

{
  int iVar1;
  int *piVar2;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d568;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  piVar2 = (int *)*param_1;
  if (piVar2 != (int *)0x0) {
    (**(code **)(*piVar2 + 4))(piVar2);
  }
  local_8 = 0xffffffff;
  iVar1 = FUN_10024010(this,piVar2);
  if ((iVar1 < 0) && (iVar1 != -0x7fffbffe)) {
    _com_issue_error(iVar1);
  }
  ExceptionList = local_10;
  return this;
}



// Function: FUN_10023f90 at 10023f90

void * __thiscall FUN_10023f90(void *this,int *param_1)

{
  int iVar1;
  int *piVar2;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d598;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  piVar2 = (int *)*param_1;
  if (piVar2 != (int *)0x0) {
    (**(code **)(*piVar2 + 4))(piVar2);
  }
  local_8 = 0xffffffff;
  iVar1 = FUN_100240d0(this,piVar2);
  if ((iVar1 < 0) && (iVar1 != -0x7fffbffe)) {
    _com_issue_error(iVar1);
  }
  ExceptionList = local_10;
  return this;
}



// Function: FUN_10024010 at 10024010

int __thiscall FUN_10024010(void *this,int *param_1)

{
  uint uVar1;
  int *extraout_EAX;
  int *piVar2;
  int iVar3;
  void *pvVar4;
  void *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d5c8;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  local_14 = this;
  if (param_1 == (int *)0x0) {
                    /* WARNING: Load size is inaccurate */
    piVar2 = *this;
    if (piVar2 != (int *)0x0) {
      *(undefined4 *)this = 0;
      (**(code **)(*piVar2 + 8))(piVar2,uVar1);
    }
    iVar3 = -0x7fffbffe;
  }
  else {
    piVar2 = param_1;
    if (param_1 == (int *)0x0) {
      _com_issue_error(-0x7fffbffd);
      piVar2 = extraout_EAX;
    }
    iVar3 = (**(code **)*piVar2)(piVar2,&DAT_1002fab8,&local_14);
                    /* WARNING: Load size is inaccurate */
    piVar2 = *this;
    pvVar4 = (void *)0x0;
    if (-1 < iVar3) {
      pvVar4 = local_14;
    }
    if (piVar2 != (int *)0x0) {
      (**(code **)(*piVar2 + 8))(piVar2);
    }
    *(void **)this = pvVar4;
  }
  local_8 = 0xffffffff;
  if (param_1 != (int *)0x0) {
    (**(code **)(*param_1 + 8))(param_1);
  }
  ExceptionList = local_10;
  return iVar3;
}



// Function: FUN_100240d0 at 100240d0

int __thiscall FUN_100240d0(void *this,int *param_1)

{
  uint uVar1;
  int *extraout_EAX;
  int *piVar2;
  int iVar3;
  void *pvVar4;
  void *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d5f8;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  local_14 = this;
  if (param_1 == (int *)0x0) {
                    /* WARNING: Load size is inaccurate */
    piVar2 = *this;
    if (piVar2 != (int *)0x0) {
      *(undefined4 *)this = 0;
      (**(code **)(*piVar2 + 8))(piVar2,uVar1);
    }
    iVar3 = -0x7fffbffe;
  }
  else {
    piVar2 = param_1;
    if (param_1 == (int *)0x0) {
      _com_issue_error(-0x7fffbffd);
      piVar2 = extraout_EAX;
    }
    iVar3 = (**(code **)*piVar2)(piVar2,&DAT_10034290,&local_14);
                    /* WARNING: Load size is inaccurate */
    piVar2 = *this;
    pvVar4 = (void *)0x0;
    if (-1 < iVar3) {
      pvVar4 = local_14;
    }
    if (piVar2 != (int *)0x0) {
      (**(code **)(*piVar2 + 8))(piVar2);
    }
    *(void **)this = pvVar4;
  }
  local_8 = 0xffffffff;
  if (param_1 != (int *)0x0) {
    (**(code **)(*param_1 + 8))(param_1);
  }
  ExceptionList = local_10;
  return iVar3;
}



// Function: FUN_10024190 at 10024190

undefined4 * __fastcall FUN_10024190(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_100241e0 at 100241e0

undefined4 * __fastcall FUN_100241e0(undefined4 *param_1)

{
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10024250 at 10024250

undefined4 * __thiscall FUN_10024250(void *this,IID *param_1,LPUNKNOWN param_2,LPUNKNOWN param_3)

{
  code *pcVar1;
  HRESULT HVar2;
  undefined4 *puVar3;
  
  *(undefined4 *)this = 0;
  HVar2 = FUN_10025b60(this,param_1,param_2,param_3);
  if ((HVar2 < 0) && (HVar2 != -0x7fffbffe)) {
    _com_issue_error(HVar2);
    pcVar1 = (code *)swi(3);
    puVar3 = (undefined4 *)(*pcVar1)();
    return puVar3;
  }
  return (undefined4 *)this;
}



// Function: FUN_10024290 at 10024290

int * __thiscall FUN_10024290(void *this,int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  *(int **)this = piVar1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))(piVar1);
  }
  return (int *)this;
}



// Function: FUN_100242c0 at 100242c0

int * __thiscall FUN_100242c0(void *this,int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  *(int **)this = piVar1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))(piVar1);
  }
  return (int *)this;
}



// Function: FUN_100242e0 at 100242e0

undefined4 * __thiscall FUN_100242e0(void *this,int *param_1,char param_2)

{
  *(int **)this = param_1;
  if ((param_2 != '\0') && (param_1 != (int *)0x0)) {
    (**(code **)(*param_1 + 4))(param_1);
  }
  return (undefined4 *)this;
}



// Function: FUN_10024320 at 10024320

int * __thiscall FUN_10024320(void *this,int param_1)

{
  undefined **local_14;
  DWORD local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  *(int *)this = param_1;
  if (param_1 == 0) {
    local_10 = GetLastError();
    if (0 < (int)local_10) {
      local_10 = local_10 & 0xffff | 0x80070000;
    }
    local_14 = _com_error::vftable;
    local_c = 0;
    local_8 = 0;
                    /* WARNING: Subroutine does not return */
    _CxxThrowException(&local_14,(ThrowInfo *)&DAT_1003c588);
  }
  return (int *)this;
}



// Function: FUN_10024380 at 10024380

int * __thiscall FUN_10024380(void *this,int param_1)

{
  undefined **local_14;
  int local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  *(int *)this = param_1;
  if (-1 < param_1) {
    return (int *)this;
  }
  local_10 = param_1;
  local_14 = _com_error::vftable;
  local_c = 0;
  local_8 = 0;
                    /* WARNING: Subroutine does not return */
  _CxxThrowException(&local_14,(ThrowInfo *)&DAT_1003c588);
}



// Function: FUN_100243c0 at 100243c0

int * __thiscall FUN_100243c0(void *this,int param_1,char param_2)

{
  code *pcVar1;
  undefined4 uVar2;
  int iVar3;
  int *piVar4;
  
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 1;
  if ((param_2 == '\0') || (param_1 == 0)) {
    *(int *)this = param_1;
  }
  else {
    uVar2 = Ordinal_149(param_1);
    iVar3 = Ordinal_150(param_1,uVar2);
    *(int *)this = iVar3;
    if (iVar3 == 0) {
      _com_issue_error(-0x7ff8fff2);
      pcVar1 = (code *)swi(3);
      piVar4 = (int *)(*pcVar1)();
      return piVar4;
    }
  }
  return (int *)this;
}



// Function: FUN_10024410 at 10024410

undefined4 * __thiscall FUN_10024410(void *this,int param_1,char param_2)

{
  uint uVar1;
  int *piVar2;
  undefined4 uVar3;
  int iVar4;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d68b;
  local_10 = ExceptionList;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  piVar2 = (int *)operator_new(0xc);
  local_8 = 0;
  if (piVar2 == (int *)0x0) {
    piVar2 = (int *)0x0;
  }
  else {
    piVar2[1] = 0;
    piVar2[2] = 1;
    if ((param_2 != '\0') && (param_1 != 0)) {
      uVar3 = Ordinal_149(param_1,uVar1);
      iVar4 = Ordinal_150(param_1,uVar3);
      *piVar2 = iVar4;
      if (iVar4 != 0) goto LAB_10024492;
      _com_issue_error(-0x7ff8fff2);
    }
    *piVar2 = param_1;
  }
LAB_10024492:
  local_8 = 0xffffffff;
  *(int **)this = piVar2;
  if (piVar2 == (int *)0x0) {
    _com_issue_error(-0x7ff8fff2);
  }
  ExceptionList = local_10;
  return (undefined4 *)this;
}



// Function: _com_error at 100244c0

/* Library Function - Single Match
    public: __thiscall _com_error::_com_error(class _com_error const &)
   
   Library: Visual Studio 2012 Release */

_com_error * __thiscall _com_error::_com_error(_com_error *this,_com_error *param_1)

{
  int *piVar1;
  
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  piVar1 = *(int **)(param_1 + 8);
  *(int **)(this + 8) = piVar1;
  *(undefined4 *)(this + 0xc) = 0;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))(piVar1);
  }
  return this;
}



// Function: FUN_10024500 at 10024500

void __fastcall FUN_10024500(int *param_1)

{
  int *piVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d6b8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1,DAT_10040398 ^ (uint)&stack0xfffffffc,param_1);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10024550 at 10024550

void __fastcall FUN_10024550(int *param_1)

{
  int *piVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d6e8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0xffffffff;
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1,DAT_10040398 ^ (uint)&stack0xfffffffc,param_1);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_100245a0 at 100245a0

void __fastcall FUN_100245a0(int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  return;
}



// Function: FUN_100245b0 at 100245b0

void __fastcall FUN_100245b0(int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  return;
}



// Function: FUN_100245c0 at 100245c0

void __fastcall FUN_100245c0(int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  return;
}



// Function: FUN_100245d0 at 100245d0

void __fastcall FUN_100245d0(int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  return;
}



// Function: FUN_100245e0 at 100245e0

void __fastcall FUN_100245e0(int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  return;
}



// Function: FUN_100245f0 at 100245f0

int * __thiscall FUN_100245f0(void *this,int param_1)

{
  undefined **local_14;
  DWORD local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  *(int *)this = param_1;
  if (param_1 == 0) {
    local_10 = GetLastError();
    if (0 < (int)local_10) {
      local_10 = local_10 & 0xffff | 0x80070000;
    }
    local_14 = _com_error::vftable;
    local_c = 0;
    local_8 = 0;
                    /* WARNING: Subroutine does not return */
    _CxxThrowException(&local_14,(ThrowInfo *)&DAT_1003c588);
  }
  return (int *)this;
}



// Function: FUN_10024650 at 10024650

int * __thiscall FUN_10024650(void *this,int param_1)

{
  undefined **local_14;
  int local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  *(int *)this = param_1;
  if (-1 < param_1) {
    return (int *)this;
  }
  local_10 = param_1;
  local_14 = _com_error::vftable;
  local_c = 0;
  local_8 = 0;
                    /* WARNING: Subroutine does not return */
  _CxxThrowException(&local_14,(ThrowInfo *)&DAT_1003c588);
}



// Function: FUN_10024690 at 10024690

uint __thiscall FUN_10024690(void *this,int param_1)

{
  code *pcVar1;
  uint uVar2;
  
  if (param_1 == 0) {
                    /* WARNING: Load size is inaccurate */
    return (uint)(*this == 0);
  }
  _com_issue_error(-0x7fffbffd);
  pcVar1 = (code *)swi(3);
  uVar2 = (*pcVar1)();
  return uVar2;
}



// Function: FUN_100246b0 at 100246b0

uint __thiscall FUN_100246b0(void *this,int param_1)

{
  code *pcVar1;
  uint uVar2;
  
  if (param_1 == 0) {
                    /* WARNING: Load size is inaccurate */
    return (uint)(*this == 0);
  }
  _com_issue_error(-0x7fffbffd);
  pcVar1 = (code *)swi(3);
  uVar2 = (*pcVar1)();
  return uVar2;
}



// Function: FUN_100246d0 at 100246d0

uint __thiscall FUN_100246d0(void *this,int param_1)

{
  code *pcVar1;
  uint uVar2;
  
  if (param_1 == 0) {
                    /* WARNING: Load size is inaccurate */
    return (uint)(*this != 0);
  }
  _com_issue_error(-0x7fffbffd);
  pcVar1 = (code *)swi(3);
  uVar2 = (*pcVar1)();
  return uVar2;
}



// Function: FUN_100246f0 at 100246f0

uint __thiscall FUN_100246f0(void *this,int param_1)

{
  code *pcVar1;
  uint uVar2;
  
  if (param_1 == 0) {
                    /* WARNING: Load size is inaccurate */
    return (uint)(*this != 0);
  }
  _com_issue_error(-0x7fffbffd);
  pcVar1 = (code *)swi(3);
  uVar2 = (*pcVar1)();
  return uVar2;
}



// Function: FUN_10024780 at 10024780

void __fastcall FUN_10024780(int *param_1)

{
  code *pcVar1;
  
  if (*param_1 != 0) {
    return;
  }
  _com_issue_error(-0x7fffbffd);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Function: FUN_10024800 at 10024800

int * __fastcall FUN_10024800(int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10024820 at 10024820

int * __fastcall FUN_10024820(int *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  *param_1 = 0;
  return param_1;
}



// Function: FUN_10024840 at 10024840

ULONG __fastcall FUN_10024840(IUnknown *param_1)

{
  ULONG UVar1;
  
  UVar1 = (*param_1->lpVtbl[8].Release)(param_1);
  if ((int)UVar1 < 0) {
    _com_issue_errorex(UVar1,param_1,(_GUID *)&DAT_1003422c);
  }
  return UVar1;
}



// Function: FUN_10024870 at 10024870

void FUN_10024870(IID *param_1,LPCSTR param_2,undefined4 param_3,undefined4 param_4)

{
  FUN_10024890(param_1,param_2,0,(LPCSTR)0x0,param_3,param_4);
  return;
}



// Function: FUN_10024890 at 10024890

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_10024890(IID *param_1,LPCSTR param_2,int param_3,LPCSTR param_4,undefined4 param_5,
                 undefined4 param_6)

{
  char *pcVar1;
  undefined4 *puVar2;
  uint uVar3;
  char cVar4;
  LPWSTR pWVar5;
  LPWSTR pWVar6;
  long lVar7;
  LPCSTR pCVar8;
  undefined4 *_Memory;
  uint local_30;
  char *local_1c;
  undefined4 *local_18;
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d718;
  local_10 = ExceptionList;
  local_30 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_14 = local_30;
  if (param_2 == (LPCSTR)0x0) goto LAB_10024a06;
  _Memory = (undefined4 *)0x0;
  local_18 = (undefined4 *)0x0;
  local_8 = 0;
  pCVar8 = param_2;
  do {
    cVar4 = *pCVar8;
    pCVar8 = pCVar8 + 1;
  } while (cVar4 != '\0');
  pcVar1 = pCVar8 + (1 - (int)(param_2 + 1));
  uVar3 = (int)pcVar1 * 2;
  if ((((int)pcVar1 >> 0x1f) << 1 | (uint)pcVar1 >> 0x1f) + (uint)(0x7fffffff < uVar3) == 0) {
    if (((int)uVar3 < 0x401) && (cVar4 = FUN_10012fe0(uVar3), cVar4 != '\0')) {
      pWVar5 = (LPWSTR)&local_30;
    }
    else {
      pWVar5 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                       CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                 ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)&local_18,
                                  uVar3);
      _Memory = local_18;
    }
    pWVar5 = FUN_100107c0(pWVar5,param_2,(uint)pcVar1 & 0x7fffffff,3);
    if (pWVar5 != (LPWSTR)0x0) {
      pWVar6 = (LPWSTR)0x0;
      if (param_4 == (LPCSTR)0x0) {
LAB_100249c4:
        FUN_10024a30(param_1,pWVar5,param_3,(int)pWVar6,param_5,param_6,(HINSTANCE)0x0);
      }
      else {
        pCVar8 = param_4;
        do {
          cVar4 = *pCVar8;
          pCVar8 = pCVar8 + 1;
        } while (cVar4 != '\0');
        local_1c = pCVar8 + (1 - (int)(param_4 + 1));
        lVar7 = ATL::AtlMultiply<int>((int *)&local_1c,(int)local_1c,2);
        pcVar1 = local_1c;
        if (-1 < lVar7) {
          if (((int)local_1c < 0x401) && (cVar4 = FUN_10012fe0((int)local_1c), cVar4 != '\0')) {
            pWVar6 = (LPWSTR)&local_30;
          }
          else {
            pWVar6 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                             CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                       ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)
                                        &local_18,(ulong)pcVar1);
            _Memory = local_18;
          }
          pWVar6 = FUN_100107c0(pWVar6,param_4,(uint)pcVar1 >> 1,3);
          if (pWVar6 != (LPWSTR)0x0) goto LAB_100249c4;
        }
      }
    }
  }
  local_8 = 0xffffffff;
  while (_Memory != (undefined4 *)0x0) {
    puVar2 = (undefined4 *)*_Memory;
    local_18 = puVar2;
    free(_Memory);
    _Memory = puVar2;
  }
LAB_10024a06:
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10024a30 at 10024a30

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */

void FUN_10024a30(IID *param_1,LPWSTR param_2,int param_3,int param_4,undefined4 param_5,int param_6
                 ,HINSTANCE param_7)

{
  undefined4 *puVar1;
  uint uVar2;
  char cVar3;
  int iVar4;
  errno_t eVar5;
  LPWSTR pWVar6;
  char *pcVar7;
  undefined4 *_Memory;
  uint local_440;
  LPOLESTR local_424;
  undefined4 *local_420;
  int *local_41c;
  int *local_418;
  CHAR local_414 [1024];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002d78d;
  local_10 = ExceptionList;
  local_440 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  _Memory = (undefined4 *)0x0;
  local_420 = (undefined4 *)0x0;
  local_8 = 0;
  local_414[0] = '\0';
  local_14 = local_440;
  if (((uint)param_2 & 0xffff0000) == 0) {
    local_41c = (int *)((uint)param_2 & 0xffff);
    iVar4 = LoadStringA(param_7,(UINT)local_41c,local_414,0x400);
    if (iVar4 == 0) {
      eVar5 = strcpy_s(local_414,0x400,"Unknown Error");
      ATL::AtlCrtErrorCheck(eVar5);
    }
    pcVar7 = local_414;
    do {
      cVar3 = *pcVar7;
      pcVar7 = pcVar7 + 1;
    } while (cVar3 != '\0');
    pcVar7 = pcVar7 + (1 - (int)(local_414 + 1));
    uVar2 = (int)pcVar7 * 2;
    if ((((int)pcVar7 >> 0x1f) << 1 | (uint)pcVar7 >> 0x1f) + (uint)(0x7fffffff < uVar2) == 0) {
      if (((int)uVar2 < 0x401) && (cVar3 = FUN_10012fe0(uVar2), cVar3 != '\0')) {
        pWVar6 = (LPWSTR)&local_440;
      }
      else {
        pWVar6 = (LPWSTR)ATL::_ATL_SAFE_ALLOCA_IMPL::
                         CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::Allocate
                                   ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)
                                    &local_420,uVar2);
        _Memory = local_420;
      }
      param_2 = FUN_100107c0(pWVar6,local_414,(uint)pcVar7 & 0x7fffffff,3);
      if (param_2 != (LPWSTR)0x0) goto LAB_10024b8f;
    }
    local_8 = 0xffffffff;
    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
    ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
              ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)&local_420);
  }
  else {
LAB_10024b8f:
    local_418 = (int *)0x0;
    local_8._0_1_ = 2;
    iVar4 = Ordinal_202(&local_418);
    if (-1 < iVar4) {
      local_41c = (int *)0x0;
      local_8 = CONCAT31(local_8._1_3_,4);
      (**(code **)(*local_418 + 0xc))(local_418,param_5);
      ProgIDFromCLSID(param_1,&local_424);
      if (local_424 != (LPOLESTR)0x0) {
        (**(code **)(*local_418 + 0x10))(local_418,local_424);
      }
      if ((param_3 != 0) && (param_4 != 0)) {
        (**(code **)(*local_418 + 0x1c))(local_418,param_3);
        (**(code **)(*local_418 + 0x18))(local_418,param_4);
      }
      CoTaskMemFree(local_424);
      (**(code **)(*local_418 + 0x14))(local_418,param_2);
      iVar4 = (**(code **)*local_418)(local_418,&DAT_1002fab8,&local_41c);
      if (-1 < iVar4) {
        Ordinal_201(0,local_41c);
      }
      local_8._0_1_ = 2;
      if (local_41c != (int *)0x0) {
        (**(code **)(*local_41c + 8))(local_41c);
      }
    }
    local_8 = (uint)local_8._1_3_ << 8;
    if (local_418 != (int *)0x0) {
      (**(code **)(*local_418 + 8))(local_418);
    }
    local_8 = 0xffffffff;
    while (_Memory != (undefined4 *)0x0) {
      puVar1 = (undefined4 *)*_Memory;
      local_420 = puVar1;
      free(_Memory);
      _Memory = puVar1;
    }
  }
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10024d00 at 10024d00

void __thiscall FUN_10024d00(void *this,int param_1)

{
  int *piVar1;
  
                    /* WARNING: Load size is inaccurate */
  piVar1 = *this;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  *(int *)this = param_1;
  return;
}



// Function: FUN_10024d20 at 10024d20

void __thiscall FUN_10024d20(void *this,int param_1)

{
  int *piVar1;
  
                    /* WARNING: Load size is inaccurate */
  piVar1 = *this;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  *(int *)this = param_1;
  return;
}



// Function: FUN_10024d40 at 10024d40

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void FUN_10024d40(void *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined8 param_5,undefined8 param_6)

{
  int *piVar1;
  undefined1 *puVar2;
  LPSTR pCVar3;
  HRESULT HVar4;
  void *this;
  uint uStack_207c;
  LPUNKNOWN local_2054;
  undefined1 *local_2050;
  int *local_204c;
  undefined4 local_2048;
  undefined4 local_2044;
  undefined4 local_2040;
  void *local_203c;
  undefined8 local_2038;
  undefined8 local_2030;
  uint local_18;
  undefined1 *local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d84f;
  local_10 = ExceptionList;
  uStack_207c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_14 = (undefined1 *)&uStack_207c;
  ExceptionList = &local_10;
  local_2044 = param_2;
  local_2048 = param_4;
  local_2038 = param_5;
  local_2030 = param_6;
  local_2040 = *(undefined4 *)((int)param_1 + 4);
  local_18 = uStack_207c;
  FUN_10025bf0(param_1,&local_204c);
  piVar1 = local_204c;
  local_8 = 0;
  if ((local_204c != (int *)0x0) && (local_204c[1] == 0)) {
    pCVar3 = ConvertBSTRToString((LPCWSTR)*local_204c);
    piVar1[1] = (int)pCVar3;
  }
  local_203c = (void *)0x0;
  HVar4 = CoCreateInstance((IID *)&DAT_10034280,(LPUNKNOWN)0x0,0x17,(IID *)&DAT_1002f4c4,&local_2054
                          );
  if (-1 < HVar4) {
    HVar4 = OleRun(local_2054);
    if (-1 < HVar4) {
      HVar4 = (*local_2054->lpVtbl->QueryInterface)(local_2054,(IID *)&DAT_1003423c,&local_203c);
    }
    (*local_2054->lpVtbl->Release)(local_2054);
    if (-1 < HVar4) goto LAB_10024e72;
  }
  local_203c = (void *)0x0;
  if ((HVar4 < 0) && (HVar4 != -0x7fffbffe)) {
    _com_issue_error(HVar4);
  }
LAB_10024e72:
  local_8._1_3_ = (undefined3)((uint)local_8 >> 8);
  local_8._0_1_ = 2;
  local_2050 = &stack0xffffdf80;
  puVar2 = &stack0xffffdf80;
  if (local_204c != (int *)0x0) {
    InterlockedIncrement(local_204c + 2);
    puVar2 = local_2050;
  }
  local_2050 = puVar2;
  local_8._0_1_ = 3;
  this = (void *)FUN_10024780((int *)&local_203c);
  local_8 = CONCAT31(local_8._1_3_,2);
  FUN_10026140(this,local_204c);
  local_8 = 1;
  FUN_10025005();
  return;
}



// Function: Catch@10024ec5 at 10024ec5

undefined * Catch_10024ec5(void)

{
  IUnknown *extraout_ECX;
  int *extraout_ECX_00;
  void *extraout_ECX_01;
  void *extraout_ECX_02;
  IUnknown *extraout_ECX_03;
  int *extraout_ECX_04;
  void *extraout_ECX_05;
  void *pvVar1;
  IUnknown *extraout_ECX_06;
  IUnknown *pIVar2;
  int unaff_EBP;
  int *piVar3;
  
  pIVar2 = *(IUnknown **)(unaff_EBP + -0x2038);
  if (pIVar2 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pIVar2 = extraout_ECX;
  }
  FUN_10024840(pIVar2);
  if (*(LPCSTR *)(unaff_EBP + -0x2058) == (LPCSTR)0x0) {
    *(undefined1 *)(unaff_EBP + -0x2014) = 0;
    piVar3 = (int *)0x1fff;
    memset((void *)(unaff_EBP + -0x2013),0,0x1fff);
    FUN_10025e50((ushort)*(undefined4 *)(unaff_EBP + -0x203c),(LPSTR)(unaff_EBP + -0x2014));
    *(undefined1 **)(unaff_EBP + -0x204c) = &stack0xfffffffc;
    FUN_1000e770(&stack0xfffffffc,(LPCSTR)(unaff_EBP + -0x2014));
    *(undefined1 *)(unaff_EBP + -4) = 5;
    pvVar1 = *(void **)(unaff_EBP + -0x2038);
    if (pvVar1 == (void *)0x0) {
      _com_issue_error(-0x7fffbffd);
      pvVar1 = extraout_ECX_01;
    }
    *(undefined1 *)(unaff_EBP + -4) = 4;
    FUN_10025ee0(pvVar1,piVar3);
  }
  else {
    *(undefined1 **)(unaff_EBP + -0x204c) = &stack0xfffffffc;
    piVar3 = extraout_ECX_00;
    FUN_1000e770(&stack0xfffffffc,*(LPCSTR *)(unaff_EBP + -0x2058));
    *(undefined1 *)(unaff_EBP + -4) = 6;
    pvVar1 = *(void **)(unaff_EBP + -0x2038);
    if (pvVar1 == (void *)0x0) {
      _com_issue_error(-0x7fffbffd);
      pvVar1 = extraout_ECX_02;
    }
    *(undefined1 *)(unaff_EBP + -4) = 4;
    FUN_10025ee0(pvVar1,piVar3);
  }
  pIVar2 = *(IUnknown **)(unaff_EBP + -0x2038);
  if (pIVar2 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pIVar2 = extraout_ECX_03;
  }
  FUN_10025fa0(pIVar2);
  *(undefined1 **)(unaff_EBP + -0x204c) = &stack0xfffffffc;
  piVar3 = extraout_ECX_04;
  FUN_1000e770(&stack0xfffffffc,"");
  *(undefined1 *)(unaff_EBP + -4) = 7;
  pvVar1 = *(void **)(unaff_EBP + -0x2038);
  if (pvVar1 == (void *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pvVar1 = extraout_ECX_05;
  }
  *(undefined1 *)(unaff_EBP + -4) = 4;
  FUN_10025fd0(pvVar1,piVar3);
  pIVar2 = *(IUnknown **)(unaff_EBP + -0x2038);
  if (pIVar2 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pIVar2 = extraout_ECX_06;
  }
  FUN_10026090(pIVar2);
  return &DAT_10024ff2;
}



// Function: FUN_10025005 at 10025005

/* WARNING: Removing unreachable block (ram,0x100252b2) */

void FUN_10025005(void)

{
  int *piVar1;
  IUnknown *pIVar2;
  undefined4 *puVar3;
  uchar *puVar4;
  ULONG UVar5;
  int *extraout_EAX;
  int *piVar6;
  int *piVar7;
  LPSTR pCVar8;
  LPCSTR pCVar9;
  undefined4 uVar10;
  LONG LVar11;
  int *extraout_ECX;
  int *extraout_ECX_00;
  void *extraout_ECX_01;
  int *extraout_ECX_02;
  void *extraout_ECX_03;
  void *extraout_ECX_04;
  void *pvVar12;
  undefined4 uVar13;
  void *extraout_ECX_05;
  uchar *unaff_EBX;
  uint unaff_EBP;
  int unaff_EDI;
  undefined4 uStack00000004;
  
  *(undefined8 *)(unaff_EBP - 0x2024) = 0;
  *(undefined8 *)(unaff_EBP - 0x201c) = 0;
  if (*(int **)(unaff_EDI + 8) != (int *)0x0) {
    (**(code **)(**(int **)(unaff_EDI + 8) + 4))();
  }
  piVar1 = *(int **)(unaff_EDI + 8);
  *(int **)(unaff_EBP - 0x204c) = piVar1;
  *(undefined1 *)(unaff_EBP - 4) = 8;
  if (piVar1 != (int *)0x0) {
    if (piVar1 == (int *)0x0) {
      _com_issue_error(-0x7fffbffd);
    }
    (**(code **)(*piVar1 + 0xc))(piVar1);
  }
  puVar4 = _mbsrchr(unaff_EBX,0x2f);
  if (puVar4 == (uchar *)0x0) {
    puVar4 = _mbsrchr(unaff_EBX,0x5c);
  }
  else {
    puVar4 = puVar4 + 1;
  }
  if (puVar4 != (uchar *)0x0) {
    unaff_EBX = puVar4 + 1;
  }
  pIVar2 = *(IUnknown **)(unaff_EBP - 0x2038);
  if (pIVar2 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
  }
  UVar5 = (*pIVar2->lpVtbl[8].Release)(pIVar2);
  piVar7 = extraout_ECX;
  if ((int)UVar5 < 0) {
    _com_issue_errorex(UVar5,pIVar2,(_GUID *)&DAT_1003422c);
    piVar7 = extraout_ECX_00;
  }
  *(undefined1 **)(unaff_EBP - 0x2040) = &stack0xfffffffc;
  FUN_1000e770(&stack0xfffffffc,*(LPCSTR *)(unaff_EBP - 0x2044));
  *(undefined1 *)(unaff_EBP - 4) = 9;
  pvVar12 = *(void **)(unaff_EBP - 0x2038);
  if (pvVar12 == (void *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pvVar12 = extraout_ECX_01;
  }
  *(undefined1 *)(unaff_EBP - 4) = 8;
  FUN_10025ee0(pvVar12,piVar7);
  *(undefined1 **)(unaff_EBP - 0x2040) = &stack0xfffffffc;
  piVar7 = extraout_ECX_02;
  FUN_1000e770(&stack0xfffffffc,(LPCSTR)unaff_EBX);
  *(undefined1 *)(unaff_EBP - 4) = 10;
  pvVar12 = *(void **)(unaff_EBP - 0x2038);
  if (pvVar12 == (void *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pvVar12 = extraout_ECX_03;
  }
  *(undefined1 *)(unaff_EBP - 4) = 8;
  FUN_10025fd0(pvVar12,piVar7);
  pIVar2 = *(IUnknown **)(unaff_EBP - 0x2038);
  if (pIVar2 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
  }
  UVar5 = (*pIVar2->lpVtbl[4].Release)(pIVar2);
  if ((int)UVar5 < 0) {
    _com_issue_errorex(UVar5,pIVar2,(_GUID *)&DAT_1003422c);
  }
  pIVar2 = *(IUnknown **)(unaff_EBP - 0x2038);
  if (pIVar2 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
  }
  uVar10 = *(undefined4 *)(unaff_EBP - 0x203c);
  uVar13 = uVar10;
  UVar5 = (*pIVar2->lpVtbl[5].Release)(pIVar2);
  if ((int)UVar5 < 0) {
    _com_issue_errorex(UVar5,pIVar2,(_GUID *)&DAT_1003422c);
  }
  if (*(char *)(unaff_EBP + 0x28) != '\0') {
    *(undefined4 *)(unaff_EBP - 0x203c) = 0;
    *(undefined1 *)(unaff_EBP - 4) = 0xb;
    piVar7 = *(int **)(unaff_EBP - 0x203c);
    if (piVar7 != (int *)0x0) {
      (**(code **)(*piVar7 + 8))(piVar7,uVar13);
    }
    *(undefined4 *)(unaff_EBP - 0x203c) = 0;
    Ordinal_202(unaff_EBP - 0x203c);
    piVar7 = *(int **)(unaff_EBP - 0x203c);
    if (piVar7 == (int *)0x0) {
      _com_issue_error(-0x7fffbffd);
      piVar7 = extraout_EAX;
    }
    (**(code **)(*piVar7 + 0xc))(piVar7,unaff_EBP - 0x2024);
    piVar7 = *(int **)(unaff_EBP - 0x203c);
    if (piVar7 == (int *)0x0) {
      _com_issue_error(-0x7fffbffd);
    }
    pvVar12 = *(void **)(unaff_EBP - 0x2038);
    if (pvVar12 == (void *)0x0) {
      _com_issue_error(-0x7fffbffd);
      pvVar12 = extraout_ECX_04;
    }
    piVar6 = FUN_10025d30(pvVar12,(undefined4 *)(unaff_EBP - 0x2040));
    *(undefined1 *)(unaff_EBP - 4) = 0xc;
    if ((undefined4 *)*piVar6 == (undefined4 *)0x0) {
      uVar13 = 0;
    }
    else {
      uVar13 = *(undefined4 *)*piVar6;
    }
    (**(code **)(*piVar7 + 0x14))(piVar7,uVar13);
    *(undefined1 *)(unaff_EBP - 4) = 0xb;
    FUN_1000f220((int *)(unaff_EBP - 0x2040));
    FUN_10023e30((void *)(unaff_EBP - 0x2040),(int *)(unaff_EBP - 0x203c));
    *(undefined1 *)(unaff_EBP - 4) = 0xd;
    piVar7 = *(int **)(unaff_EBP - 0x2040);
    if (piVar7 != (int *)0x0) {
      if (piVar7 == (int *)0x0) {
        _com_issue_error(-0x7fffbffd);
      }
      (**(code **)(*piVar7 + 4))(piVar7);
      *(undefined ***)(unaff_EBP - 0x2068) = _com_error::vftable;
      *(undefined4 *)(unaff_EBP - 0x2064) = uVar10;
      *(int **)(unaff_EBP - 0x2060) = piVar7;
      *(undefined4 *)(unaff_EBP - 0x205c) = 0;
                    /* WARNING: Subroutine does not return */
      _CxxThrowException((void *)(unaff_EBP - 0x2068),(ThrowInfo *)&DAT_1003c588);
    }
    *(undefined1 *)(unaff_EBP - 4) = 0xb;
    *(undefined1 *)(unaff_EBP - 4) = 8;
    piVar7 = *(int **)(unaff_EBP - 0x203c);
    if (piVar7 != (int *)0x0) {
      (**(code **)(*piVar7 + 8))(piVar7);
    }
  }
  pvVar12 = *(void **)(unaff_EBP - 0x2038);
  if (pvVar12 == (void *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pvVar12 = extraout_ECX_05;
  }
  piVar7 = FUN_10025d30(pvVar12,(undefined4 *)(unaff_EBP - 0x2044));
  *(undefined1 *)(unaff_EBP - 4) = 0xe;
  puVar3 = (undefined4 *)*piVar7;
  if (puVar3 == (undefined4 *)0x0) {
    pCVar9 = (LPCSTR)0x0;
  }
  else {
    if (puVar3[1] == 0) {
      pCVar8 = ConvertBSTRToString((LPCWSTR)*puVar3);
      puVar3[1] = pCVar8;
    }
    pCVar9 = (LPCSTR)puVar3[1];
  }
  uVar10 = FUN_10024890((IID *)(unaff_EBP - 0x2034),pCVar9,0,(LPCSTR)0x0,unaff_EBP - 0x2024,uVar10);
  *(undefined4 *)(unaff_EBP - 0x2040) = uVar10;
  *(undefined1 *)(unaff_EBP - 4) = 8;
  piVar7 = *(int **)(unaff_EBP - 0x2044);
  if (piVar7 != (int *)0x0) {
    LVar11 = InterlockedDecrement(piVar7 + 2);
    if ((LVar11 == 0) && (piVar7 != (int *)0x0)) {
      if (*piVar7 != 0) {
        Ordinal_6(*piVar7);
        *piVar7 = 0;
      }
      if ((void *)piVar7[1] != (void *)0x0) {
        operator_delete((void *)piVar7[1]);
        piVar7[1] = 0;
      }
      operator_delete(piVar7);
    }
    *(undefined4 *)(unaff_EBP - 0x2044) = 0;
  }
  *(undefined1 *)(unaff_EBP - 4) = 1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  *(undefined1 *)(unaff_EBP - 4) = 0;
  piVar1 = *(int **)(unaff_EBP - 0x2038);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  *(undefined4 *)(unaff_EBP - 4) = 0xffffffff;
  piVar1 = *(int **)(unaff_EBP - 0x2048);
  if (piVar1 != (int *)0x0) {
    LVar11 = InterlockedDecrement(piVar1 + 2);
    if ((LVar11 == 0) && (piVar1 != (int *)0x0)) {
      if (*piVar1 != 0) {
        Ordinal_6(*piVar1);
        *piVar1 = 0;
      }
      if ((void *)piVar1[1] != (void *)0x0) {
        operator_delete((void *)piVar1[1]);
        piVar1[1] = 0;
      }
      operator_delete(piVar1);
    }
    *(undefined4 *)(unaff_EBP - 0x2048) = 0;
  }
  ExceptionList = *(void **)(unaff_EBP - 0xc);
  uStack00000004 = 0x10025427;
  __security_check_cookie(*(uint *)(unaff_EBP - 0x14) ^ unaff_EBP);
  return;
}



// Function: FUN_10025430 at 10025430

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __cdecl FUN_10025430(undefined4 param_1,uchar *param_2)

{
  char *in_stack_00000018;
  char local_1008 [4096];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  _vsnprintf(local_1008,0xfff,in_stack_00000018,&stack0x0000001c);
  FUN_10025670(param_2);
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100254a0 at 100254a0

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __cdecl FUN_100254a0(uchar *param_1)

{
  char *in_stack_00000018;
  char local_1008 [4096];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  _vsnprintf(local_1008,0xfff,in_stack_00000018,&stack0x0000001c);
  FUN_10025670(param_1);
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10025510 at 10025510

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __cdecl FUN_10025510(uchar *param_1)

{
  char *in_stack_00000014;
  char local_1008 [4096];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  _vsnprintf(local_1008,0xfff,in_stack_00000014,&stack0x00000018);
  FUN_10025670(param_1);
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10025580 at 10025580

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __cdecl FUN_10025580(uchar *param_1)

{
  char *in_stack_0000001c;
  char local_1008 [4096];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  _vsnprintf(local_1008,0xfff,in_stack_0000001c,&stack0x00000020);
  FUN_10025670(param_1);
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100255f0 at 100255f0

/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */

void __cdecl FUN_100255f0(uchar *param_1)

{
  char *in_stack_0000001c;
  char local_1008 [4096];
  uint local_8;
  
  local_8 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  _vsnprintf(local_1008,0xfff,in_stack_0000001c,&stack0x00000020);
  FUN_10025670(param_1);
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_10025670 at 10025670

/* WARNING: Removing unreachable block (ram,0x1002583e) */

void __cdecl FUN_10025670(uchar *param_1)

{
  byte bVar1;
  IID *pIVar2;
  int *piVar3;
  void **ppvObject;
  HRESULT HVar4;
  uint uVar5;
  int *extraout_EAX;
  IUnknown *extraout_EAX_00;
  int iVar6;
  ULONG UVar7;
  uchar *puVar8;
  undefined4 **ppuVar9;
  IUnknown *extraout_EAX_01;
  IUnknown *pIVar10;
  int *extraout_EAX_02;
  int *extraout_EAX_03;
  int *piVar11;
  byte *pbVar12;
  int *extraout_ECX;
  int *extraout_ECX_00;
  int *extraout_ECX_01;
  int *extraout_ECX_02;
  int *extraout_ECX_03;
  IUnknown *extraout_ECX_04;
  int *extraout_ECX_05;
  int *extraout_ECX_06;
  IUnknown *extraout_ECX_07;
  IUnknown *extraout_ECX_08;
  undefined4 uVar13;
  undefined4 *puVar14;
  bool bVar15;
  int in_stack_00000014;
  byte *in_stack_00000018;
  undefined4 in_stack_00000020;
  LPCSTR in_stack_00000024;
  undefined **local_3c [2];
  int *local_34;
  undefined4 local_30;
  int *local_2c;
  undefined4 *local_28;
  IID *local_24;
  LPUNKNOWN local_20;
  int *local_1c;
  int *local_18;
  IUnknown *local_14;
  void *local_10;
  undefined1 *puStack_c;
  int local_8;
  
  puStack_c = &LAB_1002d8d3;
  local_10 = ExceptionList;
  ppvObject = (void **)(DAT_10040398 ^ (uint)&stack0xfffffffc);
  ExceptionList = &local_10;
  local_1c = (int *)0x0;
  local_18 = (int *)0x0;
  local_8 = 1;
  local_14 = (IUnknown *)0x0;
  HVar4 = CoCreateInstance((IID *)&DAT_10034280,(LPUNKNOWN)0x0,0x17,(IID *)&DAT_1002f4c4,&local_20);
  if (HVar4 < 0) {
LAB_10025704:
    local_14 = (IUnknown *)0x0;
    if ((HVar4 < 0) && (HVar4 != -0x7fffbffe)) {
      _com_issue_error(HVar4);
    }
  }
  else {
    HVar4 = OleRun(local_20);
    if (-1 < HVar4) {
      HVar4 = (*local_20->lpVtbl->QueryInterface)(local_20,(IID *)&DAT_1003423c,&local_14);
    }
    (*local_20->lpVtbl->Release)(local_20);
    if (HVar4 < 0) goto LAB_10025704;
  }
  local_8 = CONCAT31(local_8._1_3_,2);
  pbVar12 = PTR_s_APPEND_10040364;
  do {
    bVar1 = *in_stack_00000018;
    bVar15 = bVar1 < *pbVar12;
    if (bVar1 != *pbVar12) {
LAB_10025750:
      uVar5 = -(uint)bVar15 | 1;
      goto LAB_10025755;
    }
    if (bVar1 == 0) break;
    bVar1 = in_stack_00000018[1];
    bVar15 = bVar1 < pbVar12[1];
    if (bVar1 != pbVar12[1]) goto LAB_10025750;
    in_stack_00000018 = in_stack_00000018 + 2;
    pbVar12 = pbVar12 + 2;
  } while (bVar1 != 0);
  uVar5 = 0;
LAB_10025755:
  if (uVar5 == 0) {
    if (local_18 != (int *)0x0) {
      (**(code **)(*local_18 + 8))();
    }
    local_18 = (int *)0x0;
    Ordinal_200(0);
    if (local_18 != (int *)0x0) {
      FUN_10023f90(&local_1c,(int *)&local_18);
      local_24 = (IID *)0x0;
      piVar11 = local_18;
      if (local_18 == (int *)0x0) {
        _com_issue_error(-0x7fffbffd);
        piVar11 = extraout_EAX;
      }
      (**(code **)(*piVar11 + 0x14))(piVar11);
      pIVar2 = local_24;
      if (local_24 != (IID *)0x0) {
        local_2c = (int *)operator_new(0xc);
        local_8._1_3_ = (uint3)((uint)local_8 >> 8);
        if (local_2c == (int *)0x0) {
          local_2c = (int *)0x0;
        }
        else {
          local_2c[1] = 0;
          local_2c[2] = 1;
          *local_2c = (int)pIVar2;
        }
        local_8._0_1_ = 2;
        if (local_2c == (int *)0x0) {
          _com_issue_error(-0x7ff8fff2);
        }
        local_8._0_1_ = 4;
        pIVar10 = local_14;
        if (local_14 == (IUnknown *)0x0) {
          _com_issue_error(-0x7fffbffd);
          pIVar10 = extraout_EAX_00;
        }
        (*pIVar10->lpVtbl[9].QueryInterface)(pIVar10,local_24,ppvObject);
        local_8 = CONCAT31(local_8._1_3_,2);
        FUN_1000f220((int *)&local_2c);
      }
    }
  }
  if (local_1c == (int *)0x0) {
    local_1c = (int *)0x0;
    Ordinal_202();
    local_2c = (int *)&stack0xffffffb4;
    piVar11 = local_1c;
    piVar3 = (int *)&stack0xffffffb4;
    if (local_1c != (int *)0x0) {
      (**(code **)(*local_1c + 4))(local_1c);
      piVar3 = local_2c;
    }
    local_2c = piVar3;
    local_8 = CONCAT31((int3)((uint)local_8 >> 8),2);
    iVar6 = FUN_10024010(&local_18,piVar11);
    if ((iVar6 < 0) && (iVar6 != -0x7fffbffe)) {
      _com_issue_error(iVar6);
    }
  }
  pIVar10 = local_14;
  if (local_1c == (int *)0x0) {
    local_8._0_1_ = 1;
    if (local_14 != (IUnknown *)0x0) {
      (*local_14->lpVtbl->Release)(local_14);
    }
    local_8 = (uint)local_8._1_3_ << 8;
    if (local_18 != (int *)0x0) {
      (**(code **)(*local_18 + 8))();
    }
    local_8 = 0xffffffff;
    if (local_1c != (int *)0x0) {
      (**(code **)(*local_1c + 8))();
    }
    ExceptionList = local_10;
    return;
  }
  puVar14 = (undefined4 *)0x0;
  local_28 = (undefined4 *)0x0;
  local_8 = CONCAT31(local_8._1_3_,6);
  if (local_14 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
  }
  UVar7 = (*pIVar10->lpVtbl[8].Release)(pIVar10);
  piVar11 = extraout_ECX;
  if ((int)UVar7 < 0) {
    _com_issue_errorex(UVar7,pIVar10,(_GUID *)&DAT_1003422c);
    piVar11 = extraout_ECX_00;
  }
  pIVar10 = local_14;
  if (in_stack_00000014 == 1) {
    if (local_14 == (IUnknown *)0x0) {
      _com_issue_error(-0x7fffbffd);
    }
    UVar7 = (*pIVar10->lpVtbl[9].Release)(pIVar10);
    piVar11 = extraout_ECX_02;
  }
  else {
    if (in_stack_00000014 != 2) {
      if (in_stack_00000014 != 3) goto LAB_1002594f;
      if (local_14 == (IUnknown *)0x0) {
        _com_issue_error(-0x7fffbffd);
      }
      UVar7 = (*pIVar10->lpVtbl[9].Release)(pIVar10);
      if ((int)UVar7 < 0) {
        _com_issue_errorex(UVar7,pIVar10,(_GUID *)&DAT_1003423c);
      }
    }
    pIVar10 = local_14;
    if (local_14 == (IUnknown *)0x0) {
      _com_issue_error(-0x7fffbffd);
    }
    UVar7 = (*pIVar10->lpVtbl[10].AddRef)(pIVar10);
    piVar11 = extraout_ECX_01;
  }
  if ((int)UVar7 < 0) {
    _com_issue_errorex(UVar7,pIVar10,(_GUID *)&DAT_1003423c);
    piVar11 = extraout_ECX_03;
  }
LAB_1002594f:
  local_2c = (int *)&stack0xffffffb4;
  FUN_1000e770(&stack0xffffffb4,in_stack_00000024);
  local_8._0_1_ = 7;
  pIVar10 = local_14;
  if (local_14 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pIVar10 = extraout_ECX_04;
  }
  local_8 = CONCAT31(local_8._1_3_,6);
  FUN_10025ee0(pIVar10,piVar11);
  puVar8 = _mbsrchr(param_1,0x2f);
  if (puVar8 == (uchar *)0x0) {
    puVar8 = _mbsrchr(param_1,0x5c);
    piVar11 = extraout_ECX_06;
  }
  else {
    puVar8 = puVar8 + 1;
    piVar11 = extraout_ECX_05;
  }
  if (puVar8 != (uchar *)0x0) {
    param_1 = puVar8 + 1;
  }
  local_2c = (int *)&stack0xffffffb4;
  FUN_1000e770(&stack0xffffffb4,(LPCSTR)param_1);
  local_8._0_1_ = 8;
  pIVar10 = local_14;
  if (local_14 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pIVar10 = extraout_ECX_07;
  }
  local_8 = CONCAT31(local_8._1_3_,6);
  FUN_10025fd0(pIVar10,piVar11);
  pIVar10 = local_14;
  if (local_14 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
  }
  UVar7 = (*pIVar10->lpVtbl[4].Release)(pIVar10);
  if ((int)UVar7 < 0) {
    _com_issue_errorex(UVar7,pIVar10,(_GUID *)&DAT_1003422c);
  }
  pIVar10 = local_14;
  if (local_14 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
  }
  UVar7 = (*pIVar10->lpVtbl[5].Release)(pIVar10);
  if ((int)UVar7 < 0) {
    _com_issue_errorex(UVar7,pIVar10,(_GUID *)&DAT_1003422c);
  }
  pIVar10 = local_14;
  if (local_14 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pIVar10 = extraout_ECX_08;
  }
  ppuVar9 = (undefined4 **)FUN_10025d30(pIVar10,&local_2c);
  local_8._0_1_ = 9;
  if (&local_28 != ppuVar9) {
    Clear((int *)&local_28);
    puVar14 = *ppuVar9;
    local_28 = puVar14;
    if (puVar14 != (undefined4 *)0x0) {
      InterlockedIncrement(puVar14 + 2);
    }
  }
  local_8 = CONCAT31(local_8._1_3_,6);
  FUN_1000f220((int *)&local_2c);
  pIVar10 = local_14;
  if (local_14 == (IUnknown *)0x0) {
    _com_issue_error(-0x7fffbffd);
    pIVar10 = extraout_EAX_01;
  }
  (*pIVar10->lpVtbl->Release)(pIVar10);
  local_14 = (IUnknown *)0x0;
  piVar11 = local_1c;
  if (local_1c == (int *)0x0) {
    _com_issue_error(-0x7fffbffd);
    piVar11 = extraout_EAX_02;
  }
  (**(code **)(*piVar11 + 0xc))(piVar11,in_stack_00000020);
  piVar11 = local_1c;
  if (local_1c == (int *)0x0) {
    _com_issue_error(-0x7fffbffd);
    piVar11 = extraout_EAX_03;
  }
  if (puVar14 == (undefined4 *)0x0) {
    uVar13 = 0;
  }
  else {
    uVar13 = *puVar14;
  }
  (**(code **)(*piVar11 + 0x14))(piVar11,uVar13);
  Ordinal_201(0,local_18);
  local_3c[0] = _com_error::vftable;
  local_34 = local_18;
  local_30 = 0;
  if (local_18 != (int *)0x0) {
    (**(code **)(*local_18 + 4))(local_18);
  }
                    /* WARNING: Subroutine does not return */
  _CxxThrowException(local_3c,(ThrowInfo *)&DAT_1003c588);
}



// Function: FUN_10025b60 at 10025b60

HRESULT __thiscall FUN_10025b60(void *this,IID *param_1,LPUNKNOWN param_2,LPUNKNOWN param_3)

{
  int *piVar1;
  HRESULT HVar2;
  
                    /* WARNING: Load size is inaccurate */
  piVar1 = *this;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  if (((uint)param_3 & 0x14) == 0) {
    HVar2 = CoCreateInstance(param_1,param_2,(DWORD)param_3,(IID *)&DAT_1003423c,(LPVOID *)this);
  }
  else {
    HVar2 = CoCreateInstance(param_1,param_2,(DWORD)param_3,(IID *)&DAT_1002f4c4,&param_3);
    if (HVar2 < 0) goto LAB_10025bd9;
    HVar2 = OleRun(param_3);
    if (-1 < HVar2) {
      HVar2 = (*param_3->lpVtbl->QueryInterface)(param_3,(IID *)&DAT_1003423c,(void **)this);
    }
    (*param_3->lpVtbl->Release)(param_3);
  }
  if (-1 < HVar2) {
    return HVar2;
  }
LAB_10025bd9:
  *(undefined4 *)this = 0;
  return HVar2;
}



// Function: FUN_10025bf0 at 10025bf0

undefined4 * __thiscall FUN_10025bf0(void *this,undefined4 *param_1)

{
  int *piVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  undefined4 *extraout_ECX;
  undefined4 local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d914;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  piVar1 = *(int **)((int)this + 8);
  local_14 = 0;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 0x14))(piVar1,&local_14,DAT_10040398 ^ (uint)&stack0xfffffffc);
  }
  uVar2 = local_14;
  puVar3 = (undefined4 *)operator_new(0xc);
  if (puVar3 == (undefined4 *)0x0) {
    puVar3 = (undefined4 *)0x0;
  }
  else {
    puVar3[1] = 0;
    puVar3[2] = 1;
    *puVar3 = uVar2;
  }
  local_8 = 0;
  *param_1 = puVar3;
  if (puVar3 == (undefined4 *)0x0) {
    _com_issue_error(-0x7ff8fff2);
    param_1 = extraout_ECX;
  }
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10025cb0 at 10025cb0

undefined4 __fastcall FUN_10025cb0(int param_1)

{
  int *piVar1;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 4))(piVar1);
    return *(undefined4 *)(param_1 + 8);
  }
  return 0;
}



// Function: FUN_10025d30 at 10025d30

undefined4 * __thiscall FUN_10025d30(void *this,undefined4 *param_1)

{
  undefined4 uVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *extraout_ECX;
  undefined4 local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002d954;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
                    /* WARNING: Load size is inaccurate */
  local_14 = 0;
  iVar2 = (**(code **)(*this + 0x3c))(this,&local_14,DAT_10040398 ^ (uint)&stack0xfffffffc);
  if (iVar2 < 0) {
    _com_issue_errorex(iVar2,(IUnknown *)this,(_GUID *)&DAT_1003422c);
  }
  uVar1 = local_14;
  puVar3 = (undefined4 *)operator_new(0xc);
  if (puVar3 == (undefined4 *)0x0) {
    puVar3 = (undefined4 *)0x0;
  }
  else {
    puVar3[1] = 0;
    puVar3[2] = 1;
    *puVar3 = uVar1;
  }
  local_8 = 0;
  *param_1 = puVar3;
  if (puVar3 == (undefined4 *)0x0) {
    _com_issue_error(-0x7ff8fff2);
    param_1 = extraout_ECX;
  }
  ExceptionList = local_10;
  return param_1;
}



// Function: FUN_10025df0 at 10025df0

uint __cdecl FUN_10025df0(uint param_1)

{
  if (0 < (int)param_1) {
    param_1 = param_1 & 0xffff | 0x80070000;
  }
  return param_1;
}



// Function: FUN_10025e10 at 10025e10

uchar * __cdecl FUN_10025e10(uchar *param_1)

{
  uchar *puVar1;
  
  puVar1 = _mbsrchr(param_1,0x2f);
  if (puVar1 == (uchar *)0x0) {
    puVar1 = _mbsrchr(param_1,0x5c);
  }
  else {
    puVar1 = puVar1 + 1;
  }
  if (puVar1 == (uchar *)0x0) {
    return param_1;
  }
  return puVar1 + 1;
}



// Function: FUN_10025e50 at 10025e50

undefined4 __cdecl FUN_10025e50(ushort param_1,LPSTR param_2)

{
  FormatMessageA(0x1200,(LPCVOID)0x0,(uint)param_1,0x400,param_2,0x2000,(va_list *)0x0);
  return 0;
}



// Function: FUN_10025e80 at 10025e80

void __fastcall FUN_10025e80(IUnknown *param_1)

{
  ULONG UVar1;
  
  UVar1 = (*param_1->lpVtbl[10].AddRef)(param_1);
  if ((int)UVar1 < 0) {
    _com_issue_errorex(UVar1,param_1,(_GUID *)&DAT_1003423c);
  }
  return;
}



// Function: FUN_10025eb0 at 10025eb0

void __fastcall FUN_10025eb0(IUnknown *param_1)

{
  ULONG UVar1;
  
  UVar1 = (*param_1->lpVtbl[9].Release)(param_1);
  if ((int)UVar1 < 0) {
    _com_issue_errorex(UVar1,param_1,(_GUID *)&DAT_1003423c);
  }
  return;
}



// Function: FUN_10025ee0 at 10025ee0

void __thiscall FUN_10025ee0(void *this,int *param_1)

{
  int iVar1;
  LONG LVar2;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d978;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_1 == (int *)0x0) {
    iVar1 = 0;
  }
  else {
    iVar1 = *param_1;
  }
                    /* WARNING: Load size is inaccurate */
  iVar1 = (**(code **)(*this + 0x28))(this,iVar1,DAT_10040398 ^ (uint)&stack0xfffffffc);
  if (iVar1 < 0) {
    _com_issue_errorex(iVar1,(IUnknown *)this,(_GUID *)&DAT_1003422c);
  }
  local_8 = 0xffffffff;
  if (((param_1 != (int *)0x0) && (LVar2 = InterlockedDecrement(param_1 + 2), LVar2 == 0)) &&
     (param_1 != (int *)0x0)) {
    if (*param_1 != 0) {
      Ordinal_6(*param_1);
      *param_1 = 0;
    }
    if ((void *)param_1[1] != (void *)0x0) {
      operator_delete((void *)param_1[1]);
      param_1[1] = 0;
    }
    operator_delete(param_1);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10025fa0 at 10025fa0

void __fastcall FUN_10025fa0(IUnknown *param_1)

{
  ULONG UVar1;
  
  UVar1 = (*param_1->lpVtbl[5].Release)(param_1);
  if ((int)UVar1 < 0) {
    _com_issue_errorex(UVar1,param_1,(_GUID *)&DAT_1003422c);
  }
  return;
}



// Function: FUN_10025fd0 at 10025fd0

void __thiscall FUN_10025fd0(void *this,int *param_1)

{
  int iVar1;
  LONG LVar2;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d9a8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_1 == (int *)0x0) {
    iVar1 = 0;
  }
  else {
    iVar1 = *param_1;
  }
                    /* WARNING: Load size is inaccurate */
  iVar1 = (**(code **)(*this + 0x30))(this,iVar1,DAT_10040398 ^ (uint)&stack0xfffffffc);
  if (iVar1 < 0) {
    _com_issue_errorex(iVar1,(IUnknown *)this,(_GUID *)&DAT_1003422c);
  }
  local_8 = 0xffffffff;
  if (((param_1 != (int *)0x0) && (LVar2 = InterlockedDecrement(param_1 + 2), LVar2 == 0)) &&
     (param_1 != (int *)0x0)) {
    if (*param_1 != 0) {
      Ordinal_6(*param_1);
      *param_1 = 0;
    }
    if ((void *)param_1[1] != (void *)0x0) {
      operator_delete((void *)param_1[1]);
      param_1[1] = 0;
    }
    operator_delete(param_1);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10026090 at 10026090

void __fastcall FUN_10026090(IUnknown *param_1)

{
  ULONG UVar1;
  
  UVar1 = (*param_1->lpVtbl[4].Release)(param_1);
  if ((int)UVar1 < 0) {
    _com_issue_errorex(UVar1,param_1,(_GUID *)&DAT_1003422c);
  }
  return;
}



// Function: FUN_100260c0 at 100260c0

void __fastcall FUN_100260c0(int *param_1)

{
  int *piVar1;
  code *pcVar2;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
    *param_1 = 0;
    return;
  }
  _com_issue_error(-0x7fffbffd);
  pcVar2 = (code *)swi(3);
  (*pcVar2)();
  return;
}



// Function: FUN_10026140 at 10026140

HRESULT __thiscall FUN_10026140(void *this,int *param_1)

{
  int iVar1;
  LONG LVar2;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d9d8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_1 == (int *)0x0) {
    iVar1 = 0;
  }
  else {
    iVar1 = *param_1;
  }
                    /* WARNING: Load size is inaccurate */
  iVar1 = (**(code **)(*this + 0x6c))(this,iVar1,DAT_10040398 ^ (uint)&stack0xfffffffc);
  if (iVar1 < 0) {
    _com_issue_errorex(iVar1,(IUnknown *)this,(_GUID *)&DAT_1003422c);
  }
  local_8 = 0xffffffff;
  if (((param_1 != (int *)0x0) && (LVar2 = InterlockedDecrement(param_1 + 2), LVar2 == 0)) &&
     (param_1 != (int *)0x0)) {
    if (*param_1 != 0) {
      Ordinal_6(*param_1);
      *param_1 = 0;
    }
    if ((void *)param_1[1] != (void *)0x0) {
      operator_delete((void *)param_1[1]);
      param_1[1] = 0;
    }
    operator_delete(param_1);
  }
  ExceptionList = local_10;
  return iVar1;
}



// Function: FUN_10026210 at 10026210

void __cdecl FUN_10026210(char *param_1,rsize_t param_2,char *param_3)

{
  errno_t eVar1;
  
  eVar1 = strcpy_s(param_1,param_2,param_3);
  ATL::AtlCrtErrorCheck(eVar1);
  return;
}



// Function: FUN_10026230 at 10026230

void FUN_10026230(uchar *param_1,uint param_2)

{
                    /* WARNING: Could not recover jumptable at 0x10026234. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  _mbsrchr(param_1,param_2);
  return;
}



// Function: FUN_10026240 at 10026240

void * __cdecl FUN_10026240(uint param_1)

{
  void *pvVar1;
  void *extraout_EAX;
  
  if (param_1 == 0) {
    return (void *)0x0;
  }
  if ((param_1 < 0x40000000) && (pvVar1 = operator_new(param_1 << 2), pvVar1 != (void *)0x0)) {
    return pvVar1;
  }
                    /* WARNING: Could not recover jumptable at 0x10026265. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::_Xbad_alloc();
  return extraout_EAX;
}



// Function: FUN_10026270 at 10026270

void __cdecl FUN_10026270(undefined4 *param_1,undefined4 *param_2)

{
  FUN_10026290(param_1,param_2);
  return;
}



// Function: FUN_10026290 at 10026290

void __cdecl FUN_10026290(undefined4 *param_1,undefined4 *param_2)

{
  int *piVar1;
  LONG LVar2;
  
  if (param_1 != param_2) {
    do {
      piVar1 = (int *)*param_1;
      if (piVar1 != (int *)0x0) {
        LVar2 = InterlockedDecrement(piVar1 + 2);
        if ((LVar2 == 0) && (piVar1 != (int *)0x0)) {
          if (*piVar1 != 0) {
            Ordinal_6(*piVar1);
            *piVar1 = 0;
          }
          if ((void *)piVar1[1] != (void *)0x0) {
            operator_delete__((void *)piVar1[1]);
            piVar1[1] = 0;
          }
          operator_delete(piVar1);
        }
        *param_1 = 0;
      }
      param_1 = param_1 + 1;
    } while (param_1 != param_2);
  }
  return;
}



// Function: FUN_10026300 at 10026300

undefined1 __fastcall FUN_10026300(undefined4 param_1)

{
  undefined1 local_5;
  
  local_5 = (undefined1)((uint)param_1 >> 0x18);
  return local_5;
}



// Function: FUN_10026310 at 10026310

void FUN_10026310(int *param_1,int *param_2,int *param_3)

{
  FUN_10026340(param_1,param_2,param_3);
  return;
}



// Function: FUN_10026340 at 10026340

int * __cdecl FUN_10026340(int *param_1,int *param_2,int *param_3)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002da00;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  for (; param_1 != param_2; param_1 = param_1 + 1) {
    FUN_100265d0(param_3,param_1);
    param_3 = param_3 + 1;
  }
  ExceptionList = local_10;
  return param_3;
}



// Function: Catch@100263b7 at 100263b7

void Catch_100263b7(void)

{
  undefined4 *puVar1;
  int unaff_EBP;
  undefined4 *puVar2;
  
  puVar1 = *(undefined4 **)(unaff_EBP + 0x10);
  for (puVar2 = *(undefined4 **)(unaff_EBP + -0x14); puVar2 != puVar1; puVar2 = puVar2 + 1) {
    FUN_10026710(puVar2);
  }
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_100263e0 at 100263e0

void __cdecl FUN_100263e0(int *param_1,int *param_2,int *param_3)

{
  FUN_10026340(param_1,param_2,param_3);
  return;
}



// Function: FUN_10026420 at 10026420

undefined4 __cdecl FUN_10026420(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_10026430 at 10026430

void FUN_10026430(int *param_1,int *param_2)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002da31;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_1 != (int *)0x0) {
    iVar1 = *param_2;
    *param_1 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_100264a0 at 100264a0

void FUN_100264a0(int *param_1,int *param_2)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002da61;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_1 != (int *)0x0) {
    iVar1 = *param_2;
    *param_1 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10026510 at 10026510

void __cdecl FUN_10026510(undefined4 param_1,int *param_2,int *param_3)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002da91;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_2 != (int *)0x0) {
    iVar1 = *param_3;
    *param_2 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10026570 at 10026570

void FUN_10026570(int *param_1,int *param_2)

{
  int iVar1;
  
  if (param_1 != (int *)0x0) {
    iVar1 = *param_2;
    *param_1 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  return;
}



// Function: FUN_100265a0 at 100265a0

void __cdecl FUN_100265a0(undefined4 param_1,int *param_2,int *param_3)

{
  int iVar1;
  
  if (param_2 != (int *)0x0) {
    iVar1 = *param_3;
    *param_2 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  return;
}



// Function: FUN_100265d0 at 100265d0

void FUN_100265d0(int *param_1,int *param_2)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002dac1;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_1 != (int *)0x0) {
    iVar1 = *param_2;
    *param_1 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10026640 at 10026640

void FUN_10026640(int *param_1,int *param_2)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002daf1;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_1 != (int *)0x0) {
    iVar1 = *param_2;
    *param_1 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_100266b0 at 100266b0

void __cdecl FUN_100266b0(undefined4 param_1,int *param_2,int *param_3)

{
  int iVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002db21;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if (param_2 != (int *)0x0) {
    iVar1 = *param_3;
    *param_2 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10026710 at 10026710

void FUN_10026710(undefined4 *param_1)

{
  int *piVar1;
  LONG LVar2;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    LVar2 = InterlockedDecrement(piVar1 + 2);
    if ((LVar2 == 0) && (piVar1 != (int *)0x0)) {
      if (*piVar1 != 0) {
        Ordinal_6(*piVar1);
        *piVar1 = 0;
      }
      if ((void *)piVar1[1] != (void *)0x0) {
        operator_delete__((void *)piVar1[1]);
        piVar1[1] = 0;
      }
      operator_delete(piVar1);
    }
    *param_1 = 0;
  }
  return;
}



// Function: FUN_10026770 at 10026770

void FUN_10026770(undefined4 *param_1)

{
  int *piVar1;
  LONG LVar2;
  
  piVar1 = (int *)*param_1;
  if (piVar1 != (int *)0x0) {
    LVar2 = InterlockedDecrement(piVar1 + 2);
    if ((LVar2 == 0) && (piVar1 != (int *)0x0)) {
      if (*piVar1 != 0) {
        Ordinal_6(*piVar1);
        *piVar1 = 0;
      }
      if ((void *)piVar1[1] != (void *)0x0) {
        operator_delete__((void *)piVar1[1]);
        piVar1[1] = 0;
      }
      operator_delete(piVar1);
    }
    *param_1 = 0;
  }
  return;
}



// Function: FUN_100267d0 at 100267d0

void __cdecl FUN_100267d0(undefined4 param_1,undefined4 *param_2)

{
  int *piVar1;
  LONG LVar2;
  
  piVar1 = (int *)*param_2;
  if (piVar1 != (int *)0x0) {
    LVar2 = InterlockedDecrement(piVar1 + 2);
    if ((LVar2 == 0) && (piVar1 != (int *)0x0)) {
      if (*piVar1 != 0) {
        Ordinal_6(*piVar1);
        *piVar1 = 0;
      }
      if ((void *)piVar1[1] != (void *)0x0) {
        operator_delete__((void *)piVar1[1]);
        piVar1[1] = 0;
      }
      operator_delete(piVar1);
    }
    *param_2 = 0;
  }
  return;
}



// Function: FUN_10026830 at 10026830

undefined4 __cdecl FUN_10026830(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_10026840 at 10026840

undefined4 __cdecl FUN_10026840(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_10026850 at 10026850

undefined4 __cdecl FUN_10026850(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_100268e0 at 100268e0

undefined4 * __fastcall FUN_100268e0(undefined4 *param_1)

{
  *param_1 = KSSecLibrary::CComLicenseBase::vftable;
  param_1[5] = 0;
  param_1[6] = 0;
  param_1[7] = 0;
  param_1[8] = 0;
  param_1[9] = 0;
  param_1[10] = 0;
  param_1[0xb] = 0;
  *(undefined2 *)(param_1 + 0xc) = 0xffff;
  return param_1;
}



// Function: FUN_10026970 at 10026970

void __fastcall FUN_10026970(undefined4 *param_1)

{
  if ((undefined4 *)*param_1 != (undefined4 *)0x0) {
    FUN_10026290((undefined4 *)*param_1,(undefined4 *)param_1[1]);
    operator_delete((void *)*param_1);
    *param_1 = 0;
    param_1[1] = 0;
    param_1[2] = 0;
  }
  return;
}



// Function: FUN_100269c0 at 100269c0

void __fastcall FUN_100269c0(undefined4 *param_1)

{
  void *local_10;
  undefined1 *puStack_c;
  uint local_8;
  
  puStack_c = &LAB_1002db96;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *param_1 = KSSecLibrary::CComLicenseBase::vftable;
  local_8 = 1;
  if ((int)(param_1[10] - param_1[9]) >> 2 != 0) {
    FUN_10026290((undefined4 *)param_1[9],(undefined4 *)param_1[10]);
    param_1[10] = param_1[9];
  }
  if ((int)(param_1[7] - param_1[6]) >> 2 != 0) {
    FUN_10026290((undefined4 *)param_1[6],(undefined4 *)param_1[7]);
    param_1[7] = param_1[6];
  }
  local_8 = local_8 & 0xffffff00;
  if ((undefined4 *)param_1[9] != (undefined4 *)0x0) {
    FUN_10026290((undefined4 *)param_1[9],(undefined4 *)param_1[10]);
    operator_delete((void *)param_1[9]);
    param_1[9] = 0;
    param_1[10] = 0;
    param_1[0xb] = 0;
  }
  local_8 = 0xffffffff;
  if ((undefined4 *)param_1[6] != (undefined4 *)0x0) {
    FUN_10026290((undefined4 *)param_1[6],(undefined4 *)param_1[7]);
    operator_delete((void *)param_1[6]);
    param_1[6] = 0;
    param_1[7] = 0;
    param_1[8] = 0;
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10026ae0 at 10026ae0

int __thiscall FUN_10026ae0(void *this,int param_1)

{
                    /* WARNING: Load size is inaccurate */
  return *this + param_1 * 4;
}



// Function: FUN_10026af0 at 10026af0

undefined4 * __thiscall FUN_10026af0(void *this,byte param_1)

{
  FUN_100269c0((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_10026b20 at 10026b20

undefined4 * __thiscall FUN_10026b20(void *this,byte param_1)

{
  int *piVar1;
  LONG LVar2;
  
                    /* WARNING: Load size is inaccurate */
  piVar1 = *this;
  if (piVar1 != (int *)0x0) {
    LVar2 = InterlockedDecrement(piVar1 + 2);
    if ((LVar2 == 0) && (piVar1 != (int *)0x0)) {
      if (*piVar1 != 0) {
        Ordinal_6(*piVar1);
        *piVar1 = 0;
      }
      if ((void *)piVar1[1] != (void *)0x0) {
        operator_delete__((void *)piVar1[1]);
        piVar1[1] = 0;
      }
      operator_delete(piVar1);
    }
    *(undefined4 *)this = 0;
  }
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return (undefined4 *)this;
}



// Function: FUN_10026b90 at 10026b90

void __thiscall FUN_10026b90(void *this,undefined8 *param_1,undefined4 *param_2,undefined4 *param_3)

{
  uint uVar1;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002dbc8;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  local_8 = 0;
  if ((int)*(undefined4 **)((int)this + 0x1c) - (int)*(undefined4 **)((int)this + 0x18) >> 2 != 0) {
    FUN_10026290(*(undefined4 **)((int)this + 0x18),*(undefined4 **)((int)this + 0x1c));
    *(undefined4 *)((int)this + 0x1c) = *(undefined4 *)((int)this + 0x18);
  }
  uVar1 = 0;
  if ((int)param_3 - (int)param_2 >> 2 != 0) {
    do {
      FUN_100276f0((void *)((int)this + 0x18),param_2 + uVar1);
      uVar1 = uVar1 + 1;
    } while (uVar1 < (uint)((int)param_3 - (int)param_2 >> 2));
  }
  *(undefined8 *)((int)this + 4) = *param_1;
  *(undefined8 *)((int)this + 0xc) = param_1[1];
  local_8 = 0xffffffff;
  if (param_2 != (undefined4 *)0x0) {
    FUN_10026290(param_2,param_3);
    operator_delete(param_2);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10026c80 at 10026c80

void __thiscall FUN_10026c80(void *this,undefined8 *param_1,int *param_2)

{
  int *piVar1;
  uint uVar2;
  LONG LVar3;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002dbf8;
  local_10 = ExceptionList;
  uVar2 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  if ((int)*(undefined4 **)((int)this + 0x1c) - (int)*(undefined4 **)((int)this + 0x18) >> 2 != 0) {
    FUN_10026290(*(undefined4 **)((int)this + 0x18),*(undefined4 **)((int)this + 0x1c));
    *(undefined4 *)((int)this + 0x1c) = *(undefined4 *)((int)this + 0x18);
  }
  FUN_100276f0((void *)((int)this + 0x18),(int *)&param_2);
  piVar1 = param_2;
  *(undefined8 *)((int)this + 4) = *param_1;
  *(undefined8 *)((int)this + 0xc) = param_1[1];
  local_8 = 0xffffffff;
  if (((param_2 != (int *)0x0) && (LVar3 = InterlockedDecrement(param_2 + 2), LVar3 == 0)) &&
     (piVar1 != (int *)0x0)) {
    if (*piVar1 != 0) {
      Ordinal_6(*piVar1,uVar2);
      *piVar1 = 0;
    }
    if ((void *)piVar1[1] != (void *)0x0) {
      operator_delete__((void *)piVar1[1]);
      piVar1[1] = 0;
    }
    operator_delete(piVar1);
  }
  ExceptionList = local_10;
  return;
}



// Function: FUN_10026d70 at 10026d70

undefined4 __thiscall FUN_10026d70(void *this,undefined4 param_1,int *param_2)

{
  int *piVar1;
  code *pcVar2;
  int iVar3;
  undefined4 uVar4;
  
                    /* WARNING: Load size is inaccurate */
  uVar4 = 0;
  (**(code **)(*this + 4))(this);
  if (*(int *)((int)this + 0x24) == *(int *)((int)this + 0x28)) {
    FUN_10026e10((int)this);
  }
  if ((param_2 != (int *)0x0) && (-1 < *(short *)((int)this + 0x30))) {
    piVar1 = *(int **)(*(int *)((int)this + 0x24) + *(short *)((int)this + 0x30) * 4);
    if ((piVar1 == (int *)0x0) || (*piVar1 == 0)) {
      iVar3 = 0;
    }
    else {
      uVar4 = Ordinal_149(*piVar1);
      iVar3 = Ordinal_150(*piVar1,uVar4);
      if (iVar3 == 0) {
        _com_issue_error(-0x7ff8fff2);
        pcVar2 = (code *)swi(3);
        uVar4 = (*pcVar2)();
        return uVar4;
      }
    }
    *param_2 = iVar3;
    uVar4 = 1;
  }
  return uVar4;
}



// Function: FUN_10026df0 at 10026df0

undefined4 __fastcall FUN_10026df0(int param_1)

{
  if (*(int *)(param_1 + 0x14) == 0) {
    FUN_10026e10(param_1);
  }
  return *(undefined4 *)(param_1 + 0x14);
}



// Function: FUN_10026e10 at 10026e10

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */
/* WARNING: Unable to track spacebase fully for stack */

void __fastcall FUN_10026e10(int param_1)

{
  ushort *puVar1;
  OLECHAR OVar2;
  ushort uVar3;
  undefined4 *puVar4;
  LPOLESTR pOVar5;
  uchar *puVar6;
  HRESULT HVar7;
  int iVar8;
  LPSTR pCVar9;
  uchar *_Str1;
  int iVar10;
  uint uVar11;
  int *piVar12;
  LONG LVar13;
  LPOLESTR pOVar14;
  LPCSTR pCVar15;
  uint uVar16;
  uint local_150;
  uint local_138;
  LPOLESTR local_12c [2];
  int *local_124;
  LPCSTR local_120;
  uchar local_11c [264];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002dc39;
  local_10 = ExceptionList;
  local_150 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  *(undefined4 *)(param_1 + 0x14) = 0;
  local_14 = local_150;
  GetModuleFileNameA(DAT_10040524,(LPSTR)local_11c,0x104);
  puVar6 = _mbsrchr(local_11c,0x5c);
  if (puVar6 != (uchar *)0x0) {
    builtin_memcpy(puVar6 + 1,"cummins.lic",0xc);
    HVar7 = StringFromCLSID((IID *)(param_1 + 4),local_12c);
    pOVar5 = local_12c[0];
    if (HVar7 == 0) {
      if (local_12c[0] == (LPOLESTR)0x0) {
        local_120 = (LPCSTR)0x0;
      }
      else {
        pOVar14 = local_12c[0];
        do {
          OVar2 = *pOVar14;
          pOVar14 = pOVar14 + 1;
        } while (OVar2 != L'\0');
        iVar8 = ((int)pOVar14 - (int)(local_12c[0] + 1) >> 1) + 1;
        if (iVar8 < 0x40000000) {
          iVar10 = iVar8 * -2;
          *(undefined4 *)(&stack0xfffffeac + iVar10) = 3;
          *(int *)(&stack0xfffffea8 + iVar10) = iVar8 * 2;
          *(LPOLESTR *)(&stack0xfffffea4 + iVar10) = pOVar5;
          *(int *)(&stack0xfffffea0 + iVar10) = (int)&local_150 + iVar10;
          *(undefined4 *)(&stack0xfffffe9c + iVar10) = 0x10026f00;
          local_120 = FUN_10019d50(*(LPSTR *)(&stack0xfffffea0 + iVar10),
                                   *(LPCWSTR *)(&stack0xfffffea4 + iVar10),
                                   *(int *)(&stack0xfffffea8 + iVar10),
                                   *(UINT *)(&stack0xfffffeac + iVar10));
        }
        else {
          local_120 = (LPCSTR)0x0;
        }
      }
      pCVar15 = local_120;
      puVar6 = (uchar *)operator_new__(0x100);
      iVar8 = _access((char *)local_11c,0);
      if ((iVar8 == 0) && (puVar6 != (uchar *)0x0)) {
        GetPrivateProfileStringA(pCVar15,"Key","",(LPSTR)puVar6,0x100,(LPCSTR)local_11c);
        uVar16 = 0;
        if (*(int *)(param_1 + 0x1c) - *(int *)(param_1 + 0x18) >> 2 != 0) {
          do {
            puVar4 = *(undefined4 **)(*(int *)(param_1 + 0x18) + uVar16 * 4);
            if (puVar4 == (undefined4 *)0x0) {
              _Str1 = (uchar *)0x0;
            }
            else {
              if (puVar4[1] == 0) {
                pCVar9 = ConvertBSTRToString((LPCWSTR)*puVar4);
                puVar4[1] = pCVar9;
              }
              _Str1 = (uchar *)puVar4[1];
            }
            iVar8 = _mbscmp(_Str1,puVar6);
            if (iVar8 == 0) {
              *(short *)(param_1 + 0x30) = (short)uVar16;
              *(undefined4 *)(param_1 + 0x14) = 1;
              break;
            }
            uVar16 = uVar16 + 1;
          } while (uVar16 < (uint)(*(int *)(param_1 + 0x1c) - *(int *)(param_1 + 0x18) >> 2));
        }
      }
      if ((int)*(undefined4 **)(param_1 + 0x28) - (int)*(undefined4 **)(param_1 + 0x24) >> 2 != 0) {
        FUN_10026290(*(undefined4 **)(param_1 + 0x24),*(undefined4 **)(param_1 + 0x28));
        *(undefined4 *)(param_1 + 0x28) = *(undefined4 *)(param_1 + 0x24);
      }
      local_138 = 0;
      if (*(int *)(param_1 + 0x1c) - *(int *)(param_1 + 0x18) >> 2 != 0) {
        do {
          piVar12 = *(int **)(*(int *)(param_1 + 0x18) + local_138 * 4);
          if (piVar12 == (int *)0x0) goto LAB_10027040;
          if (*piVar12 == 0) goto LAB_10027040;
          Ordinal_149();
          iVar8 = Ordinal_150();
          if (iVar8 != 0) goto LAB_10027042;
LAB_10027036:
          do {
            _com_issue_error(-0x7ff8fff2);
LAB_10027040:
            iVar8 = 0;
LAB_10027042:
            pCVar15 = local_120;
            uVar16 = 0;
            iVar10 = Ordinal_7();
            if (iVar10 != 0) {
              do {
                if (*pCVar15 == '\0') {
                  pCVar15 = local_120;
                }
                puVar1 = (ushort *)(iVar8 + uVar16 * 2);
                *puVar1 = *puVar1 ^ (short)*pCVar15;
                uVar3 = *(ushort *)(iVar8 + uVar16 * 2);
                if (uVar3 < 0x20) {
                  *(ushort *)(iVar8 + uVar16 * 2) = uVar3 + 0x20;
                }
                uVar16 = uVar16 + 1;
                pCVar15 = pCVar15 + 1;
                uVar11 = Ordinal_7();
              } while (uVar16 < uVar11);
            }
            piVar12 = (int *)operator_new(0xc);
            local_8 = 0;
            if (piVar12 == (int *)0x0) {
              piVar12 = (int *)0x0;
            }
            else {
              piVar12[1] = 0;
              piVar12[2] = 1;
              iVar10 = Ordinal_2();
              *piVar12 = iVar10;
              if ((iVar10 == 0) && (iVar8 != 0)) goto LAB_10027036;
            }
            local_8 = 0xffffffff;
            local_124 = piVar12;
          } while (piVar12 == (int *)0x0);
          local_8 = 1;
          FUN_100276f0((undefined4 *)(param_1 + 0x24),(int *)&local_124);
          Ordinal_6();
          piVar12 = local_124;
          local_8 = 0xffffffff;
          if (local_124 != (int *)0x0) {
            LVar13 = InterlockedDecrement(local_124 + 2);
            if (LVar13 == 0) {
              if (*piVar12 != 0) {
                Ordinal_6();
                *piVar12 = 0;
              }
              if ((void *)piVar12[1] != (void *)0x0) {
                operator_delete__((void *)piVar12[1]);
                piVar12[1] = 0;
              }
              operator_delete(piVar12);
            }
            local_124 = (int *)0x0;
          }
          local_138 = local_138 + 1;
        } while (local_138 < (uint)(*(int *)(param_1 + 0x1c) - *(int *)(param_1 + 0x18) >> 2));
      }
      CoTaskMemFree(local_12c[0]);
      operator_delete__(puVar6);
    }
  }
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100271d0 at 100271d0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */
/* WARNING: Unable to track spacebase fully for stack */

void __thiscall FUN_100271d0(void *this,short *param_1)

{
  short sVar1;
  undefined4 *puVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  LPSTR pCVar6;
  uchar *_Str1;
  short *psVar7;
  uint uVar8;
  UINT aUStackY_40 [2];
  DWORD aDStackY_38 [3];
  int aiStackY_2c [2];
  uchar *local_c;
  
  uVar4 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  if (param_1 != (short *)0x0) {
    psVar7 = param_1;
    do {
      sVar1 = *psVar7;
      psVar7 = psVar7 + 1;
    } while (sVar1 != 0);
    iVar5 = ((int)psVar7 - (int)(param_1 + 1) >> 1) + 1;
    if (iVar5 < 0x40000000) {
      iVar3 = iVar5 * -2;
      if (&stack0x00000000 != (undefined1 *)0x1c) {
        *(undefined4 *)(&stack0xffffffe0 + iVar3) = 0;
        *(undefined4 *)(&stack0xffffffdc + iVar3) = 0;
        *(int *)((int)aiStackY_2c + iVar3 + 4) = iVar5 * 2;
        *(undefined1 **)((int)aiStackY_2c + iVar3) = &stack0xffffffe4;
        *(undefined4 *)((int)aiStackY_2c + iVar3 + -4) = 0xffffffff;
        *(short **)((int)aDStackY_38 + iVar3 + 4) = param_1;
        *(undefined4 *)((int)aDStackY_38 + iVar3) = 0;
        *(undefined4 *)((int)aUStackY_40 + iVar3 + 4) = 3;
        *(undefined4 *)((int)aUStackY_40 + iVar3) = 0x10027245;
        iVar5 = WideCharToMultiByte(*(UINT *)((int)aUStackY_40 + iVar3 + 4),
                                    *(DWORD *)((int)aDStackY_38 + iVar3),
                                    *(LPCWSTR *)((int)aDStackY_38 + iVar3 + 4),
                                    *(int *)((int)aiStackY_2c + iVar3 + -4),
                                    *(LPSTR *)((int)aiStackY_2c + iVar3),
                                    *(int *)((int)aiStackY_2c + iVar3 + 4),
                                    *(LPCSTR *)(&stack0xffffffdc + iVar3),
                                    *(LPBOOL *)(&stack0xffffffe0 + iVar3));
        local_c = (uchar *)(-(uint)(iVar5 != 0) & (uint)&stack0xffffffe4);
        goto LAB_10027259;
      }
    }
  }
  local_c = (uchar *)0x0;
LAB_10027259:
  if (*(int *)((int)this + 0x24) == *(int *)((int)this + 0x28)) {
    FUN_10026e10((int)this);
  }
  uVar8 = 0;
  if (*(int *)((int)this + 0x28) - *(int *)((int)this + 0x24) >> 2 != 0) {
    do {
      puVar2 = *(undefined4 **)(*(int *)((int)this + 0x24) + uVar8 * 4);
      if (puVar2 == (undefined4 *)0x0) {
        _Str1 = (uchar *)0x0;
      }
      else {
        if (puVar2[1] == 0) {
          pCVar6 = ConvertBSTRToString((LPCWSTR)*puVar2);
          puVar2[1] = pCVar6;
        }
        _Str1 = (uchar *)puVar2[1];
      }
      aiStackY_2c[1] = 0x100272a2;
      iVar5 = _mbscmp(_Str1,local_c);
      if (iVar5 == 0) {
        *(short *)((int)this + 0x30) = (short)uVar8;
        *(undefined4 *)((int)this + 0x14) = 1;
      }
      uVar8 = uVar8 + 1;
    } while (uVar8 < (uint)(*(int *)((int)this + 0x28) - *(int *)((int)this + 0x24) >> 2));
  }
  __security_check_cookie(uVar4 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100272f0 at 100272f0

void FUN_100272f0(undefined4 *param_1,undefined4 *param_2)

{
  FUN_10026290(param_1,param_2);
  return;
}



// Function: FUN_10027310 at 10027310

undefined4 FUN_10027310(undefined4 param_1)

{
  return param_1;
}



// Function: FUN_10027320 at 10027320

uint __thiscall FUN_10027320(void *this,uint param_1)

{
  uint uVar1;
  
                    /* WARNING: Load size is inaccurate */
  uVar1 = *(int *)((int)this + 8) - *this >> 2;
  if (0x3fffffff - (uVar1 >> 1) < uVar1) {
    uVar1 = 0;
    if (param_1 != 0) {
      uVar1 = param_1;
    }
    return uVar1;
  }
  uVar1 = uVar1 + (uVar1 >> 1);
  if (uVar1 < param_1) {
    uVar1 = param_1;
  }
  return uVar1;
}



// Function: FUN_10027360 at 10027360

undefined4 __thiscall FUN_10027360(void *this,uint param_1)

{
  uint3 uVar1;
  
  uVar1 = (uint3)(param_1 >> 8);
                    /* WARNING: Load size is inaccurate */
  if ((param_1 < *(uint *)((int)this + 4)) && (*this <= param_1)) {
    return CONCAT31(uVar1,1);
  }
  return (uint)uVar1 << 8;
}



// Function: FUN_10027390 at 10027390

void __thiscall FUN_10027390(void *this,uint param_1)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int *piVar3;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002dc70;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  piVar3 = (int *)0x0;
  if (param_1 != 0) {
    if (param_1 < 0x40000000) {
      piVar3 = (int *)operator_new(param_1 * 4);
      if (piVar3 != (int *)0x0) goto LAB_100273f0;
    }
    std::_Xbad_alloc();
  }
LAB_100273f0:
  local_8 = 0;
                    /* WARNING: Load size is inaccurate */
  FUN_10026310(*this,*(int **)((int)this + 4),piVar3);
  local_8 = 0xffffffff;
  puVar1 = *(undefined4 **)((int)this + 4);
                    /* WARNING: Load size is inaccurate */
  puVar2 = *this;
  if (puVar2 != (undefined4 *)0x0) {
    FUN_10026290(puVar2,puVar1);
                    /* WARNING: Load size is inaccurate */
    operator_delete(*this);
  }
  *(int **)((int)this + 8) = piVar3 + param_1;
  *(int **)((int)this + 4) = piVar3 + ((int)puVar1 - (int)puVar2 >> 2);
  *(int **)this = piVar3;
  ExceptionList = local_10;
  return;
}



// Function: Catch@1002745b at 1002745b

void Catch_1002745b(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x14));
                    /* WARNING: Subroutine does not return */
  _CxxThrowException((void *)0x0,(ThrowInfo *)0x0);
}



// Function: FUN_10027470 at 10027470

void __thiscall FUN_10027470(void *this,uint param_1)

{
  int *extraout_ECX;
  int extraout_EDX;
  int iVar1;
  uint uVar2;
  uint unaff_retaddr;
  
  iVar1 = *(int *)((int)this + 8);
  if (param_1 <= (uint)(iVar1 - *(int *)((int)this + 4) >> 2)) {
    return;
  }
                    /* WARNING: Load size is inaccurate */
  if (0x3fffffffU - (*(int *)((int)this + 4) - *this >> 2) < param_1) {
    std::_Xlength_error("vector<T> too long");
    this = extraout_ECX;
    iVar1 = extraout_EDX;
  }
                    /* WARNING: Load size is inaccurate */
  uVar2 = iVar1 - *this >> 2;
  if (0x3fffffff - (uVar2 >> 1) < uVar2) {
    FUN_10027390(this,unaff_retaddr);
    return;
  }
  FUN_10027390(this,unaff_retaddr);
  return;
}



// Function: FUN_100274f0 at 100274f0

void __fastcall FUN_100274f0(undefined4 *param_1)

{
  if ((undefined4 *)*param_1 != (undefined4 *)0x0) {
    FUN_10026290((undefined4 *)*param_1,(undefined4 *)param_1[1]);
    operator_delete((void *)*param_1);
    *param_1 = 0;
    param_1[1] = 0;
    param_1[2] = 0;
  }
  return;
}



// Function: FUN_10027560 at 10027560

void FUN_10027560(uchar *param_1,uint param_2)

{
                    /* WARNING: Could not recover jumptable at 0x10027564. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  _mbsrchr(param_1,param_2);
  return;
}



// Function: FUN_10027570 at 10027570

void * FUN_10027570(uint param_1)

{
  void *pvVar1;
  void *extraout_ECX;
  
  pvVar1 = (void *)0x0;
  if (param_1 != 0) {
    if ((param_1 < 0x40000000) && (pvVar1 = operator_new(param_1 << 2), pvVar1 != (void *)0x0)) {
      return pvVar1;
    }
    std::_Xbad_alloc();
    pvVar1 = extraout_ECX;
  }
  return pvVar1;
}



// Function: FUN_100275b0 at 100275b0

void * FUN_100275b0(uint param_1)

{
  void *pvVar1;
  void *extraout_ECX;
  
  pvVar1 = (void *)0x0;
  if (param_1 != 0) {
    if ((param_1 < 0x40000000) && (pvVar1 = operator_new(param_1 << 2), pvVar1 != (void *)0x0)) {
      return pvVar1;
    }
    std::_Xbad_alloc();
    pvVar1 = extraout_ECX;
  }
  return pvVar1;
}



// Function: FUN_10027600 at 10027600

void __fastcall FUN_10027600(undefined4 *param_1)

{
  FUN_10026290((undefined4 *)*param_1,(undefined4 *)param_1[1]);
  param_1[1] = *param_1;
  return;
}



// Function: FUN_10027630 at 10027630

void FUN_10027630(int *param_1,int *param_2)

{
  int iVar1;
  
  if (param_1 != (int *)0x0) {
    iVar1 = *param_2;
    *param_1 = iVar1;
    if (iVar1 != 0) {
      InterlockedIncrement((LONG *)(iVar1 + 8));
    }
  }
  return;
}



// Function: FUN_10027660 at 10027660

void FUN_10027660(void *param_1)

{
  operator_delete(param_1);
  return;
}



// Function: FUN_10027680 at 10027680

void FUN_10027680(void *param_1)

{
  operator_delete(param_1);
  return;
}



// Function: FUN_100276f0 at 100276f0

void __thiscall FUN_100276f0(void *this,int *param_1)

{
  int *piVar1;
  int *piVar2;
  int iVar3;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002dca1;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  piVar1 = *(int **)((int)this + 4);
                    /* WARNING: Load size is inaccurate */
  if ((param_1 < piVar1) && (piVar2 = *this, piVar2 <= param_1)) {
    if (piVar1 == *(int **)((int)this + 8)) {
      FUN_10027470(this,1);
    }
                    /* WARNING: Load size is inaccurate */
    local_8 = 0;
    if (*(int **)((int)this + 4) != (int *)0x0) {
      iVar3 = *(int *)(*this + ((int)param_1 - (int)piVar2 >> 2) * 4);
      **(int **)((int)this + 4) = iVar3;
      if (iVar3 != 0) {
        InterlockedIncrement((LONG *)(iVar3 + 8));
      }
    }
  }
  else {
    if (piVar1 == *(int **)((int)this + 8)) {
      FUN_10027470(this,1);
    }
    if (*(int **)((int)this + 4) != (int *)0x0) {
      iVar3 = *param_1;
      **(int **)((int)this + 4) = iVar3;
      if (iVar3 != 0) {
        InterlockedIncrement((LONG *)(iVar3 + 8));
      }
    }
  }
  *(int *)((int)this + 4) = *(int *)((int)this + 4) + 4;
  ExceptionList = local_10;
  return;
}



// Function: FUN_100277c0 at 100277c0

void FUN_100277c0(uchar *param_1,uchar *param_2)

{
                    /* WARNING: Could not recover jumptable at 0x100277c4. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  _mbscmp(param_1,param_2);
  return;
}



// Function: CAtlBaseModule at 10027995

/* Library Function - Single Match
    public: __thiscall ATL::CAtlBaseModule::CAtlBaseModule(void)
   
   Library: Visual Studio 2012 Release */

CAtlBaseModule * __thiscall ATL::CAtlBaseModule::CAtlBaseModule(CAtlBaseModule *this)

{
  long lVar1;
  
  _ATL_BASE_MODULE70::_ATL_BASE_MODULE70((_ATL_BASE_MODULE70 *)this);
  *(undefined4 *)this = 0x38;
  *(undefined4 *)(this + 8) = 0x10000000;
  *(undefined4 *)(this + 4) = 0x10000000;
  *(undefined4 *)(this + 0xc) = 0xb00;
  *(undefined **)(this + 0x10) = &DAT_10035f2c;
  lVar1 = CComCriticalSection::Init((CComCriticalSection *)(this + 0x14));
  if (lVar1 < 0) {
    DAT_100403bc = 1;
  }
  return this;
}



// Function: FUN_100279d3 at 100279d3

undefined4 * __thiscall FUN_100279d3(void *this,undefined4 *param_1)

{
  *(undefined4 *)this = *param_1;
  return (undefined4 *)this;
}



// Function: _ATL_BASE_MODULE70 at 100279e3

/* Library Function - Single Match
    public: __thiscall ATL::_ATL_BASE_MODULE70::_ATL_BASE_MODULE70(void)
   
   Library: Visual Studio 2012 Release */

_ATL_BASE_MODULE70 * __thiscall
ATL::_ATL_BASE_MODULE70::_ATL_BASE_MODULE70(_ATL_BASE_MODULE70 *this)

{
  memset(this + 0x14,0,0x18);
  *(undefined4 *)(this + 0x2c) = 0;
  *(undefined4 *)(this + 0x30) = 0;
  *(undefined4 *)(this + 0x34) = 0;
  return this;
}



// Function: ~CAtlBaseModule at 10027a0b

/* Library Function - Single Match
    public: __thiscall ATL::CAtlBaseModule::~CAtlBaseModule(void)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

void __thiscall ATL::CAtlBaseModule::~CAtlBaseModule(CAtlBaseModule *this)

{
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 0x14));
  CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>::
  RemoveAll((CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
             *)(this + 0x2c));
  return;
}



// Function: operator[] at 10027a29

/* Library Function - Single Match
    public: struct HINSTANCE__ * & __thiscall ATL::CSimpleArray<struct HINSTANCE__ *,class
   ATL::CSimpleArrayEqualHelper<struct HINSTANCE__ *> >::operator[](int)
   
   Library: Visual Studio 2012 Release */

HINSTANCE__ ** __thiscall
ATL::CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>::
operator[](CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
           *this,int param_1)

{
  code *pcVar1;
  HINSTANCE__ **ppHVar2;
  
  if ((-1 < param_1) && (param_1 < *(int *)(this + 4))) {
    return (HINSTANCE__ **)(*(int *)this + param_1 * 4);
  }
  RaiseException(0xc000008c,1,0,(ULONG_PTR *)0x0);
  pcVar1 = (code *)swi(3);
  ppHVar2 = (HINSTANCE__ **)(*pcVar1)();
  return ppHVar2;
}



// Function: Add at 10027a53

/* Library Function - Single Match
    public: int __thiscall ATL::CSimpleArray<struct HINSTANCE__ *,class
   ATL::CSimpleArrayEqualHelper<struct HINSTANCE__ *> >::Add(struct HINSTANCE__ * const &)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release */

int __thiscall
ATL::CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>::Add
          (CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
           *this,HINSTANCE__ **param_1)

{
  undefined4 *puVar1;
  HINSTANCE__ **_Memory;
  code *pcVar2;
  void *pvVar3;
  int iVar4;
  uint _Count;
  
  iVar4 = *(int *)(this + 8);
  if (*(int *)(this + 4) == iVar4) {
    _Memory = *(HINSTANCE__ ***)this;
    if ((_Memory <= param_1) && (param_1 < _Memory + iVar4)) {
      FUN_10010aa0(0x80004005);
      pcVar2 = (code *)swi(3);
      iVar4 = (*pcVar2)();
      return iVar4;
    }
    if (iVar4 == 0) {
      _Count = 1;
LAB_10027a8a:
      pvVar3 = _recalloc(_Memory,_Count,4);
      if (pvVar3 != (void *)0x0) {
        *(uint *)(this + 8) = _Count;
        *(void **)this = pvVar3;
        goto LAB_10027a9f;
      }
    }
    else {
      _Count = *(int *)(this + 4) * 2;
      if ((-1 < (int)_Count) && (_Count < 0x20000000)) goto LAB_10027a8a;
    }
    iVar4 = 0;
  }
  else {
LAB_10027a9f:
    puVar1 = (undefined4 *)(*(int *)this + *(int *)(this + 4) * 4);
    if (puVar1 != (undefined4 *)0x0) {
      *puVar1 = *param_1;
    }
    *(int *)(this + 4) = *(int *)(this + 4) + 1;
    iVar4 = 1;
  }
  return iVar4;
}



// Function: AddResourceInstance at 10027acb

/* Library Function - Single Match
    public: bool __thiscall ATL::CAtlBaseModule::AddResourceInstance(struct HINSTANCE__ *)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release */

bool __thiscall ATL::CAtlBaseModule::AddResourceInstance(CAtlBaseModule *this,HINSTANCE__ *param_1)

{
  int iVar1;
  
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 0x14));
  iVar1 = CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
          ::Add((CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
                 *)(this + 0x2c),&param_1);
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 0x14));
  return iVar1 != 0;
}



// Function: GetHInstanceAt at 10027afe

/* Library Function - Single Match
    public: struct HINSTANCE__ * __thiscall ATL::CAtlBaseModule::GetHInstanceAt(int)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release */

HINSTANCE__ * __thiscall ATL::CAtlBaseModule::GetHInstanceAt(CAtlBaseModule *this,int param_1)

{
  HINSTANCE__ **ppHVar1;
  HINSTANCE__ *pHVar2;
  
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 0x14));
  if ((*(int *)(this + 0x30) < param_1) || (param_1 < 0)) {
    pHVar2 = (HINSTANCE__ *)0x0;
  }
  else if (param_1 == *(int *)(this + 0x30)) {
    pHVar2 = *(HINSTANCE__ **)(this + 8);
  }
  else {
    ppHVar1 = CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
              ::operator[]((CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
                            *)(this + 0x2c),param_1);
    pHVar2 = *ppHVar1;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 0x14));
  return pHVar2;
}



// Function: InternalSetAtIndex at 10027b47

/* Library Function - Multiple Matches With Same Base Name
    public: void __thiscall ATL::CSimpleArray<unsigned long,class
   ATL::CSimpleArrayEqualHelper<unsigned long> >::InternalSetAtIndex(int,unsigned long const &)
    public: void __thiscall ATL::CSimpleArray<struct HINSTANCE__ *,class
   ATL::CSimpleArrayEqualHelper<struct HINSTANCE__ *> >::InternalSetAtIndex(int,struct HINSTANCE__ *
   const &)
    public: void __thiscall ATL::CSimpleArray<class CDHtmlControlSink *,class
   ATL::CSimpleArrayEqualHelper<class CDHtmlControlSink *> >::InternalSetAtIndex(int,class
   CDHtmlControlSink * const &)
    public: void __thiscall ATL::CSimpleArray<class CDHtmlElementEventSink *,class
   ATL::CSimpleArrayEqualHelper<class CDHtmlElementEventSink *> >::InternalSetAtIndex(int,class
   CDHtmlElementEventSink * const &)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

void __thiscall InternalSetAtIndex(void *this,int param_1,undefined4 *param_2)

{
  undefined4 *puVar1;
  
                    /* WARNING: Load size is inaccurate */
  puVar1 = (undefined4 *)(*this + param_1 * 4);
  if (puVar1 != (undefined4 *)0x0) {
    *puVar1 = *param_2;
  }
  return;
}



// Function: RemoveAll at 10027b61

/* Library Function - Single Match
    public: void __thiscall ATL::CSimpleArray<struct HINSTANCE__ *,class
   ATL::CSimpleArrayEqualHelper<struct HINSTANCE__ *> >::RemoveAll(void)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

void __thiscall
ATL::CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>::
RemoveAll(CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
          *this)

{
  if (*(int *)this != 0) {
    free(*(void **)this);
    *(undefined4 *)this = 0;
  }
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0;
  return;
}



// Function: RemoveAt at 10027b7e

/* Library Function - Single Match
    public: int __thiscall ATL::CSimpleArray<struct HINSTANCE__ *,class
   ATL::CSimpleArrayEqualHelper<struct HINSTANCE__ *> >::RemoveAt(int)
   
   Library: Visual Studio 2012 Release */

int __thiscall
ATL::CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>::
RemoveAt(CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
         *this,int param_1)

{
  void *pvVar1;
  int iVar2;
  uint uVar3;
  
  if ((param_1 < 0) || (iVar2 = *(int *)(this + 4), iVar2 <= param_1)) {
    iVar2 = 0;
  }
  else {
    if (param_1 != iVar2 + -1) {
      uVar3 = (iVar2 - param_1) * 4;
      pvVar1 = (void *)(*(int *)this + param_1 * 4);
      Checked::memmove_s(pvVar1,uVar3,(void *)((int)pvVar1 + 4),uVar3 - 4);
    }
    *(int *)(this + 4) = *(int *)(this + 4) + -1;
    iVar2 = 1;
  }
  return iVar2;
}



// Function: RemoveResourceInstance at 10027bc6

/* Library Function - Single Match
    public: bool __thiscall ATL::CAtlBaseModule::RemoveResourceInstance(struct HINSTANCE__ *)
   
   Library: Visual Studio 2012 Release */

bool __thiscall
ATL::CAtlBaseModule::RemoveResourceInstance(CAtlBaseModule *this,HINSTANCE__ *param_1)

{
  HINSTANCE__ **ppHVar1;
  bool bVar2;
  int iVar3;
  
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 0x14));
  bVar2 = false;
  iVar3 = 0;
  if (0 < *(int *)(this + 0x30)) {
    do {
      ppHVar1 = CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
                ::operator[]((CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
                              *)(this + 0x2c),iVar3);
      if (*ppHVar1 == param_1) {
        CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>::
        RemoveAt((CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>
                  *)(this + 0x2c),iVar3);
        bVar2 = true;
        break;
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 < *(int *)(this + 0x30));
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 0x14));
  return bVar2;
}



// Function: memmove_s at 10027c23

/* Library Function - Single Match
    void __cdecl ATL::Checked::memmove_s(void *,unsigned int,void const *,unsigned int)
   
   Library: Visual Studio 2012 Release */

void __cdecl ATL::Checked::memmove_s(void *param_1,uint param_2,void *param_3,uint param_4)

{
  errno_t eVar1;
  
  eVar1 = ::memmove_s(param_1,param_2,param_3,param_4);
  AtlCrtErrorCheck(eVar1);
  return;
}



// Function: CAtlComModule at 10027c42

/* Library Function - Single Match
    public: __thiscall ATL::CAtlComModule::CAtlComModule(void)
   
   Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release */

CAtlComModule * __thiscall ATL::CAtlComModule::CAtlComModule(CAtlComModule *this)

{
  long lVar1;
  
  _ATL_COM_MODULE70::_ATL_COM_MODULE70((_ATL_COM_MODULE70 *)this);
  *(undefined4 *)this = 0;
  *(undefined4 *)(this + 4) = 0x10000000;
  *(undefined **)(this + 8) = &DAT_1003ca50;
  *(undefined **)(this + 0xc) = &DAT_1003ca50;
  lVar1 = CComCriticalSection::Init((CComCriticalSection *)(this + 0x10));
  if (lVar1 < 0) {
    DAT_100403bc = 1;
  }
  else {
    *(undefined4 *)this = 0x28;
  }
  return this;
}



// Function: _ATL_COM_MODULE70 at 10027c81

/* Library Function - Single Match
    public: __thiscall ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70(void)
   
   Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release */

_ATL_COM_MODULE70 * __thiscall ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70(_ATL_COM_MODULE70 *this)

{
  memset(this + 0x10,0,0x18);
  return this;
}



// Function: Term at 10027c9e

/* Library Function - Single Match
    public: void __thiscall ATL::CAtlComModule::Term(void)
   
   Library: Visual Studio 2012 Release */

void __thiscall ATL::CAtlComModule::Term(CAtlComModule *this)

{
  int *piVar1;
  int *piVar2;
  int *piVar3;
  
  if (*(int *)this != 0) {
    piVar3 = *(int **)(this + 8);
    if (piVar3 < *(int **)(this + 0xc)) {
      do {
        if ((*piVar3 != 0) && (piVar1 = *(int **)(*piVar3 + 0x10), *piVar1 != 0)) {
          piVar2 = (int *)DecodePointer((PVOID)*piVar1);
          (**(code **)(*piVar2 + 8))(piVar2);
          *piVar1 = 0;
        }
        piVar3 = piVar3 + 1;
      } while (piVar3 < *(int **)(this + 0xc));
    }
    DeleteCriticalSection((LPCRITICAL_SECTION)(this + 0x10));
    *(undefined4 *)this = 0;
  }
  return;
}



// Function: `vector_constructor_iterator' at 10027ce8

/* Library Function - Single Match
    void __stdcall `vector constructor iterator'(void *,unsigned int,int,void * (__thiscall*)(void
   *))
   
   Library: Visual Studio 2012 Release */

void _vector_constructor_iterator_
               (void *param_1,uint param_2,int param_3,_func_void_ptr_void_ptr *param_4)

{
  int iVar1;
  void *unaff_EDI;
  
  for (iVar1 = param_3 + -1; -1 < iVar1; iVar1 = iVar1 + -1) {
    (*param_4)(unaff_EDI);
  }
  return;
}



// Function: `vector_destructor_iterator' at 10027d07

/* Library Function - Single Match
    void __stdcall `vector destructor iterator'(void *,unsigned int,int,void (__thiscall*)(void *))
   
   Library: Visual Studio 2012 Release */

void _vector_destructor_iterator_
               (void *param_1,uint param_2,int param_3,_func_void_void_ptr *param_4)

{
  void *unaff_EDI;
  
  while( true ) {
    param_3 = param_3 + -1;
    if (param_3 < 0) break;
    (*param_4)(unaff_EDI);
  }
  return;
}



// Function: _com_dispatch_method at 10027d30

/* Library Function - Single Match
    long __cdecl _com_dispatch_method(struct IDispatch *,long,unsigned short,unsigned short,void
   *,unsigned short const *,...)
   
   Library: Visual Studio 2012 Release */

long __cdecl
_com_dispatch_method
          (IDispatch *param_1,long param_2,ushort param_3,ushort param_4,void *param_5,
          ushort *param_6,...)

{
  long lVar1;
  IErrorInfo *local_8;
  
  lVar1 = _com_invoke_helper(param_1,param_2,param_3,param_4,param_5,param_6,&stack0x0000001c,
                             &local_8);
  if (lVar1 < 0) {
    (*(code *)PTR_FUN_10040368)(lVar1,local_8);
  }
  return lVar1;
}



// Function: _com_dispatch_propget at 10027d70

/* Library Function - Single Match
    long __stdcall _com_dispatch_propget(struct IDispatch *,long,unsigned short,void *)
   
   Library: Visual Studio 2012 Release */

long _com_dispatch_propget(IDispatch *param_1,long param_2,ushort param_3,void *param_4)

{
  long lVar1;
  
  lVar1 = _com_dispatch_method(param_1,param_2,2,param_3,param_4,(ushort *)0x0);
  return lVar1;
}



// Function: _com_dispatch_propput at 10027d90

/* Library Function - Single Match
    long __cdecl _com_dispatch_propput(struct IDispatch *,long,unsigned short,...)
   
   Library: Visual Studio 2012 Release */

long __cdecl _com_dispatch_propput(IDispatch *param_1,long param_2,ushort param_3,...)

{
  ushort uVar1;
  long lVar2;
  IErrorInfo *local_c;
  ushort local_8 [2];
  
  local_8[0] = param_3;
  local_8[1] = 0;
  if ((param_3 == 9) || (uVar1 = 4, param_3 == 0xd)) {
    uVar1 = 8;
  }
  lVar2 = _com_invoke_helper(param_1,param_2,uVar1,0,(void *)0x0,local_8,&stack0x00000010,&local_c);
  if (lVar2 < 0) {
    (*(code *)PTR_FUN_10040368)(lVar2,local_c);
  }
  return lVar2;
}



// Function: _com_issue_error at 10027df0

/* Library Function - Single Match
    void __stdcall _com_issue_error(long)
   
   Library: Visual Studio 2012 Release */

void _com_issue_error(long param_1)

{
  (*(code *)PTR_FUN_10040368)(param_1,0);
  return;
}



// Function: _com_issue_errorex at 10027e10

/* Library Function - Single Match
    void __stdcall _com_issue_errorex(long,struct IUnknown *,struct _GUID const &)
   
   Library: Visual Studio 2012 Release */

void _com_issue_errorex(long param_1,IUnknown *param_2,_GUID *param_3)

{
  HRESULT HVar1;
  int iVar2;
  undefined4 **ppuVar3;
  void **unaff_ESI;
  undefined4 **local_8;
  
  local_8 = (undefined4 **)0x0;
  ppuVar3 = (undefined4 **)0x0;
  if ((param_2 != (IUnknown *)0x0) &&
     (HVar1 = (*param_2->lpVtbl->QueryInterface)(param_2,(IID *)&DAT_1002fb28,&param_2),
     ppuVar3 = local_8, -1 < HVar1)) {
    HVar1 = (*param_2->lpVtbl[1].QueryInterface)(param_2,param_3,unaff_ESI);
    (*param_2->lpVtbl->Release)(param_2);
    ppuVar3 = local_8;
    if (HVar1 == 0) {
      local_8 = &local_8;
      iVar2 = Ordinal_200(0);
      local_8 = (undefined4 **)(~-(uint)(iVar2 != 0) & (uint)local_8);
      (*(code *)PTR_FUN_10040368)(param_1,local_8);
      return;
    }
  }
  local_8 = ppuVar3;
  (*(code *)PTR_FUN_10040368)(param_1);
  return;
}



// Function: FUN_10027e90 at 10027e90

void FUN_10027e90(undefined *param_1)

{
  PTR_FUN_10040368 = param_1;
  return;
}



// Function: _variant_t at 10027ea0

/* Library Function - Single Match
    public: __thiscall _variant_t::_variant_t(long,unsigned short)
   
   Library: Visual Studio 2012 Release */

_variant_t * __thiscall _variant_t::_variant_t(_variant_t *this,long param_1,ushort param_2)

{
  code *pcVar1;
  _variant_t *p_Var2;
  
  if (param_2 != 3) {
    if (param_2 == 10) goto LAB_10027ebf;
    if (param_2 != 0xb) {
      _com_issue_error(-0x7ff8ffa9);
      pcVar1 = (code *)swi(3);
      p_Var2 = (_variant_t *)(*pcVar1)();
      return p_Var2;
    }
  }
  if (param_2 != 10) {
    if (param_2 == 0xb) {
      *(undefined2 *)this = 0xb;
      *(ushort *)(this + 8) = -(ushort)(param_1 != 0);
      return this;
    }
    *(undefined2 *)this = 3;
    *(long *)(this + 8) = param_1;
    return this;
  }
LAB_10027ebf:
  *(undefined2 *)this = 10;
  *(long *)(this + 8) = param_1;
  return this;
}



// Function: ConvertBSTRToString at 10027f20

/* Library Function - Multiple Matches With Same Base Name
    char * __stdcall _com_util::ConvertBSTRToString(unsigned short *)
    char * __stdcall _com_util::ConvertBSTRToString(wchar_t *)
   
   Library: Visual Studio 2012 Release */

LPSTR ConvertBSTRToString(LPCWSTR param_1)

{
  WCHAR WVar1;
  code *pcVar2;
  uint cbMultiByte;
  DWORD DVar3;
  LPSTR pCVar4;
  int iVar5;
  LPCWSTR pWVar6;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_1002dcc0;
  local_10 = ExceptionList;
  if (param_1 == (LPCWSTR)0x0) {
    return (LPSTR)0x0;
  }
  pWVar6 = param_1;
  do {
    WVar1 = *pWVar6;
    pWVar6 = pWVar6 + 1;
  } while (WVar1 != L'\0');
  iVar5 = ((int)pWVar6 - (int)(param_1 + 1) >> 1) + 1;
  ExceptionList = &local_10;
  cbMultiByte = WideCharToMultiByte(0,0,param_1,iVar5,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);
  if (cbMultiByte == 0) {
    DVar3 = GetLastError();
    if (0 < (int)DVar3) {
      DVar3 = DVar3 & 0xffff | 0x80070000;
    }
    _com_issue_error(DVar3);
  }
  local_8 = 0;
  pCVar4 = (LPSTR)operator_new(cbMultiByte);
  local_8 = 0xffffffff;
  if (pCVar4 != (LPSTR)0x0) {
    iVar5 = WideCharToMultiByte(0,0,param_1,iVar5,pCVar4,cbMultiByte,(LPCSTR)0x0,(LPBOOL)0x0);
    if (iVar5 == 0) {
      operator_delete(pCVar4);
      DVar3 = GetLastError();
      if (0 < (int)DVar3) {
        DVar3 = DVar3 & 0xffff | 0x80070000;
      }
      _com_issue_error(DVar3);
    }
    ExceptionList = local_10;
    return pCVar4;
  }
  _com_issue_error(-0x7ff8fff2);
  pcVar2 = (code *)swi(3);
  pCVar4 = (LPSTR)(*pcVar2)();
  return pCVar4;
}



// Function: Catch_All@10028023 at 10028023

undefined * Catch_All_10028023(void)

{
  return &DAT_10028029;
}



// Function: ConvertStringToBSTR at 10028040

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */
/* Library Function - Multiple Matches With Same Base Name
    unsigned short * __stdcall _com_util::ConvertStringToBSTR(char const *)
    wchar_t * __stdcall _com_util::ConvertStringToBSTR(char const *)
   
   Library: Visual Studio 2012 Release */

void ConvertStringToBSTR(LPCSTR param_1)

{
  uint uVar1;
  int iVar2;
  int cchWideChar;
  DWORD DVar3;
  LPWSTR lpWideCharStr;
  int extraout_EAX;
  uint local_3c;
  void *local_14;
  code *pcStack_10;
  uint local_c;
  undefined4 local_8;
  
  local_8 = 0xfffffffe;
  pcStack_10 = FUN_1002910b;
  local_14 = ExceptionList;
  local_c = DAT_10040398 ^ 0x1003c898;
  uVar1 = DAT_10040398 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_14;
  local_3c = uVar1;
  if (param_1 != (LPCSTR)0x0) {
    iVar2 = lstrlenA(param_1);
    iVar2 = iVar2 + 1;
    cchWideChar = MultiByteToWideChar(0,0,param_1,iVar2,(LPWSTR)0x0,0);
    if (cchWideChar == 0) {
      DVar3 = GetLastError();
      if (0 < (int)DVar3) {
        DVar3 = DVar3 & 0xffff | 0x80070000;
      }
      _com_issue_error(DVar3);
    }
    local_8 = 0;
    if (cchWideChar < 0x1000) {
      lpWideCharStr = (LPWSTR)&local_3c;
    }
    else {
      lpWideCharStr = (LPWSTR)malloc(cchWideChar * 2);
    }
    local_8 = 0xfffffffe;
    if (lpWideCharStr == (LPWSTR)0x0) {
      _com_issue_error(-0x7ff8fff2);
      iVar2 = extraout_EAX;
    }
    iVar2 = MultiByteToWideChar(0,0,param_1,iVar2,lpWideCharStr,cchWideChar);
    if (iVar2 == 0) {
      if (0xfff < cchWideChar) {
        free(lpWideCharStr);
      }
      DVar3 = GetLastError();
      if (0 < (int)DVar3) {
        DVar3 = DVar3 & 0xffff | 0x80070000;
      }
      _com_issue_error(DVar3);
    }
    iVar2 = Ordinal_2(lpWideCharStr);
    if (0xfff < cchWideChar) {
      free(lpWideCharStr);
    }
    if (iVar2 == 0) {
      _com_issue_error(-0x7ff8fff2);
    }
  }
  ExceptionList = local_14;
  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);
  return;
}



// Function: FUN_100281c0 at 100281c0

uint FUN_100281c0(uint param_1)

{
  if (0 < (int)param_1) {
    param_1 = param_1 & 0xffff | 0x80070000;
  }
  return param_1;
}



// Function: FUN_100281e0 at 100281e0

void FUN_100281e0(undefined4 param_1,undefined4 param_2)

{
  undefined **local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  local_10 = param_1;
  local_c = param_2;
  local_14 = _com_error::vftable;
  local_8 = 0;
                    /* WARNING: Subroutine does not return */
  _CxxThrowException(&local_14,(ThrowInfo *)&DAT_1003c588);
}



// Function: _com_dispatch_raw_method at 10028210

/* Library Function - Single Match
    long __cdecl _com_dispatch_raw_method(struct IDispatch *,long,unsigned short,unsigned short,void
   *,unsigned short const *,...)
   
   Library: Visual Studio 2012 Release */

long __cdecl
_com_dispatch_raw_method
          (IDispatch *param_1,long param_2,ushort param_3,ushort param_4,void *param_5,
          ushort *param_6,...)

{
  long lVar1;
  IErrorInfo *local_8;
  
  lVar1 = _com_invoke_helper(param_1,param_2,param_3,param_4,param_5,param_6,&stack0x0000001c,
                             &local_8);
  if (lVar1 < 0) {
    Ordinal_201(0,local_8);
  }
  return lVar1;
}



// Function: _com_dispatch_raw_propget at 10028250

/* Library Function - Single Match
    long __stdcall _com_dispatch_raw_propget(struct IDispatch *,long,unsigned short,void *)
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
   Visual Studio 2019 Release */

long _com_dispatch_raw_propget(IDispatch *param_1,long param_2,ushort param_3,void *param_4)

{
  long lVar1;
  
  lVar1 = _com_dispatch_raw_method(param_1,param_2,2,param_3,param_4,(ushort *)0x0);
  return lVar1;
}



// Function: _com_dispatch_raw_propput at 10028270

/* Library Function - Single Match
    long __cdecl _com_dispatch_raw_propput(struct IDispatch *,long,unsigned short,...)
   
   Library: Visual Studio 2012 Release */

long __cdecl _com_dispatch_raw_propput(IDispatch *param_1,long param_2,ushort param_3,...)

{
  ushort uVar1;
  long lVar2;
  IErrorInfo *local_c;
  ushort local_8 [2];
  
  local_8[0] = param_3;
  local_8[1] = 0;
  if ((param_3 == 9) || (uVar1 = 4, param_3 == 0xd)) {
    uVar1 = 8;
  }
  lVar2 = _com_invoke_helper(param_1,param_2,uVar1,0,(void *)0x0,local_8,&stack0x00000010,&local_c);
  if (lVar2 < 0) {
    Ordinal_201(0,local_c);
  }
  return lVar2;
}



// Function: _com_invoke_helper at 100282d0

/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */
/* Library Function - Single Match
    long __cdecl _com_invoke_helper(struct IDispatch *,long,unsigned short,unsigned short,void
   *,unsigned short const *,char *,struct IErrorInfo * *)
   
   Library: Visual Studio 2012 Release */

long __cdecl
_com_invoke_helper(IDispatch *param_1,long param_2,ushort param_3,ushort param_4,void *param_5,
                  ushort *param_6,char *param_7,IErrorInfo **param_8)

{
  ushort uVar1;
  short *psVar2;
  long lVar3;
  ushort uVar4;
  short *psVar5;
  undefined4 *puVar6;
  int *piVar7;
  ushort *puVar8;
  uint uVar9;
  uint *puVar10;
  int *piVar11;
  int *piVar12;
  int iVar13;
  int *piVar14;
  uint *puVar15;
  undefined2 in_stack_0000000e;
  undefined2 in_stack_00000012;
  uint uStack_9c;
  uint local_8c;
  undefined4 local_78;
  undefined4 local_74;
  undefined4 local_70;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  ushort *local_4c;
  uint *local_48;
  undefined1 *local_44;
  undefined4 *local_40;
  int local_3c;
  uint local_38;
  undefined4 *local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined1 local_28;
  undefined1 uStack_27;
  undefined2 uStack_26;
  undefined4 uStack_24;
  uint local_20;
  undefined1 *local_1c;
  void *local_14;
  code *pcStack_10;
  uint local_c;
  undefined4 local_8;
  
  local_8 = 0xfffffffe;
  pcStack_10 = FUN_1002910b;
  local_14 = ExceptionList;
  local_c = DAT_10040398 ^ 0x1003c910;
  local_8c = DAT_10040398 ^ (uint)&stack0xfffffffc;
  local_1c = (undefined1 *)&local_8c;
  ExceptionList = &local_14;
  local_20 = local_8c;
  puVar15 = &local_8c;
  if (param_1 == (IDispatch *)0x0) goto LAB_10028645;
  if (param_8 != (IErrorInfo **)0x0) {
    *param_8 = (IErrorInfo *)0x0;
  }
  local_44 = (undefined1 *)0x0;
  local_40 = (undefined4 *)0x0;
  local_3c = 0;
  local_38 = 0;
  puVar15 = &local_8c;
  if (param_6 != (ushort *)0x0) {
    local_3c = lstrlenW((LPCWSTR)param_6);
    puVar15 = (uint *)local_1c;
  }
  local_1c = (undefined1 *)puVar15;
  local_54 = 0xfffffffd;
  if ((param_3 & 0xc) != 0) {
    puVar15 = (uint *)local_1c;
    if (local_3c == 0) goto LAB_10028645;
    local_38 = 1;
    local_40 = &local_54;
  }
  if (local_3c != 0) {
    local_1c = (undefined1 *)&local_8c;
    local_34 = &local_8c;
    local_8 = 0xfffffffe;
    uStack_9c = 0x1002839c;
    memset(&local_8c,0,local_3c * 0x10);
    local_44 = (undefined1 *)&local_8c;
    local_4c = param_6;
    puVar10 = &uStack_9c + local_3c * 4;
    local_48 = puVar10;
    puVar15 = &local_8c;
    if (*param_6 != 0) {
      piVar14 = (int *)(&stack0xffffff6c + local_3c * 0x10);
      piVar7 = (int *)(param_7 + -4);
      local_48 = (uint *)0x5;
      local_50 = 0xe;
      piVar11 = (int *)(param_7 + -8);
      do {
        uVar1 = *local_4c;
        uVar4 = uVar1 & 0xf7ff;
        *(ushort *)puVar10 = uVar4;
        if (0x4002 < uVar4) {
          switch(uVar4) {
          case 0x4003:
          case 0x4004:
          case 0x4005:
          case 0x4006:
          case 0x4007:
          case 0x4008:
          case 0x4009:
          case 0x400a:
          case 0x400b:
          case 0x400c:
          case 0x400d:
          case 0x400e:
          case 0x4010:
          case 0x4011:
          case 0x4012:
          case 0x4013:
          case 0x4014:
          case 0x4015:
          case 0x4016:
          case 0x4017:
          case 0x4019:
          case 0x4024:
            break;
          default:
switchD_10028415_caseD_f:
            puVar15 = (uint *)local_1c;
            if ((uVar1 & 0x2000) == 0) goto LAB_10028645;
          }
switchD_10028415_caseD_3:
          piVar12 = piVar11 + 1;
          piVar7 = piVar7 + 1;
          *piVar14 = *piVar7;
          goto LAB_10028500;
        }
        if (uVar4 == 0x4002) goto switchD_10028415_caseD_3;
        switch(uVar4) {
        case 2:
        case 0x12:
          piVar12 = piVar11 + 1;
          piVar7 = piVar7 + 1;
          *(short *)piVar14 = (short)*piVar7;
          break;
        case 3:
        case 8:
        case 9:
        case 10:
        case 0xd:
        case 0x13:
        case 0x16:
        case 0x17:
        case 0x19:
        case 0x24:
          goto switchD_10028415_caseD_3;
        case 4:
          *(ushort *)puVar10 = 5;
        case 5:
        case 7:
          piVar12 = piVar11 + 2;
          piVar7 = piVar7 + 2;
          *(undefined8 *)piVar14 = *(undefined8 *)piVar12;
          break;
        case 6:
          piVar12 = piVar11 + 1;
          piVar7 = piVar7 + 1;
          piVar11 = (int *)*piVar7;
          *piVar14 = *piVar11;
          piVar14[1] = piVar11[1];
          break;
        case 0xb:
          piVar12 = piVar11 + 1;
          piVar7 = piVar7 + 1;
          *(ushort *)piVar14 = -(ushort)((short)*piVar7 != 0);
          break;
        case 0xc:
          piVar12 = piVar11 + 1;
          piVar7 = piVar7 + 1;
          puVar15 = (uint *)*piVar7;
          *puVar10 = *puVar15;
          puVar10[1] = puVar15[1];
          puVar10[2] = puVar15[2];
          puVar10[3] = puVar15[3];
          break;
        case 0xe:
          piVar12 = piVar11 + 1;
          piVar7 = piVar7 + 1;
          puVar15 = (uint *)*piVar7;
          *puVar10 = *puVar15;
          puVar10[1] = puVar15[1];
          puVar10[2] = puVar15[2];
          puVar10[3] = puVar15[3];
          *(ushort *)puVar10 = 0xe;
          break;
        default:
          goto switchD_10028415_caseD_f;
        case 0x10:
        case 0x11:
          piVar12 = piVar11 + 1;
          piVar7 = piVar7 + 1;
          *(char *)piVar14 = (char)*piVar7;
          break;
        case 0x14:
        case 0x15:
          piVar12 = piVar11 + 2;
          piVar7 = piVar7 + 2;
          *piVar14 = *piVar12;
          piVar14[1] = piVar11[3];
        }
LAB_10028500:
        puVar10 = puVar10 + -4;
        piVar14 = piVar14 + -4;
        local_4c = local_4c + 1;
        piVar11 = piVar12;
        puVar15 = local_34;
      } while (*local_4c != 0);
    }
    psVar5 = (short *)(puVar15 + local_38 * 4);
    puVar8 = param_6 + (local_3c - local_38) + -1;
    iVar13 = 0;
    if (param_6 <= puVar8) {
      while (puVar15 = local_34, (*puVar8 & 0xbfff) == 0x80c) {
        psVar2 = psVar5;
        if ((*puVar8 & 0x4000) != 0) {
          psVar2 = *(short **)(psVar5 + 4);
        }
        if ((*psVar2 != 10) || (*(int *)(psVar2 + 4) != -0x7ffdfffc)) break;
        iVar13 = iVar13 + 1;
        psVar5 = psVar5 + 8;
        puVar8 = puVar8 + -1;
        if (puVar8 < param_6) break;
      }
    }
    if (iVar13 != 0) {
      uVar9 = 0;
      if (local_38 != 0) {
        puVar6 = puVar15 + iVar13 * 4;
        do {
          *puVar6 = *puVar15;
          puVar6[1] = puVar15[1];
          puVar6[2] = puVar15[2];
          puVar6[3] = puVar15[3];
          uVar9 = uVar9 + 1;
          puVar15 = puVar15 + 4;
          puVar6 = puVar6 + 4;
        } while (uVar9 < local_38);
      }
      local_3c = local_3c - iVar13;
      local_44 = local_44 + iVar13 * 0x10;
    }
  }
  Ordinal_8();
  local_78 = 0;
  local_74 = 0;
  local_70 = 0;
  local_6c = 0;
  local_68 = 0;
  local_64 = 0;
  local_60 = 0;
  local_5c = 0;
  local_58 = 0xffffffff;
  uStack_9c = -(uint)(param_4 != 0) & (uint)&local_30;
  iVar13 = (**(code **)(*(int *)param_1 + 0x18))(param_1,param_2,&DAT_1002f490,0,_param_3,&local_44)
  ;
  if (iVar13 < 0) {
    Ordinal_9(&local_30);
    puVar15 = (uint *)local_1c;
    if (iVar13 == -0x7ffdfff7) {
      _com_handle_excepinfo((tagEXCEPINFO *)&local_78,param_8);
      puVar15 = (uint *)local_1c;
    }
    goto LAB_10028645;
  }
  puVar15 = (uint *)local_1c;
  if ((param_4 == 0) || (param_5 == (void *)0x0)) goto LAB_10028645;
  if ((param_4 != 0xc) &&
     ((param_4 != (ushort)local_30 &&
      (iVar13 = Ordinal_12(&local_30,&local_30,0,_param_4), iVar13 < 0)))) {
    Ordinal_9(&local_30);
    puVar15 = (uint *)local_1c;
    goto LAB_10028645;
  }
  puVar15 = (uint *)local_1c;
  if (param_4 < 0x4003) {
    if (param_4 != 0x4002) {
      switch(param_4) {
      case 2:
      case 0xb:
      case 0x12:
        *(ushort *)param_5 = CONCAT11(uStack_27,local_28);
        break;
      case 3:
      case 8:
      case 9:
      case 10:
      case 0xd:
      case 0x13:
      case 0x16:
      case 0x17:
      case 0x19:
      case 0x24:
        goto switchD_100286ef_caseD_3;
      case 4:
        *(uint *)param_5 = CONCAT22(uStack_26,CONCAT11(uStack_27,local_28));
        break;
      case 5:
      case 7:
        *(ulonglong *)param_5 = CONCAT44(uStack_24,CONCAT22(uStack_26,CONCAT11(uStack_27,local_28)))
        ;
        break;
      case 6:
      case 0x14:
      case 0x15:
        *(uint *)param_5 = CONCAT22(uStack_26,CONCAT11(uStack_27,local_28));
        *(undefined4 *)((int)param_5 + 4) = uStack_24;
        break;
      case 0xc:
      case 0xe:
        *(undefined4 *)param_5 = local_30;
        *(undefined4 *)((int)param_5 + 4) = local_2c;
        *(uint *)((int)param_5 + 8) = CONCAT22(uStack_26,CONCAT11(uStack_27,local_28));
        *(undefined4 *)((int)param_5 + 0xc) = uStack_24;
        break;
      default:
        goto switchD_100286ef_caseD_f;
      case 0x10:
      case 0x11:
        *(undefined1 *)param_5 = local_28;
      }
      goto LAB_10028645;
    }
  }
  else {
    switch(param_4) {
    case 0x4003:
    case 0x4004:
    case 0x4005:
    case 0x4006:
    case 0x4007:
    case 0x4008:
    case 0x4009:
    case 0x400a:
    case 0x400b:
    case 0x400c:
    case 0x400d:
    case 0x400e:
    case 0x4010:
    case 0x4011:
    case 0x4012:
    case 0x4013:
    case 0x4014:
    case 0x4015:
    case 0x4016:
    case 0x4017:
    case 0x4019:
    case 0x4024:
      break;
    default:
switchD_100286ef_caseD_f:
      if ((param_4 & 0x2000) == 0) {
        Ordinal_9(&local_30);
        puVar15 = (uint *)local_1c;
        goto LAB_10028645;
      }
    }
  }
switchD_100286ef_caseD_3:
  *(uint *)param_5 = CONCAT22(uStack_26,CONCAT11(uStack_27,local_28));
LAB_10028645:
  local_1c = (undefined1 *)puVar15;
  ExceptionList = local_14;
  lVar3 = __security_check_cookie(local_20 ^ (uint)&stack0xfffffffc);
  return lVar3;
}



// Function: FUN_10028880 at 10028880

int FUN_10028880(ushort param_1)

{
  if (0xfdff < param_1) {
    return -0x7ffb0001;
  }
  return param_1 + 0x80040200;
}



// Function: _com_handle_excepinfo at 100288b0

/* Library Function - Single Match
    long __stdcall _com_handle_excepinfo(struct tagEXCEPINFO &,struct IErrorInfo * *)
   
   Library: Visual Studio 2012 Release */

long _com_handle_excepinfo(tagEXCEPINFO *param_1,IErrorInfo **param_2)

{
  ushort uVar1;
  tagEXCEPINFO *ptVar2;
  IErrorInfo **ppIVar3;
  int iVar4;
  
  ptVar2 = param_1;
  if (*(code **)(param_1 + 0x18) != (code *)0x0) {
    (**(code **)(param_1 + 0x18))(param_1);
  }
  ppIVar3 = param_2;
  param_1 = (tagEXCEPINFO *)0x0;
  if (param_2 != (IErrorInfo **)0x0) {
    iVar4 = Ordinal_202(&param_1);
    if (-1 < iVar4) {
      (**(code **)(*(int *)param_1 + 0xc))(param_1,&DAT_1002f4f0);
      if (*(int *)(ptVar2 + 4) != 0) {
        (**(code **)(*(int *)param_1 + 0x10))(param_1,*(int *)(ptVar2 + 4));
      }
      if (*(int *)(ptVar2 + 8) != 0) {
        (**(code **)(*(int *)param_1 + 0x14))(param_1,*(int *)(ptVar2 + 8));
      }
      if (*(int *)(ptVar2 + 0xc) != 0) {
        (**(code **)(*(int *)param_1 + 0x18))(param_1,*(int *)(ptVar2 + 0xc));
      }
      (**(code **)(*(int *)param_1 + 0x1c))(param_1,*(undefined4 *)(ptVar2 + 0x10));
      iVar4 = (*(code *)**(undefined4 **)param_1)(param_1,&DAT_1002fab8,ppIVar3);
      if (iVar4 < 0) {
        *ppIVar3 = (IErrorInfo *)0x0;
      }
      (**(code **)(*(int *)param_1 + 8))(param_1);
    }
  }
  if (*(int *)(ptVar2 + 4) != 0) {
    Ordinal_6(*(int *)(ptVar2 + 4));
  }
  if (*(int *)(ptVar2 + 8) != 0) {
    Ordinal_6(*(int *)(ptVar2 + 8));
  }
  if (*(int *)(ptVar2 + 0xc) != 0) {
    Ordinal_6(*(int *)(ptVar2 + 0xc));
  }
  uVar1 = *(ushort *)ptVar2;
  if (uVar1 != 0) {
    if (0xfdff < uVar1) {
      return -0x7ffb0001;
    }
    return uVar1 + 0x80040200;
  }
  return *(long *)(ptVar2 + 0x1c);
}



// Function: `eh_vector_destructor_iterator' at 100289a6

/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */
/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */
/* Library Function - Single Match
    void __stdcall `eh vector destructor iterator'(void *,unsigned int,int,void (__thiscall*)(void
   *))
   
   Library: Visual Studio 2012 Release */

void _eh_vector_destructor_iterator_
               (void *param_1,uint param_2,int param_3,_func_void_void_ptr *param_4)

{
  void *in_stack_ffffffd0;
  
  while( true ) {
    param_3 = param_3 + -1;
    if (param_3 < 0) break;
    (*param_4)(in_stack_ffffffd0);
  }
  FUN_10028a05();
  return;
}



// Function: FUN_10028a05 at 10028a05

void FUN_10028a05(void)

{
  int in_EAX;
  uint unaff_EBX;
  int unaff_EBP;
  void *unaff_ESI;
  int unaff_EDI;
  
  if (in_EAX == 0) {
    __ArrayUnwind(unaff_ESI,unaff_EBX,unaff_EDI,*(_func_void_void_ptr **)(unaff_EBP + 0x14));
  }
  return;
}



// Function: FUN_10028a15 at 10028a15

undefined4 __cdecl FUN_10028a15(undefined4 *param_1)

{
  undefined4 extraout_EAX;
  
  if (*(int *)*param_1 != -0x1f928c9d) {
    return 0;
  }
  terminate();
  return extraout_EAX;
}



// Function: __ArrayUnwind at 10028a2e

/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */
/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */
/* Library Function - Single Match
    void __stdcall __ArrayUnwind(void *,unsigned int,int,void (__thiscall*)(void *))
   
   Library: Visual Studio 2012 Release */

void __ArrayUnwind(void *param_1,uint param_2,int param_3,_func_void_void_ptr *param_4)

{
  void *in_stack_ffffffc8;
  
  while( true ) {
    param_3 = param_3 + -1;
    if (param_3 < 0) break;
    (*param_4)(in_stack_ffffffc8);
  }
  return;
}



// Function: __security_check_cookie at 10028a98

/* Library Function - Single Match
    @__security_check_cookie@4
   
   Library: Visual Studio 2012 Release
   __fastcall __security_check_cookie,4 */

void __fastcall __security_check_cookie(int param_1)

{
  if (param_1 == DAT_10040398) {
    return;
  }
                    /* WARNING: Subroutine does not return */
  ___report_gsfailure();
}



// Function: FID_conflict:`vector_deleting_destructor' at 10028abe

/* Library Function - Multiple Matches With Different Base Names
    public: virtual void * __thiscall CDaoRelationFieldInfo::`vector deleting destructor'(unsigned
   int)
    public: virtual void * __thiscall type_info::`vector deleting destructor'(unsigned int)
   
   Library: Visual Studio 2012 Release */

type_info * __thiscall FID_conflict__vector_deleting_destructor_(void *this,byte param_1)

{
  type_info *ptVar1;
  
  if ((param_1 & 2) == 0) {
    type_info::~type_info((type_info *)this);
    ptVar1 = (type_info *)this;
    if ((param_1 & 1) != 0) {
      operator_delete(this);
    }
  }
  else {
    ptVar1 = (type_info *)((int)this + -4);
    _eh_vector_destructor_iterator_(this,0xc,*(int *)ptVar1,type_info::~type_info);
    if ((param_1 & 1) != 0) {
      operator_delete(ptVar1);
    }
  }
  return ptVar1;
}



// Function: `eh_vector_constructor_iterator' at 10028b08

/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */
/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */
/* Library Function - Single Match
    void __stdcall `eh vector constructor iterator'(void *,unsigned int,int,void (__thiscall*)(void
   *),void (__thiscall*)(void *))
   
   Library: Visual Studio 2012 Release */

void _eh_vector_constructor_iterator_
               (void *param_1,uint param_2,int param_3,_func_void_void_ptr *param_4,
               _func_void_void_ptr *param_5)

{
  int iVar1;
  void *in_stack_ffffffcc;
  
  for (iVar1 = 0; iVar1 < param_3; iVar1 = iVar1 + 1) {
    (*param_4)(in_stack_ffffffcc);
  }
  FUN_10028b60();
  return;
}



// Function: FUN_10028b60 at 10028b60

void FUN_10028b60(void)

{
  int in_EAX;
  uint unaff_EBX;
  int unaff_EBP;
  int unaff_ESI;
  void *unaff_EDI;
  
  if (in_EAX == 0) {
    __ArrayUnwind(unaff_EDI,unaff_EBX,unaff_ESI,*(_func_void_void_ptr **)(unaff_EBP + 0x18));
  }
  return;
}



// Function: __onexit at 10028bb8

/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */
/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */
/* Library Function - Single Match
    __onexit
   
   Library: Visual Studio 2012 Release */

_onexit_t __cdecl __onexit(_onexit_t param_1)

{
  _onexit_t p_Var1;
  PVOID pvVar2;
  PVOID *ppvVar3;
  PVOID *ppvVar4;
  PVOID local_24;
  PVOID local_20 [5];
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_1003c990;
  uStack_c = 0x10028bc4;
  local_20[0] = DecodePointer(DAT_10040908);
  if (local_20[0] == (PVOID)0xffffffff) {
    p_Var1 = _onexit(param_1);
  }
  else {
    _lock(8);
    local_8 = (undefined *)0x0;
    local_20[0] = DecodePointer(DAT_10040908);
    local_24 = DecodePointer(DAT_10040904);
    ppvVar4 = &local_24;
    ppvVar3 = local_20;
    pvVar2 = EncodePointer(param_1);
    p_Var1 = (_onexit_t)__dllonexit(pvVar2,ppvVar3,ppvVar4);
    DAT_10040908 = EncodePointer(local_20[0]);
    DAT_10040904 = EncodePointer(local_24);
    local_8 = (undefined *)0xfffffffe;
    FUN_10028c54();
  }
  return p_Var1;
}



// Function: FUN_10028c54 at 10028c54

void FUN_10028c54(void)

{
  _unlock(8);
  return;
}



// Function: _atexit at 10028c5d

/* Library Function - Single Match
    _atexit
   
   Library: Visual Studio 2012 Release */

int __cdecl _atexit(_func_4879 *param_1)

{
  _onexit_t p_Var1;
  
  p_Var1 = __onexit((_onexit_t)param_1);
  return (p_Var1 != (_onexit_t)0x0) - 1;
}



// Function: ___raise_securityfailure at 10028c72

/* Library Function - Single Match
    ___raise_securityfailure
   
   Library: Visual Studio 2012 Release */

void __cdecl ___raise_securityfailure(EXCEPTION_POINTERS *param_1)

{
  DAT_100408dc = IsDebuggerPresent();
  _crt_debugger_hook(1);
  __crtUnhandledException(param_1);
  if (DAT_100408dc == 0) {
    _crt_debugger_hook(1);
  }
  __crtTerminateProcess(0xc0000409);
  return;
}



// Function: ___report_gsfailure at 10028caf

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
/* Library Function - Single Match
    ___report_gsfailure
   
   Library: Visual Studio 2012 Release */

void __cdecl ___report_gsfailure(void)

{
  code *pcVar1;
  uint uVar2;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar3;
  undefined4 extraout_EDX;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte bVar4;
  byte bVar5;
  byte in_AF;
  byte bVar6;
  byte bVar7;
  byte in_TF;
  byte in_IF;
  byte bVar8;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined8 uVar9;
  undefined4 unaff_retaddr;
  
  uVar2 = IsProcessorFeaturePresent(0x17);
  uVar9 = CONCAT44(extraout_EDX,uVar2);
  bVar4 = 0;
  bVar8 = 0;
  bVar7 = (int)uVar2 < 0;
  bVar6 = uVar2 == 0;
  bVar5 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;
  uVar3 = extraout_ECX;
  if (!(bool)bVar6) {
    pcVar1 = (code *)swi(0x29);
    uVar9 = (*pcVar1)();
    uVar3 = extraout_ECX_00;
  }
  _DAT_100406b8 = (undefined4)((ulonglong)uVar9 >> 0x20);
  _DAT_100406c0 = (undefined4)uVar9;
  _DAT_100406d0 =
       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar8 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |
       (uint)(in_TF & 1) * 0x100 | (uint)(bVar7 & 1) * 0x80 | (uint)(bVar6 & 1) * 0x40 |
       (uint)(in_AF & 1) * 0x10 | (uint)(bVar5 & 1) * 4 | (uint)(bVar4 & 1) |
       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |
       (uint)(in_AC & 1) * 0x40000;
  _DAT_100406d4 = &stack0x00000004;
  _DAT_10040610 = 0x10001;
  _DAT_100405c0 = 0xc0000409;
  _DAT_100405c4 = 1;
  _DAT_100405d0 = 1;
  DAT_100405d4 = 2;
  _DAT_100405cc = unaff_retaddr;
  _DAT_1004069c = in_GS;
  _DAT_100406a0 = in_FS;
  _DAT_100406a4 = in_ES;
  _DAT_100406a8 = in_DS;
  _DAT_100406ac = unaff_EDI;
  _DAT_100406b0 = unaff_ESI;
  _DAT_100406b4 = unaff_EBX;
  _DAT_100406bc = uVar3;
  _DAT_100406c4 = unaff_EBP;
  DAT_100406c8 = unaff_retaddr;
  _DAT_100406cc = in_CS;
  _DAT_100406d8 = in_SS;
  ___raise_securityfailure((EXCEPTION_POINTERS *)&PTR_DAT_10035ffc);
  return;
}



// Function: ___report_rangecheckfailure at 10028da8

/* Library Function - Single Match
    ___report_rangecheckfailure
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */

void ___report_rangecheckfailure(void)

{
  ___report_securityfailure(8);
  return;
}



// Function: ___report_securityfailure at 10028db4

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
/* Library Function - Single Match
    ___report_securityfailure
   
   Library: Visual Studio 2012 Release */

void __cdecl ___report_securityfailure(undefined4 param_1)

{
  code *pcVar1;
  uint uVar2;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar3;
  undefined4 extraout_EDX;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte bVar4;
  byte bVar5;
  byte in_AF;
  byte bVar6;
  byte bVar7;
  byte in_TF;
  byte in_IF;
  byte bVar8;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined8 uVar9;
  undefined4 unaff_retaddr;
  
  uVar2 = IsProcessorFeaturePresent(0x17);
  uVar9 = CONCAT44(extraout_EDX,uVar2);
  bVar4 = 0;
  bVar8 = 0;
  bVar7 = (int)uVar2 < 0;
  bVar6 = uVar2 == 0;
  bVar5 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;
  uVar3 = extraout_ECX;
  if (!(bool)bVar6) {
    pcVar1 = (code *)swi(0x29);
    uVar9 = (*pcVar1)();
    uVar3 = extraout_ECX_00;
  }
  _DAT_100406b8 = (undefined4)((ulonglong)uVar9 >> 0x20);
  _DAT_100406c0 = (undefined4)uVar9;
  _DAT_100406d0 =
       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar8 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |
       (uint)(in_TF & 1) * 0x100 | (uint)(bVar7 & 1) * 0x80 | (uint)(bVar6 & 1) * 0x40 |
       (uint)(in_AF & 1) * 0x10 | (uint)(bVar5 & 1) * 4 | (uint)(bVar4 & 1) |
       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |
       (uint)(in_AC & 1) * 0x40000;
  _DAT_100406d4 = &param_1;
  _DAT_100405c0 = 0xc0000409;
  _DAT_100405c4 = 1;
  _DAT_100405d0 = 1;
  DAT_100405d4 = param_1;
  _DAT_100405cc = unaff_retaddr;
  _DAT_1004069c = in_GS;
  _DAT_100406a0 = in_FS;
  _DAT_100406a4 = in_ES;
  _DAT_100406a8 = in_DS;
  _DAT_100406ac = unaff_EDI;
  _DAT_100406b0 = unaff_ESI;
  _DAT_100406b4 = unaff_EBX;
  _DAT_100406bc = uVar3;
  _DAT_100406c4 = unaff_EBP;
  DAT_100406c8 = unaff_retaddr;
  _DAT_100406cc = in_CS;
  _DAT_100406d8 = in_SS;
  ___raise_securityfailure((EXCEPTION_POINTERS *)&PTR_DAT_10035ffc);
  return;
}



// Function: ___report_securityfailureEx at 10028e82

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
/* Library Function - Single Match
    ___report_securityfailureEx
   
   Library: Visual Studio 2012 Release */

void __cdecl ___report_securityfailureEx(undefined4 param_1,uint param_2,int param_3)

{
  code *pcVar1;
  uint uVar2;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar3;
  undefined4 extraout_EDX;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte bVar4;
  byte bVar5;
  byte in_AF;
  byte bVar6;
  byte bVar7;
  byte in_TF;
  byte in_IF;
  byte bVar8;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined8 uVar9;
  undefined4 unaff_retaddr;
  uint local_8;
  
  uVar2 = IsProcessorFeaturePresent(0x17);
  uVar9 = CONCAT44(extraout_EDX,uVar2);
  bVar4 = 0;
  bVar8 = 0;
  bVar7 = (int)uVar2 < 0;
  bVar6 = uVar2 == 0;
  bVar5 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;
  uVar3 = extraout_ECX;
  if (!(bool)bVar6) {
    pcVar1 = (code *)swi(0x29);
    uVar9 = (*pcVar1)();
    uVar3 = extraout_ECX_00;
  }
  _DAT_100406d0 =
       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar8 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |
       (uint)(in_TF & 1) * 0x100 | (uint)(bVar7 & 1) * 0x80 | (uint)(bVar6 & 1) * 0x40 |
       (uint)(in_AF & 1) * 0x10 | (uint)(bVar5 & 1) * 4 | (uint)(bVar4 & 1) |
       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |
       (uint)(in_AC & 1) * 0x40000;
  _DAT_100406d4 = &param_1;
  _DAT_100405c0 = 0xc0000409;
  _DAT_100405c4 = 1;
  if ((param_2 != 0) && (param_3 == 0)) {
    param_2 = 0;
  }
  if (0xe < param_2) {
    param_2 = param_2 - 1;
  }
  _DAT_100405d0 = param_2 + 1;
  DAT_100405d4 = param_1;
  _DAT_100405cc = unaff_retaddr;
  _DAT_1004069c = in_GS;
  _DAT_100406a0 = in_FS;
  _DAT_100406a4 = in_ES;
  _DAT_100406a8 = in_DS;
  _DAT_100406ac = unaff_EDI;
  _DAT_100406b0 = unaff_ESI;
  _DAT_100406b4 = unaff_EBX;
  _DAT_100406bc = uVar3;
  _DAT_100406c4 = unaff_EBP;
  DAT_100406c8 = unaff_retaddr;
  _DAT_100406cc = in_CS;
  _DAT_100406d8 = in_SS;
  for (local_8 = 0; _DAT_100406b8 = (undefined4)((ulonglong)uVar9 >> 0x20),
      _DAT_100406c0 = (undefined4)uVar9, local_8 < param_2; local_8 = local_8 + 1) {
    *(undefined4 *)(&DAT_100405d8 + local_8 * 4) = *(undefined4 *)(param_3 + local_8 * 4);
    uVar9 = CONCAT44(_DAT_100406b8,_DAT_100406c0);
  }
  ___raise_securityfailure((EXCEPTION_POINTERS *)&PTR_DAT_10035ffc);
  return;
}



// Function: FUN_10028fa8 at 10028fa8

/* WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3 */

void FUN_10028fa8(uint param_1)

{
  operator_new(param_1);
  FUN_10028fd0();
  return;
}



// Function: Catch_All@10028fc3 at 10028fc3

undefined * Catch_All_10028fc3(void)

{
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -0x14) = 0;
  return &DAT_10028fcd;
}



// Function: FUN_10028fd0 at 10028fd0

/* WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3 */

void FUN_10028fd0(void)

{
  return;
}



// Function: FUN_10028fd6 at 10028fd6

void FUN_10028fd6(uint param_1)

{
  FUN_10028fa8(param_1);
  return;
}



// Function: FUN_10028fdf at 10028fdf

void __cdecl FUN_10028fdf(void *param_1)

{
  operator_delete(param_1);
  return;
}



// Function: FUN_10028fed at 10028fed

void __cdecl FUN_10028fed(void *param_1)

{
  operator_delete__(param_1);
  return;
}



// Function: __allmul at 10029070

/* Library Function - Single Match
    __allmul
   
   Library: Visual Studio 2010 Debug */

longlong __allmul(uint param_1,int param_2,uint param_3,int param_4)

{
  if (param_4 == 0 && param_2 == 0) {
    return (ulonglong)param_1 * (ulonglong)param_3;
  }
  return CONCAT44((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +
                  param_2 * param_3 + param_1 * param_4,
                  (int)((ulonglong)param_1 * (ulonglong)param_3));
}



// Function: __alloca_probe_16 at 100290b0

/* WARNING: This is an inlined function */
/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */
/* Library Function - Single Match
    __alloca_probe_16
   
   Library: Visual Studio 2012 Release */

uint __alloca_probe_16(void)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 0xf;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// Function: __alloca_probe_8 at 100290c6

/* WARNING: This is an inlined function */
/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */
/* Library Function - Single Match
    __alloca_probe_8
   
   Library: Visual Studio */

uint __alloca_probe_8(void)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 7;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// Function: __alloca_probe at 100290e0

/* WARNING: This is an inlined function */
/* Library Function - Single Match
    __chkstk
   
   Library: Visual Studio */

void __alloca_probe(void)

{
  undefined1 *in_EAX;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 unaff_retaddr;
  undefined1 auStack_4 [4];
  
  puVar2 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX))
  ;
  for (puVar1 = (undefined4 *)((uint)auStack_4 & 0xfffff000); puVar2 < puVar1;
      puVar1 = puVar1 + -0x400) {
  }
  *puVar2 = unaff_retaddr;
  return;
}



// Function: FUN_1002910b at 1002910b

void __cdecl
FUN_1002910b(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  except_handler4_common(&DAT_10040398,__security_check_cookie,param_1,param_2,param_3,param_4);
  return;
}



// Function: __CRT_INIT@12 at 100291a5

/* Library Function - Single Match
    __CRT_INIT@12
   
   Library: Visual Studio 2012 Release */

undefined4 __CRT_INIT_12(int *param_1,int *param_2,int *param_3)

{
  bool bVar1;
  void *pvVar2;
  void *pvVar3;
  int *_Memory;
  int *piVar4;
  PVOID pvVar5;
  code *pcVar6;
  int *piVar7;
  int *piVar8;
  int iVar9;
  BOOL BVar10;
  
  if (param_2 == (int *)0x0) {
    if (DAT_100408e4 < 1) {
      return 0;
    }
    DAT_100408e4 = DAT_100408e4 + -1;
    bVar1 = false;
    do {
      pvVar3 = (void *)0x0;
      LOCK();
      pvVar2 = StackBase;
      if (DAT_100408f8 != (void *)0x0) {
        pvVar3 = DAT_100408f8;
        pvVar2 = DAT_100408f8;
      }
      DAT_100408f8 = pvVar2;
      UNLOCK();
      if (pvVar3 == (void *)0x0) goto LAB_100291f8;
    } while (pvVar3 != StackBase);
    bVar1 = true;
LAB_100291f8:
    if (DAT_100408fc == 2) {
      _Memory = (int *)DecodePointer(DAT_10040908);
      if (_Memory != (int *)0x0) {
        piVar4 = (int *)DecodePointer(DAT_10040904);
        param_1 = piVar4;
        param_2 = _Memory;
        param_3 = _Memory;
        while (piVar4 = piVar4 + -1, _Memory <= piVar4) {
          if ((*piVar4 != 0) && (pvVar5 = EncodePointer((PVOID)0x0), (PVOID)*piVar4 != pvVar5)) {
            pcVar6 = (code *)DecodePointer((PVOID)*piVar4);
            pvVar5 = EncodePointer((PVOID)0x0);
            *piVar4 = (int)pvVar5;
            (*pcVar6)();
            piVar7 = (int *)DecodePointer(DAT_10040908);
            piVar8 = (int *)DecodePointer(DAT_10040904);
            if ((param_2 != piVar7) || (_Memory = param_3, param_1 != piVar8)) {
              piVar4 = piVar8;
              _Memory = piVar7;
              param_1 = piVar8;
              param_2 = piVar7;
              param_3 = piVar7;
            }
          }
        }
        if (_Memory != (int *)0xffffffff) {
          free(_Memory);
        }
        DAT_10040904 = EncodePointer((PVOID)0x0);
        DAT_10040908 = DAT_10040904;
      }
      DAT_100408fc = 0;
      if (!bVar1) {
        LOCK();
        DAT_100408f8 = (void *)0x0;
        UNLOCK();
      }
    }
    else {
      _amsg_exit(0x1f);
    }
  }
  else if (param_2 == (int *)0x1) {
    bVar1 = false;
    do {
      pvVar3 = (void *)0x0;
      LOCK();
      pvVar2 = StackBase;
      if (DAT_100408f8 != (void *)0x0) {
        pvVar3 = DAT_100408f8;
        pvVar2 = DAT_100408f8;
      }
      DAT_100408f8 = pvVar2;
      UNLOCK();
      if (pvVar3 == (void *)0x0) goto LAB_10029313;
    } while (pvVar3 != StackBase);
    bVar1 = true;
LAB_10029313:
    if (DAT_100408fc == 0) {
      DAT_100408fc = 1;
      iVar9 = initterm_e(&DAT_1002f3bc,&DAT_1002f3c8);
      if (iVar9 != 0) {
        return 0;
      }
      initterm(&DAT_1002f368,&DAT_1002f3b8);
      DAT_100408fc = 2;
    }
    else {
      _amsg_exit(0x1f);
    }
    if (!bVar1) {
      LOCK();
      DAT_100408f8 = (void *)0x0;
      UNLOCK();
    }
    if ((DAT_10040900 != (code *)0x0) &&
       (BVar10 = __IsNonwritableInCurrentImage((PBYTE)&DAT_10040900), BVar10 != 0)) {
      (*DAT_10040900)(param_1,2,param_3);
    }
    DAT_100408e4 = DAT_100408e4 + 1;
  }
  return 1;
}



// Function: entry at 1002939a

void entry(HMODULE param_1,int *param_2,int *param_3)

{
  if (param_2 == (int *)0x1) {
    ___security_init_cookie();
  }
  ___DllMainCRTStartup(param_1,param_2,param_3);
  return;
}



// Function: ___DllMainCRTStartup at 100293bd

/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */
/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */
/* WARNING: Removing unreachable block (ram,0x1002946e) */
/* WARNING: Removing unreachable block (ram,0x10029404) */
/* WARNING: Removing unreachable block (ram,0x100294a0) */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
/* Library Function - Single Match
    ___DllMainCRTStartup
   
   Library: Visual Studio 2012 Release */

uint __cdecl ___DllMainCRTStartup(HMODULE param_1,int *param_2,int *param_3)

{
  uint uVar1;
  int iVar2;
  
  _DAT_100403a0 = param_2;
  if ((param_2 == (int *)0x0) && (DAT_100408e4 == 0)) {
    uVar1 = 0;
  }
  else if (((param_2 != (int *)0x1) && (param_2 != (int *)0x2)) ||
          (uVar1 = __CRT_INIT_12(&param_1->unused,param_2,param_3), uVar1 != 0)) {
    uVar1 = FUN_10015b40(param_1,(int)param_2);
    if ((param_2 == (int *)0x1) && (uVar1 == 0)) {
      FUN_10015b40(param_1,0);
      __CRT_INIT_12(&param_1->unused,(int *)0x0,param_3);
    }
    if ((param_2 == (int *)0x0) || (param_2 == (int *)0x3)) {
      iVar2 = __CRT_INIT_12(&param_1->unused,param_2,param_3);
      uVar1 = uVar1 & -(uint)(iVar2 != 0);
    }
  }
  FUN_100294e5();
  return uVar1;
}



// Function: FUN_100294e5 at 100294e5

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_100294e5(void)

{
  _DAT_100403a0 = 0xffffffff;
  return;
}



// Function: __SEH_prolog4 at 100295a0

/* WARNING: This is an inlined function */
/* WARNING: Unable to track spacebase fully for stack */
/* WARNING: Variable defined which should be unmapped: param_2 */
/* Library Function - Single Match
    __SEH_prolog4
   
   Library: Visual Studio */

void __cdecl __SEH_prolog4(undefined4 param_1,int param_2)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined4 unaff_retaddr;
  uint auStack_1c [5];
  undefined1 local_8 [8];
  
  iVar1 = -param_2;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_10040398 ^ (uint)&param_2;
  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;
  ExceptionList = local_8;
  return;
}



// Function: __SEH_epilog4 at 100295e5

/* WARNING: This is an inlined function */
/* Library Function - Single Match
    __SEH_epilog4
   
   Library: Visual Studio */

void __SEH_epilog4(void)

{
  undefined4 *unaff_EBP;
  undefined4 unaff_retaddr;
  
  ExceptionList = (void *)unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}



// Function: __EH_epilog3 at 1002962a

/* WARNING: This is an inlined function */
/* Library Function - Single Match
    __EH_epilog3
   
   Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012 */

void __EH_epilog3(void)

{
  undefined4 *unaff_EBP;
  undefined4 unaff_retaddr;
  
  ExceptionList = (void *)unaff_EBP[-3];
  *unaff_EBP = unaff_retaddr;
  return;
}



// Function: __EH_prolog3_catch at 100296c5

/* WARNING: This is an inlined function */
/* WARNING: Unable to track spacebase fully for stack */
/* WARNING: Variable defined which should be unmapped: param_1 */
/* Library Function - Single Match
    __EH_prolog3_catch
   
   Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012 */

void __cdecl __EH_prolog3_catch(int param_1)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined4 unaff_retaddr;
  uint auStack_1c [5];
  undefined1 local_8 [8];
  
  iVar1 = -param_1;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_10040398 ^ (uint)&param_1;
  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;
  ExceptionList = local_8;
  return;
}



// Function: __FindPESection at 10029750

/* Library Function - Single Match
    __FindPESection
   
   Library: Visual Studio 2012 Release */

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)

{
  int iVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  uint uVar3;
  
  iVar1 = *(int *)(pImageBase + 0x3c);
  uVar3 = 0;
  p_Var2 = (PIMAGE_SECTION_HEADER)
           (pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);
  if (*(ushort *)(pImageBase + iVar1 + 6) != 0) {
    do {
      if ((p_Var2->VirtualAddress <= rva) &&
         (rva < (p_Var2->Misc).PhysicalAddress + p_Var2->VirtualAddress)) {
        return p_Var2;
      }
      uVar3 = uVar3 + 1;
      p_Var2 = p_Var2 + 1;
    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}



// Function: __IsNonwritableInCurrentImage at 100297a0

/* Library Function - Single Match
    __IsNonwritableInCurrentImage
   
   Library: Visual Studio 2012 Release */

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  BOOL BVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  void *local_14;
  code *pcStack_10;
  uint local_c;
  undefined4 local_8;
  
  pcStack_10 = FUN_1002910b;
  local_14 = ExceptionList;
  local_c = DAT_10040398 ^ 0x1003ca30;
  ExceptionList = &local_14;
  local_8 = 0;
  BVar1 = __ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_10000000);
  if (BVar1 != 0) {
    p_Var2 = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_10000000,(DWORD_PTR)(pTarget + -0x10000000));
    if (p_Var2 != (PIMAGE_SECTION_HEADER)0x0) {
      ExceptionList = local_14;
      return ~(p_Var2->Characteristics >> 0x1f) & 1;
    }
  }
  ExceptionList = local_14;
  return 0;
}



// Function: __ValidateImageBase at 10029860

/* Library Function - Single Match
    __ValidateImageBase
   
   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release */

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  uint uVar1;
  
  if (*(short *)pImageBase != 0x5a4d) {
    return 0;
  }
  uVar1 = 0;
  if (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550) {
    uVar1 = (uint)((short)*(int *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b)
    ;
  }
  return uVar1;
}



// Function: ___security_init_cookie at 10029891

/* Library Function - Single Match
    ___security_init_cookie
   
   Library: Visual Studio 2012 Release */

void __cdecl ___security_init_cookie(void)

{
  DWORD DVar1;
  LARGE_INTEGER local_18;
  _FILETIME local_10;
  uint local_8;
  
  local_10.dwLowDateTime = 0;
  local_10.dwHighDateTime = 0;
  if ((DAT_10040398 == 0xbb40e64e) || ((DAT_10040398 & 0xffff0000) == 0)) {
    GetSystemTimeAsFileTime(&local_10);
    local_8 = local_10.dwHighDateTime ^ local_10.dwLowDateTime;
    DVar1 = GetCurrentThreadId();
    local_8 = local_8 ^ DVar1;
    DVar1 = GetCurrentProcessId();
    local_8 = local_8 ^ DVar1;
    QueryPerformanceCounter(&local_18);
    DAT_10040398 = local_18.s.HighPart ^ local_18.s.LowPart ^ local_8 ^ (uint)&local_8;
    if (DAT_10040398 == 0xbb40e64e) {
      DAT_10040398 = 0xbb40e64f;
    }
    else if ((DAT_10040398 & 0xffff0000) == 0) {
      DAT_10040398 = DAT_10040398 | (DAT_10040398 | 0x4711) << 0x10;
    }
    DAT_1004039c = ~DAT_10040398;
  }
  else {
    DAT_1004039c = ~DAT_10040398;
  }
  return;
}



// Function: ~_Fac_node at 100299e0

/* Library Function - Single Match
    public: __thiscall std::_Fac_node::~_Fac_node(void)
   
   Library: Visual Studio 2012 Release */

void __thiscall std::_Fac_node::~_Fac_node(_Fac_node *this)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)(**(code **)(**(int **)(this + 4) + 8))();
  if (puVar1 != (undefined4 *)0x0) {
    (**(code **)*puVar1)(1);
  }
  return;
}



// Function: FUN_100299f5 at 100299f5

void FUN_100299f5(void)

{
  _Fac_node *this;
  
  while (this = DAT_100408f0, DAT_100408f0 != (_Fac_node *)0x0) {
    DAT_100408f0 = *(_Fac_node **)DAT_100408f0;
    std::_Fac_node::~_Fac_node(this);
    operator_delete(this);
  }
  return;
}



// Function: `scalar_deleting_destructor' at 10029a19

/* Library Function - Single Match
    public: void * __thiscall std::_Fac_node::`scalar deleting destructor'(unsigned int)
   
   Library: Visual Studio 2012 Release */

void * __thiscall std::_Fac_node::_scalar_deleting_destructor_(_Fac_node *this,uint param_1)

{
  ~_Fac_node(this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return this;
}



// Function: Facet_Register at 10029a38

/* Library Function - Multiple Matches With Same Base Name
    private: static void __cdecl std::locale::facet::_Facet_Register(class std::locale::facet *)
    void __cdecl std::_Facet_Register(class std::_Facet_base *)
   
   Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release */

void __cdecl Facet_Register(undefined4 param_1)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)operator_new(8);
  if (puVar1 == (undefined4 *)0x0) {
    puVar1 = (undefined4 *)0x0;
  }
  else {
    *puVar1 = DAT_100408f0;
    puVar1[1] = param_1;
  }
  DAT_100408f0 = puVar1;
  return;
}



// Function: Unwind@10029b90 at 10029b90

void Unwind_10029b90(void)

{
  int unaff_EBP;
  
  ~_ExceptionPtr_static<>(*(int *)(unaff_EBP + -0x10) + 8);
  return;
}



// Function: Unwind@10029b9b at 10029b9b

void Unwind_10029b9b(void)

{
  int unaff_EBP;
  
  FUN_100020f0(*(int *)(unaff_EBP + -0x10) + 0x38);
  return;
}



// Function: Unwind@10029bc1 at 10029bc1

void Unwind_10029bc1(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x30));
  return;
}



// Function: Unwind@10029be4 at 10029be4

void Unwind_10029be4(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@10029c07 at 10029c07

void Unwind_10029c07(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@10029c2a at 10029c2a

void Unwind_10029c2a(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@10029c4d at 10029c4d

void Unwind_10029c4d(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@10029c70 at 10029c70

void Unwind_10029c70(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@10029c93 at 10029c93

void Unwind_10029c93(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@10029cb6 at 10029cb6

void Unwind_10029cb6(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@10029cd9 at 10029cd9

void Unwind_10029cd9(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@10029d00 at 10029d00

void Unwind_10029d00(void)

{
  FUN_10002070();
  return;
}



// Function: Unwind@10029d08 at 10029d08

void Unwind_10029d08(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((LPCRITICAL_SECTION)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@10029d30 at 10029d30

void Unwind_10029d30(void)

{
  int unaff_EBP;
  
  FUN_10002080(*(LPCRITICAL_SECTION *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@10029d60 at 10029d60

void Unwind_10029d60(void)

{
  FUN_10002060();
  return;
}



// Function: Unwind@10029d90 at 10029d90

void Unwind_10029d90(void)

{
  FUN_10002070();
  return;
}



// Function: Unwind@10029d98 at 10029d98

void Unwind_10029d98(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((LPCRITICAL_SECTION)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@10029dc0 at 10029dc0

void Unwind_10029dc0(void)

{
  int unaff_EBP;
  
  FUN_10002080(*(LPCRITICAL_SECTION *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@10029df0 at 10029df0

void Unwind_10029df0(void)

{
  FUN_10002060();
  return;
}



// Function: Unwind@10029e20 at 10029e20

void Unwind_10029e20(void)

{
  int unaff_EBP;
  
  FUN_10002040(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@10029e50 at 10029e50

void Unwind_10029e50(void)

{
  int unaff_EBP;
  
  ~_ExceptionPtr_static<>(*(int *)(unaff_EBP + -0x10) + 0x14);
  return;
}



// Function: Unwind@10029e5b at 10029e5b

void Unwind_10029e5b(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 0x34));
  return;
}



// Function: Unwind@10029e66 at 10029e66

void Unwind_10029e66(void)

{
  int unaff_EBP;
  
  FUN_1000efa0((_Container_base0 *)(*(int *)(unaff_EBP + -0x10) + 0x4c));
  return;
}



// Function: Unwind@10029e71 at 10029e71

void Unwind_10029e71(void)

{
  int unaff_EBP;
  
  FUN_1000efc0((_Container_base0 *)(*(int *)(unaff_EBP + -0x10) + 0x58));
  return;
}



// Function: Unwind@10029e7c at 10029e7c

void Unwind_10029e7c(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 100));
  return;
}



// Function: Unwind@10029e87 at 10029e87

void Unwind_10029e87(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 0x68));
  return;
}



// Function: Unwind@10029e92 at 10029e92

void Unwind_10029e92(void)

{
  int unaff_EBP;
  
  FUN_1000ee60((int *)(*(int *)(unaff_EBP + -0x10) + 0x6c));
  return;
}



// Function: Unwind@10029e9d at 10029e9d

void Unwind_10029e9d(void)

{
  int unaff_EBP;
  
  FUN_1000eea0((int *)(*(int *)(unaff_EBP + -0x10) + 0x70));
  return;
}



// Function: Unwind@10029ea8 at 10029ea8

void Unwind_10029ea8(void)

{
  int unaff_EBP;
  
  FID_conflict__CAtlWinModule((LPCRITICAL_SECTION)(*(int *)(unaff_EBP + -0x10) + 0x74));
  return;
}



// Function: Unwind@10029eb3 at 10029eb3

void Unwind_10029eb3(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 0xa4));
  return;
}



// Function: Unwind@10029ec1 at 10029ec1

void Unwind_10029ec1(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 0xb4));
  return;
}



// Function: Unwind@10029eea at 10029eea

void Unwind_10029eea(void)

{
  int unaff_EBP;
  
  FUN_1000ef40((int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@10029ef2 at 10029ef2

void Unwind_10029ef2(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x24) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x24) = *(uint *)(unaff_EBP + -0x24) & 0xfffffffe;
    FUN_1000ef60(*(int **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@10029f26 at 10029f26

void Unwind_10029f26(void)

{
  int unaff_EBP;
  
  FUN_1000eee0((int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@10029f2e at 10029f2e

void Unwind_10029f2e(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x30));
  return;
}



// Function: Unwind@10029f36 at 10029f36

void Unwind_10029f36(void)

{
  int unaff_EBP;
  
  FUN_1000f240(unaff_EBP + -0x58);
  return;
}



// Function: Unwind@10029f3e at 10029f3e

void Unwind_10029f3e(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@10029f46 at 10029f46

void Unwind_10029f46(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@10029f69 at 10029f69

void Unwind_10029f69(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + 0xc));
  return;
}



// Function: Unwind@10029f71 at 10029f71

void Unwind_10029f71(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@10029f79 at 10029f79

void Unwind_10029f79(void)

{
  int unaff_EBP;
  
  FUN_100020f0(unaff_EBP + -0x8c);
  return;
}



// Function: Unwind@10029f84 at 10029f84

void Unwind_10029f84(void)

{
  int unaff_EBP;
  
  FUN_100020f0(unaff_EBP + -0x7c);
  return;
}



// Function: Unwind@10029f8c at 10029f8c

void Unwind_10029f8c(void)

{
  int unaff_EBP;
  
  FUN_100020f0(unaff_EBP + -0x6c);
  return;
}



// Function: Unwind@10029fb2 at 10029fb2

void Unwind_10029fb2(void)

{
  int unaff_EBP;
  
  FUN_100020f0(unaff_EBP + -0x3c);
  return;
}



// Function: Unwind@10029fd5 at 10029fd5

void Unwind_10029fd5(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x34));
  return;
}



// Function: Unwind@1002a002 at 1002a002

void Unwind_1002a002(void)

{
  int unaff_EBP;
  
  FUN_1000eee0((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002a00a at 1002a00a

void Unwind_1002a00a(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a012 at 1002a012

void Unwind_1002a012(void)

{
  int unaff_EBP;
  
  FUN_1000f240(unaff_EBP + -0x60);
  return;
}



// Function: Unwind@1002a01a at 1002a01a

void Unwind_1002a01a(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002a022 at 1002a022

void Unwind_1002a022(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x4c));
  return;
}



// Function: Unwind@1002a045 at 1002a045

void Unwind_1002a045(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x78));
  return;
}



// Function: Unwind@1002a04d at 1002a04d

void Unwind_1002a04d(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002a055 at 1002a055

void Unwind_1002a055(void)

{
  int unaff_EBP;
  
  FUN_1000eee0((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002a05d at 1002a05d

void Unwind_1002a05d(void)

{
  int unaff_EBP;
  
  FUN_1000f240(unaff_EBP + -0xb4);
  return;
}



// Function: Unwind@1002a068 at 1002a068

void Unwind_1002a068(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x84));
  return;
}



// Function: Unwind@1002a073 at 1002a073

void Unwind_1002a073(void)

{
  int unaff_EBP;
  
  FUN_1000f240(unaff_EBP + -0xc4);
  return;
}



// Function: Unwind@1002a07e at 1002a07e

void Unwind_1002a07e(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x8c));
  return;
}



// Function: Unwind@1002a089 at 1002a089

void Unwind_1002a089(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x94));
  return;
}



// Function: Unwind@1002a094 at 1002a094

void Unwind_1002a094(void)

{
  int unaff_EBP;
  
  FUN_1000eee0((int *)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002a09c at 1002a09c

void Unwind_1002a09c(void)

{
  int unaff_EBP;
  
  FUN_1000f240(unaff_EBP + -0xd4);
  return;
}



// Function: Unwind@1002a0a7 at 1002a0a7

void Unwind_1002a0a7(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x80));
  return;
}



// Function: Unwind@1002a0af at 1002a0af

void Unwind_1002a0af(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x90));
  return;
}



// Function: Unwind@1002a0d8 at 1002a0d8

void Unwind_1002a0d8(void)

{
  int unaff_EBP;
  
  FUN_100020f0(unaff_EBP + -0xc0);
  return;
}



// Function: Unwind@1002a0e3 at 1002a0e3

void Unwind_1002a0e3(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -200));
  return;
}



// Function: Unwind@1002a0ee at 1002a0ee

void Unwind_1002a0ee(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x7c));
  return;
}



// Function: Unwind@1002a11e at 1002a11e

void Unwind_1002a11e(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002a126 at 1002a126

void Unwind_1002a126(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a149 at 1002a149

void Unwind_1002a149(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002a16c at 1002a16c

void Unwind_1002a16c(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002a174 at 1002a174

void Unwind_1002a174(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002a17c at 1002a17c

void Unwind_1002a17c(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x5c));
  return;
}



// Function: Unwind@1002a19f at 1002a19f

void Unwind_1002a19f(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x24));
  return;
}



// Function: Unwind@1002a1a7 at 1002a1a7

void Unwind_1002a1a7(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002a1ca at 1002a1ca

void Unwind_1002a1ca(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x1054));
  return;
}



// Function: Unwind@1002a1d5 at 1002a1d5

void Unwind_1002a1d5(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x1028));
  return;
}



// Function: Unwind@1002a1e0 at 1002a1e0

void Unwind_1002a1e0(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x1040));
  return;
}



// Function: Unwind@1002a213 at 1002a213

void Unwind_1002a213(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x34));
  return;
}



// Function: Unwind@1002a236 at 1002a236

void Unwind_1002a236(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002a23e at 1002a23e

void Unwind_1002a23e(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a246 at 1002a246

void Unwind_1002a246(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002a24e at 1002a24e

void Unwind_1002a24e(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x4c));
  return;
}



// Function: Unwind@1002a256 at 1002a256

void Unwind_1002a256(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x54));
  return;
}



// Function: Unwind@1002a279 at 1002a279

void Unwind_1002a279(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002a281 at 1002a281

void Unwind_1002a281(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x98));
  return;
}



// Function: Unwind@1002a28c at 1002a28c

void Unwind_1002a28c(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x70));
  return;
}



// Function: Unwind@1002a294 at 1002a294

void Unwind_1002a294(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x78));
  return;
}



// Function: Unwind@1002a29c at 1002a29c

void Unwind_1002a29c(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x80));
  return;
}



// Function: Unwind@1002a2a4 at 1002a2a4

void Unwind_1002a2a4(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x8c));
  return;
}



// Function: Unwind@1002a2af at 1002a2af

void Unwind_1002a2af(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x9c));
  return;
}



// Function: Unwind@1002a2d8 at 1002a2d8

void Unwind_1002a2d8(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + 0xc));
  return;
}



// Function: Unwind@1002a2e0 at 1002a2e0

void Unwind_1002a2e0(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002a2e8 at 1002a2e8

void Unwind_1002a2e8(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x50));
  return;
}



// Function: Unwind@1002a30b at 1002a30b

void Unwind_1002a30b(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 0x1c));
  return;
}



// Function: Unwind@1002a313 at 1002a313

void Unwind_1002a313(void)

{
  int unaff_EBP;
  
  FUN_1000ee80((int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002a31b at 1002a31b

void Unwind_1002a31b(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002a323 at 1002a323

void Unwind_1002a323(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x4c));
  return;
}



// Function: Unwind@1002a32b at 1002a32b

void Unwind_1002a32b(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x54));
  return;
}



// Function: Unwind@1002a333 at 1002a333

void Unwind_1002a333(void)

{
  int unaff_EBP;
  
  FUN_1000ee40((int *)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a33b at 1002a33b

void Unwind_1002a33b(void)

{
  int unaff_EBP;
  
  FUN_1000eec0((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002a35e at 1002a35e

void Unwind_1002a35e(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 0x18));
  return;
}



// Function: Unwind@1002a366 at 1002a366

void Unwind_1002a366(void)

{
  int unaff_EBP;
  
  FUN_1000ef20((int *)(unaff_EBP + -0x30));
  return;
}



// Function: Unwind@1002a36e at 1002a36e

void Unwind_1002a36e(void)

{
  int unaff_EBP;
  
  FUN_1000ee80((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002a376 at 1002a376

void Unwind_1002a376(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a37e at 1002a37e

void Unwind_1002a37e(void)

{
  int unaff_EBP;
  
  FUN_1000eec0((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002a3a1 at 1002a3a1

void Unwind_1002a3a1(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002a3c4 at 1002a3c4

void Unwind_1002a3c4(void)

{
  int unaff_EBP;
  
  FUN_1000ef60((int *)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a3cc at 1002a3cc

void Unwind_1002a3cc(void)

{
  int unaff_EBP;
  
  FUN_1000f0a0((undefined4 *)(unaff_EBP + -0x8c));
  return;
}



// Function: Unwind@1002a3d7 at 1002a3d7

void Unwind_1002a3d7(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a3df at 1002a3df

void Unwind_1002a3df(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x4c));
  return;
}



// Function: Unwind@1002a3e7 at 1002a3e7

void Unwind_1002a3e7(void)

{
  int unaff_EBP;
  
  FUN_1000eee0((int *)(unaff_EBP + -0x34));
  return;
}



// Function: Unwind@1002a3ef at 1002a3ef

void Unwind_1002a3ef(void)

{
  int unaff_EBP;
  
  FUN_1000f240(unaff_EBP + -0x70);
  return;
}



// Function: Unwind@1002a3f7 at 1002a3f7

void Unwind_1002a3f7(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x54));
  return;
}



// Function: Unwind@1002a3ff at 1002a3ff

void Unwind_1002a3ff(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x60));
  return;
}



// Function: Unwind@1002a42f at 1002a42f

void Unwind_1002a42f(void)

{
  int unaff_EBP;
  
  FUN_1000ef60((int *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a437 at 1002a437

void Unwind_1002a437(void)

{
  int unaff_EBP;
  
  FUN_1000f0a0((undefined4 *)(unaff_EBP + -0x68));
  return;
}



// Function: Unwind@1002a43f at 1002a43f

void Unwind_1002a43f(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a447 at 1002a447

void Unwind_1002a447(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x4c));
  return;
}



// Function: Unwind@1002a474 at 1002a474

void Unwind_1002a474(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x138));
  return;
}



// Function: Unwind@1002a47f at 1002a47f

void Unwind_1002a47f(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x15c));
  return;
}



// Function: Unwind@1002a48a at 1002a48a

void Unwind_1002a48a(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x154));
  return;
}



// Function: Unwind@1002a495 at 1002a495

void Unwind_1002a495(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x158));
  return;
}



// Function: Unwind@1002a4a0 at 1002a4a0

void Unwind_1002a4a0(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x140));
  return;
}



// Function: Unwind@1002a4ab at 1002a4ab

void Unwind_1002a4ab(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x150));
  return;
}



// Function: Unwind@1002a4de at 1002a4de

void Unwind_1002a4de(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a50b at 1002a50b

void Unwind_1002a50b(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a538 at 1002a538

void Unwind_1002a538(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a565 at 1002a565

void Unwind_1002a565(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a592 at 1002a592

void Unwind_1002a592(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002a59a at 1002a59a

void Unwind_1002a59a(void)

{
  int unaff_EBP;
  
  FUN_100020f0(unaff_EBP + -0x60);
  return;
}



// Function: Unwind@1002a5a2 at 1002a5a2

void Unwind_1002a5a2(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x44) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x44) = *(uint *)(unaff_EBP + -0x44) & 0xfffffffe;
    FID_conflict__bad_alloc(*(int **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002a5d6 at 1002a5d6

void Unwind_1002a5d6(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002a5de at 1002a5de

void Unwind_1002a5de(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002a601 at 1002a601

void Unwind_1002a601(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a609 at 1002a609

void Unwind_1002a609(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002a636 at 1002a636

void Unwind_1002a636(void)

{
  int unaff_EBP;
  
  FUN_10023a90((undefined4 *)(unaff_EBP + -0x5c));
  return;
}



// Function: Unwind@1002a63e at 1002a63e

void Unwind_1002a63e(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x84));
  return;
}



// Function: Unwind@1002a671 at 1002a671

void Unwind_1002a671(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x54));
  return;
}



// Function: Unwind@1002a679 at 1002a679

void Unwind_1002a679(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x34));
  return;
}



// Function: Unwind@1002a681 at 1002a681

void Unwind_1002a681(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002a689 at 1002a689

void Unwind_1002a689(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a691 at 1002a691

void Unwind_1002a691(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002a699 at 1002a699

void Unwind_1002a699(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -100));
  return;
}



// Function: Unwind@1002a6bc at 1002a6bc

void Unwind_1002a6bc(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a6c4 at 1002a6c4

void Unwind_1002a6c4(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x94));
  return;
}



// Function: Unwind@1002a6cf at 1002a6cf

void Unwind_1002a6cf(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002a6d7 at 1002a6d7

void Unwind_1002a6d7(void)

{
  int unaff_EBP;
  
  FUN_1000ef00((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002a6df at 1002a6df

void Unwind_1002a6df(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x70));
  return;
}



// Function: Unwind@1002a6e7 at 1002a6e7

void Unwind_1002a6e7(void)

{
  int unaff_EBP;
  
  FUN_1000ef60((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002a6ef at 1002a6ef

void Unwind_1002a6ef(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x78));
  return;
}



// Function: Unwind@1002a6f7 at 1002a6f7

void Unwind_1002a6f7(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x80));
  return;
}



// Function: Unwind@1002a6ff at 1002a6ff

void Unwind_1002a6ff(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x6c));
  return;
}



// Function: Unwind@1002a707 at 1002a707

void Unwind_1002a707(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x7c));
  return;
}



// Function: Unwind@1002a70f at 1002a70f

void Unwind_1002a70f(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0xa8));
  return;
}



// Function: Unwind@1002a738 at 1002a738

void Unwind_1002a738(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x34));
  return;
}



// Function: Unwind@1002a740 at 1002a740

void Unwind_1002a740(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002a748 at 1002a748

void Unwind_1002a748(void)

{
  int unaff_EBP;
  
  FUN_1000efc0((_Container_base0 *)(unaff_EBP + -0x40));
  return;
}



// Function: Unwind@1002a750 at 1002a750

void Unwind_1002a750(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002a758 at 1002a758

void Unwind_1002a758(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x50));
  return;
}



// Function: Unwind@1002a77b at 1002a77b

void Unwind_1002a77b(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x4c));
  return;
}



// Function: Unwind@1002a783 at 1002a783

void Unwind_1002a783(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x34));
  return;
}



// Function: Unwind@1002a78b at 1002a78b

void Unwind_1002a78b(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x30));
  return;
}



// Function: Unwind@1002a793 at 1002a793

void Unwind_1002a793(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x5c));
  return;
}



// Function: Unwind@1002a7b6 at 1002a7b6

void Unwind_1002a7b6(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x50));
  return;
}



// Function: Unwind@1002a7be at 1002a7be

void Unwind_1002a7be(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x30));
  return;
}



// Function: Unwind@1002a7c6 at 1002a7c6

void Unwind_1002a7c6(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x34));
  return;
}



// Function: Unwind@1002a7ce at 1002a7ce

void Unwind_1002a7ce(void)

{
  int unaff_EBP;
  
  FUN_1000efc0((_Container_base0 *)(unaff_EBP + -0x60));
  return;
}



// Function: Unwind@1002a7d6 at 1002a7d6

void Unwind_1002a7d6(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x54));
  return;
}



// Function: Unwind@1002a7de at 1002a7de

void Unwind_1002a7de(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002a7e6 at 1002a7e6

void Unwind_1002a7e6(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x78));
  return;
}



// Function: Unwind@1002a813 at 1002a813

void Unwind_1002a813(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002a81b at 1002a81b

void Unwind_1002a81b(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002a823 at 1002a823

void Unwind_1002a823(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a846 at 1002a846

void Unwind_1002a846(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a84e at 1002a84e

void Unwind_1002a84e(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a871 at 1002a871

void Unwind_1002a871(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a879 at 1002a879

void Unwind_1002a879(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a89c at 1002a89c

void Unwind_1002a89c(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002a8a4 at 1002a8a4

void Unwind_1002a8a4(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002a8ac at 1002a8ac

void Unwind_1002a8ac(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a8cf at 1002a8cf

void Unwind_1002a8cf(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a8d7 at 1002a8d7

void Unwind_1002a8d7(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a8fa at 1002a8fa

void Unwind_1002a8fa(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a902 at 1002a902

void Unwind_1002a902(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a925 at 1002a925

void Unwind_1002a925(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a92d at 1002a92d

void Unwind_1002a92d(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a950 at 1002a950

void Unwind_1002a950(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a958 at 1002a958

void Unwind_1002a958(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a97b at 1002a97b

void Unwind_1002a97b(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002a983 at 1002a983

void Unwind_1002a983(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002a9a6 at 1002a9a6

void Unwind_1002a9a6(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002a9ae at 1002a9ae

void Unwind_1002a9ae(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x54));
  return;
}



// Function: Unwind@1002a9db at 1002a9db

void Unwind_1002a9db(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x54));
  return;
}



// Function: Unwind@1002a9e3 at 1002a9e3

void Unwind_1002a9e3(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x40));
  return;
}



// Function: Unwind@1002a9eb at 1002a9eb

void Unwind_1002a9eb(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002a9f3 at 1002a9f3

void Unwind_1002a9f3(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x68));
  return;
}



// Function: Unwind@1002aa20 at 1002aa20

void Unwind_1002aa20(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002aa28 at 1002aa28

void Unwind_1002aa28(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002aa4b at 1002aa4b

void Unwind_1002aa4b(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002aa53 at 1002aa53

void Unwind_1002aa53(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002aa76 at 1002aa76

void Unwind_1002aa76(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002aa7e at 1002aa7e

void Unwind_1002aa7e(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002aaa1 at 1002aaa1

void Unwind_1002aaa1(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002aaa9 at 1002aaa9

void Unwind_1002aaa9(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002aacc at 1002aacc

void Unwind_1002aacc(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002aad4 at 1002aad4

void Unwind_1002aad4(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002aaf7 at 1002aaf7

void Unwind_1002aaf7(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002aaff at 1002aaff

void Unwind_1002aaff(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x3c));
  return;
}



// Function: Unwind@1002ab22 at 1002ab22

void Unwind_1002ab22(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002ab2a at 1002ab2a

void Unwind_1002ab2a(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002ab4d at 1002ab4d

void Unwind_1002ab4d(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002ab55 at 1002ab55

void Unwind_1002ab55(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002ab78 at 1002ab78

void Unwind_1002ab78(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x60));
  return;
}



// Function: Unwind@1002ab80 at 1002ab80

void Unwind_1002ab80(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002ab88 at 1002ab88

void Unwind_1002ab88(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002ab90 at 1002ab90

void Unwind_1002ab90(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0xd4));
  return;
}



// Function: Unwind@1002ab9b at 1002ab9b

void Unwind_1002ab9b(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0xdc));
  return;
}



// Function: Unwind@1002aba6 at 1002aba6

void Unwind_1002aba6(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0xbc));
  return;
}



// Function: Unwind@1002abb1 at 1002abb1

void Unwind_1002abb1(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x80));
  return;
}



// Function: Unwind@1002abb9 at 1002abb9

void Unwind_1002abb9(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0xc4));
  return;
}



// Function: Unwind@1002abc4 at 1002abc4

void Unwind_1002abc4(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0xe4));
  return;
}



// Function: Unwind@1002abcf at 1002abcf

void Unwind_1002abcf(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0xcc));
  return;
}



// Function: Unwind@1002abda at 1002abda

void Unwind_1002abda(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0xa0));
  return;
}



// Function: Unwind@1002abe5 at 1002abe5

void Unwind_1002abe5(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0xb0));
  return;
}



// Function: Unwind@1002abf0 at 1002abf0

void Unwind_1002abf0(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0xf4));
  return;
}



// Function: Unwind@1002ac19 at 1002ac19

void Unwind_1002ac19(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x38));
  return;
}



// Function: Unwind@1002ac21 at 1002ac21

void Unwind_1002ac21(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002ac29 at 1002ac29

void Unwind_1002ac29(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x48));
  return;
}



// Function: Unwind@1002ac4c at 1002ac4c

void Unwind_1002ac4c(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x54));
  return;
}



// Function: Unwind@1002ac54 at 1002ac54

void Unwind_1002ac54(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x90));
  return;
}



// Function: Unwind@1002ac5f at 1002ac5f

void Unwind_1002ac5f(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x7c));
  return;
}



// Function: Unwind@1002ac67 at 1002ac67

void Unwind_1002ac67(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002ac6f at 1002ac6f

void Unwind_1002ac6f(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int **)(unaff_EBP + -0x84));
  return;
}



// Function: Unwind@1002ac7a at 1002ac7a

void Unwind_1002ac7a(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x8c));
  return;
}



// Function: Unwind@1002ac85 at 1002ac85

void Unwind_1002ac85(void)

{
  int unaff_EBP;
  
  FUN_100020f0(unaff_EBP + -0x70);
  return;
}



// Function: Unwind@1002ac8d at 1002ac8d

void Unwind_1002ac8d(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0xac));
  return;
}



// Function: Unwind@1002acb6 at 1002acb6

void Unwind_1002acb6(void)

{
  int unaff_EBP;
  
  FUN_1000ee20((undefined4 *)(unaff_EBP + -0x5c));
  return;
}



// Function: Unwind@1002acbe at 1002acbe

void Unwind_1002acbe(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002acc6 at 1002acc6

void Unwind_1002acc6(void)

{
  int unaff_EBP;
  
  FUN_100020f0(unaff_EBP + -0x6c);
  return;
}



// Function: Unwind@1002acce at 1002acce

void Unwind_1002acce(void)

{
  int unaff_EBP;
  
  _com_error::~_com_error((_com_error *)(unaff_EBP + -0x8c));
  return;
}



// Function: Unwind@1002ad00 at 1002ad00

void Unwind_1002ad00(void)

{
  int unaff_EBP;
  
  FUN_1000eea0(*(int **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002ad30 at 1002ad30

void Unwind_1002ad30(void)

{
  int unaff_EBP;
  
  FUN_1000ef20(*(int **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002ad60 at 1002ad60

void Unwind_1002ad60(void)

{
  int unaff_EBP;
  
  FUN_1000ef40(*(int **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002ad90 at 1002ad90

void Unwind_1002ad90(void)

{
  int unaff_EBP;
  
  FUN_1000ee40(*(int **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002adc0 at 1002adc0

void Unwind_1002adc0(void)

{
  int unaff_EBP;
  
  FUN_1000ef00(*(int **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002adf0 at 1002adf0

void Unwind_1002adf0(void)

{
  int unaff_EBP;
  
  FUN_1000ee40((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002ae20 at 1002ae20

void Unwind_1002ae20(void)

{
  int unaff_EBP;
  
  FUN_1000eea0((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002ae50 at 1002ae50

void Unwind_1002ae50(void)

{
  int unaff_EBP;
  
  FUN_1000ef00((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002ae80 at 1002ae80

void Unwind_1002ae80(void)

{
  int unaff_EBP;
  
  FUN_1000ef20((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002aeb0 at 1002aeb0

void Unwind_1002aeb0(void)

{
  int unaff_EBP;
  
  FUN_1000ef40((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002af40 at 1002af40

void Unwind_1002af40(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002af70 at 1002af70

void Unwind_1002af70(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002afa0 at 1002afa0

void Unwind_1002afa0(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002afd0 at 1002afd0

void Unwind_1002afd0(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002b000 at 1002b000

void Unwind_1002b000(void)

{
  int unaff_EBP;
  
  _anon_026BA49F::_ExceptionPtr_normal::~_ExceptionPtr_normal
            ((_ExceptionPtr_normal *)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@1002b00b at 1002b00b

void Unwind_1002b00b(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int *)(unaff_EBP + -0x10) + 0x10);
  return;
}



// Function: Unwind@1002b040 at 1002b040

void Unwind_1002b040(void)

{
  int unaff_EBP;
  
  FUN_1000efe0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b070 at 1002b070

void Unwind_1002b070(void)

{
  int unaff_EBP;
  
  FUN_1000efe0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b0a0 at 1002b0a0

void Unwind_1002b0a0(void)

{
  FUN_10002070();
  return;
}



// Function: Unwind@1002b0d0 at 1002b0d0

void Unwind_1002b0d0(void)

{
  int unaff_EBP;
  
  FUN_1000ed60(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b100 at 1002b100

void Unwind_1002b100(void)

{
  int unaff_EBP;
  
  FUN_1000ed60(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b130 at 1002b130

void Unwind_1002b130(void)

{
  int unaff_EBP;
  
  FUN_1000ed60(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b160 at 1002b160

void Unwind_1002b160(void)

{
  int unaff_EBP;
  
  FUN_1000ed60(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b190 at 1002b190

void Unwind_1002b190(void)

{
  int unaff_EBP;
  
  FUN_1000ed90(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b1c0 at 1002b1c0

void Unwind_1002b1c0(void)

{
  int unaff_EBP;
  
  FUN_1000edc0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b1f0 at 1002b1f0

void Unwind_1002b1f0(void)

{
  int unaff_EBP;
  
  FUN_1000edc0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b220 at 1002b220

void Unwind_1002b220(void)

{
  int unaff_EBP;
  
  FUN_1000edf0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b250 at 1002b250

void Unwind_1002b250(void)

{
  FUN_10002060();
  return;
}



// Function: Unwind@1002b280 at 1002b280

void Unwind_1002b280(void)

{
  int unaff_EBP;
  
  FUN_1000f260(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b2b0 at 1002b2b0

void Unwind_1002b2b0(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b2e0 at 1002b2e0

void Unwind_1002b2e0(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b310 at 1002b310

void Unwind_1002b310(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002b340 at 1002b340

void Unwind_1002b340(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002b370 at 1002b370

void Unwind_1002b370(void)

{
  int unaff_EBP;
  
  FUN_10002040(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b3a0 at 1002b3a0

void Unwind_1002b3a0(void)

{
  int unaff_EBP;
  
  _anon_026BA49F::_ExceptionPtr_normal::~_ExceptionPtr_normal
            ((_ExceptionPtr_normal *)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@1002b3ab at 1002b3ab

void Unwind_1002b3ab(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int *)(unaff_EBP + -0x10) + 0x10);
  return;
}



// Function: Unwind@1002b3e0 at 1002b3e0

void Unwind_1002b3e0(void)

{
  int unaff_EBP;
  
  FUN_1000efe0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b410 at 1002b410

void Unwind_1002b410(void)

{
  int unaff_EBP;
  
  FUN_1000efe0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b440 at 1002b440

void Unwind_1002b440(void)

{
  FUN_10002070();
  return;
}



// Function: Unwind@1002b470 at 1002b470

void Unwind_1002b470(void)

{
  int unaff_EBP;
  
  FUN_1000ed60(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b4a0 at 1002b4a0

void Unwind_1002b4a0(void)

{
  int unaff_EBP;
  
  FUN_1000ed90(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b4d0 at 1002b4d0

void Unwind_1002b4d0(void)

{
  int unaff_EBP;
  
  FUN_1000edc0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b500 at 1002b500

void Unwind_1002b500(void)

{
  int unaff_EBP;
  
  FUN_1000edf0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b530 at 1002b530

void Unwind_1002b530(void)

{
  int unaff_EBP;
  
  ~_ExceptionPtr_static<>(*(int *)(unaff_EBP + -0x10) + 8);
  return;
}



// Function: Unwind@1002b53b at 1002b53b

void Unwind_1002b53b(void)

{
  int unaff_EBP;
  
  FUN_100020f0(*(int *)(unaff_EBP + -0x10) + 0x38);
  return;
}



// Function: Unwind@1002b570 at 1002b570

void Unwind_1002b570(void)

{
  FUN_10002060();
  return;
}



// Function: Unwind@1002b5a0 at 1002b5a0

void Unwind_1002b5a0(void)

{
  int unaff_EBP;
  
  FUN_1000ef60((int *)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@1002b5d0 at 1002b5d0

void Unwind_1002b5d0(void)

{
  int unaff_EBP;
  
  FUN_1000f260(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b600 at 1002b600

void Unwind_1002b600(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b630 at 1002b630

void Unwind_1002b630(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002b660 at 1002b660

void Unwind_1002b660(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002b690 at 1002b690

void Unwind_1002b690(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002b6c0 at 1002b6c0

void Unwind_1002b6c0(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002b6f0 at 1002b6f0

void Unwind_1002b6f0(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002b720 at 1002b720

void Unwind_1002b720(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002b750 at 1002b750

void Unwind_1002b750(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002b780 at 1002b780

void Unwind_1002b780(void)

{
  int unaff_EBP;
  
  ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
  ~CComCritSecLock<class_ATL::CComCriticalSection>
            ((CComCritSecLock<class_ATL::CComCriticalSection> *)(unaff_EBP + -0x24));
  return;
}



// Function: Unwind@1002b7b0 at 1002b7b0

void Unwind_1002b7b0(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 0x28));
  return;
}



// Function: Unwind@1002b7b8 at 1002b7b8

void Unwind_1002b7b8(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 0x20));
  return;
}



// Function: Unwind@1002b7c0 at 1002b7c0

void Unwind_1002b7c0(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 0x1c));
  return;
}



// Function: Unwind@1002b7c8 at 1002b7c8

void Unwind_1002b7c8(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x1c) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x1c) = *(uint *)(unaff_EBP + -0x1c) & 0xfffffffe;
    FUN_1000ee40(*(int **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002b800 at 1002b800

void Unwind_1002b800(void)

{
  int unaff_EBP;
  
  FUN_10028fdf(*(void **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002b830 at 1002b830

void Unwind_1002b830(void)

{
  int unaff_EBP;
  
  FUN_10028fdf(*(void **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002b860 at 1002b860

void Unwind_1002b860(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x1c) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x1c) = *(uint *)(unaff_EBP + -0x1c) & 0xfffffffe;
    FUN_1000ef20(*(int **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002b8a0 at 1002b8a0

void Unwind_1002b8a0(void)

{
  int unaff_EBP;
  
  ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
  ~CComCritSecLock<class_ATL::CComCriticalSection>
            ((CComCritSecLock<class_ATL::CComCriticalSection> *)(unaff_EBP + -0x154));
  return;
}



// Function: Unwind@1002b8ab at 1002b8ab

void Unwind_1002b8ab(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x134));
  return;
}



// Function: Unwind@1002b8b6 at 1002b8b6

void Unwind_1002b8b6(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x128));
  return;
}



// Function: Unwind@1002b8c1 at 1002b8c1

void Unwind_1002b8c1(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x130));
  return;
}



// Function: Unwind@1002b8cc at 1002b8cc

void Unwind_1002b8cc(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -300));
  return;
}



// Function: Unwind@1002b900 at 1002b900

void Unwind_1002b900(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002b908 at 1002b908

void Unwind_1002b908(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002b930 at 1002b930

void Unwind_1002b930(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002b960 at 1002b960

void Unwind_1002b960(void)

{
  int unaff_EBP;
  
  FUN_10028fed(*(void **)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002b972 at 1002b972

void Unwind_1002b972(void)

{
  int unaff_EBP;
  
  FUN_10002040((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002b9a0 at 1002b9a0

void Unwind_1002b9a0(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002b9f0 at 1002b9f0

void Unwind_1002b9f0(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x30));
  return;
}



// Function: Unwind@1002b9f8 at 1002b9f8

void Unwind_1002b9f8(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x34));
  return;
}



// Function: Unwind@1002ba60 at 1002ba60

void Unwind_1002ba60(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002ba90 at 1002ba90

void Unwind_1002ba90(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x18) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x18) = *(uint *)(unaff_EBP + -0x18) & 0xfffffffe;
    ~basic_string<>(*(void **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002bad0 at 1002bad0

void Unwind_1002bad0(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    ~basic_string<>(*(void **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002bb10 at 1002bb10

void Unwind_1002bb10(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x18) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x18) = *(uint *)(unaff_EBP + -0x18) & 0xfffffffe;
    ~basic_string<>(*(void **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002bb50 at 1002bb50

void Unwind_1002bb50(void)

{
  int unaff_EBP;
  
  FUN_10016db0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002bb80 at 1002bb80

void Unwind_1002bb80(void)

{
  int unaff_EBP;
  
  _anon_026BA49F::_ExceptionPtr_normal::~_ExceptionPtr_normal
            ((_ExceptionPtr_normal *)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@1002bb8b at 1002bb8b

void Unwind_1002bb8b(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int *)(unaff_EBP + -0x10) + 0xc);
  return;
}



// Function: Unwind@1002bbc0 at 1002bbc0

void Unwind_1002bbc0(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffe;
    FUN_100269c0((undefined4 *)(*(int *)(unaff_EBP + -0x10) + 0x34));
    return;
  }
  return;
}



// Function: Unwind@1002bbdc at 1002bbdc

void Unwind_1002bbdc(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 2) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffd;
    FUN_10016d20();
    return;
  }
  return;
}



// Function: Unwind@1002bbf8 at 1002bbf8

void Unwind_1002bbf8(void)

{
  int unaff_EBP;
  
  ~_ExceptionPtr_static<>(*(int *)(unaff_EBP + -0x10) + 4);
  return;
}



// Function: Unwind@1002bc03 at 1002bc03

void Unwind_1002bc03(void)

{
  FUN_10016f30();
  return;
}



// Function: Unwind@1002bc30 at 1002bc30

void Unwind_1002bc30(void)

{
  int unaff_EBP;
  
  FUN_10016fe0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002bc60 at 1002bc60

void Unwind_1002bc60(void)

{
  int unaff_EBP;
  
  FUN_10016fe0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002bc90 at 1002bc90

void Unwind_1002bc90(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffe;
    FUN_100269c0((undefined4 *)(*(int *)(unaff_EBP + -0x10) + 0x34));
    return;
  }
  return;
}



// Function: Unwind@1002bcac at 1002bcac

void Unwind_1002bcac(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 2) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffd;
    FUN_10016d20();
    return;
  }
  return;
}



// Function: Unwind@1002bcc8 at 1002bcc8

void Unwind_1002bcc8(void)

{
  int unaff_EBP;
  
  FUN_100169b0(*(int *)(unaff_EBP + -0x10) + 0x34);
  return;
}



// Function: Unwind@1002bcf0 at 1002bcf0

void Unwind_1002bcf0(void)

{
  int unaff_EBP;
  
  FUN_10016e10(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002bd20 at 1002bd20

void Unwind_1002bd20(void)

{
  int unaff_EBP;
  
  FUN_10016cc0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002bd50 at 1002bd50

void Unwind_1002bd50(void)

{
  int unaff_EBP;
  
  FUN_10016cf0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002bd80 at 1002bd80

void Unwind_1002bd80(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffe;
    FUN_100269c0((undefined4 *)(*(int *)(unaff_EBP + -0x10) + 4));
    return;
  }
  return;
}



// Function: Unwind@1002bdc0 at 1002bdc0

void Unwind_1002bdc0(void)

{
  FUN_100170d0();
  return;
}



// Function: Unwind@1002bdf0 at 1002bdf0

void Unwind_1002bdf0(void)

{
  int unaff_EBP;
  
  ~_ExceptionPtr_static<>(*(int *)(unaff_EBP + -0x10) + 4);
  return;
}



// Function: Unwind@1002be20 at 1002be20

void Unwind_1002be20(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002be50 at 1002be50

void Unwind_1002be50(void)

{
  int unaff_EBP;
  
  FUN_10016d30(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002be80 at 1002be80

void Unwind_1002be80(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffe;
    FUN_100269c0((undefined4 *)(*(int *)(unaff_EBP + -0x10) + 0xc));
    return;
  }
  return;
}



// Function: Unwind@1002be9c at 1002be9c

void Unwind_1002be9c(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 2) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffd;
    FUN_10016d20();
    return;
  }
  return;
}



// Function: Unwind@1002beb8 at 1002beb8

void Unwind_1002beb8(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002bee0 at 1002bee0

void Unwind_1002bee0(void)

{
  int unaff_EBP;
  
  FID_conflict__CAtlWinModule((int *)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@1002bf10 at 1002bf10

void Unwind_1002bf10(void)

{
  FUN_10002060();
  return;
}



// Function: Unwind@1002bf40 at 1002bf40

void Unwind_1002bf40(void)

{
  int unaff_EBP;
  
  FUN_10016db0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002bf70 at 1002bf70

void Unwind_1002bf70(void)

{
  int unaff_EBP;
  
  _anon_026BA49F::_ExceptionPtr_normal::~_ExceptionPtr_normal
            ((_ExceptionPtr_normal *)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@1002bf7b at 1002bf7b

void Unwind_1002bf7b(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int *)(unaff_EBP + -0x10) + 0xc);
  return;
}



// Function: Unwind@1002bfb0 at 1002bfb0

void Unwind_1002bfb0(void)

{
  int unaff_EBP;
  
  ~_ExceptionPtr_static<>(*(int *)(unaff_EBP + -0x10) + -0x30);
  return;
}



// Function: Unwind@1002bfbb at 1002bfbb

void Unwind_1002bfbb(void)

{
  FUN_10016f30();
  return;
}



// Function: Unwind@1002bff0 at 1002bff0

void Unwind_1002bff0(void)

{
  int unaff_EBP;
  
  FUN_10016fe0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002c020 at 1002c020

void Unwind_1002c020(void)

{
  int unaff_EBP;
  
  FUN_10016fe0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002c050 at 1002c050

void Unwind_1002c050(void)

{
  int unaff_EBP;
  
  FUN_100169b0(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002c080 at 1002c080

void Unwind_1002c080(void)

{
  int unaff_EBP;
  
  FUN_10016e10(*(undefined4 **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002c0b0 at 1002c0b0

void Unwind_1002c0b0(void)

{
  int unaff_EBP;
  
  FUN_10016cc0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002c0e0 at 1002c0e0

void Unwind_1002c0e0(void)

{
  int unaff_EBP;
  
  FUN_10016cf0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002c110 at 1002c110

void Unwind_1002c110(void)

{
  FUN_100170d0();
  return;
}



// Function: Unwind@1002c140 at 1002c140

void Unwind_1002c140(void)

{
  int unaff_EBP;
  
  ~_ExceptionPtr_static<>(*(int *)(unaff_EBP + -0x10) + 4);
  return;
}



// Function: Unwind@1002c170 at 1002c170

void Unwind_1002c170(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc(*(int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002c1a0 at 1002c1a0

void Unwind_1002c1a0(void)

{
  int unaff_EBP;
  
  FUN_10016d30(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002c1d0 at 1002c1d0

void Unwind_1002c1d0(void)

{
  int unaff_EBP;
  
  FID_conflict__CAtlWinModule((int *)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@1002c200 at 1002c200

void Unwind_1002c200(void)

{
  int unaff_EBP;
  
  ~_ExceptionPtr_static<>(*(int *)(unaff_EBP + -0x10) + 0x14);
  return;
}



// Function: Unwind@1002c20b at 1002c20b

void Unwind_1002c20b(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 0x34));
  return;
}



// Function: Unwind@1002c216 at 1002c216

void Unwind_1002c216(void)

{
  int unaff_EBP;
  
  FUN_1000efa0((_Container_base0 *)(*(int *)(unaff_EBP + -0x10) + 0x4c));
  return;
}



// Function: Unwind@1002c221 at 1002c221

void Unwind_1002c221(void)

{
  int unaff_EBP;
  
  FUN_1000efc0((_Container_base0 *)(*(int *)(unaff_EBP + -0x10) + 0x58));
  return;
}



// Function: Unwind@1002c22c at 1002c22c

void Unwind_1002c22c(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 100));
  return;
}



// Function: Unwind@1002c237 at 1002c237

void Unwind_1002c237(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 0x68));
  return;
}



// Function: Unwind@1002c242 at 1002c242

void Unwind_1002c242(void)

{
  int unaff_EBP;
  
  FUN_1000ee60((int *)(*(int *)(unaff_EBP + -0x10) + 0x6c));
  return;
}



// Function: Unwind@1002c24d at 1002c24d

void Unwind_1002c24d(void)

{
  int unaff_EBP;
  
  FUN_1000eea0((int *)(*(int *)(unaff_EBP + -0x10) + 0x70));
  return;
}



// Function: Unwind@1002c258 at 1002c258

void Unwind_1002c258(void)

{
  int unaff_EBP;
  
  FID_conflict__CAtlWinModule((LPCRITICAL_SECTION)(*(int *)(unaff_EBP + -0x10) + 0x74));
  return;
}



// Function: Unwind@1002c263 at 1002c263

void Unwind_1002c263(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 0xa4));
  return;
}



// Function: Unwind@1002c271 at 1002c271

void Unwind_1002c271(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(*(int *)(unaff_EBP + -0x10) + 0xb4));
  return;
}



// Function: Unwind@1002c2a0 at 1002c2a0

void Unwind_1002c2a0(void)

{
  FUN_10002060();
  return;
}



// Function: Unwind@1002c2d0 at 1002c2d0

void Unwind_1002c2d0(void)

{
  int unaff_EBP;
  
  FUN_100168e0((undefined4 *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002c2d8 at 1002c2d8

void Unwind_1002c2d8(void)

{
  int unaff_EBP;
  
  FUN_10016900((undefined4 *)(unaff_EBP + -0x24));
  return;
}



// Function: Unwind@1002c300 at 1002c300

void Unwind_1002c300(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002c330 at 1002c330

void Unwind_1002c330(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002c360 at 1002c360

void Unwind_1002c360(void)

{
  int unaff_EBP;
  
  ~CTempBuffer<>((int *)(unaff_EBP + -0x121c));
  return;
}



// Function: Unwind@1002c36b at 1002c36b

void Unwind_1002c36b(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x1250));
  return;
}



// Function: Unwind@1002c376 at 1002c376

void Unwind_1002c376(void)

{
  int unaff_EBP;
  
  ~CTempBuffer<>((int *)(unaff_EBP + -0x1118));
  return;
}



// Function: Unwind@1002c3b0 at 1002c3b0

void Unwind_1002c3b0(void)

{
  int unaff_EBP;
  
  ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
  ~CComCritSecLock<class_ATL::CComCriticalSection>
            ((CComCritSecLock<class_ATL::CComCriticalSection> *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002c3e0 at 1002c3e0

void Unwind_1002c3e0(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x130));
  return;
}



// Function: Unwind@1002c420 at 1002c420

void Unwind_1002c420(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x124));
  return;
}



// Function: Unwind@1002c42b at 1002c42b

void Unwind_1002c42b(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x148));
  return;
}



// Function: Unwind@1002c436 at 1002c436

void Unwind_1002c436(void)

{
  int unaff_EBP;
  
  FUN_10016f60((CRegKey *)(unaff_EBP + -0x17c));
  return;
}



// Function: Unwind@1002c441 at 1002c441

void Unwind_1002c441(void)

{
  int unaff_EBP;
  
  FUN_10016f60((CRegKey *)(unaff_EBP + -0x16c));
  return;
}



// Function: Unwind@1002c480 at 1002c480

void Unwind_1002c480(void)

{
  int unaff_EBP;
  
  FUN_10002040((undefined4 *)(unaff_EBP + -0x22c));
  return;
}



// Function: Unwind@1002c48b at 1002c48b

void Unwind_1002c48b(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x228));
  return;
}



// Function: Unwind@1002c496 at 1002c496

void Unwind_1002c496(void)

{
  int unaff_EBP;
  
  FUN_10002040((undefined4 *)(unaff_EBP + -0x224));
  return;
}



// Function: Unwind@1002c4d0 at 1002c4d0

void Unwind_1002c4d0(void)

{
  int unaff_EBP;
  
  FUN_10002040((undefined4 *)(unaff_EBP + -0x24));
  return;
}



// Function: Unwind@1002c4d8 at 1002c4d8

void Unwind_1002c4d8(void)

{
  int unaff_EBP;
  
  FID_conflict__bad_alloc((int *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002c500 at 1002c500

void Unwind_1002c500(void)

{
  int unaff_EBP;
  
  FUN_10028fdf(*(void **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002c530 at 1002c530

void Unwind_1002c530(void)

{
  int unaff_EBP;
  
  FUN_10028fdf(*(void **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002c560 at 1002c560

void Unwind_1002c560(void)

{
  int unaff_EBP;
  
  FUN_10028fdf(*(void **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002c590 at 1002c590

void Unwind_1002c590(void)

{
  int unaff_EBP;
  
  FUN_10028fdf(*(void **)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002c5c0 at 1002c5c0

void Unwind_1002c5c0(void)

{
  int unaff_EBP;
  
  ATL::CComCritSecLock<class_ATL::CComCriticalSection>::
  ~CComCritSecLock<class_ATL::CComCriticalSection>
            ((CComCritSecLock<class_ATL::CComCriticalSection> *)(unaff_EBP + -0x20));
  return;
}



// Function: Unwind@1002c5f0 at 1002c5f0

void Unwind_1002c5f0(void)

{
  FUN_10015bb0();
  return;
}



// Function: Unwind@1002c609 at 1002c609

void Unwind_1002c609(void)

{
  FUN_10015bc0();
  return;
}



// Function: Unwind@1002c640 at 1002c640

void Unwind_1002c640(void)

{
  int unaff_EBP;
  
  FUN_10016f40(unaff_EBP + -0x58);
  return;
}



// Function: Unwind@1002c670 at 1002c670

void Unwind_1002c670(void)

{
  int unaff_EBP;
  
  FUN_10016f60((CRegKey *)(unaff_EBP + -0x128));
  return;
}



// Function: Unwind@1002c6b0 at 1002c6b0

void Unwind_1002c6b0(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x430));
  return;
}



// Function: Unwind@1002c6bb at 1002c6bb

void Unwind_1002c6bb(void)

{
  int unaff_EBP;
  
  ~CTempBuffer<>((int *)(unaff_EBP + -0x418));
  return;
}



// Function: Unwind@1002c6f0 at 1002c6f0

void Unwind_1002c6f0(void)

{
  int unaff_EBP;
  
  FUN_10016f60((CRegKey *)(unaff_EBP + -0x112c));
  return;
}



// Function: Unwind@1002c6fb at 1002c6fb

void Unwind_1002c6fb(void)

{
  int unaff_EBP;
  
  FUN_10016f60((CRegKey *)(unaff_EBP + -0x1140));
  return;
}



// Function: Unwind@1002c706 at 1002c706

void Unwind_1002c706(void)

{
  int unaff_EBP;
  
  FUN_10016f60((CRegKey *)(unaff_EBP + -0x1160));
  return;
}



// Function: Unwind@1002c711 at 1002c711

void Unwind_1002c711(void)

{
  int unaff_EBP;
  
  FUN_10016f60((CRegKey *)(unaff_EBP + -0x1170));
  return;
}



// Function: Unwind@1002c71c at 1002c71c

void Unwind_1002c71c(void)

{
  int unaff_EBP;
  
  FUN_10016f60((CRegKey *)(unaff_EBP + -0x1180));
  return;
}



// Function: Unwind@1002c750 at 1002c750

void Unwind_1002c750(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002c780 at 1002c780

void Unwind_1002c780(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002c7b0 at 1002c7b0

void Unwind_1002c7b0(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002c7e0 at 1002c7e0

void Unwind_1002c7e0(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x1c));
  return;
}



// Function: Unwind@1002c810 at 1002c810

void Unwind_1002c810(void)

{
  int unaff_EBP;
  
  FUN_10016f80((undefined4 *)(unaff_EBP + -0x96c));
  return;
}



// Function: Unwind@1002c81b at 1002c81b

void Unwind_1002c81b(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x940));
  return;
}



// Function: Unwind@1002c850 at 1002c850

void Unwind_1002c850(void)

{
  int unaff_EBP;
  
  FUN_10016f80((undefined4 *)(unaff_EBP + -0x970));
  return;
}



// Function: Unwind@1002c85b at 1002c85b

void Unwind_1002c85b(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x944));
  return;
}



// Function: Unwind@1002c890 at 1002c890

void Unwind_1002c890(void)

{
  DAT_100404d4 = DAT_100404d4 & 0xfffffffe;
  return;
}



// Function: Unwind@1002c8c0 at 1002c8c0

void Unwind_1002c8c0(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    ~basic_string<>(*(void **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002c900 at 1002c900

void Unwind_1002c900(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    ~basic_string<>(*(void **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002c940 at 1002c940

void Unwind_1002c940(void)

{
  int unaff_EBP;
  
  FUN_1000ef60((int *)(*(int *)(unaff_EBP + -0x10) + 4));
  return;
}



// Function: Unwind@1002c970 at 1002c970

void Unwind_1002c970(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f4);
  return;
}



// Function: Unwind@1002c9a0 at 1002c9a0

void Unwind_1002c9a0(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002c9aa at 1002c9aa

void Unwind_1002c9aa(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002c9d0 at 1002c9d0

void Unwind_1002c9d0(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002c9da at 1002c9da

void Unwind_1002c9da(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002ca00 at 1002ca00

void Unwind_1002ca00(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f4);
  return;
}



// Function: Unwind@1002ca30 at 1002ca30

void Unwind_1002ca30(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002ca3a at 1002ca3a

void Unwind_1002ca3a(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002ca60 at 1002ca60

void Unwind_1002ca60(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002ca6a at 1002ca6a

void Unwind_1002ca6a(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002ca90 at 1002ca90

void Unwind_1002ca90(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002ca98 at 1002ca98

void Unwind_1002ca98(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002cad0 at 1002cad0

void Unwind_1002cad0(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x44));
  return;
}



// Function: Unwind@1002cad8 at 1002cad8

void Unwind_1002cad8(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002cae0 at 1002cae0

void Unwind_1002cae0(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x5c));
  return;
}



// Function: Unwind@1002cb10 at 1002cb10

void Unwind_1002cb10(void)

{
  int unaff_EBP;
  
  FUN_10020a70((int *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002cb18 at 1002cb18

void Unwind_1002cb18(void)

{
  int unaff_EBP;
  
  FUN_10020ab0((int *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002cb20 at 1002cb20

void Unwind_1002cb20(void)

{
  int unaff_EBP;
  
  FUN_10020a70((int *)(unaff_EBP + -0x2c));
  return;
}



// Function: Unwind@1002cb50 at 1002cb50

void Unwind_1002cb50(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cb53. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::_Lockit::~_Lockit((_Lockit *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002cb80 at 1002cb80

void Unwind_1002cb80(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cb83. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  ~basic_streambuf<char,struct_std::char_traits<char>_>
            (*(basic_streambuf<char,struct_std::char_traits<char>_> **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002cbb0 at 1002cbb0

void Unwind_1002cbb0(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cbb3. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002cbb9 at 1002cbb9

void Unwind_1002cbb9(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
                    /* WARNING: Could not recover jumptable at 0x1002cbcf. Too many branches */
                    /* WARNING: Treating indirect jump as call */
    std::basic_ios<char,struct_std::char_traits<char>_>::
    ~basic_ios<char,struct_std::char_traits<char>_>
              ((basic_ios<char,struct_std::char_traits<char>_> *)
               (*(int *)(unaff_EBP + -0x14) + 0x78));
    return;
  }
  return;
}



// Function: Unwind@1002cbd6 at 1002cbd6

void Unwind_1002cbd6(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cbdc. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_iostream<char,struct_std::char_traits<char>_>::
  ~basic_iostream<char,struct_std::char_traits<char>_>
            ((basic_iostream<char,struct_std::char_traits<char>_> *)
             (*(int *)(unaff_EBP + -0x14) + 0x20));
  return;
}



// Function: Unwind@1002cbe2 at 1002cbe2

void Unwind_1002cbe2(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cbe5. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  ~basic_streambuf<char,struct_std::char_traits<char>_>
            (*(basic_streambuf<char,struct_std::char_traits<char>_> **)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002cbeb at 1002cbeb

void Unwind_1002cbeb(void)

{
  int unaff_EBP;
  
  FUN_10020920((basic_streambuf<char,struct_std::char_traits<char>_> *)
               (*(int *)(unaff_EBP + -0x14) + 0x18));
  return;
}



// Function: Unwind@1002cc20 at 1002cc20

void Unwind_1002cc20(void)

{
  int unaff_EBP;
  
  FUN_10020a70(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002cc50 at 1002cc50

void Unwind_1002cc50(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cc53. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  ~basic_streambuf<char,struct_std::char_traits<char>_>
            (*(basic_streambuf<char,struct_std::char_traits<char>_> **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002cc80 at 1002cc80

void Unwind_1002cc80(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cc86. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_iostream<char,struct_std::char_traits<char>_>::
  ~basic_iostream<char,struct_std::char_traits<char>_>
            ((basic_iostream<char,struct_std::char_traits<char>_> *)
             (*(int *)(unaff_EBP + -0x10) + -0x58));
  return;
}



// Function: Unwind@1002cc8c at 1002cc8c

void Unwind_1002cc8c(void)

{
  int unaff_EBP;
  
  FUN_10020920((basic_streambuf<char,struct_std::char_traits<char>_> *)
               (*(int *)(unaff_EBP + -0x10) + -0x60));
  return;
}



// Function: Unwind@1002cc97 at 1002cc97

void Unwind_1002cc97(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cc9a. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  ~basic_streambuf<char,struct_std::char_traits<char>_>
            (*(basic_streambuf<char,struct_std::char_traits<char>_> **)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002ccc0 at 1002ccc0

void Unwind_1002ccc0(void)

{
  int unaff_EBP;
  
  FUN_10020a70(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002ccf0 at 1002ccf0

void Unwind_1002ccf0(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002ccf3. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002cd20 at 1002cd20

void Unwind_1002cd20(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cd23. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_streambuf<char,struct_std::char_traits<char>_>::
  ~basic_streambuf<char,struct_std::char_traits<char>_>
            (*(basic_streambuf<char,struct_std::char_traits<char>_> **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002cd50 at 1002cd50

void Unwind_1002cd50(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cd53. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002cd80 at 1002cd80

void Unwind_1002cd80(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f4);
  return;
}



// Function: Unwind@1002cdb0 at 1002cdb0

void Unwind_1002cdb0(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002cdba at 1002cdba

void Unwind_1002cdba(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002cde0 at 1002cde0

void Unwind_1002cde0(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002cdea at 1002cdea

void Unwind_1002cdea(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002ce10 at 1002ce10

void Unwind_1002ce10(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f4);
  return;
}



// Function: Unwind@1002ce40 at 1002ce40

void Unwind_1002ce40(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002ce4a at 1002ce4a

void Unwind_1002ce4a(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002ce70 at 1002ce70

void Unwind_1002ce70(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002ce7a at 1002ce7a

void Unwind_1002ce7a(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002cea0 at 1002cea0

void Unwind_1002cea0(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002ced0 at 1002ced0

void Unwind_1002ced0(void)

{
  int unaff_EBP;
  
  FUN_10020bb0(unaff_EBP + -0xcc);
  return;
}



// Function: Unwind@1002cedb at 1002cedb

void Unwind_1002cedb(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cede. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + 0xc));
  return;
}



// Function: Unwind@1002cf10 at 1002cf10

void Unwind_1002cf10(void)

{
  int unaff_EBP;
  
  FUN_10020bb0(unaff_EBP + -0xcc);
  return;
}



// Function: Unwind@1002cf1b at 1002cf1b

void Unwind_1002cf1b(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cf1e. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + 0xc));
  return;
}



// Function: Unwind@1002cf50 at 1002cf50

void Unwind_1002cf50(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x30));
  return;
}



// Function: Unwind@1002cf58 at 1002cf58

void Unwind_1002cf58(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x48));
  return;
}



// Function: Unwind@1002cf60 at 1002cf60

void Unwind_1002cf60(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x60));
  return;
}



// Function: Unwind@1002cf68 at 1002cf68

void Unwind_1002cf68(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cf6e. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_ostream<char,struct_std::char_traits<char>_>::_vbase_destructor_
            ((basic_ostream<char,struct_std::char_traits<char>_> *)(unaff_EBP + -0xd8));
  return;
}



// Function: Unwind@1002cfa0 at 1002cfa0

void Unwind_1002cfa0(void)

{
  int unaff_EBP;
  
  FUN_10020bb0(unaff_EBP + -0xcc);
  return;
}



// Function: Unwind@1002cfab at 1002cfab

void Unwind_1002cfab(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cfae. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + 0xc));
  return;
}



// Function: Unwind@1002cfe0 at 1002cfe0

void Unwind_1002cfe0(void)

{
  int unaff_EBP;
  
  FUN_10020bb0(unaff_EBP + -0xcc);
  return;
}



// Function: Unwind@1002cfeb at 1002cfeb

void Unwind_1002cfeb(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002cfee. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + 0xc));
  return;
}



// Function: Unwind@1002d020 at 1002d020

void Unwind_1002d020(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002d026. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_ostream<char,struct_std::char_traits<char>_>::_vbase_destructor_
            ((basic_ostream<char,struct_std::char_traits<char>_> *)(unaff_EBP + -0x98));
  return;
}



// Function: Unwind@1002d02c at 1002d02c

void Unwind_1002d02c(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002d032. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + -0x9c));
  return;
}



// Function: Unwind@1002d038 at 1002d038

void Unwind_1002d038(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002d03e. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_ostream<char,struct_std::char_traits<char>_>::_vbase_destructor_
            ((basic_ostream<char,struct_std::char_traits<char>_> *)(unaff_EBP + -0x98));
  return;
}



// Function: Unwind@1002d044 at 1002d044

void Unwind_1002d044(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002d047. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002d04d at 1002d04d

void Unwind_1002d04d(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002d053. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::basic_ostream<char,struct_std::char_traits<char>_>::_vbase_destructor_
            ((basic_ostream<char,struct_std::char_traits<char>_> *)(unaff_EBP + -0x98));
  return;
}



// Function: Unwind@1002d059 at 1002d059

void Unwind_1002d059(void)

{
  int unaff_EBP;
  
                    /* WARNING: Could not recover jumptable at 0x1002d05c. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  std::ios_base::~ios_base(*(ios_base **)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002d080 at 1002d080

void Unwind_1002d080(void)

{
  int unaff_EBP;
  
  FUN_1000ef60((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002d088 at 1002d088

void Unwind_1002d088(void)

{
  int unaff_EBP;
  
  FUN_1000f0a0((undefined4 *)(unaff_EBP + -0x50));
  return;
}



// Function: Unwind@1002d090 at 1002d090

void Unwind_1002d090(void)

{
  int unaff_EBP;
  
  FUN_1000ef60((int *)(unaff_EBP + -0x4c));
  return;
}



// Function: Unwind@1002d0c0 at 1002d0c0

void Unwind_1002d0c0(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d0f0 at 1002d0f0

void Unwind_1002d0f0(void)

{
  int unaff_EBP;
  
  FUN_10020a90((int *)(unaff_EBP + 0x10));
  return;
}



// Function: Unwind@1002d120 at 1002d120

void Unwind_1002d120(void)

{
  int unaff_EBP;
  
  FUN_10020a90((int *)(unaff_EBP + 0x10));
  return;
}



// Function: Unwind@1002d150 at 1002d150

void Unwind_1002d150(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d180 at 1002d180

void Unwind_1002d180(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x10) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x10) = *(uint *)(unaff_EBP + -0x10) & 0xfffffffe;
    ~basic_string<>(*(void **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002d1c0 at 1002d1c0

void Unwind_1002d1c0(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d1f0 at 1002d1f0

void Unwind_1002d1f0(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f4);
  return;
}



// Function: Unwind@1002d220 at 1002d220

void Unwind_1002d220(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002d22a at 1002d22a

void Unwind_1002d22a(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002d250 at 1002d250

void Unwind_1002d250(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002d25a at 1002d25a

void Unwind_1002d25a(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002d280 at 1002d280

void Unwind_1002d280(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f4);
  return;
}



// Function: Unwind@1002d2b0 at 1002d2b0

void Unwind_1002d2b0(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002d2ba at 1002d2ba

void Unwind_1002d2ba(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002d2e0 at 1002d2e0

void Unwind_1002d2e0(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002d2ea at 1002d2ea

void Unwind_1002d2ea(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002d310 at 1002d310

void Unwind_1002d310(void)

{
  int unaff_EBP;
  
  ~basic_string<>(*(void **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d318 at 1002d318

void Unwind_1002d318(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(*(int *)(unaff_EBP + -0x10) + 0x18));
  return;
}



// Function: Unwind@1002d323 at 1002d323

void Unwind_1002d323(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(*(int *)(unaff_EBP + -0x10) + 0x30));
  return;
}



// Function: Unwind@1002d350 at 1002d350

void Unwind_1002d350(void)

{
  int unaff_EBP;
  
  ~basic_string<>(*(void **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d358 at 1002d358

void Unwind_1002d358(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(*(int *)(unaff_EBP + -0x10) + 0x18));
  return;
}



// Function: Unwind@1002d363 at 1002d363

void Unwind_1002d363(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(*(int *)(unaff_EBP + -0x10) + 0x30));
  return;
}



// Function: Unwind@1002d390 at 1002d390

void Unwind_1002d390(void)

{
  int unaff_EBP;
  
  ~basic_string<>(*(void **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d398 at 1002d398

void Unwind_1002d398(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(*(int *)(unaff_EBP + -0x10) + 0x18));
  return;
}



// Function: Unwind@1002d3a3 at 1002d3a3

void Unwind_1002d3a3(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(*(int *)(unaff_EBP + -0x10) + 0x30));
  return;
}



// Function: Unwind@1002d3d0 at 1002d3d0

void Unwind_1002d3d0(void)

{
  int unaff_EBP;
  
  ~basic_string<>(*(void **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d3d8 at 1002d3d8

void Unwind_1002d3d8(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(*(int *)(unaff_EBP + -0x10) + 0x18));
  return;
}



// Function: Unwind@1002d3e3 at 1002d3e3

void Unwind_1002d3e3(void)

{
  int unaff_EBP;
  
  ~basic_string<>((void *)(*(int *)(unaff_EBP + -0x10) + 0x30));
  return;
}



// Function: Unwind@1002d410 at 1002d410

void Unwind_1002d410(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f4);
  return;
}



// Function: Unwind@1002d440 at 1002d440

void Unwind_1002d440(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002d44a at 1002d44a

void Unwind_1002d44a(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002d470 at 1002d470

void Unwind_1002d470(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002d47a at 1002d47a

void Unwind_1002d47a(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002d4a0 at 1002d4a0

void Unwind_1002d4a0(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f4);
  return;
}



// Function: Unwind@1002d4d0 at 1002d4d0

void Unwind_1002d4d0(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002d4da at 1002d4da

void Unwind_1002d4da(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403f8);
  return;
}



// Function: Unwind@1002d500 at 1002d500

void Unwind_1002d500(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002d50a at 1002d50a

void Unwind_1002d50a(void)

{
  FUN_1000f260((undefined4 *)&DAT_100403fc);
  return;
}



// Function: Unwind@1002d530 at 1002d530

void Unwind_1002d530(void)

{
  int unaff_EBP;
  
  FUN_100245d0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d560 at 1002d560

void Unwind_1002d560(void)

{
  int unaff_EBP;
  
  FUN_100245d0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d590 at 1002d590

void Unwind_1002d590(void)

{
  int unaff_EBP;
  
  FUN_100245e0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d5c0 at 1002d5c0

void Unwind_1002d5c0(void)

{
  int unaff_EBP;
  
  FUN_100245d0((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002d5f0 at 1002d5f0

void Unwind_1002d5f0(void)

{
  int unaff_EBP;
  
  FUN_100245e0((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002d620 at 1002d620

void Unwind_1002d620(void)

{
  int unaff_EBP;
  
  FUN_100245a0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d650 at 1002d650

void Unwind_1002d650(void)

{
  int unaff_EBP;
  
  FUN_100245b0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d680 at 1002d680

void Unwind_1002d680(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d6b0 at 1002d6b0

void Unwind_1002d6b0(void)

{
  int unaff_EBP;
  
  FUN_100245a0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d6e0 at 1002d6e0

void Unwind_1002d6e0(void)

{
  int unaff_EBP;
  
  FUN_100245b0(*(int **)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d710 at 1002d710

void Unwind_1002d710(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002d740 at 1002d740

void Unwind_1002d740(void)

{
  int unaff_EBP;
  
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>::
  ~CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator>
            ((CAtlSafeAllocBufferManager<class_ATL::CCRTAllocator> *)(unaff_EBP + -0x41c));
  return;
}



// Function: Unwind@1002d74b at 1002d74b

void Unwind_1002d74b(void)

{
  int unaff_EBP;
  
  FUN_100245a0((int *)(unaff_EBP + -0x414));
  return;
}



// Function: Unwind@1002d756 at 1002d756

void Unwind_1002d756(void)

{
  int unaff_EBP;
  
  FUN_10024500((int *)(unaff_EBP + -0x414));
  return;
}



// Function: Unwind@1002d761 at 1002d761

void Unwind_1002d761(void)

{
  int unaff_EBP;
  
  FUN_100245b0((int *)(unaff_EBP + -0x418));
  return;
}



// Function: Unwind@1002d76c at 1002d76c

void Unwind_1002d76c(void)

{
  int unaff_EBP;
  
  FUN_10024550((int *)(unaff_EBP + -0x418));
  return;
}



// Function: Unwind@1002d777 at 1002d777

void Unwind_1002d777(void)

{
  int unaff_EBP;
  
  FUN_100245b0((int *)(unaff_EBP + -0x418));
  return;
}



// Function: Unwind@1002d782 at 1002d782

void Unwind_1002d782(void)

{
  int unaff_EBP;
  
  FUN_100245a0((int *)(unaff_EBP + -0x414));
  return;
}



// Function: Unwind@1002d7c0 at 1002d7c0

void Unwind_1002d7c0(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x2048));
  return;
}



// Function: Unwind@1002d7cb at 1002d7cb

void Unwind_1002d7cb(void)

{
  int unaff_EBP;
  
  FUN_100245c0((int *)(unaff_EBP + -0x2038));
  return;
}



// Function: Unwind@1002d7d6 at 1002d7d6

void Unwind_1002d7d6(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x204c));
  return;
}



// Function: Unwind@1002d7e1 at 1002d7e1

void Unwind_1002d7e1(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x204c));
  return;
}



// Function: Unwind@1002d7ec at 1002d7ec

void Unwind_1002d7ec(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x204c));
  return;
}



// Function: Unwind@1002d7f7 at 1002d7f7

void Unwind_1002d7f7(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x204c));
  return;
}



// Function: Unwind@1002d802 at 1002d802

void Unwind_1002d802(void)

{
  int unaff_EBP;
  
  FUN_100245e0((int *)(unaff_EBP + -0x204c));
  return;
}



// Function: Unwind@1002d80d at 1002d80d

void Unwind_1002d80d(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x2040));
  return;
}



// Function: Unwind@1002d818 at 1002d818

void Unwind_1002d818(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x2040));
  return;
}



// Function: Unwind@1002d823 at 1002d823

void Unwind_1002d823(void)

{
  int unaff_EBP;
  
  FUN_100245d0((int *)(unaff_EBP + -0x203c));
  return;
}



// Function: Unwind@1002d82e at 1002d82e

void Unwind_1002d82e(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x2040));
  return;
}



// Function: Unwind@1002d839 at 1002d839

void Unwind_1002d839(void)

{
  int unaff_EBP;
  
  FUN_100245e0((int *)(unaff_EBP + -0x2040));
  return;
}



// Function: Unwind@1002d844 at 1002d844

void Unwind_1002d844(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x2044));
  return;
}



// Function: Unwind@1002d880 at 1002d880

void Unwind_1002d880(void)

{
  int unaff_EBP;
  
  FUN_100245d0((int *)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002d888 at 1002d888

void Unwind_1002d888(void)

{
  int unaff_EBP;
  
  FUN_100245e0((int *)(unaff_EBP + -0x14));
  return;
}



// Function: Unwind@1002d890 at 1002d890

void Unwind_1002d890(void)

{
  int unaff_EBP;
  
  FUN_100245c0((int *)(unaff_EBP + -0x10));
  return;
}



// Function: Unwind@1002d898 at 1002d898

void Unwind_1002d898(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d8a3 at 1002d8a3

void Unwind_1002d8a3(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d8ab at 1002d8ab

void Unwind_1002d8ab(void)

{
  int unaff_EBP;
  
  FUN_100245d0(*(int **)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d8b3 at 1002d8b3

void Unwind_1002d8b3(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x24));
  return;
}



// Function: Unwind@1002d8bb at 1002d8bb

void Unwind_1002d8bb(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d8c3 at 1002d8c3

void Unwind_1002d8c3(void)

{
  int unaff_EBP;
  
  FUN_1000f220(*(int **)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d8cb at 1002d8cb

void Unwind_1002d8cb(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x28));
  return;
}



// Function: Unwind@1002d8f0 at 1002d8f0

void Unwind_1002d8f0(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002d8fb at 1002d8fb

void Unwind_1002d8fb(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffe;
    FUN_1000f220(*(int **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002d930 at 1002d930

void Unwind_1002d930(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x18));
  return;
}



// Function: Unwind@1002d93b at 1002d93b

void Unwind_1002d93b(void)

{
  int unaff_EBP;
  
  if ((*(uint *)(unaff_EBP + -0x14) & 1) != 0) {
    *(uint *)(unaff_EBP + -0x14) = *(uint *)(unaff_EBP + -0x14) & 0xfffffffe;
    FUN_1000f220(*(int **)(unaff_EBP + 8));
    return;
  }
  return;
}



// Function: Unwind@1002d970 at 1002d970

void Unwind_1002d970(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002d9a0 at 1002d9a0

void Unwind_1002d9a0(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002d9d0 at 1002d9d0

void Unwind_1002d9d0(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 8));
  return;
}



// Function: Unwind@1002da20 at 1002da20

void Unwind_1002da20(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002da50 at 1002da50

void Unwind_1002da50(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002da80 at 1002da80

void Unwind_1002da80(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002dab0 at 1002dab0

void Unwind_1002dab0(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002dae0 at 1002dae0

void Unwind_1002dae0(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002db10 at 1002db10

void Unwind_1002db10(void)

{
  FUN_1000f2b0();
  return;
}



// Function: Unwind@1002db40 at 1002db40

void Unwind_1002db40(void)

{
  int unaff_EBP;
  
  FUN_10026970((undefined4 *)(*(int *)(unaff_EBP + -0x10) + 0x18));
  return;
}



// Function: Unwind@1002db4b at 1002db4b

void Unwind_1002db4b(void)

{
  int unaff_EBP;
  
  FUN_10026970((undefined4 *)(*(int *)(unaff_EBP + -0x10) + 0x24));
  return;
}



// Function: Unwind@1002db80 at 1002db80

void Unwind_1002db80(void)

{
  int unaff_EBP;
  
  FUN_10026970((undefined4 *)(*(int *)(unaff_EBP + -0x14) + 0x18));
  return;
}



// Function: Unwind@1002db8b at 1002db8b

void Unwind_1002db8b(void)

{
  int unaff_EBP;
  
  FUN_10026970((undefined4 *)(*(int *)(unaff_EBP + -0x14) + 0x24));
  return;
}



// Function: Unwind@1002dbc0 at 1002dbc0

void Unwind_1002dbc0(void)

{
  int unaff_EBP;
  
  FUN_10026970((undefined4 *)(unaff_EBP + 0xc));
  return;
}



// Function: Unwind@1002dbf0 at 1002dbf0

void Unwind_1002dbf0(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + 0xc));
  return;
}



// Function: Unwind@1002dc20 at 1002dc20

void Unwind_1002dc20(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x13c));
  return;
}



// Function: Unwind@1002dc2e at 1002dc2e

void Unwind_1002dc2e(void)

{
  int unaff_EBP;
  
  FUN_1000f220((int *)(unaff_EBP + -0x120));
  return;
}



// Function: Unwind@1002dc90 at 1002dc90

void Unwind_1002dc90(void)

{
  FUN_1000f2b0();
  return;
}



// Function: FUN_1002dd00 at 1002dd00

void FUN_1002dd00(void)

{
  FUN_1000e620((undefined4 *)&DAT_100403f4);
  _atexit(FUN_1002e560);
  return;
}



// Function: FUN_1002dd20 at 1002dd20

void FUN_1002dd20(void)

{
  FUN_1000e680((undefined4 *)&DAT_100403f8);
  _atexit(FUN_1002e570);
  return;
}



// Function: FUN_1002dd40 at 1002dd40

void FUN_1002dd40(void)

{
  FUN_1000e6e0((undefined4 *)&DAT_100403fc);
  _atexit(FUN_1002e580);
  return;
}



// Function: FUN_1002dd60 at 1002dd60

void FUN_1002dd60(void)

{
  std::locale::id::id((id *)&DAT_10040400,0);
  return;
}



// Function: FUN_1002dd80 at 1002dd80

void FUN_1002dd80(void)

{
  std::locale::id::id((id *)&DAT_10040404,0);
  return;
}



// Function: FUN_1002dda0 at 1002dda0

void FUN_1002dda0(void)

{
  FUN_1000e770(&DAT_100403f0,"20");
  _atexit(FUN_1002e590);
  return;
}



// Function: FUN_1002ddd0 at 1002ddd0

void FUN_1002ddd0(void)

{
  FUN_1000e770(&DAT_100403e0,"BNG");
  _atexit(FUN_1002e5a0);
  return;
}



// Function: FUN_1002de00 at 1002de00

void FUN_1002de00(void)

{
  FUN_1000e770(&DAT_100403dc,"BVO");
  _atexit(FUN_1002e5b0);
  return;
}



// Function: FUN_1002de30 at 1002de30

void FUN_1002de30(void)

{
  FUN_1000e770(&DAT_100403ec,"CNG");
  _atexit(FUN_1002e5c0);
  return;
}



// Function: FUN_1002de60 at 1002de60

void FUN_1002de60(void)

{
  FUN_1000e770(&DAT_100403e4,"ECI");
  _atexit(FUN_1002e5d0);
  return;
}



// Function: FUN_1002de90 at 1002de90

void FUN_1002de90(void)

{
  return;
}



// Function: FUN_1002dea0 at 1002dea0

void FUN_1002dea0(void)

{
  return;
}



// Function: FUN_1002deb0 at 1002deb0

void FUN_1002deb0(void)

{
  FUN_1000e620((undefined4 *)&DAT_100403f4);
  _atexit(FUN_1002e5e0);
  return;
}



// Function: FUN_1002ded0 at 1002ded0

void FUN_1002ded0(void)

{
  FUN_1000e680((undefined4 *)&DAT_100403f8);
  _atexit(FUN_1002e5f0);
  return;
}



// Function: FUN_1002def0 at 1002def0

void FUN_1002def0(void)

{
  FUN_1000e6e0((undefined4 *)&DAT_100403fc);
  _atexit(FUN_1002e600);
  return;
}



// Function: FUN_1002df10 at 1002df10

void FUN_1002df10(void)

{
  std::locale::id::id((id *)&DAT_10040400,0);
  return;
}



// Function: FUN_1002df30 at 1002df30

void FUN_1002df30(void)

{
  std::locale::id::id((id *)&DAT_10040404,0);
  return;
}



// Function: FUN_1002df50 at 1002df50

void FUN_1002df50(void)

{
  FUN_100164a0((undefined4 *)&DAT_100404dc);
  _atexit(FUN_1002e610);
  return;
}



// Function: FUN_1002df70 at 1002df70

void FUN_1002df70(void)

{
  return;
}



// Function: FUN_1002df80 at 1002df80

void FUN_1002df80(void)

{
  return;
}



// Function: FUN_1002df90 at 1002df90

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002df90(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c97a;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403f4 = std::_Generic_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e620);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002dff0 at 1002dff0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002dff0(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c9b4;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403f8 = std::_Iostream_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e670);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e060 at 1002e060

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e060(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002c9e4;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403fc = std::_System_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e6c0);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e0f0 at 1002e0f0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e0f0(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002cd8a;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403f4 = std::_Generic_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e710);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e150 at 1002e150

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e150(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002cdc4;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403f8 = std::_Iostream_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e760);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e1c0 at 1002e1c0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e1c0(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002cdf4;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403fc = std::_System_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e7b0);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e250 at 1002e250

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e250(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d1fa;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403f4 = std::_Generic_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e800);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e2b0 at 1002e2b0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e2b0(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d234;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403f8 = std::_Iostream_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e850);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e320 at 1002e320

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e320(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d264;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403fc = std::_System_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e8a0);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e3b0 at 1002e3b0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e3b0(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d41a;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403f4 = std::_Generic_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e8f0);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e410 at 1002e410

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e410(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d454;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403f8 = std::_Iostream_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e940);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e480 at 1002e480

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e480(void)

{
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  puStack_c = &LAB_1002d484;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  _DAT_100403fc = std::_System_error_category::vftable;
  local_8 = 0xffffffff;
  _atexit(FUN_1002e990);
  ExceptionList = local_10;
  return;
}



// Function: FUN_1002e560 at 1002e560

void FUN_1002e560(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f4);
  return;
}



// Function: FUN_1002e570 at 1002e570

void FUN_1002e570(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: FUN_1002e580 at 1002e580

void FUN_1002e580(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: FUN_1002e590 at 1002e590

void FUN_1002e590(void)

{
  FUN_1000f220((int *)&DAT_100403f0);
  return;
}



// Function: FUN_1002e5a0 at 1002e5a0

void FUN_1002e5a0(void)

{
  FUN_1000f220((int *)&DAT_100403e0);
  return;
}



// Function: FUN_1002e5b0 at 1002e5b0

void FUN_1002e5b0(void)

{
  FUN_1000f220((int *)&DAT_100403dc);
  return;
}



// Function: FUN_1002e5c0 at 1002e5c0

void FUN_1002e5c0(void)

{
  FUN_1000f220((int *)&DAT_100403ec);
  return;
}



// Function: FUN_1002e5d0 at 1002e5d0

void FUN_1002e5d0(void)

{
  FUN_1000f220((int *)&DAT_100403e4);
  return;
}



// Function: FUN_1002e5e0 at 1002e5e0

void FUN_1002e5e0(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f4);
  return;
}



// Function: FUN_1002e5f0 at 1002e5f0

void FUN_1002e5f0(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403f8);
  return;
}



// Function: FUN_1002e600 at 1002e600

void FUN_1002e600(void)

{
  FID_conflict__bad_alloc((undefined4 *)&DAT_100403fc);
  return;
}



// Function: FUN_1002e610 at 1002e610

void FUN_1002e610(void)

{
  FUN_10016e70((undefined4 *)&DAT_100404dc);
  return;
}



// Function: FUN_1002e620 at 1002e620

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e620(void)

{
  _DAT_100403f4 = std::error_category::vftable;
  return;
}



// Function: FUN_1002e670 at 1002e670

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e670(void)

{
  _DAT_100403f8 = std::error_category::vftable;
  return;
}



// Function: FUN_1002e6c0 at 1002e6c0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e6c0(void)

{
  _DAT_100403fc = std::error_category::vftable;
  return;
}



// Function: FUN_1002e710 at 1002e710

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e710(void)

{
  _DAT_100403f4 = std::error_category::vftable;
  return;
}



// Function: FUN_1002e760 at 1002e760

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e760(void)

{
  _DAT_100403f8 = std::error_category::vftable;
  return;
}



// Function: FUN_1002e7b0 at 1002e7b0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e7b0(void)

{
  _DAT_100403fc = std::error_category::vftable;
  return;
}



// Function: FUN_1002e800 at 1002e800

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e800(void)

{
  _DAT_100403f4 = std::error_category::vftable;
  return;
}



// Function: FUN_1002e850 at 1002e850

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e850(void)

{
  _DAT_100403f8 = std::error_category::vftable;
  return;
}



// Function: FUN_1002e8a0 at 1002e8a0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e8a0(void)

{
  _DAT_100403fc = std::error_category::vftable;
  return;
}



// Function: FUN_1002e8f0 at 1002e8f0

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e8f0(void)

{
  _DAT_100403f4 = std::error_category::vftable;
  return;
}



// Function: FUN_1002e940 at 1002e940

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e940(void)

{
  _DAT_100403f8 = std::error_category::vftable;
  return;
}



// Function: FUN_1002e990 at 1002e990

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_1002e990(void)

{
  _DAT_100403fc = std::error_category::vftable;
  return;
}



// Function: FUN_1002e9d2 at 1002e9d2

void FUN_1002e9d2(void)

{
  ATL::CAtlBaseModule::~CAtlBaseModule((CAtlBaseModule *)&DAT_10040520);
  return;
}



// Function: FUN_1002e9dc at 1002e9dc

void FUN_1002e9dc(void)

{
  ATL::CAtlComModule::Term((CAtlComModule *)&DAT_10040558);
  return;
}



// Function: FUN_1002e9f0 at 1002e9f0

void FUN_1002e9f0(void)

{
  Ordinal_9(&DAT_10040370);
  return;
}



// Function: FUN_1002e9fc at 1002e9fc

void FUN_1002e9fc(void)

{
  FUN_100299f5();
  return;
}



